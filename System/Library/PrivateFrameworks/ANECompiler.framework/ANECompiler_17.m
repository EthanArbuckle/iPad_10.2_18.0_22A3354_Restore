uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThan,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThan>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseLessThan>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseLessThan>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseLessThan>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseLessThan>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseLessThan>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseLessThan>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseLessThan>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThan>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThan>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThan>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThan>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.less_than";
  v16[1] = (char *)14;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseCompareReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThan>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThan,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThan,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThan,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThan,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThan,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqual>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseLessThanEqual>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseLessThanEqual>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseLessThanEqual>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseLessThanEqual>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseLessThanEqual>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseLessThanEqual>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseLessThanEqual>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThanEqual>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThanEqual>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThanEqual>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThanEqual>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.less_than_equal";
  v16[1] = (char *)20;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseCompareReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqual>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThanEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanEqualZero>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseLessThanEqualZero>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseLessThanEqualZero>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseLessThanEqualZero>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseLessThanEqualZero>,mlir::OpTrait::OneOperand<mlir::anec::ElementwiseLessThanEqualZero>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseLessThanEqualZero>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseLessThanEqualZero>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThanEqualZero>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::mutateOpForTransposeSwap;
  v11 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::getExecutionCost;
  v13 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v14 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::inferReturnTypes;
  v14[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::refineReturnTypes;
  v14[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v16 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::inferPromotedReturnTypes;
  v16[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::inferReturnTypes;
  v17 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
  v18 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v18 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::isCompatibleReturnTypes;
  v19 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v19, v18);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::mutateOpForTransposeSwap()
{
  return 1;
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThanEqualZero>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThanEqualZero>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.less_than_equal_zero";
  v16[1] = (char *)25;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseCompareReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanEqualZero>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThanEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseLessThanZero>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseLessThanZero>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseLessThanZero>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseLessThanZero>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseLessThanZero>,mlir::OpTrait::OneOperand<mlir::anec::ElementwiseLessThanZero>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseLessThanZero>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseLessThanZero>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThanZero>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseLessThanZero>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::mutateOpForTransposeSwap;
  v11 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::getExecutionCost;
  v13 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v14 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::inferReturnTypes;
  v14[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::refineReturnTypes;
  v14[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v16 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::inferPromotedReturnTypes;
  v16[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::inferReturnTypes;
  v17 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
  v18 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v18 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::isCompatibleReturnTypes;
  v19 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v19, v18);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::mutateOpForTransposeSwap()
{
  return 1;
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThanZero>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseLessThanZero>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.less_than_zero";
  v16[1] = (char *)19;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseCompareReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseLessThanZero>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseLessThanZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::anec::ElementwiseMax::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMax>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseMax>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseMax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseMax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseMax>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseMax>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseMax>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseMax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseMax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseMax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseMax>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseMax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseMax>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseMax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseMax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseMax>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseMax>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseMax>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.max";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMax>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return !*(_DWORD *)(a5 + 8) && mlir::OpTrait::impl::foldCommutative(a2, a3, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::anec::ElementwiseMin::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMin>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseMin>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseMin>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseMin>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseMin>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseMin>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseMin>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseMin>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseMin>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseMin>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseMin>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseMin>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseMin>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseMin>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseMin>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseMin>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseMin>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseMin>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseMin>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.min";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMin>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return !*(_DWORD *)(a5 + 8) && mlir::OpTrait::impl::foldCommutative(a2, a3, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::anec::ElementwiseMult::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseMult>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseMult>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseMult>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseMult>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseMult>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseMult>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseMult>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::ElementwiseMult>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseMult>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseMult>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseMult>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseMult>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseMult>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseMult>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseMult>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseMult>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseMult>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseMult>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseMult>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseMult>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.mult";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseMult>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return !*(_DWORD *)(a5 + 8) && mlir::OpTrait::impl::foldCommutative(a2, a3, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v34 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v33 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v32 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v31 = mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v35 == a1
      || v34 == a1
      || v33 == a1
      || v32 == a1
      || v31 == a1
      || v30 == a1
      || v29 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::anec::ConstantFoldable<Empty>]";
      v12 = 94;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[143];
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseMult,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqual>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseNotEqual>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseNotEqual>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseNotEqual>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseNotEqual>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseNotEqual>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseNotEqual>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.not_equal";
  v16[1] = (char *)14;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseCompareReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqual>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return !*(_DWORD *)(a5 + 8) && mlir::OpTrait::impl::foldCommutative(a2, a3, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseNotEqual,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsCommutative,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseNotEqualZero>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseNotEqualZero>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseNotEqualZero>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseNotEqualZero>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseNotEqualZero>,mlir::OpTrait::OneOperand<mlir::anec::ElementwiseNotEqualZero>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseNotEqualZero>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseNotEqualZero>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseNotEqualZero>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseNotEqualZero>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::mutateOpForTransposeSwap;
  v11 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::getExecutionCost;
  v13 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v14 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::inferReturnTypes;
  v14[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::refineReturnTypes;
  v14[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v16 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::inferPromotedReturnTypes;
  v16[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::inferReturnTypes;
  v17 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
  v18 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v18 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::isCompatibleReturnTypes;
  v19 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v19, v18);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::mutateOpForTransposeSwap()
{
  return 1;
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseNotEqualZero>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseNotEqualZero>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.not_equal_zero";
  v16[1] = (char *)19;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseCompareReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseNotEqualZero>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseNotEqualZero,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwisePower>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwisePower>,mlir::OpTrait::OneResult<mlir::anec::ElementwisePower>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwisePower>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwisePower>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwisePower>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwisePower>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwisePower>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwisePower>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwisePower>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwisePower>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwisePower>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwisePower>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwisePower>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwisePower>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwisePower>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwisePower>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwisePower>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.power";
  v16[1] = (char *)10;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwisePower>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwisePower,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSquare>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseSquare>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseSquare>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseSquare>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseSquare>,mlir::OpTrait::OneOperand<mlir::anec::ElementwiseSquare>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseSquare>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseSquare>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseSquare>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseSquare>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::mutateOpForTransposeSwap;
  v11 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::getExecutionCost;
  v13 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v14 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::inferReturnTypes;
  v14[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::refineReturnTypes;
  v14[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v16 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::inferPromotedReturnTypes;
  v16[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::inferReturnTypes;
  v17 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
  v18 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v18 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::isCompatibleReturnTypes;
  v19 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v19, v18);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::mutateOpForTransposeSwap()
{
  return 1;
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseSquare>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseSquare>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.square";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSquare>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseSquare,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::anec::ElementwiseSub::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ElementwiseSub>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseSub>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseSub>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseSub>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseSub>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseSub>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseSub>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseSub>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseSub>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseSub>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseSub>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseSub>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseSub>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseSub>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseSub>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseSub>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::getZinIrUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X1>, uint64_t *a2@<X8>)
{
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::addOpToNetwork(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2, uint64_t a3)
{
  mlir::anec::_anonymous_namespace_ *v4;

  v4 = a2;
  return mlir::anec::ElementwiseAbs::addOpToNetwork(&v4, a3);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap((uint64_t)&v7, a2, a3, a5, a6);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseSub>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ElementwiseSub>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.sub";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ElementwiseSub>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneResult<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ElementwiseAdd>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::ElementwiseAdd>,mlir::OpTrait::OpInvariants<mlir::anec::ElementwiseAdd>,mlir::OpTrait::IsCommutative<mlir::anec::ElementwiseAdd>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ElementwiseAdd>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::InferTypeOpInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ElementwiseAdd>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ElementwiseSub,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Elu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Elu>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Elu>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3EluEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Elu>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Elu>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Elu>,mlir::OpTrait::OneResult<mlir::anec::Elu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Elu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Elu>,mlir::OpTrait::OneOperand<mlir::anec::Elu>,mlir::OpTrait::OpInvariants<mlir::anec::Elu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Elu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Elu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Elu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Elu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Elu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Elu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Elu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Elu>,mlir::InferTypeOpInterface::Trait<mlir::anec::Elu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Elu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Elu>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Elu>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Elu>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Elu>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Elu>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Elu>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Elu>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Elu>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Elu>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Elu>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Elu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Elu>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Elu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.elu";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Elu>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Elu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Elu>,mlir::OpTrait::OneResult<mlir::anec::Elu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Elu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Elu>,mlir::OpTrait::OneOperand<mlir::anec::Elu>,mlir::OpTrait::OpInvariants<mlir::anec::Elu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Elu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Elu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Elu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Elu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Elu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Elu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Elu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Elu>,mlir::InferTypeOpInterface::Trait<mlir::anec::Elu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Elu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Elu>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Elu>,mlir::OpTrait::OneResult<mlir::anec::Elu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Elu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Elu>,mlir::OpTrait::OneOperand<mlir::anec::Elu>,mlir::OpTrait::OpInvariants<mlir::anec::Elu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Elu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Elu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Elu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Elu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Elu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Elu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Elu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Elu>,mlir::InferTypeOpInterface::Trait<mlir::anec::Elu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Elu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Elu>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Elu::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Elu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Erf>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Erf>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Erf>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3ErfEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Erf>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Erf>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Erf>,mlir::OpTrait::OneResult<mlir::anec::Erf>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Erf>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Erf>,mlir::OpTrait::OneOperand<mlir::anec::Erf>,mlir::OpTrait::OpInvariants<mlir::anec::Erf>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Erf>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Erf>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Erf>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Erf>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Erf>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Erf>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Erf>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Erf>,mlir::InferTypeOpInterface::Trait<mlir::anec::Erf>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Erf>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Erf>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Erf>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Erf>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Erf>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Erf>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Erf>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Erf>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Erf>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Erf>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Erf>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Erf>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Erf>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Erf>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.erf";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Erf>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Erf>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Erf,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Exp2EJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Exp2>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Exp2>,mlir::OpTrait::OneResult<mlir::anec::Exp2>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Exp2>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Exp2>,mlir::OpTrait::OneOperand<mlir::anec::Exp2>,mlir::OpTrait::OpInvariants<mlir::anec::Exp2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Exp2>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Exp2>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Exp2>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Exp2>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Exp2>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Exp2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Exp2>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Exp2>,mlir::InferTypeOpInterface::Trait<mlir::anec::Exp2>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Exp2>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Exp2>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Exp2>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Exp2>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.exp2";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Exp2>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Exp2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Flatten>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Flatten>,mlir::OpTrait::OneResult<mlir::anec::Flatten>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Flatten>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Flatten>,mlir::OpTrait::OneOperand<mlir::anec::Flatten>,mlir::OpTrait::OpInvariants<mlir::anec::Flatten>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Flatten>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Flatten>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Flatten>,mlir::OpTrait::TypeChanger<mlir::anec::Flatten>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Flatten>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Flatten>,mlir::InferTypeOpInterface::Trait<mlir::anec::Flatten>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Flatten>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Flatten>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::getZinIrUnitInfo@<X0>(mlir::Operation *a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  mlir::Operation *v7;
  uint64_t FactorsAttr;

  v7 = a1;
  v4 = operator new();
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_QWORD *)(v4 + 72) = -1;
  *(_QWORD *)v4 = off_24C01FA98;
  *(_QWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 80) = 0;
  FactorsAttr = mlir::anec::BatchToSpace::getFactorsAttr(&v7);
  result = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&FactorsAttr);
  if (result == 1)
    v6 = 1;
  else
    v6 = 2;
  *(_DWORD *)(v4 + 80) = v6;
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Flatten::addOpToNetwork(&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::getExecutionCost()
{
  return 0.0;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Flatten>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Flatten>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Flatten>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Flatten>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.flatten";
  v16[1] = (char *)12;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Flatten::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Flatten>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Flatten>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v27 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Flatten>,mlir::OpTrait::OneResult<mlir::anec::Flatten>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Flatten>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Flatten>,mlir::OpTrait::OneOperand<mlir::anec::Flatten>,mlir::OpTrait::OpInvariants<mlir::anec::Flatten>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Flatten>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Flatten>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Flatten>,mlir::OpTrait::TypeChanger<mlir::anec::Flatten>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Flatten>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Flatten>,mlir::InferTypeOpInterface::Trait<mlir::anec::Flatten>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Flatten>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Flatten>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Flatten>,mlir::OpTrait::OneResult<mlir::anec::Flatten>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Flatten>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Flatten>,mlir::OpTrait::OneOperand<mlir::anec::Flatten>,mlir::OpTrait::OpInvariants<mlir::anec::Flatten>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Flatten>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Flatten>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Flatten>,mlir::OpTrait::TypeChanger<mlir::anec::Flatten>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Flatten>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Flatten>,mlir::InferTypeOpInterface::Trait<mlir::anec::Flatten>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Flatten>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Flatten>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Flatten::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Flatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Floor>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Floor>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Floor>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec5FloorEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Floor>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Floor>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Floor>,mlir::OpTrait::OneResult<mlir::anec::Floor>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Floor>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Floor>,mlir::OpTrait::OneOperand<mlir::anec::Floor>,mlir::OpTrait::OpInvariants<mlir::anec::Floor>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Floor>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Floor>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Floor>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Floor>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Floor>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Floor>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Floor>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Floor>,mlir::InferTypeOpInterface::Trait<mlir::anec::Floor>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Floor>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Floor>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Floor>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Floor>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Floor>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Floor>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Floor>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Floor>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Floor>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Floor>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Floor>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Floor>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Floor>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Floor>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.floor";
  v16[1] = (char *)10;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Floor>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Floor>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Floor,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::GOC>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::GOC>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::GOC>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::GOC>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::GOC>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GOC>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::GOC>,mlir::OpTrait::OneResult<mlir::anec::GOC>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GOC>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GOC>,mlir::OpTrait::NOperands<3u>::Impl<mlir::anec::GOC>,mlir::OpTrait::OpInvariants<mlir::anec::GOC>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::GOC>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GOC>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::GOC>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GOC>,mlir::OpTrait::anec::HasWeights<mlir::anec::GOC>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GOC>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GOC>,mlir::InferTypeOpInterface::Trait<mlir::anec::GOC>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GOC>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GOC>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::GOC>::addOpToNetwork;
  v3 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::GOC>::mutateOpForReshapeSwap;
  v5 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::getEffects;
  v7 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GOC>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GOC>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GOC>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::GOC>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3, mlir::anec::ANECIRWeights *a4)
{
  mlir::anec *v5;

  v5 = a2;
  return mlir::anec::GOC::addOpToNetwork(&v5, a3, a4);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::GOC>::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _QWORD *a5, uint64_t a6)
{
  uint64_t v7;

  v7 = a2;
  return mlir::anec::GOC::mutateOpForReshapeSwap((uint64_t)&v7, a3, a4, a5, a6);
}

uint64_t mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::GOC::getExecutionCost(&v4, a3);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GOC>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::GOC>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::GOC>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.gain_offset_control";
  v16[1] = (char *)24;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GOC>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GOC>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::anec::detail::GOCGenericAdaptorBase::GOCGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::anec::GOC::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v33 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v32 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v31 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::anec::HasWeights<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::HasWeights>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v33 == a1
      || v32 == a1
      || v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<3>::Impl<Empty>]";
      v12 = 90;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[149];
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::GOC>,mlir::OpTrait::OneResult<mlir::anec::GOC>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GOC>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GOC>,mlir::OpTrait::NOperands<3u>::Impl<mlir::anec::GOC>,mlir::OpTrait::OpInvariants<mlir::anec::GOC>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::GOC>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GOC>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::GOC>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GOC>,mlir::OpTrait::anec::HasWeights<mlir::anec::GOC>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GOC>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GOC>,mlir::InferTypeOpInterface::Trait<mlir::anec::GOC>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GOC>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GOC>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::GOC>,mlir::OpTrait::OneResult<mlir::anec::GOC>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GOC>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GOC>,mlir::OpTrait::NOperands<3u>::Impl<mlir::anec::GOC>,mlir::OpTrait::OpInvariants<mlir::anec::GOC>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::GOC>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GOC>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::GOC>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GOC>,mlir::OpTrait::anec::HasWeights<mlir::anec::GOC>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GOC>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GOC>,mlir::InferTypeOpInterface::Trait<mlir::anec::GOC>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GOC>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GOC>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)
    && (v6 = a1, mlir::anec::GOC::verifyInvariantsImpl((uint64_t **)&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::GOC,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::ConstantFoldable,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_9NOperandsILj2EE4ImplENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE3EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSX_ILSY_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_9NOperandsILj2EE4ImplENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE3EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSX_ILSY_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_9NOperandsILj2EE4ImplENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE3EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSX_ILSY_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_9NOperandsILj2EE4ImplENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE3EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSX_ILSY_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_9NOperandsILj2EE4ImplENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE3EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSX_ILSY_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_9NOperandsILj2EE4ImplENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE3EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS17_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_9NOperandsILj2EE4ImplENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE3EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS17_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_9NOperandsILj2EE4ImplENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE3EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSS_ILST_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1B_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec8GatherNDEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_9NOperandsILj2EE4ImplENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE3EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSS_ILST_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1B_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GatherND>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::GatherND>,mlir::OpTrait::OneResult<mlir::anec::GatherND>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GatherND>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GatherND>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::GatherND>,mlir::OpTrait::OpInvariants<mlir::anec::GatherND>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GatherND>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::anec::GatherND>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::GatherND>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GatherND>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GatherND>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GatherND>,mlir::InferTypeOpInterface::Trait<mlir::anec::GatherND>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GatherND>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GatherND>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::GatherND::getZinIrUnitInfo((mlir::anec::GatherND *)&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::GatherND::addOpToNetwork((mlir::anec::GatherND *)&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GatherND>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::GatherND>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::GatherND>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GatherND>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.gather_nd";
  v16[1] = (char *)14;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::GatherND::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GatherND>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GatherND>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::GatherND>,mlir::OpTrait::OneResult<mlir::anec::GatherND>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GatherND>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GatherND>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::GatherND>,mlir::OpTrait::OpInvariants<mlir::anec::GatherND>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GatherND>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::anec::GatherND>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::GatherND>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GatherND>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GatherND>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GatherND>,mlir::InferTypeOpInterface::Trait<mlir::anec::GatherND>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GatherND>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GatherND>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::GatherND>,mlir::OpTrait::OneResult<mlir::anec::GatherND>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GatherND>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GatherND>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::GatherND>,mlir::OpTrait::OpInvariants<mlir::anec::GatherND>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GatherND>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::anec::GatherND>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::GatherND>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GatherND>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GatherND>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GatherND>,mlir::InferTypeOpInterface::Trait<mlir::anec::GatherND>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GatherND>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GatherND>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::anec::GatherND::verifyInvariantsImpl((uint64_t **)&v6))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::GatherND,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Gelu>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Gelu>,mlir::OpTrait::OneResult<mlir::anec::Gelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Gelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Gelu>,mlir::OpTrait::OneOperand<mlir::anec::Gelu>,mlir::OpTrait::OpInvariants<mlir::anec::Gelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Gelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Gelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Gelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Gelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Gelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Gelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Gelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::Gelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Gelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Gelu>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Gelu>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Gelu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.gelu";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Gelu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Gelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE4EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE4EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE4EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec15GlobalArgMinMaxEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE4EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::GlobalArgMinMax>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneResult<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneOperand<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OpInvariants<mlir::anec::GlobalArgMinMax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::anec::GlobalArgMinMax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GlobalArgMinMax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::InferTypeOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GlobalArgMinMax>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::getZinIrUnitInfo@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v3;

  v3 = a1;
  return mlir::anec::GlobalArgMinMax::getZinIrUnitInfo((mlir::anec::GlobalArgMinMax *)&v3, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::GlobalArgMinMax::addOpToNetwork((mlir::anec::GlobalArgMinMax *)&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GlobalArgMinMax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::GlobalArgMinMax>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::GlobalArgMinMax>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GlobalArgMinMax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.global_arg_min_max";
  v16[1] = (char *)23;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::GlobalArgMinMax::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::GlobalArgMinMax>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GlobalArgMinMax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v27 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneResult<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneOperand<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OpInvariants<mlir::anec::GlobalArgMinMax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::anec::GlobalArgMinMax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GlobalArgMinMax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::InferTypeOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GlobalArgMinMax>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneResult<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OneOperand<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::OpInvariants<mlir::anec::GlobalArgMinMax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::anec::GlobalArgMinMax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::GlobalArgMinMax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::InferTypeOpInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::GlobalArgMinMax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::GlobalArgMinMax>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::GlobalArgMinMax::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::GlobalArgMinMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::HighPrecisionSigmoid>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::OneResult<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::ZeroSuccessors<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::OneOperand<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::OpInvariants<mlir::anec::HighPrecisionSigmoid>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::HighPrecisionSigmoid>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::HighPrecisionSigmoid>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::InferTypeOpInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::HighPrecisionSigmoid>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::HighPrecisionSigmoid>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::HighPrecisionSigmoid>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::HighPrecisionSigmoid>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.high_precision_sigmoid";
  v16[1] = (char *)27;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::HighPrecisionSigmoid>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::HighPrecisionSigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::InputView>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::InputView>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::InputView>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::InputView>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InputView>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::InputView>,mlir::OpTrait::OneResult<mlir::anec::InputView>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::InputView>,mlir::OpTrait::ZeroSuccessors<mlir::anec::InputView>,mlir::OpTrait::OneOperand<mlir::anec::InputView>,mlir::OpTrait::OpInvariants<mlir::anec::InputView>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::InputView>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::InputView>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::InputView>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::anec::InputView>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::InputView>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::InputView>,mlir::InferTypeOpInterface::Trait<mlir::anec::InputView>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::InputView>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::InputView>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::InputView>::getZinIrUnitInfo;
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::InputView>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::getEffects;
  v7 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InputView>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InputView>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InputView>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void *mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::InputView>::getZinIrUnitInfo@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v3;

  v3 = a1;
  return mlir::anec::InputView::getZinIrUnitInfo((mlir::anec::InputView *)&v3, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::InputView>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::InputView::addOpToNetwork((mlir::anec::InputView *)&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::getExecutionCost()
{
  return 0.0;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InputView>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InputView>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::InputView>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::InputView>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InputView>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.input_view";
  v16[1] = (char *)15;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InputView>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::InputView::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InputView>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InputView>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v27 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultElementType<Empty>]";
      v12 = 104;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[157];
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::InputView>,mlir::OpTrait::OneResult<mlir::anec::InputView>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::InputView>,mlir::OpTrait::ZeroSuccessors<mlir::anec::InputView>,mlir::OpTrait::OneOperand<mlir::anec::InputView>,mlir::OpTrait::OpInvariants<mlir::anec::InputView>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::InputView>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::InputView>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::InputView>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::anec::InputView>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::InputView>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::InputView>,mlir::InferTypeOpInterface::Trait<mlir::anec::InputView>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::InputView>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::InputView>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::InputView>,mlir::OpTrait::OneResult<mlir::anec::InputView>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::InputView>,mlir::OpTrait::ZeroSuccessors<mlir::anec::InputView>,mlir::OpTrait::OneOperand<mlir::anec::InputView>,mlir::OpTrait::OpInvariants<mlir::anec::InputView>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::InputView>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::InputView>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::InputView>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::anec::InputView>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::InputView>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::InputView>,mlir::InferTypeOpInterface::Trait<mlir::anec::InputView>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::InputView>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::InputView>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::anec::InputView::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultElementType(a1, v6))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::InputView,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec12InstanceNormEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::InstanceNorm>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::InstanceNorm>,mlir::OpTrait::OneResult<mlir::anec::InstanceNorm>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::InstanceNorm>,mlir::OpTrait::ZeroSuccessors<mlir::anec::InstanceNorm>,mlir::OpTrait::OneOperand<mlir::anec::InstanceNorm>,mlir::OpTrait::OpInvariants<mlir::anec::InstanceNorm>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::InstanceNorm>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::InstanceNorm>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::InstanceNorm>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::InstanceNorm>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::InferTypeOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::InstanceNorm>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::InstanceNorm>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::InstanceNorm::getZinIrUnitInfo((mlir::anec::InstanceNorm *)&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::InstanceNorm::addOpToNetwork((mlir::anec::InstanceNorm *)&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::InstanceNorm::getExecutionCost(&v4, a3);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::inferReturnTypes(mlir::Float16Type *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InstanceNorm>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::refineReturnTypes(mlir::Float16Type *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::InstanceNorm>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::InstanceNorm>::refineReturnTypes(mlir::Float16Type *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InstanceNorm>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.instance_norm";
  v16[1] = (char *)18;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::inferPromotedReturnTypes(mlir::Float16Type *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::InstanceNorm::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::InstanceNorm>::inferReturnTypes(mlir::Float16Type *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InstanceNorm>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v27 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::InstanceNorm>,mlir::OpTrait::OneResult<mlir::anec::InstanceNorm>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::InstanceNorm>,mlir::OpTrait::ZeroSuccessors<mlir::anec::InstanceNorm>,mlir::OpTrait::OneOperand<mlir::anec::InstanceNorm>,mlir::OpTrait::OpInvariants<mlir::anec::InstanceNorm>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::InstanceNorm>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::InstanceNorm>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::InstanceNorm>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::InstanceNorm>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::InferTypeOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::InstanceNorm>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::InstanceNorm>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::InstanceNorm>,mlir::OpTrait::OneResult<mlir::anec::InstanceNorm>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::InstanceNorm>,mlir::OpTrait::ZeroSuccessors<mlir::anec::InstanceNorm>,mlir::OpTrait::OneOperand<mlir::anec::InstanceNorm>,mlir::OpTrait::OpInvariants<mlir::anec::InstanceNorm>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::InstanceNorm>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::InstanceNorm>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::InstanceNorm>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::InstanceNorm>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::InferTypeOpInterface::Trait<mlir::anec::InstanceNorm>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::InstanceNorm>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::InstanceNorm>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::InstanceNorm::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::InstanceNorm,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Invert>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Invert>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Invert>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Invert>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Invert>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Invert>,mlir::OpTrait::OneResult<mlir::anec::Invert>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Invert>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Invert>,mlir::OpTrait::OneOperand<mlir::anec::Invert>,mlir::OpTrait::OpInvariants<mlir::anec::Invert>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Invert>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::Invert>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Invert>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Invert>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Invert>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Invert>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Invert>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Invert>,mlir::InferTypeOpInterface::Trait<mlir::anec::Invert>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Invert>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Invert>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Invert>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Invert>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Invert>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Invert>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Invert>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Invert>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Invert>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Invert>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Invert>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Invert>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Invert>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Invert>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.invert";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Invert>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Invert>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v34 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v33 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v32 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v31 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::TransposeSwapInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::NeuronOpTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::NeuronOpTrait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v35 == a1
      || v34 == a1
      || v33 == a1
      || v32 == a1
      || v31 == a1
      || v30 == a1
      || v29 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Invert>,mlir::OpTrait::OneResult<mlir::anec::Invert>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Invert>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Invert>,mlir::OpTrait::OneOperand<mlir::anec::Invert>,mlir::OpTrait::OpInvariants<mlir::anec::Invert>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Invert>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::Invert>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Invert>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Invert>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Invert>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Invert>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Invert>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Invert>,mlir::InferTypeOpInterface::Trait<mlir::anec::Invert>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Invert>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Invert>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Invert>,mlir::OpTrait::OneResult<mlir::anec::Invert>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Invert>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Invert>,mlir::OpTrait::OneOperand<mlir::anec::Invert>,mlir::OpTrait::OpInvariants<mlir::anec::Invert>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Invert>,mlir::OpTrait::anec::ConstantFoldable<mlir::anec::Invert>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Invert>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Invert>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Invert>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Invert>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Invert>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Invert>,mlir::InferTypeOpInterface::Trait<mlir::anec::Invert>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Invert>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Invert>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Invert::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Invert,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::OpTrait::anec::ConstantFoldable,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::L2NormPool>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::L2NormPool>,mlir::OpTrait::OneResult<mlir::anec::L2NormPool>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::L2NormPool>,mlir::OpTrait::ZeroSuccessors<mlir::anec::L2NormPool>,mlir::OpTrait::OneOperand<mlir::anec::L2NormPool>,mlir::OpTrait::OpInvariants<mlir::anec::L2NormPool>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::L2NormPool>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::L2NormPool>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::L2NormPool>,mlir::InferTypeOpInterface::Trait<mlir::anec::L2NormPool>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::L2NormPool>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::L2NormPool>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::addOpToNetwork;
  v3 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::getExecutionCost;
  v5 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v6 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::inferReturnTypes;
  v6[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::refineReturnTypes;
  v6[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::isCompatibleReturnTypes;
  v7 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v8 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::inferPromotedReturnTypes;
  v8[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::inferReturnTypes;
  v9 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::L2NormPool::addOpToNetwork(&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::getExecutionCost(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  return mlir::anec::getPoolExecutionCost<mlir::anec::MaxPool>(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::L2NormPool>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::L2NormPool>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::L2NormPool>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::L2NormPool>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.l2norm_pool";
  v16[1] = (char *)16;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::L2NormPool::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::L2NormPool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::L2NormPool>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v25;
  uint64_t v26;

  v26 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v25 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v12 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v26 == a2
      || v25 == a2
      || v3 == a2
      || v4 == a2
      || v5 == a2
      || v6 == a2
      || v7 == a2
      || v8 == a2
      || v9 == a2
      || v10 == a2
      || v11 == a2
      || v12 == a2;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::L2NormPool>,mlir::OpTrait::OneResult<mlir::anec::L2NormPool>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::L2NormPool>,mlir::OpTrait::ZeroSuccessors<mlir::anec::L2NormPool>,mlir::OpTrait::OneOperand<mlir::anec::L2NormPool>,mlir::OpTrait::OpInvariants<mlir::anec::L2NormPool>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::L2NormPool>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::L2NormPool>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::L2NormPool>,mlir::InferTypeOpInterface::Trait<mlir::anec::L2NormPool>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::L2NormPool>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::L2NormPool>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::L2NormPool>,mlir::OpTrait::OneResult<mlir::anec::L2NormPool>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::L2NormPool>,mlir::OpTrait::ZeroSuccessors<mlir::anec::L2NormPool>,mlir::OpTrait::OneOperand<mlir::anec::L2NormPool>,mlir::OpTrait::OpInvariants<mlir::anec::L2NormPool>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::L2NormPool>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::L2NormPool>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::L2NormPool>,mlir::InferTypeOpInterface::Trait<mlir::anec::L2NormPool>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::L2NormPool>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::L2NormPool>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::L2NormPool::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::L2NormPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::LeakyRelu>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::LeakyRelu>,mlir::OpTrait::OneResult<mlir::anec::LeakyRelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::LeakyRelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::LeakyRelu>,mlir::OpTrait::OneOperand<mlir::anec::LeakyRelu>,mlir::OpTrait::OpInvariants<mlir::anec::LeakyRelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::LeakyRelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::LeakyRelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::LeakyRelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::LeakyRelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::LeakyRelu>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::LeakyRelu>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::LeakyRelu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.leaky_relu";
  v16[1] = (char *)15;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::LeakyRelu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::LeakyRelu>,mlir::OpTrait::OneResult<mlir::anec::LeakyRelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::LeakyRelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::LeakyRelu>,mlir::OpTrait::OneOperand<mlir::anec::LeakyRelu>,mlir::OpTrait::OpInvariants<mlir::anec::LeakyRelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::LeakyRelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::LeakyRelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::LeakyRelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::LeakyRelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::LeakyRelu>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::LeakyRelu>,mlir::OpTrait::OneResult<mlir::anec::LeakyRelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::LeakyRelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::LeakyRelu>,mlir::OpTrait::OneOperand<mlir::anec::LeakyRelu>,mlir::OpTrait::OpInvariants<mlir::anec::LeakyRelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::LeakyRelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::LeakyRelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::LeakyRelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::LeakyRelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::LeakyRelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::LeakyRelu>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::LeakyRelu::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::LeakyRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Linear>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Linear>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Linear>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Linear>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Linear>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Linear>,mlir::OpTrait::OneResult<mlir::anec::Linear>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Linear>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Linear>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::Linear>,mlir::OpTrait::OpInvariants<mlir::anec::Linear>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Linear>,mlir::OpTrait::anec::HasWeights<mlir::anec::Linear>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Linear>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Linear>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Linear>,mlir::InferTypeOpInterface::Trait<mlir::anec::Linear>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Linear>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Linear>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Linear>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::getExecutionCost;
  v7 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v8 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::inferReturnTypes;
  v8[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::refineReturnTypes;
  v8[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::isCompatibleReturnTypes;
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v10 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Linear>::inferPromotedReturnTypes;
  v10[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Linear>::inferReturnTypes;
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Linear>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Linear>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3, mlir::anec::ANECIRWeights *a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::anec::Linear::addOpToNetwork(&v5, a3, a4);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::getExecutionCost()
{
  return 0.0;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Linear>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Linear>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Linear>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Linear>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Linear>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.linear";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Linear>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Linear::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Linear>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Linear>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::anec::HasWeights<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::HasWeights>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v29 == a1
      || v28 == a1
      || v27 == a1
      || v26 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Linear>,mlir::OpTrait::OneResult<mlir::anec::Linear>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Linear>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Linear>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::Linear>,mlir::OpTrait::OpInvariants<mlir::anec::Linear>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Linear>,mlir::OpTrait::anec::HasWeights<mlir::anec::Linear>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Linear>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Linear>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Linear>,mlir::InferTypeOpInterface::Trait<mlir::anec::Linear>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Linear>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Linear>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Linear>,mlir::OpTrait::OneResult<mlir::anec::Linear>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Linear>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Linear>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::Linear>,mlir::OpTrait::OpInvariants<mlir::anec::Linear>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Linear>,mlir::OpTrait::anec::HasWeights<mlir::anec::Linear>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Linear>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Linear>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Linear>,mlir::InferTypeOpInterface::Trait<mlir::anec::Linear>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Linear>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Linear>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::anec::Linear::verifyInvariantsImpl((uint64_t **)&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Linear,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::HasWeights,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Log2>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Log2>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Log2>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4Log2EJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Log2>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Log2>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Log2>,mlir::OpTrait::OneResult<mlir::anec::Log2>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Log2>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Log2>,mlir::OpTrait::OneOperand<mlir::anec::Log2>,mlir::OpTrait::OpInvariants<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Log2>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Log2>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Log2>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Log2>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Log2>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Log2>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Log2>,mlir::InferTypeOpInterface::Trait<mlir::anec::Log2>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Log2>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Log2>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Log2>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Log2>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Log2>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Log2>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Log2>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Log2>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Log2>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Log2>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Log2>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Log2>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Log2>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Log2>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.log2";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Log2>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Log2>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Log2>,mlir::OpTrait::OneResult<mlir::anec::Log2>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Log2>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Log2>,mlir::OpTrait::OneOperand<mlir::anec::Log2>,mlir::OpTrait::OpInvariants<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Log2>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Log2>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Log2>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Log2>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Log2>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Log2>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Log2>,mlir::InferTypeOpInterface::Trait<mlir::anec::Log2>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Log2>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Log2>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Log2>,mlir::OpTrait::OneResult<mlir::anec::Log2>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Log2>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Log2>,mlir::OpTrait::OneOperand<mlir::anec::Log2>,mlir::OpTrait::OpInvariants<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Log2>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Log2>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Log2>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Log2>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Log2>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Log2>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Log2>,mlir::InferTypeOpInterface::Trait<mlir::anec::Log2>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Log2>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Log2>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Invert::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Log2,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MatMul>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::MatMul>,mlir::OpTrait::OneResult<mlir::anec::MatMul>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::MatMul>,mlir::OpTrait::ZeroSuccessors<mlir::anec::MatMul>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::MatMul>,mlir::OpTrait::OpInvariants<mlir::anec::MatMul>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::MatMul>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::MatMul>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::MatMul>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::MatMul>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::MatMul>,mlir::InferTypeOpInterface::Trait<mlir::anec::MatMul>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::MatMul>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::MatMul>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::MatMul::getZinIrUnitInfo((mlir::anec::MatMul *)&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::MatMul::addOpToNetwork((mlir::anec::MatMul *)&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::MatMul::getExecutionCost(&v4, a3);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MatMul>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::MatMul>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::MatMul>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MatMul>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.matmul";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::MatMul::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MatMul>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MatMul>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v29 == a1
      || v28 == a1
      || v27 == a1
      || v26 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::MatMul>,mlir::OpTrait::OneResult<mlir::anec::MatMul>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::MatMul>,mlir::OpTrait::ZeroSuccessors<mlir::anec::MatMul>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::MatMul>,mlir::OpTrait::OpInvariants<mlir::anec::MatMul>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::MatMul>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::MatMul>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::MatMul>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::MatMul>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::MatMul>,mlir::InferTypeOpInterface::Trait<mlir::anec::MatMul>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::MatMul>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::MatMul>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::MatMul>,mlir::OpTrait::OneResult<mlir::anec::MatMul>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::MatMul>,mlir::OpTrait::ZeroSuccessors<mlir::anec::MatMul>,mlir::OpTrait::NOperands<2u>::Impl<mlir::anec::MatMul>,mlir::OpTrait::OpInvariants<mlir::anec::MatMul>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::MatMul>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::MatMul>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::MatMul>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::MatMul>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::MatMul>,mlir::InferTypeOpInterface::Trait<mlir::anec::MatMul>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::MatMul>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::MatMul>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::anec::MatMul::verifyInvariantsImpl((uint64_t **)&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::MatMul,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::MaxPool>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::MaxPool>,mlir::OpTrait::OneResult<mlir::anec::MaxPool>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::MaxPool>,mlir::OpTrait::ZeroSuccessors<mlir::anec::MaxPool>,mlir::OpTrait::OneOperand<mlir::anec::MaxPool>,mlir::OpTrait::OpInvariants<mlir::anec::MaxPool>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::MaxPool>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::MaxPool>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::MaxPool>,mlir::InferTypeOpInterface::Trait<mlir::anec::MaxPool>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::MaxPool>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::MaxPool>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::addOpToNetwork;
  v3 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::getExecutionCost;
  v5 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v6 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::inferReturnTypes;
  v6[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::refineReturnTypes;
  v6[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::isCompatibleReturnTypes;
  v7 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v8 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::inferPromotedReturnTypes;
  v8[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::inferReturnTypes;
  v9 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::MaxPool::addOpToNetwork(&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::getExecutionCost(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  return mlir::anec::getPoolExecutionCost<mlir::anec::MaxPool>(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MaxPool>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::MaxPool>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::MaxPool>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MaxPool>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.max_pool";
  v16[1] = (char *)13;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::MaxPool::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::MaxPool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MaxPool>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v25;
  uint64_t v26;

  v26 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v25 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v12 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v26 == a2
      || v25 == a2
      || v3 == a2
      || v4 == a2
      || v5 == a2
      || v6 == a2
      || v7 == a2
      || v8 == a2
      || v9 == a2
      || v10 == a2
      || v11 == a2
      || v12 == a2;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::L2NormPool>,mlir::OpTrait::OneResult<mlir::anec::L2NormPool>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::L2NormPool>,mlir::OpTrait::ZeroSuccessors<mlir::anec::L2NormPool>,mlir::OpTrait::OneOperand<mlir::anec::L2NormPool>,mlir::OpTrait::OpInvariants<mlir::anec::L2NormPool>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::L2NormPool>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::L2NormPool>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::L2NormPool>,mlir::InferTypeOpInterface::Trait<mlir::anec::L2NormPool>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::L2NormPool>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::L2NormPool>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::MaxPool,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::foldHook()
{
  mlir::Operation *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::NRelu>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::NRelu>,mlir::OpTrait::OneResult<mlir::anec::NRelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::NRelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::NRelu>,mlir::OpTrait::OneOperand<mlir::anec::NRelu>,mlir::OpTrait::OpInvariants<mlir::anec::NRelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::NRelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::NRelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::NRelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::NRelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::NRelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::NRelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::NRelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::NRelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::NRelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::NRelu>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::NRelu>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::NRelu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.n_relu";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::NRelu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::NRelu>,mlir::OpTrait::OneResult<mlir::anec::NRelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::NRelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::NRelu>,mlir::OpTrait::OneOperand<mlir::anec::NRelu>,mlir::OpTrait::OpInvariants<mlir::anec::NRelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::NRelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::NRelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::NRelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::NRelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::NRelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::NRelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::NRelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::NRelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::NRelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::NRelu>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::NRelu>,mlir::OpTrait::OneResult<mlir::anec::NRelu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::NRelu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::NRelu>,mlir::OpTrait::OneOperand<mlir::anec::NRelu>,mlir::OpTrait::OpInvariants<mlir::anec::NRelu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::NRelu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::NRelu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::NRelu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::NRelu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::NRelu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::NRelu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::NRelu>,mlir::InferTypeOpInterface::Trait<mlir::anec::NRelu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::NRelu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::NRelu>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::NRelu::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::NRelu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Padding>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Padding>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Padding>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Padding>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Padding>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Padding>,mlir::OpTrait::OneResult<mlir::anec::Padding>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Padding>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Padding>,mlir::OpTrait::OneOperand<mlir::anec::Padding>,mlir::OpTrait::OpInvariants<mlir::anec::Padding>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Padding>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Padding>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Padding>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Padding>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Padding>,mlir::InferTypeOpInterface::Trait<mlir::anec::Padding>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Padding>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Padding>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Padding>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Padding>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Padding>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Padding>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Padding>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Padding>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::Padding::getZinIrUnitInfo((mlir::anec::Padding *)&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Padding>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Padding::addOpToNetwork((mlir::anec::Padding *)&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Padding>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Padding>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Padding>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Padding>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Padding>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.padding";
  v16[1] = (char *)12;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Padding>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Padding::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Padding>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Padding>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v29 == a1
      || v28 == a1
      || v27 == a1
      || v26 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Padding>,mlir::OpTrait::OneResult<mlir::anec::Padding>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Padding>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Padding>,mlir::OpTrait::OneOperand<mlir::anec::Padding>,mlir::OpTrait::OpInvariants<mlir::anec::Padding>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Padding>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Padding>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Padding>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Padding>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Padding>,mlir::InferTypeOpInterface::Trait<mlir::anec::Padding>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Padding>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Padding>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Padding>,mlir::OpTrait::OneResult<mlir::anec::Padding>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Padding>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Padding>,mlir::OpTrait::OneOperand<mlir::anec::Padding>,mlir::OpTrait::OpInvariants<mlir::anec::Padding>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Padding>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Padding>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Padding>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Padding>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Padding>,mlir::InferTypeOpInterface::Trait<mlir::anec::Padding>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Padding>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Padding>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Padding::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Padding,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelShuffle>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::PixelShuffle>,mlir::OpTrait::OneResult<mlir::anec::PixelShuffle>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::PixelShuffle>,mlir::OpTrait::ZeroSuccessors<mlir::anec::PixelShuffle>,mlir::OpTrait::OneOperand<mlir::anec::PixelShuffle>,mlir::OpTrait::OpInvariants<mlir::anec::PixelShuffle>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::PixelShuffle>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::PixelShuffle>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::PixelShuffle>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::PixelShuffle>,mlir::InferTypeOpInterface::Trait<mlir::anec::PixelShuffle>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::PixelShuffle>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::PixelShuffle>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::getZinIrUnitInfo;
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::getExecutionCost;
  v7 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v8 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::inferReturnTypes;
  v8[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::refineReturnTypes;
  v8[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::isCompatibleReturnTypes;
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v10 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::inferPromotedReturnTypes;
  v10[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::inferReturnTypes;
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::getZinIrUnitInfo(mlir::Operation *a1@<X1>, uint64_t *a2@<X8>)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrPixelShuffleUnitInfo,mlir::anec::PixelShuffle>(a1, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::PixelShuffle::addOpToNetwork(&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::PixelShuffle>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::PixelShuffle>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::PixelShuffle>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::PixelShuffle>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.pixel_shuffle";
  v16[1] = (char *)18;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::PixelShuffle::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelShuffle>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::PixelShuffle>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v12 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v28 == a2
      || v27 == a2
      || v26 == a2
      || v3 == a2
      || v4 == a2
      || v5 == a2
      || v6 == a2
      || v7 == a2
      || v8 == a2
      || v9 == a2
      || v10 == a2
      || v11 == a2
      || v12 == a2;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::BatchToSpace>,mlir::OpTrait::OneResult<mlir::anec::BatchToSpace>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::BatchToSpace>,mlir::OpTrait::ZeroSuccessors<mlir::anec::BatchToSpace>,mlir::OpTrait::OneOperand<mlir::anec::BatchToSpace>,mlir::OpTrait::OpInvariants<mlir::anec::BatchToSpace>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::BatchToSpace>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::BatchToSpace>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::BatchToSpace>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::BatchToSpace>,mlir::InferTypeOpInterface::Trait<mlir::anec::BatchToSpace>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::BatchToSpace>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::BatchToSpace>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::PixelShuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::PixelUnshuffle>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::PixelUnshuffle>,mlir::OpTrait::OneResult<mlir::anec::PixelUnshuffle>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::PixelUnshuffle>,mlir::OpTrait::ZeroSuccessors<mlir::anec::PixelUnshuffle>,mlir::OpTrait::OneOperand<mlir::anec::PixelUnshuffle>,mlir::OpTrait::OpInvariants<mlir::anec::PixelUnshuffle>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::PixelUnshuffle>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::PixelUnshuffle>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::PixelUnshuffle>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::PixelUnshuffle>,mlir::InferTypeOpInterface::Trait<mlir::anec::PixelUnshuffle>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::PixelUnshuffle>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::PixelUnshuffle>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::getZinIrUnitInfo;
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::getExecutionCost;
  v7 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v8 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::inferReturnTypes;
  v8[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::refineReturnTypes;
  v8[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::isCompatibleReturnTypes;
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v10 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::inferPromotedReturnTypes;
  v10[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::inferReturnTypes;
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::getZinIrUnitInfo(mlir::Operation *a1@<X1>, uint64_t *a2@<X8>)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrPixelUnshuffleUnitInfo,mlir::anec::PixelUnshuffle>(a1, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::PixelUnshuffle::addOpToNetwork(&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::PixelUnshuffle>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::PixelUnshuffle>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::PixelUnshuffle>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::PixelUnshuffle>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.pixel_unshuffle";
  v16[1] = (char *)20;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::PixelUnshuffle::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::PixelUnshuffle>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::PixelUnshuffle>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v12 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v28 == a2
      || v27 == a2
      || v26 == a2
      || v3 == a2
      || v4 == a2
      || v5 == a2
      || v6 == a2
      || v7 == a2
      || v8 == a2
      || v9 == a2
      || v10 == a2
      || v11 == a2
      || v12 == a2;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::BatchToSpace>,mlir::OpTrait::OneResult<mlir::anec::BatchToSpace>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::BatchToSpace>,mlir::OpTrait::ZeroSuccessors<mlir::anec::BatchToSpace>,mlir::OpTrait::OneOperand<mlir::anec::BatchToSpace>,mlir::OpTrait::OpInvariants<mlir::anec::BatchToSpace>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::BatchToSpace>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::BatchToSpace>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::BatchToSpace>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::BatchToSpace>,mlir::InferTypeOpInterface::Trait<mlir::anec::BatchToSpace>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::BatchToSpace>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::BatchToSpace>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::PixelUnshuffle,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Quant>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Quant>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Quant>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Quant>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Quant>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Quant>,mlir::OpTrait::OneResult<mlir::anec::Quant>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Quant>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Quant>,mlir::OpTrait::OneOperand<mlir::anec::Quant>,mlir::OpTrait::OpInvariants<mlir::anec::Quant>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Quant>,mlir::OpTrait::anec::SupportConstantOperands<mlir::anec::Quant>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Quant>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Quant>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Quant>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Quant>,mlir::InferTypeOpInterface::Trait<mlir::anec::Quant>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Quant>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Quant>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Quant>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Quant>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Quant>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Quant>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Quant>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void *mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Quant>::getZinIrUnitInfo@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v3;

  v3 = a1;
  return mlir::anec::Quant::getZinIrUnitInfo((mlir::anec::Quant *)&v3, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Quant>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Quant::addOpToNetwork((mlir::anec::Quant *)&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Quant>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Quant>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Quant>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.quant";
  v16[1] = (char *)10;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Quant>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Quant>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::DeQuant>,mlir::OpTrait::OneResult<mlir::anec::DeQuant>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::DeQuant>,mlir::OpTrait::ZeroSuccessors<mlir::anec::DeQuant>,mlir::OpTrait::OneOperand<mlir::anec::DeQuant>,mlir::OpTrait::OpInvariants<mlir::anec::DeQuant>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::DeQuant>,mlir::OpTrait::anec::SupportConstantOperands<mlir::anec::DeQuant>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::DeQuant>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::DeQuant>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::DeQuant>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::DeQuant>,mlir::InferTypeOpInterface::Trait<mlir::anec::DeQuant>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::DeQuant>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::DeQuant>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Quant,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceAvgEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceAvg>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceAvg>,mlir::OpTrait::OneResult<mlir::anec::ReduceAvg>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceAvg>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceAvg>,mlir::OpTrait::OneOperand<mlir::anec::ReduceAvg>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceAvg>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceAvg>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceAvg>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceAvg>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceAvg>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::getZinIrUnitInfo;
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::ReduceAvg::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::getZinIrUnitInfo@<X0>(mlir::anec *this@<X1>, uint64_t *a2@<X8>)
{
  return mlir::anec::getReductionZinIrUnitInfo(this, a2);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceAvg>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceAvg>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceAvg>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceAvg>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.reduce_avg";
  v16[1] = (char *)15;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::ReduceAvg::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceAvg>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceAvg>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v27 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceAvg>,mlir::OpTrait::OneResult<mlir::anec::ReduceAvg>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceAvg>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceAvg>,mlir::OpTrait::OneOperand<mlir::anec::ReduceAvg>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceAvg>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceAvg>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceAvg>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceAvg>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceAvg>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceAvg>,mlir::OpTrait::OneResult<mlir::anec::ReduceAvg>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceAvg>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceAvg>,mlir::OpTrait::OneOperand<mlir::anec::ReduceAvg>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceAvg>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceAvg>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceAvg>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceAvg>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceAvg>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::ReduceAvg::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::ReduceAvg,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMaxEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMax>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceMax>,mlir::OpTrait::OneResult<mlir::anec::ReduceMax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceMax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceMax>,mlir::OpTrait::OneOperand<mlir::anec::ReduceMax>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceMax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceMax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceMax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceMax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceMax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceMax>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceMax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceMax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceMax>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::getZinIrUnitInfo;
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::ReduceAvg::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::getZinIrUnitInfo@<X0>(mlir::anec *this@<X1>, uint64_t *a2@<X8>)
{
  return mlir::anec::getReductionZinIrUnitInfo(this, a2);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceMax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceMax>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceMax>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceMax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.reduce_max";
  v16[1] = (char *)15;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::ReduceMax::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMax>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceMax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceAvg>,mlir::OpTrait::OneResult<mlir::anec::ReduceAvg>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceAvg>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceAvg>,mlir::OpTrait::OneOperand<mlir::anec::ReduceAvg>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceAvg>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceAvg>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceAvg>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceAvg>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceAvg>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ReduceMax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::foldHook()
{
  mlir::Operation *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceMinEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceMin>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceMin>,mlir::OpTrait::OneResult<mlir::anec::ReduceMin>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceMin>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceMin>,mlir::OpTrait::OneOperand<mlir::anec::ReduceMin>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceMin>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceMin>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceMin>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceMin>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceMin>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceMin>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceMin>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceMin>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceMin>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceMin>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::getZinIrUnitInfo;
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::ReduceAvg::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::getZinIrUnitInfo@<X0>(mlir::anec *this@<X1>, uint64_t *a2@<X8>)
{
  return mlir::anec::getReductionZinIrUnitInfo(this, a2);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceMin>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceMin>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceMin>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceMin>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.reduce_min";
  v16[1] = (char *)15;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::ReduceMin::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceMin>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceMin>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceAvg>,mlir::OpTrait::OneResult<mlir::anec::ReduceAvg>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceAvg>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceAvg>,mlir::OpTrait::OneOperand<mlir::anec::ReduceAvg>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceAvg>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceAvg>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceAvg>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceAvg>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceAvg>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ReduceMin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec9ReduceSumEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::ReduceSum>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceSum>,mlir::OpTrait::OneResult<mlir::anec::ReduceSum>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceSum>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceSum>,mlir::OpTrait::OneOperand<mlir::anec::ReduceSum>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceSum>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceSum>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceSum>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceSum>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceSum>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceSum>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceSum>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceSum>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceSum>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceSum>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::getZinIrUnitInfo;
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::ReduceAvg::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::getZinIrUnitInfo@<X0>(mlir::anec *this@<X1>, uint64_t *a2@<X8>)
{
  return mlir::anec::getReductionZinIrUnitInfo(this, a2);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceSum>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceSum>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::ReduceSum>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceSum>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.reduce_sum";
  v16[1] = (char *)15;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::ReduceSum::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::ReduceSum>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ReduceSum>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ReduceAvg>,mlir::OpTrait::OneResult<mlir::anec::ReduceAvg>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ReduceAvg>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ReduceAvg>,mlir::OpTrait::OneOperand<mlir::anec::ReduceAvg>,mlir::OpTrait::OpInvariants<mlir::anec::ReduceAvg>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ReduceAvg>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ReduceAvg>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ReduceAvg>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::InferTypeOpInterface::Trait<mlir::anec::ReduceAvg>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ReduceAvg>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ReduceAvg>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::ReduceSum,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  void **v10;
  void *v11;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v13 = v15;
  v14 = 0x300000000;
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::RegionReturn>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)&v13, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::RegionReturn>::getExecutionCost;
  v7 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)&v13, v7, v6);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"anec.region_return", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::anec::RegionReturn,void>::id, (uint64_t)&v13);
  v8 = v13;
  if ((_DWORD)v14)
  {
    v9 = 16 * v14;
    v10 = (void **)((char *)v13 + 8);
    do
    {
      v11 = *v10;
      v10 += 2;
      free(v11);
      v9 -= 16;
    }
    while (v9);
    v8 = v13;
  }
  if (v8 != v15)
    free(v8);
  *a1 = &off_24C042D68;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::hashProperties()
{
  return 0;
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::RegionReturn>::addOpToNetwork(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v4;

  v4 = a2;
  return mlir::anec::RegionReturn::addOpToNetwork(&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::RegionReturn>::getExecutionCost()
{
  return 0.0;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  return v3 == a2 || v4 == a2 || v5 == a2 || v6 == a2 || v7 == a2 || v8 == a2 || v9 == a2 || v10 == a2 || v11 == a2;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v12 = 84;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[223];
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::RegionReturn>,mlir::OpTrait::ZeroResults<mlir::anec::RegionReturn>,mlir::OpTrait::ZeroSuccessors<mlir::anec::RegionReturn>,mlir::OpTrait::VariadicOperands<mlir::anec::RegionReturn>,mlir::OpTrait::OpInvariants<mlir::anec::RegionReturn>,mlir::OpTrait::IsTerminator<mlir::anec::RegionReturn>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::RegionReturn>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::RegionReturn>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::RegionReturn>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::RegionReturn>,mlir::OpTrait::ZeroResults<mlir::anec::RegionReturn>,mlir::OpTrait::ZeroSuccessors<mlir::anec::RegionReturn>,mlir::OpTrait::VariadicOperands<mlir::anec::RegionReturn>,mlir::OpTrait::OpInvariants<mlir::anec::RegionReturn>,mlir::OpTrait::IsTerminator<mlir::anec::RegionReturn>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::RegionReturn>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::RegionReturn>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::RegionReturn>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4))
  {
    if ((*(_BYTE *)(a1 + 46) & 0x80) != 0 && (v6 = *(unsigned int *)(a1 + 68), (_DWORD)v6))
    {
      v7 = 0;
      v8 = *(_QWORD *)(a1 + 72) + 24;
      while (mlir::anec::__mlir_ods_local_type_constraint_ANECOps2((uint64_t *)a1, (const void **)(*(_QWORD *)(*(_QWORD *)v8 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v7))
      {
        ++v7;
        v8 += 32;
        if (v6 == v7)
          goto LABEL_9;
      }
    }
    else
    {
LABEL_9:
      if (mlir::OpTrait::impl::verifyIsTerminator((mlir::OpTrait::impl *)a1, v5))
        return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>(a1) != 0;
    }
  }
  return 0;
}

uint64_t mlir::Op<mlir::anec::RegionReturn,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::OpTrait::IsTerminator,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Relu>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Relu>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Relu>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Relu>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Relu>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Relu>,mlir::OpTrait::OneResult<mlir::anec::Relu>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Relu>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Relu>,mlir::OpTrait::OneOperand<mlir::anec::Relu>,mlir::OpTrait::OpInvariants<mlir::anec::Relu>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Relu>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Relu>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Relu>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Relu>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Relu>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Relu>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Relu>,mlir::InferTypeOpInterface::Trait<mlir::anec::Relu>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Relu>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Relu>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Relu>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Relu>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Relu>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Relu>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Relu>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Relu>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Relu>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Relu>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Relu>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Relu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Relu>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Relu>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.relu";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Relu>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Relu>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Relu,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::anec::Reshape::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Reshape>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Reshape>,mlir::OpTrait::OneResult<mlir::anec::Reshape>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Reshape>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Reshape>,mlir::OpTrait::OneOperand<mlir::anec::Reshape>,mlir::OpTrait::OpInvariants<mlir::anec::Reshape>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Reshape>,mlir::OpTrait::anec::SupportConstantOperands<mlir::anec::Reshape>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Reshape>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Reshape>,mlir::OpTrait::TypeChanger<mlir::anec::Reshape>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Reshape>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Reshape>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::getZinIrUnitInfo@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v3;

  v3 = a1;
  return mlir::anec::Reshape::getZinIrUnitInfo((mlir::anec::Reshape *)&v3, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Reshape::addOpToNetwork((mlir::anec::Reshape *)&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Reshape>::getExecutionCost()
{
  return 0.0;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::anec::detail::ReshapeGenericAdaptorBase::ReshapeGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = (unint64_t)mlir::anec::Reshape::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v12 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  return v28 == a2
      || v27 == a2
      || v26 == a2
      || v3 == a2
      || v4 == a2
      || v5 == a2
      || v6 == a2
      || v7 == a2
      || v8 == a2
      || v9 == a2
      || v10 == a2
      || v11 == a2
      || v12 == a2;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

uint64_t mlir::Op<mlir::anec::Reshape,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Resize>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSZ_ILS10_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSZ_ILS10_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSZ_ILS10_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSZ_ILS10_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSZ_ILS10_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Resize>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Resize>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Resize>::populateDefaultAttrs(int a1, mlir::anec::Resize *this, mlir::OperationName *a3)
{
  mlir::anec::Resize::populateDefaultAttrs(this, a3, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSU_ILSV_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec6ResizeEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSU_ILSV_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Resize>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Resize>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Resize>,mlir::OpTrait::OneResult<mlir::anec::Resize>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Resize>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Resize>,mlir::OpTrait::OneOperand<mlir::anec::Resize>,mlir::OpTrait::OpInvariants<mlir::anec::Resize>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Resize>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Resize>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Resize>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Resize>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Resize>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Resize>,mlir::InferTypeOpInterface::Trait<mlir::anec::Resize>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Resize>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Resize>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Resize>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Resize>::getZinIrUnitInfo;
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Resize>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Resize>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Resize>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Resize>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Resize::addOpToNetwork((mlir::anec::Resize *)&v4, a3);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Resize>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::Resize::getZinIrUnitInfo((mlir::anec::Resize *)&v2, a2);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::getExecutionCost()
{
  return 0.0;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Resize>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Resize>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Resize>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Resize>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Resize>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.resize";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Resize>::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Resize::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Resize>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Resize>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v27 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Resize>,mlir::OpTrait::OneResult<mlir::anec::Resize>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Resize>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Resize>,mlir::OpTrait::OneOperand<mlir::anec::Resize>,mlir::OpTrait::OpInvariants<mlir::anec::Resize>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Resize>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Resize>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Resize>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Resize>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Resize>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Resize>,mlir::InferTypeOpInterface::Trait<mlir::anec::Resize>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Resize>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Resize>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Resize>,mlir::OpTrait::OneResult<mlir::anec::Resize>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Resize>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Resize>,mlir::OpTrait::OneOperand<mlir::anec::Resize>,mlir::OpTrait::OpInvariants<mlir::anec::Resize>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Resize>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Resize>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Resize>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Resize>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Resize>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Resize>,mlir::InferTypeOpInterface::Trait<mlir::anec::Resize>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Resize>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Resize>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Resize::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Resize,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec12RoundNearestEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::RoundNearest>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::RoundNearest>,mlir::OpTrait::OneResult<mlir::anec::RoundNearest>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::RoundNearest>,mlir::OpTrait::ZeroSuccessors<mlir::anec::RoundNearest>,mlir::OpTrait::OneOperand<mlir::anec::RoundNearest>,mlir::OpTrait::OpInvariants<mlir::anec::RoundNearest>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::RoundNearest>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::RoundNearest>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::RoundNearest>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::RoundNearest>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::RoundNearest>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::RoundNearest>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::RoundNearest>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::RoundNearest>,mlir::InferTypeOpInterface::Trait<mlir::anec::RoundNearest>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::RoundNearest>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::RoundNearest>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::RoundNearest>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::RoundNearest>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.round_nearest";
  v16[1] = (char *)18;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::RoundNearest>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::RoundNearest,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5RsqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2;
  v5 = (*(BOOL (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5RsqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec5RsqrtEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec5RsqrtEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec5RsqrtEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec5RsqrtEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Rsqrt>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Rsqrt>,mlir::OpTrait::OneResult<mlir::anec::Rsqrt>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Rsqrt>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Rsqrt>,mlir::OpTrait::OneOperand<mlir::anec::Rsqrt>,mlir::OpTrait::OpInvariants<mlir::anec::Rsqrt>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Rsqrt>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Rsqrt>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Rsqrt>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Rsqrt>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Rsqrt>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Rsqrt>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Rsqrt>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Rsqrt>,mlir::InferTypeOpInterface::Trait<mlir::anec::Rsqrt>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Rsqrt>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Rsqrt>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Rsqrt>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Rsqrt>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.r_sqrt";
  v16[1] = (char *)11;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Rsqrt>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  mlir::Operation *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::anec::detail::RsqrtGenericAdaptorBase::RsqrtGenericAdaptorBase((uint64_t)v14, (unsigned int *)a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::anec::Rsqrt::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8
    || (mlir::Operation *)((char *)a2 - 16) == (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    return v9 > 7;
  }
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Log2>,mlir::OpTrait::OneResult<mlir::anec::Log2>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Log2>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Log2>,mlir::OpTrait::OneOperand<mlir::anec::Log2>,mlir::OpTrait::OpInvariants<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Log2>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Log2>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Log2>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Log2>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Log2>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Log2>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Log2>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Log2>,mlir::InferTypeOpInterface::Trait<mlir::anec::Log2>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Log2>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Log2>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Rsqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sigmoid>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Sigmoid>,mlir::OpTrait::OneResult<mlir::anec::Sigmoid>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Sigmoid>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Sigmoid>,mlir::OpTrait::OneOperand<mlir::anec::Sigmoid>,mlir::OpTrait::OpInvariants<mlir::anec::Sigmoid>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Sigmoid>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Sigmoid>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Sigmoid>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Sigmoid>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Sigmoid>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Sigmoid>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Sigmoid>,mlir::InferTypeOpInterface::Trait<mlir::anec::Sigmoid>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Sigmoid>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Sigmoid>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sigmoid>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sigmoid>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.sigmoid";
  v16[1] = (char *)12;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sigmoid>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Sigmoid,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sign>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Sign>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sign>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SignEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sign>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sign>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Sign>,mlir::OpTrait::OneResult<mlir::anec::Sign>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Sign>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Sign>,mlir::OpTrait::OneOperand<mlir::anec::Sign>,mlir::OpTrait::OpInvariants<mlir::anec::Sign>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Sign>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Sign>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Sign>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Sign>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Sign>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Sign>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Sign>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Sign>,mlir::InferTypeOpInterface::Trait<mlir::anec::Sign>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Sign>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Sign>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sign>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sign>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sign>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sign>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sign>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sign>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sign>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sign>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sign>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sign>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sign>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sign>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.sign";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sign>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sign>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Sign,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sin>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Sin>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sin>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SinEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE4EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sin>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sin>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Sin>,mlir::OpTrait::OneResult<mlir::anec::Sin>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Sin>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Sin>,mlir::OpTrait::OneOperand<mlir::anec::Sin>,mlir::OpTrait::OpInvariants<mlir::anec::Sin>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::anec::Sin>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Sin>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Sin>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Sin>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Sin>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Sin>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Sin>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Sin>,mlir::InferTypeOpInterface::Trait<mlir::anec::Sin>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Sin>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Sin>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sin>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sin>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sin>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sin>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sin>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sin>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sin>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sin>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sin>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sin>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sin>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sin>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.sin";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sin>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sin>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Cos>,mlir::OpTrait::OneResult<mlir::anec::Cos>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Cos>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Cos>,mlir::OpTrait::OneOperand<mlir::anec::Cos>,mlir::OpTrait::OpInvariants<mlir::anec::Cos>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::anec::Cos>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Cos>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Cos>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Cos>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Cos>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Cos>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Cos>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Cos>,mlir::InferTypeOpInterface::Trait<mlir::anec::Cos>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Cos>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Cos>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Sin,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSG_20ReshapeSwapInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSG_20ReshapeSwapInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSG_20ReshapeSwapInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSG_20ReshapeSwapInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_23PlistGeneratorInterface5TraitENSG_22ZinIrUnitInfoInterface5TraitENSG_20ReshapeSwapInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1G_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENS7_20ReshapeSwapInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS17_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_23PlistGeneratorInterface5TraitENS7_22ZinIrUnitInfoInterface5TraitENS7_20ReshapeSwapInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS17_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSB_20ReshapeSwapInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1B_vE9CallbacksE
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec7SoftmaxEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_23PlistGeneratorInterface5TraitENSB_22ZinIrUnitInfoInterface5TraitENSB_20ReshapeSwapInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1B_vE9CallbacksE
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Softmax>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Softmax>,mlir::OpTrait::OneResult<mlir::anec::Softmax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Softmax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Softmax>,mlir::OpTrait::OneOperand<mlir::anec::Softmax>,mlir::OpTrait::OpInvariants<mlir::anec::Softmax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Softmax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Softmax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Softmax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Softmax>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Softmax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Softmax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Softmax>,mlir::InferTypeOpInterface::Trait<mlir::anec::Softmax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Softmax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Softmax>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::getZinIrUnitInfo;
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::mutateOpForReshapeSwap;
  v9 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Softmax::addOpToNetwork((mlir::anec::Softmax *)&v4, a3);
}

uint64_t mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::getZinIrUnitInfo@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v3;

  v3 = a1;
  return mlir::anec::Softmax::getZinIrUnitInfo((mlir::anec::Softmax *)&v3, a2);
}

BOOL mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::mutateOpForReshapeSwap(uint64_t a1, mlir::Operation *a2, const void *a3, uint64_t a4)
{
  mlir::Operation *v5;

  v5 = a2;
  return mlir::anec::Softmax::mutateOpForReshapeSwap(&v5, a3, a4);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mlir::anec::getExecutionCostFromInputSize(a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Softmax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Softmax>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Softmax>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Softmax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.softmax";
  v16[1] = (char *)12;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x24BDAC8D0];
  v15[0] = a4;
  v15[1] = a5;
  v11 = mlir::ValueRange::dereference_iterator(v15, 0);
  v12 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8));
  v13 = *(unsigned int *)(a11 + 8);
  if (v13 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v13) = v12;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Softmax>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Softmax>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v33 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v32 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v31 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v28 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ReshapeSwapInterface::Trait>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v33 == a1
      || v32 == a1
      || v31 == a1
      || v30 == a1
      || v29 == a1
      || v28 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Softmax>,mlir::OpTrait::OneResult<mlir::anec::Softmax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Softmax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Softmax>,mlir::OpTrait::OneOperand<mlir::anec::Softmax>,mlir::OpTrait::OpInvariants<mlir::anec::Softmax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Softmax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Softmax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Softmax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Softmax>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Softmax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Softmax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Softmax>,mlir::InferTypeOpInterface::Trait<mlir::anec::Softmax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Softmax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Softmax>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Softmax>,mlir::OpTrait::OneResult<mlir::anec::Softmax>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Softmax>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Softmax>,mlir::OpTrait::OneOperand<mlir::anec::Softmax>,mlir::OpTrait::OpInvariants<mlir::anec::Softmax>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Softmax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Softmax>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Softmax>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Softmax>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Softmax>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Softmax>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Softmax>,mlir::InferTypeOpInterface::Trait<mlir::anec::Softmax>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Softmax>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Softmax>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Softmax::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Softmax,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToBatch>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::SpaceToBatch>,mlir::OpTrait::OneResult<mlir::anec::SpaceToBatch>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::SpaceToBatch>,mlir::OpTrait::ZeroSuccessors<mlir::anec::SpaceToBatch>,mlir::OpTrait::OneOperand<mlir::anec::SpaceToBatch>,mlir::OpTrait::OpInvariants<mlir::anec::SpaceToBatch>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::SpaceToBatch>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::SpaceToBatch>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::SpaceToBatch>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::SpaceToBatch>,mlir::InferTypeOpInterface::Trait<mlir::anec::SpaceToBatch>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::SpaceToBatch>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::SpaceToBatch>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::getZinIrUnitInfo;
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::getExecutionCost;
  v7 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v8 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::inferReturnTypes;
  v8[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::refineReturnTypes;
  v8[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::isCompatibleReturnTypes;
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v10 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::inferPromotedReturnTypes;
  v10[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::inferReturnTypes;
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::getZinIrUnitInfo(mlir::Operation *a1@<X1>, uint64_t *a2@<X8>)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrSpaceToBatchUnitInfo,mlir::anec::SpaceToBatch>(a1, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::SpaceToBatch::addOpToNetwork(&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::SpaceToBatch>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::SpaceToBatch>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::SpaceToBatch>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::SpaceToBatch>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.space_to_batch";
  v16[1] = (char *)19;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::SpaceToBatch::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToBatch>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::SpaceToBatch>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v28 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v27 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v26 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v12 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v28 == a2
      || v27 == a2
      || v26 == a2
      || v3 == a2
      || v4 == a2
      || v5 == a2
      || v6 == a2
      || v7 == a2
      || v8 == a2
      || v9 == a2
      || v10 == a2
      || v11 == a2
      || v12 == a2;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::BatchToSpace>,mlir::OpTrait::OneResult<mlir::anec::BatchToSpace>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::BatchToSpace>,mlir::OpTrait::ZeroSuccessors<mlir::anec::BatchToSpace>,mlir::OpTrait::OneOperand<mlir::anec::BatchToSpace>,mlir::OpTrait::OpInvariants<mlir::anec::BatchToSpace>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::BatchToSpace>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::BatchToSpace>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::BatchToSpace>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::BatchToSpace>,mlir::InferTypeOpInterface::Trait<mlir::anec::BatchToSpace>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::BatchToSpace>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::BatchToSpace>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::SpaceToBatch,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1C_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1C_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1C_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1C_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1C_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS13_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS13_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS17_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec14SpaceToChannelEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS17_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::SpaceToChannel>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::SpaceToChannel>,mlir::OpTrait::OneResult<mlir::anec::SpaceToChannel>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::SpaceToChannel>,mlir::OpTrait::ZeroSuccessors<mlir::anec::SpaceToChannel>,mlir::OpTrait::OneOperand<mlir::anec::SpaceToChannel>,mlir::OpTrait::OpInvariants<mlir::anec::SpaceToChannel>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::SpaceToChannel>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::SpaceToChannel>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::SpaceToChannel>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::SpaceToChannel>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::SpaceToChannel>,mlir::InferTypeOpInterface::Trait<mlir::anec::SpaceToChannel>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::SpaceToChannel>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::SpaceToChannel>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::getZinIrUnitInfo;
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::getExecutionCost;
  v7 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v8 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::inferReturnTypes;
  v8[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::refineReturnTypes;
  v8[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::isCompatibleReturnTypes;
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v10 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::inferPromotedReturnTypes;
  v10[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::inferReturnTypes;
  v11 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::getZinIrUnitInfo(mlir::Operation *a1@<X1>, uint64_t *a2@<X8>)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrSpaceToChannelUnitInfo,mlir::anec::SpaceToChannel>(a1, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::SpaceToChannel::addOpToNetwork(&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::SpaceToChannel>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::SpaceToChannel>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::SpaceToChannel>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::SpaceToChannel>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.space_to_channel";
  v16[1] = (char *)21;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::SpaceToChannel::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::SpaceToChannel>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::SpaceToChannel>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::ChannelToSpace>,mlir::OpTrait::OneResult<mlir::anec::ChannelToSpace>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::ChannelToSpace>,mlir::OpTrait::ZeroSuccessors<mlir::anec::ChannelToSpace>,mlir::OpTrait::OneOperand<mlir::anec::ChannelToSpace>,mlir::OpTrait::OpInvariants<mlir::anec::ChannelToSpace>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::ChannelToSpace>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::ChannelToSpace>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::ChannelToSpace>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::ChannelToSpace>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::ChannelToSpace>,mlir::InferTypeOpInterface::Trait<mlir::anec::ChannelToSpace>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::ChannelToSpace>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::ChannelToSpace>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::SpaceToChannel,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec3SqrEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqr>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Sqr>,mlir::OpTrait::OneResult<mlir::anec::Sqr>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Sqr>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Sqr>,mlir::OpTrait::OneOperand<mlir::anec::Sqr>,mlir::OpTrait::OpInvariants<mlir::anec::Sqr>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Sqr>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Sqr>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Sqr>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Sqr>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Sqr>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Sqr>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Sqr>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Sqr>,mlir::InferTypeOpInterface::Trait<mlir::anec::Sqr>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Sqr>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Sqr>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sqr>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sqr>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.sqr";
  v16[1] = (char *)8;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqr>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Sqr,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4SqrtEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Sqrt>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Sqrt>,mlir::OpTrait::OneResult<mlir::anec::Sqrt>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Sqrt>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Sqrt>,mlir::OpTrait::OneOperand<mlir::anec::Sqrt>,mlir::OpTrait::OpInvariants<mlir::anec::Sqrt>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Sqrt>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Sqrt>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Sqrt>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Sqrt>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Sqrt>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Sqrt>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Sqrt>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Sqrt>,mlir::InferTypeOpInterface::Trait<mlir::anec::Sqrt>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Sqrt>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Sqrt>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sqrt>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Sqrt>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.sqrt";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Sqrt>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Sqrt,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Swish>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Swish>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Swish>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Swish>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Swish>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Swish>,mlir::OpTrait::OneResult<mlir::anec::Swish>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Swish>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Swish>,mlir::OpTrait::OneOperand<mlir::anec::Swish>,mlir::OpTrait::OpInvariants<mlir::anec::Swish>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Swish>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Swish>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Swish>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Swish>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Swish>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Swish>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Swish>,mlir::InferTypeOpInterface::Trait<mlir::anec::Swish>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Swish>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Swish>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Swish>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Swish>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Swish>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Swish>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Swish>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Swish>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Swish>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Swish>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Swish>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Swish>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Swish>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Swish>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.swish";
  v16[1] = (char *)10;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Swish>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Swish>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Swish,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::T0>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::T0>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::T0>::getParseAssemblyFn(uint64_t (**a1)(mlir::AsmParser *a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::anec::T0::parse;
  a1[3] = (uint64_t (*)(mlir::AsmParser *, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                             + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::T0>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::T0>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::T0>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::OneRegion<mlir::anec::T0>,mlir::OpTrait::ZeroResults<mlir::anec::T0>,mlir::OpTrait::ZeroSuccessors<mlir::anec::T0>,mlir::OpTrait::ZeroOperands<mlir::anec::T0>,mlir::OpTrait::OpInvariants<mlir::anec::T0>,mlir::SymbolOpInterface::Trait<mlir::anec::T0>,mlir::CallableOpInterface::Trait<mlir::anec::T0>,mlir::FunctionOpInterface::Trait<mlir::anec::T0>,mlir::OpTrait::IsIsolatedFromAbove<mlir::anec::T0>,mlir::OpTrait::RegionOp<mlir::anec::T0>,mlir::TargetLegalizerInterface::Trait<mlir::anec::T0>,mlir::FormableRegionOpInterface::Trait<mlir::anec::T0>,mlir::anec::RegionPerformanceInterface::Trait<mlir::anec::T0>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::T0>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::T0>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(0x80uLL, 0x800408754F03FuLL);
  *v2 = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getNameAttr;
  v2[1] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setName;
  v2[2] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getVisibility;
  v2[3] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isNested;
  v2[4] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isPrivate;
  v2[5] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isPublic;
  v2[6] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setVisibility;
  v2[7] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setNested;
  v2[8] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setPrivate;
  v2[9] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setPublic;
  v2[10] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getSymbolUses;
  v2[11] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::symbolKnownUseEmpty;
  v2[12] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::replaceAllSymbolUses;
  v2[13] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isOptionalSymbol;
  v2[14] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::canDiscardOnUseEmpty;
  v2[15] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isDeclaration;
  v3 = mlir::TypeID::get<mlir::SymbolOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(0x48uLL, 0x800404C0E4D0CuLL);
  *v4 = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getCallableRegion;
  v4[1] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getArgumentTypes;
  v4[2] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getResultTypes;
  v4[3] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getArgAttrsAttr;
  v4[4] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getResAttrsAttr;
  v4[5] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setArgAttrsAttr;
  v4[6] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setResAttrsAttr;
  v4[7] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::removeArgAttrsAttr;
  v4[8] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::removeResAttrsAttr;
  v5 = mlir::TypeID::get<mlir::CallableOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>>((uint64_t)a1);
  v6 = malloc_type_malloc(0x30uLL, 0x800407D3415B1uLL);
  *v6 = mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::legalizeBody;
  v6[1] = mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::legalizeRegionBody;
  v6[2] = mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::getFunctionType;
  v6[3] = mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::setFunctionType;
  v6[4] = mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::getBody;
  v6[5] = mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::getBodyBlock;
  v7 = mlir::TypeID::get<mlir::TargetLegalizerInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v8 = mlir::detail::FormableRegionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isRegionProfitable;
  v8[1] = mlir::detail::FormableRegionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::build;
  v9 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v10 = mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getMemoryLinkWidthBytes;
  v10[1] = mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getMemoryClockRateHz;
  v10[2] = mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getComputeClockRateHz;
  v10[3] = mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getNumberOfNEs;
  v11 = mlir::TypeID::get<mlir::anec::RegionPerformanceInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v12 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getExecutionCost;
  v13 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getNameAttr(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolName(this, this);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::StringAttr *Context;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;

  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = 261;
  v7[0] = "sym_name";
  v7[1] = 8;
  v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getVisibility(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isNested(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 2;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isPrivate(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 1;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isPublic(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 0;
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setVisibility(uint64_t a1, uint64_t a2, int a3)
{
  mlir::SymbolTable::setSymbolVisibility(a2, a3);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setNested(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 2);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setPrivate(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 1);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setPublic(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 0);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getSymbolUses(mlir::SymbolTable *a1@<X1>, mlir::Operation *a2@<X2>, uint64_t a3@<X8>)
{
  mlir::SymbolTable::getSymbolUses(a1, a2, a3);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::symbolKnownUseEmpty(uint64_t a1, mlir::SymbolTable *a2, mlir::Operation *a3)
{
  return mlir::SymbolTable::symbolKnownUseEmpty(a2, a3, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::replaceAllSymbolUses(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4)
{
  return mlir::SymbolTable::replaceAllSymbolUses(a2, a3, a4);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isOptionalSymbol()
{
  return 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::canDiscardOnUseEmpty(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) != 0;
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isDeclaration()
{
  return 0;
}

unint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getCallableRegion(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) != 0)
    return ((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
         + 32 * *(unsigned int *)(a2 + 40);
  else
    return 0;
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getArgumentTypes(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  uint64_t FunctionTypeAttr;

  v3 = a2;
  FunctionTypeAttr = mlir::anec::A11Legacy::getFunctionTypeAttr(&v3);
  FunctionTypeAttr = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FunctionTypeAttr);
  return mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionTypeAttr);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getResultTypes(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  uint64_t FunctionTypeAttr;

  v3 = a2;
  FunctionTypeAttr = mlir::anec::A11Legacy::getFunctionTypeAttr(&v3);
  FunctionTypeAttr = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FunctionTypeAttr);
  return mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionTypeAttr);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getArgAttrsAttr(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  v3 = a2;
  return mlir::anec::A11Legacy::getArgAttrsAttr(&v3);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getResAttrsAttr(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  v3 = a2;
  return mlir::anec::A11Legacy::getResAttrsAttr(&v3);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setArgAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96), a3);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setResAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16), a3);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::removeArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  return mlir::Operation::removeAttr(a2, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96));
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::removeResAttrsAttr(uint64_t a1, uint64_t a2)
{
  return mlir::Operation::removeAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>>(uint64_t a1)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;

  v2 = malloc_type_malloc(0x38uLL, 0xE004091171B8EuLL);
  *v2 = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getFunctionType;
  v2[1] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setFunctionTypeAttr;
  v2[2] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::cloneTypeWith;
  v2[3] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::verifyBody;
  v2[4] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::verifyType;
  v2[5] = 0;
  v2[6] = 0;
  v3 = mlir::TypeID::get<mlir::SymbolOpInterface>();
  v4 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v4)
    goto LABEL_9;
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v4;
  do
  {
    v7 = v4 >> 1;
    v8 = &v5[2 * (v4 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v4 += ~(v4 >> 1);
    if (v10 < v3)
      v5 = v9;
    else
      v4 = v7;
  }
  while (v4);
  if (v5 != (_QWORD *)v6 && *v5 == v3)
    v11 = v5[1];
  else
LABEL_9:
    v11 = 0;
  v2[5] = v11;
  v12 = mlir::TypeID::get<mlir::CallableOpInterface>();
  v13 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v13)
    goto LABEL_18;
  v14 = *(_QWORD **)a1;
  v15 = *(_QWORD *)a1 + 16 * v13;
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != (_QWORD *)v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_18:
    v20 = 0;
  v2[6] = v20;
  v21 = mlir::TypeID::get<mlir::FunctionOpInterface>();
  mlir::detail::InterfaceMap::insert(a1, v21, v2);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getFunctionType(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  uint64_t FunctionTypeAttr;

  v3 = a2;
  FunctionTypeAttr = mlir::anec::A11Legacy::getFunctionTypeAttr(&v3);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FunctionTypeAttr);
}

void mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::setFunctionTypeAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8), a3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::cloneTypeWith(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mlir::Operation *v11;
  uint64_t FunctionTypeAttr;

  v11 = a2;
  FunctionTypeAttr = mlir::anec::A11Legacy::getFunctionTypeAttr(&v11);
  FunctionTypeAttr = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FunctionTypeAttr);
  return mlir::FunctionType::clone((mlir::Attribute *)&FunctionTypeAttr, a3, a4, a5, a6);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::verifyBody(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  v3 = a2;
  return mlir::detail::FunctionOpInterfaceTrait<mlir::anec::A11Legacy>::verifyBody(&v3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::verifyType()
{
  return 1;
}

uint64_t mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::legalizeBody(uint64_t a1, mlir::SymbolRefAttr *a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6)
{
  return mlir::legalizeA12(a2, a3, a4, a5, a6);
}

uint64_t mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::legalizeRegionBody(uint64_t a1, mlir::SymbolRefAttr *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return mlir::legalizeA12(a2, a3, a4, a5, a6, a7);
}

uint64_t mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::getFunctionType(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  uint64_t FunctionTypeAttr;

  v3 = a2;
  FunctionTypeAttr = mlir::anec::A11Legacy::getFunctionTypeAttr(&v3);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FunctionTypeAttr);
}

void mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::setFunctionType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8);
  v5 = mlir::TypeAttr::get(a3);
  mlir::Operation::setAttr(a2, v4, v5);
}

unint64_t mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::getBody(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) != 0)
    return ((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
         + 32 * *(unsigned int *)(a2 + 40);
  else
    return 0;
}

uint64_t mlir::detail::TargetLegalizerInterfaceInterfaceTraits::Model<mlir::anec::T0>::getBodyBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v2)
    return v2 - 8;
  else
    return 0;
}

uint64_t mlir::detail::FormableRegionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::isRegionProfitable()
{
  return 1;
}

__n128 mlir::detail::FormableRegionOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::build(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t *a5, void *a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, _QWORD *a11, unint64_t a12, uint64_t a13, uint64_t a14, mlir::Operation **a15, uint64_t a16, void *__src, uint64_t a18)
{
  __n128 result;

  mlir::anec::A11Legacy::build(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, __src, a18);
  return result;
}

float mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getMemoryLinkWidthBytes()
{
  return 64.0;
}

float mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getMemoryClockRateHz()
{
  return 960000000.0;
}

float mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getComputeClockRateHz()
{
  return 800000000.0;
}

float mlir::anec::detail::RegionPerformanceInterfaceInterfaceTraits::Model<mlir::anec::T0>::getNumberOfNEs()
{
  return 16.0;
}

void mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::T0>::getExecutionCost(uint64_t a1, uint64_t a2)
{
  mlir::anec::getANEExecutionCost(a2, 0x10000);
}

float sub_207114028()
{
  return 0.0;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t InterfaceFor;
  uint64_t AttrData;
  uint64_t v9;
  uint64_t v10;

  mlir::OpState::printOpName(a2, a3, a4, a5);
  InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  mlir::function_interface_impl::printFunctionOp(a3, a2, InterfaceFor, 0, AttrData, v9, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16));
}

BOOL mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::anec::A12>,mlir::OpTrait::ZeroResults<mlir::anec::A12>,mlir::OpTrait::ZeroSuccessors<mlir::anec::A12>,mlir::OpTrait::ZeroOperands<mlir::anec::A12>,mlir::OpTrait::OpInvariants<mlir::anec::A12>,mlir::SymbolOpInterface::Trait<mlir::anec::A12>,mlir::CallableOpInterface::Trait<mlir::anec::A12>,mlir::FunctionOpInterface::Trait<mlir::anec::A12>,mlir::OpTrait::IsIsolatedFromAbove<mlir::anec::A12>,mlir::OpTrait::RegionOp<mlir::anec::A12>,mlir::TargetLegalizerInterface::Trait<mlir::anec::A12>,mlir::FormableRegionOpInterface::Trait<mlir::anec::A12>,mlir::anec::RegionPerformanceInterface::Trait<mlir::anec::A12>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A12>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::A12>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::T0,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpTrait::RegionOp,mlir::TargetLegalizerInterface::Trait,mlir::FormableRegionOpInterface::Trait,mlir::anec::RegionPerformanceInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::OpTrait::impl::verifyIsIsolatedFromAbove(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tanh>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Tanh>,mlir::OpTrait::OneResult<mlir::anec::Tanh>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Tanh>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Tanh>,mlir::OpTrait::OneOperand<mlir::anec::Tanh>,mlir::OpTrait::OpInvariants<mlir::anec::Tanh>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Tanh>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Tanh>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Tanh>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Tanh>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Tanh>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Tanh>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Tanh>,mlir::InferTypeOpInterface::Trait<mlir::anec::Tanh>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Tanh>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Tanh>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Tanh>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Tanh>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.tanh";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tanh>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Broadcast>,mlir::OpTrait::OneResult<mlir::anec::Broadcast>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Broadcast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Broadcast>,mlir::OpTrait::OneOperand<mlir::anec::Broadcast>,mlir::OpTrait::OpInvariants<mlir::anec::Broadcast>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Broadcast>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Broadcast>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Broadcast>,mlir::OpTrait::TypeChanger<mlir::anec::Broadcast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Broadcast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Broadcast>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Tanh,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Tile>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENSG_22ZinIrUnitInfoInterface5TraitENSG_23PlistGeneratorInterface5TraitENSV_ILSW_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1E_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Tile>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS7_22ZinIrUnitInfoInterface5TraitENS7_23PlistGeneratorInterface5TraitENSM_ILSN_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS15_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Tile>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec4TileEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENS2_23MemoryEffectOpInterface5TraitENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENSB_22ZinIrUnitInfoInterface5TraitENSB_23PlistGeneratorInterface5TraitENSQ_ILSR_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS19_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Tile>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Tile>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Tile>,mlir::OpTrait::OneResult<mlir::anec::Tile>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Tile>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Tile>,mlir::OpTrait::OneOperand<mlir::anec::Tile>,mlir::OpTrait::OpInvariants<mlir::anec::Tile>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Tile>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Tile>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Tile>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Tile>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Tile>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Tile>,mlir::InferTypeOpInterface::Trait<mlir::anec::Tile>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Tile>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Tile>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Tile>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Tile>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tile>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tile>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tile>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Tile>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::Tile::getZinIrUnitInfo((mlir::anec::Tile *)&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Tile>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Tile::addOpToNetwork((mlir::anec::Tile *)&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::getExecutionCost()
{
  return 0.0;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Tile>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Tile>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Tile>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Tile>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Tile>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.tile";
  v16[1] = (char *)9;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tile>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Tile::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Tile>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Tile>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Tile>,mlir::OpTrait::OneResult<mlir::anec::Tile>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Tile>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Tile>,mlir::OpTrait::OneOperand<mlir::anec::Tile>,mlir::OpTrait::OpInvariants<mlir::anec::Tile>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Tile>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Tile>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Tile>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Tile>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Tile>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Tile>,mlir::InferTypeOpInterface::Trait<mlir::anec::Tile>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Tile>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Tile>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Tile>,mlir::OpTrait::OneResult<mlir::anec::Tile>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Tile>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Tile>,mlir::OpTrait::OneOperand<mlir::anec::Tile>,mlir::OpTrait::OpInvariants<mlir::anec::Tile>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Tile>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Tile>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Tile>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Tile>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Tile>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Tile>,mlir::InferTypeOpInterface::Trait<mlir::anec::Tile>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Tile>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Tile>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Tile::verifyInvariantsImpl((uint64_t **)&v7))
    && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Tile,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::anec::Transpose::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Transpose>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Transpose>,mlir::OpTrait::OneResult<mlir::anec::Transpose>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Transpose>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Transpose>,mlir::OpTrait::OneOperand<mlir::anec::Transpose>,mlir::OpTrait::OpInvariants<mlir::anec::Transpose>,mlir::OpTrait::anec::SupportConstantOperands<mlir::anec::Transpose>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Transpose>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Transpose>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Transpose>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::anec::Transpose>,mlir::OpTrait::TypeChanger<mlir::anec::Transpose>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Transpose>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Transpose>,mlir::InferTypeOpInterface::Trait<mlir::anec::Transpose>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Transpose>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Transpose>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::getZinIrUnitInfo;
  v3 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::getEffects;
  v7 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::getZinIrUnitInfo(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = a1;
  mlir::anec::Transpose::getZinIrUnitInfo((mlir::anec::Transpose *)&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::addOpToNetwork(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Transpose::addOpToNetwork((mlir::anec::Transpose *)&v4, a3);
}

BOOL mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::anec::Transpose::getExecutionCost(&v4, a3);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Transpose>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Transpose>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Transpose>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Transpose>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.transpose";
  v16[1] = (char *)14;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Transpose::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Transpose>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Transpose>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  mlir::Operation *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::anec::detail::TransposeGenericAdaptorBase::TransposeGenericAdaptorBase((uint64_t)v14, (unsigned int *)a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::anec::Transpose::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8
    || (mlir::Operation *)((char *)a2 - 16) == (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    return v9 > 7;
  }
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v35 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v34 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v33 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl>(void)::Empty>>();
  v32 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v31 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v30 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v29 = mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
  v2 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface::Trait>(void)::Empty>>();
  v3 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::PlistGeneratorInterface::Trait>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::anec::InferReturnTypesInterface::Trait>(void)::Empty>>();
  v11 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>>();
  return v35 == a1
      || v34 == a1
      || v33 == a1
      || v32 == a1
      || v31 == a1
      || v30 == a1
      || v29 == a1
      || v2 == a1
      || v3 == a1
      || v4 == a1
      || v5 == a1
      || v6 == a1
      || v7 == a1
      || v8 == a1
      || v9 == a1
      || v10 == a1
      || v11 == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Transpose>,mlir::OpTrait::OneResult<mlir::anec::Transpose>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Transpose>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Transpose>,mlir::OpTrait::OneOperand<mlir::anec::Transpose>,mlir::OpTrait::OpInvariants<mlir::anec::Transpose>,mlir::OpTrait::anec::SupportConstantOperands<mlir::anec::Transpose>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Transpose>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Transpose>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Transpose>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::anec::Transpose>,mlir::OpTrait::TypeChanger<mlir::anec::Transpose>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Transpose>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Transpose>,mlir::InferTypeOpInterface::Trait<mlir::anec::Transpose>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Transpose>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Transpose>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Transpose>,mlir::OpTrait::OneResult<mlir::anec::Transpose>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Transpose>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Transpose>,mlir::OpTrait::OneOperand<mlir::anec::Transpose>,mlir::OpTrait::OpInvariants<mlir::anec::Transpose>,mlir::OpTrait::anec::SupportConstantOperands<mlir::anec::Transpose>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Transpose>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Transpose>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Transpose>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::anec::Transpose>,mlir::OpTrait::TypeChanger<mlir::anec::Transpose>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Transpose>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Transpose>,mlir::InferTypeOpInterface::Trait<mlir::anec::Transpose>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Transpose>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Transpose>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::anec::Transpose::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultElementType(a1, v6))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Transpose,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::SupportConstantOperands,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
     + 2 >= 8)
  {
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((_ZN4llvm6detail18UniqueFunctionBaseIN4mlir13LogicalResultEJPNS2_9OperationENS_8ArrayRefINS2_9AttributeEEERNS_15SmallVectorImplINS2_12OpFoldResultEEEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSI_9OneResultENSI_14OneTypedResultINS2_10MemRefTypeEE4ImplENSI_14ZeroSuccessorsENSI_10OneOperandENSI_12OpInvariantsENSI_4anec13MinimumFamilyILNSG_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSG_23PlistGeneratorInterface5TraitENSG_20ReshapeSwapInterface5TraitENSG_22TransposeSwapInterface5TraitENSS_13NeuronOpTraitENST_ILSU_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSG_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getFoldHookFnEvEUlS5_S8_SC_E_KS1H_vE9CallbacksE
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIbJN4mlir6TypeIDEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENS9_9OneResultENS9_14OneTypedResultINS2_10MemRefTypeEE4ImplENS9_14ZeroSuccessorsENS9_10OneOperandENS9_12OpInvariantsENS9_4anec13MinimumFamilyILNS7_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENS7_23PlistGeneratorInterface5TraitENS7_20ReshapeSwapInterface5TraitENS7_22TransposeSwapInterface5TraitENSJ_13NeuronOpTraitENSK_ILSL_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENS7_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE13getHasTraitFnEvEUlS3_E_KS18_vE9CallbacksE
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)_ZN4llvm6detail18UniqueFunctionBaseIvJPN4mlir9OperationERNS2_12OpAsmPrinterENS_9StringRefEEE15CallbacksHolderIZNS2_2OpINS2_4anec5TruncEJNS2_7OpTrait11ZeroRegionsENSD_9OneResultENSD_14OneTypedResultINS2_10MemRefTypeEE4ImplENSD_14ZeroSuccessorsENSD_10OneOperandENSD_12OpInvariantsENSD_4anec13MinimumFamilyILNSB_6FamilyE2EE4ImplENS2_23MemoryEffectOpInterface5TraitENSB_23PlistGeneratorInterface5TraitENSB_20ReshapeSwapInterface5TraitENSB_22TransposeSwapInterface5TraitENSN_13NeuronOpTraitENSO_ILSP_0EE4ImplENS2_24ExecutionCostOpInterface5TraitENS2_20InferTypeOpInterface5TraitENSB_25InferReturnTypesInterface5TraitENS2_30CompatibleReturnTypesInterface5TraitEEE18getPrintAssemblyFnEvEUlS4_S6_S7_E_KS1C_vE9CallbacksE
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Trunc>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Trunc>,mlir::OpTrait::OneResult<mlir::anec::Trunc>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Trunc>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Trunc>,mlir::OpTrait::OneOperand<mlir::anec::Trunc>,mlir::OpTrait::OpInvariants<mlir::anec::Trunc>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Trunc>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Trunc>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Trunc>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Trunc>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Trunc>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Trunc>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Trunc>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Trunc>,mlir::InferTypeOpInterface::Trait<mlir::anec::Trunc>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Trunc>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Trunc>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::addOpToNetwork;
  v5 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::mutateOpForReshapeSwap;
  v7 = mlir::TypeID::get<mlir::anec::ReshapeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::mutateOpForTransposeSwap;
  v9 = mlir::TypeID::get<mlir::anec::TransposeSwapInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v10 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::getExecutionCost;
  v11 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v12 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::inferReturnTypes;
  v12[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::refineReturnTypes;
  v12[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::isCompatibleReturnTypes;
  v13 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v14 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::inferPromotedReturnTypes;
  v14[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::inferReturnTypes;
  v15 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
  v16 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v16 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::isCompatibleReturnTypes;
  v17 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v17, v16);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::addOpToNetwork(uint64_t a1, mlir::anec *a2, uint64_t a3)
{
  mlir::anec *v4;

  v4 = a2;
  return mlir::anec::Ceil::addOpToNetwork(&v4, a3);
}

uint64_t mlir::anec::detail::ReshapeSwapInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::mutateOpForReshapeSwap()
{
  return 1;
}

uint64_t mlir::anec::detail::TransposeSwapInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::mutateOpForTransposeSwap()
{
  return 1;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::getExecutionCost(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  float v6;
  void *v7;
  float v8;
  uint64_t v10;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_7;
  v6 = 0.0;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    while (1)
    {
      v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (!DefiningOp)
        goto LABEL_7;
    }
    if (v7 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
LABEL_7:
      return v8;
    }
  }
  return v6;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Trunc>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Trunc>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.trunc";
  v16[1] = (char *)10;
  if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::inferPromotedReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::inferElementwiseReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Trunc>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Ceil>,mlir::OpTrait::OneResult<mlir::anec::Ceil>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Ceil>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Ceil>,mlir::OpTrait::OneOperand<mlir::anec::Ceil>,mlir::OpTrait::OpInvariants<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::anec::Ceil>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Ceil>,mlir::anec::ReshapeSwapInterface::Trait<mlir::anec::Ceil>,mlir::anec::TransposeSwapInterface::Trait<mlir::anec::Ceil>,mlir::OpTrait::anec::NeuronOpTrait<mlir::anec::Ceil>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Ceil>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Ceil>,mlir::InferTypeOpInterface::Trait<mlir::anec::Ceil>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Ceil>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Ceil>>(a1, a2);
}

BOOL mlir::Op<mlir::anec::Trunc,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl,mlir::MemoryEffectOpInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::anec::ReshapeSwapInterface::Trait,mlir::anec::TransposeSwapInterface::Trait,mlir::OpTrait::anec::NeuronOpTrait,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::Unflatten>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::get<mlir::OpTrait::ZeroRegions<mlir::anec::Unflatten>,mlir::OpTrait::OneResult<mlir::anec::Unflatten>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Unflatten>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Unflatten>,mlir::OpTrait::OneOperand<mlir::anec::Unflatten>,mlir::OpTrait::OpInvariants<mlir::anec::Unflatten>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Unflatten>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Unflatten>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Unflatten>,mlir::OpTrait::TypeChanger<mlir::anec::Unflatten>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Unflatten>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Unflatten>,mlir::InferTypeOpInterface::Trait<mlir::anec::Unflatten>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Unflatten>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Unflatten>>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::getEffects;
  v3 = mlir::TypeID::get<mlir::MemoryEffectOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v3, v2);
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::getZinIrUnitInfo;
  v5 = mlir::TypeID::get<mlir::anec::ZinIrUnitInfoInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v5, v4);
  v6 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v6 = mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::addOpToNetwork;
  v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v7, v6);
  v8 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v8 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::getExecutionCost;
  v9 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v9, v8);
  v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v10 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::inferReturnTypes;
  v10[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::refineReturnTypes;
  v10[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::isCompatibleReturnTypes;
  v11 = mlir::TypeID::get<mlir::InferTypeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v11, v10);
  v12 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v12 = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::inferPromotedReturnTypes;
  v12[1] = mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::inferReturnTypes;
  v13 = mlir::TypeID::get<mlir::anec::InferReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v13, v12);
  v14 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v14 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::isCompatibleReturnTypes;
  v15 = mlir::TypeID::get<mlir::CompatibleReturnTypesInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)a1, v15, v14);
}

void mlir::anec::detail::ZinIrUnitInfoInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::getZinIrUnitInfo(mlir::Operation *a1@<X1>, uint64_t *a2@<X8>)
{
  mlir::Operation *v2;

  v2 = a1;
  mlir::anec::Unflatten::getZinIrUnitInfo(&v2, a2);
}

uint64_t mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::addOpToNetwork(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  mlir::Operation *v4;

  v4 = a2;
  return mlir::anec::Unflatten::addOpToNetwork(&v4, a3);
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::getExecutionCost()
{
  return 0.0;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Unflatten>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Unflatten>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::anec::Unflatten>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  _QWORD *v14;
  char *v16[2];
  unint64_t v17[2];
  unint64_t v18[2];
  void *v19;
  uint64_t v20;
  _BYTE v21[32];
  uint64_t v22;
  _QWORD v23[24];

  v23[23] = *MEMORY[0x24BDAC8D0];
  v19 = v21;
  v20 = 0x400000000;
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Unflatten>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v19))goto LABEL_8;
  mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  {
    v13 = 1;
    goto LABEL_9;
  }
  v16[0] = "anec.unflatten";
  v16[1] = (char *)14;
  if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v22);
    v14 = mlir::InFlightDiagnostic::append<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(&v22, "'", v16, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a11);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v22);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v23);
  }
  else
  {
LABEL_8:
    v13 = 0;
  }
LABEL_9:
  if (v19 != v21)
    free(v19);
  return v13;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::Unflatten::inferPromotedReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceInterfaceTraits::Model<mlir::anec::Unflatten>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Unflatten>::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Unflatten>,mlir::OpTrait::OneResult<mlir::anec::Unflatten>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Unflatten>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Unflatten>,mlir::OpTrait::OneOperand<mlir::anec::Unflatten>,mlir::OpTrait::OpInvariants<mlir::anec::Unflatten>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Unflatten>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Unflatten>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Unflatten>,mlir::OpTrait::TypeChanger<mlir::anec::Unflatten>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Unflatten>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Unflatten>,mlir::InferTypeOpInterface::Trait<mlir::anec::Unflatten>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Unflatten>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Unflatten>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::Unflatten>,mlir::OpTrait::OneResult<mlir::anec::Unflatten>,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<mlir::anec::Unflatten>,mlir::OpTrait::ZeroSuccessors<mlir::anec::Unflatten>,mlir::OpTrait::OneOperand<mlir::anec::Unflatten>,mlir::OpTrait::OpInvariants<mlir::anec::Unflatten>,mlir::MemoryEffectOpInterface::Trait<mlir::anec::Unflatten>,mlir::anec::ZinIrUnitInfoInterface::Trait<mlir::anec::Unflatten>,mlir::anec::PlistGeneratorInterface::Trait<mlir::anec::Unflatten>,mlir::OpTrait::TypeChanger<mlir::anec::Unflatten>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::Unflatten>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::Unflatten>,mlir::InferTypeOpInterface::Trait<mlir::anec::Unflatten>,mlir::anec::InferReturnTypesInterface::Trait<mlir::anec::Unflatten>,mlir::CompatibleReturnTypesInterface::Trait<mlir::anec::Unflatten>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::Unflatten::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::anec::Unflatten,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::anec::ZinIrUnitInfoInterface::Trait,mlir::anec::PlistGeneratorInterface::Trait,mlir::OpTrait::TypeChanger,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::anec::InferReturnTypesInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  void **v8;
  void *v9;
  void *v11;
  uint64_t v12;
  _QWORD v13[7];

  v13[6] = *MEMORY[0x24BDAC8D0];
  v11 = v13;
  v12 = 0x300000000;
  v4 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v4 = mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::UnrealizedConversionCast>::getExecutionCost;
  v5 = mlir::TypeID::get<mlir::ExecutionCostOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)&v11, v5, v4);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"anec.unrealized_conversion_cast", 31, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::anec::UnrealizedConversionCast,void>::id, (uint64_t)&v11);
  v6 = v11;
  if ((_DWORD)v12)
  {
    v7 = 16 * v12;
    v8 = (void **)((char *)v11 + 8);
    do
    {
      v9 = *v8;
      v8 += 2;
      free(v9);
      v7 -= 16;
    }
    while (v7);
    v6 = v11;
  }
  if (v6 != v13)
    free(v6);
  *a1 = &off_24C0441B8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v7;
  _QWORD v8[24];

  v8[23] = *MEMORY[0x24BDAC8D0];
  a5(&v7, a6);
  if (v7)
  {
    mlir::Diagnostic::operator<<((uint64_t)v8, "this operation does not support properties");
    if (v7)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v7);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::hashProperties()
{
  return 0;
}

float mlir::detail::ExecutionCostOpInterfaceInterfaceTraits::Model<mlir::anec::UnrealizedConversionCast>::getExecutionCost()
{
  return 0.0;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = mlir::TypeID::get<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>>();
  v4 = mlir::TypeID::get<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>>();
  v5 = mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>>();
  v6 = mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>>();
  v7 = mlir::TypeID::get<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>>();
  v8 = mlir::TypeID::get<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>>();
  v9 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  v10 = mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ExecutionCostOpInterface::Trait>(void)::Empty>>();
  return v3 == a2 || v4 == a2 || v5 == a2 || v6 == a2 || v7 == a2 || v8 == a2 || v9 == a2 || v10 == a2;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<Empty>]";
      v12 = 110;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[263];
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OneResult<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OneOperand<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OpInvariants<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::UnrealizedConversionCast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::UnrealizedConversionCast>>(a1, a2);
  return 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OneResult<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::ZeroSuccessors<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OneOperand<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::OpInvariants<mlir::anec::UnrealizedConversionCast>,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::UnrealizedConversionCast>,mlir::ExecutionCostOpInterface::Trait<mlir::anec::UnrealizedConversionCast>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v7 = a1, mlir::anec::UnrealizedConversionCast::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::Op<mlir::anec::UnrealizedConversionCast,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ShapedType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl,mlir::ExecutionCostOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)5>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = 0x100000002;
  v3 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v3) & 1) != 0)
    return 0x100000005;
  v4 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v4) & 1) != 0)
    return 0x100000004;
  v5 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v5) & 1) != 0)
    return 0x100000003;
  v6 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v6) & 1) != 0)
    return v2;
  return mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)1>(a1);
}

uint64_t mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)1>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void **v7;
  __int16 v8;
  uint64_t v9;
  _QWORD v10[24];

  v10[23] = *MEMORY[0x24BDAC8D0];
  v2 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v2) & 1) != 0)
  {
    v3 = 0x100000000;
    v4 = 1;
  }
  else
  {
    v5 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
    if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v5) & 1) != 0)
    {
      v4 = 0;
      v3 = 0x100000000;
    }
    else
    {
      v8 = 259;
      mlir::Operation::emitOpError((uint64_t *)a1, &v7, (uint64_t)&v9);
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v9);
      if (v9)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v9);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v10);
      v3 = 0;
      v4 = 0;
    }
  }
  return v3 | v4;
}

uint64_t *llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;

  v1 = a1;
  v2 = *a1;
  v3 = mlir::TypeID::get<mlir::ShapedType>();
  v4 = *(unsigned int *)(v2 + 16);
  if (!(_DWORD)v4)
    return 0;
  v5 = *(_QWORD **)(v2 + 8);
  v6 = &v5[2 * v4];
  do
  {
    v7 = v4 >> 1;
    v8 = &v5[2 * (v4 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v4 += ~(v4 >> 1);
    if (v10 < v3)
      v5 = v9;
    else
      v4 = v7;
  }
  while (v4);
  if (v5 == v6 || *v5 != v3 || !v5[1])
    return 0;
  if (v1)
  {
    v12 = *v1;
    v13 = mlir::TypeID::get<mlir::ShapedType>();
    v14 = *(unsigned int *)(v12 + 16);
    if ((_DWORD)v14)
    {
      v15 = *(_QWORD **)(v12 + 8);
      do
      {
        v16 = v14 >> 1;
        v17 = &v15[2 * (v14 >> 1)];
        v19 = *v17;
        v18 = v17 + 2;
        v14 += ~(v14 >> 1);
        if (v19 < v13)
          v15 = v18;
        else
          v14 = v16;
      }
      while (v14);
    }
  }
  return v1;
}

void ZinIrBroadcastUnitInfo::~ZinIrBroadcastUnitInfo(ZinIrBroadcastUnitInfo *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C021950;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C021950;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

_QWORD *std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__emplace_unique_key_args<ZinIrDimension,std::piecewise_construct_t const&,std::tuple<ZinIrDimension&&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t prime;
  unint64_t v19;
  uint8x8_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x20uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = v17;
    else
      prime = v16;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v8 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v8)
      goto LABEL_41;
    if (prime < v8)
    {
      v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (v20 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        v19 = std::__next_prime(v19);
      }
      else
      {
        v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2)
          v19 = v21;
      }
      if (prime <= v19)
        prime = v19;
      if (prime < v8)
LABEL_41:
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(a1, prime);
    }
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *v11 = *v23;
LABEL_55:
    *v23 = v11;
    goto LABEL_56;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v22 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v24 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v24 >= v8)
        v24 %= v8;
    }
    else
    {
      v24 &= v8 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_55;
  }
LABEL_56:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v13 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= a2)
              v13 %= a2;
          }
          else
          {
            v13 &= a2 - 1;
          }
          if (v13 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v13))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v13) = v7;
              goto LABEL_19;
            }
            *v7 = *v11;
            v12 = 8 * v13;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + v12);
            **(_QWORD **)(*(_QWORD *)a1 + v12) = v11;
            v11 = v7;
          }
          v13 = v8;
LABEL_19:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v13;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void llvm::detail::provider_format_adapter<long long &>::~provider_format_adapter()
{
  JUMPOUT(0x20BD002F8);
}

llvm::raw_ostream *llvm::detail::provider_format_adapter<long long &>::format(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return llvm::format_provider<long long,void>::format(*(unint64_t **)(a1 + 8), a2, a3, a4);
}

llvm::raw_ostream *llvm::format_provider<long long,void>::format(unint64_t *a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  int v6;
  unint64_t v7;
  unint64_t v8;
  int v10;
  unsigned int v11;
  size_t v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  unint64_t v16;

  v14 = a3;
  v15 = a4;
  v13 = 0;
  if (llvm::detail::HelperFunctions::consumeHexStyle((uint64_t)&v14, &v13))
  {
    v6 = v13;
    v16 = 0;
    if (llvm::consumeUnsignedInteger(&v14, 0xAu, &v16))
      v7 = 0;
    else
      v7 = v16;
    if (ZinHWEnumsUtils::IsHWKernelFormatFloat(v6))
      v8 = v7 + 2;
    else
      v8 = v7;
    return llvm::write_hex(a2, *a1, v13, v8, 1);
  }
  if (v15)
  {
    v10 = 0;
    v11 = *v14;
    if (v11 <= 0x63)
    {
      if (v11 != 68)
      {
        if (v11 != 78)
          goto LABEL_20;
        goto LABEL_17;
      }
LABEL_18:
      v10 = 0;
      ++v14;
      goto LABEL_19;
    }
    if (v11 == 100)
      goto LABEL_18;
    if (v11 == 110)
    {
LABEL_17:
      ++v14;
      v10 = 1;
LABEL_19:
      --v15;
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_20:
  v16 = 0;
  if (llvm::consumeUnsignedInteger(&v14, 0xAu, &v16))
    v12 = 0;
  else
    v12 = v16;
  return llvm::write_integer(a2, *a1, v12, v10);
}

BOOL llvm::detail::HelperFunctions::consumeHexStyle(uint64_t a1, int *a2)
{
  _BOOL8 v4;
  unint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unint64_t v8;
  int v9;

  v4 = llvm::StringRef::starts_with_insensitive((unsigned __int8 **)a1, "x", 1uLL);
  if (!v4)
    return v4;
  v5 = *(_QWORD *)(a1 + 8);
  if (v5 >= 2)
  {
    v6 = *(unsigned __int8 **)a1;
    if (**(_WORD **)a1 == 11640)
    {
      v7 = v6 + 2;
      v8 = v5 - 2;
      v9 = 1;
    }
    else
    {
      if (*(_WORD *)v6 == 11608)
      {
        v9 = 0;
      }
      else
      {
        if (*(_WORD *)v6 == 11128)
        {
          v7 = v6 + 2;
          v8 = v5 - 2;
          goto LABEL_15;
        }
        if (*v6 == 120)
        {
LABEL_10:
          v7 = v6 + 1;
          v8 = v5 - 1;
LABEL_15:
          v9 = 3;
          goto LABEL_16;
        }
        if (*(_WORD *)v6 != 11096)
          goto LABEL_18;
        v9 = 2;
      }
      v7 = v6 + 2;
      v8 = v5 - 2;
    }
LABEL_16:
    *(_QWORD *)a1 = v7;
    *(_QWORD *)(a1 + 8) = v8;
LABEL_20:
    *a2 = v9;
    return v4;
  }
  if (v5)
  {
    v6 = *(unsigned __int8 **)a1;
    if (**(_BYTE **)a1 == 120)
      goto LABEL_10;
  }
LABEL_18:
  if ((llvm::StringRef::consume_front((const void **)a1, "X", 1uLL) & 1) != 0)
  {
    v9 = 2;
    goto LABEL_20;
  }
  return v4;
}

uint64_t llvm::StringRef::consume_front(const void **a1, const void *a2, size_t __n)
{
  size_t v3;
  char *v6;
  size_t v8;

  v3 = (size_t)a1[1];
  if (v3 < __n)
    return 0;
  v6 = (char *)*a1;
  if (__n)
  {
    if (memcmp(*a1, a2, __n))
      return 0;
  }
  if (v3 >= __n)
    v8 = __n;
  else
    v8 = v3;
  *a1 = &v6[v8];
  a1[1] = (const void *)(v3 - v8);
  return 1;
}

void llvm::detail::provider_format_adapter<long long const&>::~provider_format_adapter()
{
  JUMPOUT(0x20BD002F8);
}

llvm::raw_ostream *llvm::detail::provider_format_adapter<long long const&>::format(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return llvm::format_provider<long long,void>::format(*(unint64_t **)(a1 + 8), a2, a3, a4);
}

uint64_t llvm::SmallVectorImpl<long long>::insert_one_impl<long long>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;

  v5 = *(_QWORD *)a1;
  v6 = *(unsigned int *)(a1 + 8);
  if (*(_QWORD *)a1 + 8 * v6 == a2)
  {
    v10 = *a3;
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v6 + 1, 8);
      v6 = *(unsigned int *)(a1 + 8);
      v5 = *(_QWORD *)a1;
    }
    *(_QWORD *)(v5 + 8 * v6) = v10;
    v11 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v11;
    return *(_QWORD *)a1 + 8 * v11 - 8;
  }
  else
  {
    v7 = (a2 - v5) >> 3;
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v6 + 1, 8);
      v5 = *(_QWORD *)a1;
      v6 = *(unsigned int *)(a1 + 8);
    }
    v8 = (uint64_t *)(v5 + 8 * v7);
    v9 = (_QWORD *)(v5 + 8 * v6);
    *v9 = *(v9 - 1);
    if (v9 - 1 != v8)
    {
      memmove(v8 + 1, v8, (char *)(v9 - 1) - (char *)v8);
      LODWORD(v6) = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v6 + 1;
    *v8 = *a3;
  }
  return (uint64_t)v8;
}

void ZinIrConvUnitInfo::~ZinIrConvUnitInfo(ZinIrConvUnitInfo *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  *(_QWORD *)this = off_24C01ED88;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  *(_QWORD *)this = off_24C017CA0;
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    v5 = *((_QWORD *)this + 6);
    v6 = (void *)*((_QWORD *)this + 5);
    if (v5 != v4)
    {
      do
      {
        if (*(char *)(v5 - 1) < 0)
          operator delete(*(void **)(v5 - 24));
        v5 -= 24;
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v4;
    operator delete(v6);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  *(_QWORD *)this = off_24C01ED88;
  v2 = (void *)*((_QWORD *)this + 19);
  if (v2)
  {
    *((_QWORD *)this + 20) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  *(_QWORD *)this = off_24C017CA0;
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    v5 = *((_QWORD *)this + 6);
    v6 = (void *)*((_QWORD *)this + 5);
    if (v5 != v4)
    {
      do
      {
        if (*(char *)(v5 - 1) < 0)
          operator delete(*(void **)(v5 - 24));
        v5 -= 24;
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v4;
    operator delete(v6);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::ElementwiseMax &>(mlir::anec::ElementwiseMax &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ClampedRelu,mlir::Value &,llvm::APFloat &,llvm::APFloat>(mlir::Float16Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  const llvm::detail::DoubleAPFloat *v14;
  void *v15;
  llvm::APFloatBase *v16;
  void *v17;
  _QWORD *v18;
  ZinIrHalH13g *v19;
  ZinIrHalH13g *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  char v27[8];
  _QWORD v28[3];
  char v29[8];
  _QWORD v30[3];
  _QWORD v31[39];

  v31[38] = *MEMORY[0x24BDAC8D0];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.clamped_relu", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"anec.clamped_relu";
    v25[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v11);
  v13 = *a3;
  v15 = *(void **)(a4 + 8);
  v14 = (const llvm::detail::DoubleAPFloat *)(a4 + 8);
  v17 = llvm::APFloatBase::PPCDoubleDouble(v16);
  if (v17 == v15)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v30, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v30, v14);
  v18 = (_QWORD *)(a5 + 8);
  if (v17 == *(void **)(a5 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v18);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v28, (uint64_t)v18);
  mlir::anec::ClampedRelu::build(a1, (uint64_t)v31, v13, (uint64_t)v29, (uint64_t)v27);
  if (v17 == (void *)v28[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  if (v17 == (void *)v30[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v30);
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v20;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::ElementwiseMin &>(mlir::anec::ElementwiseMin &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ClampedRelu,mlir::Value &,llvm::APFloat,llvm::APFloat&>(mlir::Float16Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  llvm::APFloatBase *v16;
  void *v17;
  const llvm::detail::DoubleAPFloat *v18;
  ZinIrHalH13g *v19;
  ZinIrHalH13g *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  char v27[8];
  _QWORD v28[3];
  char v29[8];
  _QWORD v30[3];
  _QWORD v31[39];

  v31[38] = *MEMORY[0x24BDAC8D0];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.clamped_relu", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"anec.clamped_relu";
    v25[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v11);
  v13 = *a3;
  v15 = *(void **)(a4 + 8);
  v14 = (_QWORD *)(a4 + 8);
  v17 = llvm::APFloatBase::PPCDoubleDouble(v16);
  if (v17 == v15)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v30, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v30, (uint64_t)v14);
  v18 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  if (v17 == *(void **)(a5 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v18);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v28, v18);
  mlir::anec::ClampedRelu::build(a1, (uint64_t)v31, v13, (uint64_t)v29, (uint64_t)v27);
  if (v17 == (void *)v28[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  if (v17 == (void *)v30[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v30);
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v20;
}

void std::__shared_ptr_pointer<mlir::anec::ANECIRNeuron *,std::shared_ptr<mlir::anec::ANECIRNeuron>::__shared_ptr_default_delete<mlir::anec::ANECIRNeuron,mlir::anec::ANECIRNeuron>,std::allocator<mlir::anec::ANECIRNeuron>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

mlir::anec::ANECIRUnit *std::__shared_ptr_pointer<mlir::anec::ANECIRNeuron *,std::shared_ptr<mlir::anec::ANECIRNeuron>::__shared_ptr_default_delete<mlir::anec::ANECIRNeuron,mlir::anec::ANECIRNeuron>,std::allocator<mlir::anec::ANECIRNeuron>>::__on_zero_shared(uint64_t a1)
{
  mlir::anec::ANECIRUnit *result;

  result = *(mlir::anec::ANECIRUnit **)(a1 + 24);
  if (result)
  {
    mlir::anec::ANECIRUnit::~ANECIRUnit(result);
    JUMPOUT(0x20BD002F8);
  }
  return result;
}

void std::deque<mlir::Operation *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  void *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  BOOL v36;
  int64_t v37;
  unint64_t v38;
  char *v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  int64_t v44;
  unint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  __int128 *v55;
  _OWORD *v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  __int128 *v63;
  _OWORD *v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_57:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v30 = (v5 - v9) >> 2;
      if (v5 == v9)
        v30 = 1;
      if (!(v30 >> 61))
      {
        v31 = v30 >> 2;
        v32 = 8 * v30;
        v33 = (char *)operator new(8 * v30);
        v34 = &v33[8 * v31];
        v35 = &v33[v32];
        v37 = v5 - v7;
        v36 = v5 == v7;
        v5 = v34;
        if (!v36)
        {
          v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            v52 = &v33[8 * v31];
            v39 = v52;
            if ((unint64_t)(v52 - v7) >= 0x20)
            {
              v53 = (v38 >> 3) + 1;
              v54 = 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
              v39 = &v34[v54];
              v7 += v54;
              v55 = (__int128 *)(v6 + 3);
              v56 = v52 + 16;
              v57 = v53 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v58 = *v55;
                *(v56 - 1) = *(v55 - 1);
                *v56 = v58;
                v55 += 2;
                v56 += 2;
                v57 -= 4;
              }
              while (v57);
              if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_55;
            }
          }
          else
          {
            v39 = &v33[8 * v31];
          }
          do
          {
            v59 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v39 = v59;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_55;
      }
LABEL_65:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_57;
  }
  v18 = *(char **)(a1 + 8);
  v17 = *(char **)(a1 + 16);
  v19 = v17 - v18;
  v20 = (v17 - v18) >> 3;
  v21 = *(char **)(a1 + 24);
  v22 = (uint64_t)&v21[-*(_QWORD *)a1];
  if (v20 < (unint64_t)(v22 >> 3))
  {
    if (v21 != v17)
    {
      v68 = (char *)operator new(0x1000uLL);
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back((char **)a1, &v68);
      return;
    }
    v68 = (char *)operator new(0x1000uLL);
    std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)a1, &v68);
    v40 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v40 + 1);
    v8 = *v40;
    *(_QWORD *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_57;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v41 = (v5 - v9) >> 2;
      if (v5 == v9)
        v41 = 1;
      if (!(v41 >> 61))
      {
        v42 = v41 >> 2;
        v43 = 8 * v41;
        v33 = (char *)operator new(8 * v41);
        v34 = &v33[8 * v42];
        v35 = &v33[v43];
        v44 = v5 - v7;
        v36 = v5 == v7;
        v5 = v34;
        if (!v36)
        {
          v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            v60 = &v33[8 * v42];
            v46 = v60;
            if ((unint64_t)(v60 - v7) >= 0x20)
            {
              v61 = (v45 >> 3) + 1;
              v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
              v46 = &v34[v62];
              v7 += v62;
              v63 = (__int128 *)(v40 + 3);
              v64 = v60 + 16;
              v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v66 = *v63;
                *(v64 - 1) = *(v63 - 1);
                *v64 = v66;
                v63 += 2;
                v64 += 2;
                v65 -= 4;
              }
              while (v65);
              if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_55;
            }
          }
          else
          {
            v46 = &v33[8 * v42];
          }
          do
          {
            v67 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v46 = v67;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_55:
        *(_QWORD *)a1 = v33;
        *(_QWORD *)(a1 + 8) = v34;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_57;
      }
      goto LABEL_65;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v21 == *(char **)a1)
    v24 = 1;
  else
    v24 = v23;
  v72 = a1 + 24;
  if (v24 >> 61)
    goto LABEL_65;
  v25 = (char *)operator new(8 * v24);
  v26 = &v25[8 * v20];
  v68 = v25;
  v69 = v26;
  v27 = &v25[8 * v24];
  v71 = v27;
  v28 = operator new(0x1000uLL);
  if (v20 == v24)
  {
    if (v19 < 1)
    {
      if (v17 == v18)
        v47 = 1;
      else
        v47 = v19 >> 2;
      if (v47 >> 61)
        goto LABEL_65;
      v48 = (char *)operator new(8 * v47);
      v26 = &v48[8 * (v47 >> 2)];
      v27 = &v48[8 * v47];
      v68 = v48;
      v69 = v26;
      v71 = v27;
      operator delete(v25);
      v18 = *(char **)(a1 + 8);
      v17 = *(char **)(a1 + 16);
      v25 = v48;
    }
    else
    {
      v29 = v20 + 2;
      if (v20 >= -1)
        v29 = v20 + 1;
      v26 -= 8 * (v29 >> 1);
      v69 = v26;
    }
  }
  *(_QWORD *)v26 = v28;
  v49 = v26 + 8;
  v70 = v26 + 8;
  if (v17 == v18)
  {
    v17 = v18;
  }
  else
  {
    do
    {
      v17 -= 8;
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)&v68, v17);
    }
    while (v17 != *(char **)(a1 + 8));
    v25 = v68;
    v26 = v69;
    v18 = *(char **)(a1 + 16);
    v49 = v70;
    v27 = v71;
  }
  v50 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v26;
  v68 = v50;
  v69 = v17;
  v51 = *(char **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v49;
  *(_QWORD *)(a1 + 24) = v27;
  v70 = v18;
  v71 = v51;
  if (v18 != v17)
    v70 = &v18[(v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8];
  if (v50)
    operator delete(v50);
}

void ZinIrSoftmaxUnitInfo::~ZinIrSoftmaxUnitInfo(ZinIrSoftmaxUnitInfo *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C01FAD8;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C01FAD8;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

_QWORD *std::__hash_table<ZinIrDimension,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,std::allocator<ZinIrDimension>>::__emplace_unique_key_args<ZinIrDimension,ZinIrDimension>(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t prime;
  unint64_t v18;
  uint8x8_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      prime = v16;
    else
      prime = v15;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v7 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v7)
      goto LABEL_41;
    if (prime < v7)
    {
      v18 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (v19 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v19.i16[0] = vaddlv_u8(v19), v19.u32[0] > 1uLL))
      {
        v18 = std::__next_prime(v18);
      }
      else
      {
        v20 = 1 << -(char)__clz(v18 - 1);
        if (v18 >= 2)
          v18 = v20;
      }
      if (prime <= v18)
        prime = v18;
      if (prime < v7)
LABEL_41:
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(a1, prime);
    }
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v10 = *v22;
LABEL_55:
    *v22 = v10;
    goto LABEL_56;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v23 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v23 >= v7)
        v23 %= v7;
    }
    else
    {
      v23 &= v7 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_55;
  }
LABEL_56:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void ZinIrChannelToSpaceUnitInfo::~ZinIrChannelToSpaceUnitInfo(ZinIrChannelToSpaceUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrPixelShuffleUnitInfo::~ZinIrPixelShuffleUnitInfo(ZinIrPixelShuffleUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrPixelUnshuffleUnitInfo::~ZinIrPixelUnshuffleUnitInfo(ZinIrPixelUnshuffleUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrSpaceToChannelUnitInfo::~ZinIrSpaceToChannelUnitInfo(ZinIrSpaceToChannelUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrBatchToSpaceUnitInfo::~ZinIrBatchToSpaceUnitInfo(ZinIrBatchToSpaceUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrSpaceToBatchUnitInfo::~ZinIrSpaceToBatchUnitInfo(ZinIrSpaceToBatchUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrResizeUnitInfo::~ZinIrResizeUnitInfo(ZinIrResizeUnitInfo *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C01F040;
  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24C01F040;
  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
  JUMPOUT(0x20BD002F8);
}

void llvm::detail::provider_format_adapter<unsigned long long &>::~provider_format_adapter()
{
  JUMPOUT(0x20BD002F8);
}

llvm::raw_ostream *llvm::detail::provider_format_adapter<unsigned long long &>::format(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return llvm::format_provider<unsigned long long,void>::format(*(unint64_t **)(a1 + 8), a2, a3, a4);
}

llvm::raw_ostream *llvm::format_provider<unsigned long long,void>::format(unint64_t *a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  int v6;
  unint64_t v7;
  unint64_t v8;
  int v10;
  unsigned int v11;
  size_t v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  unint64_t v16;

  v14 = a3;
  v15 = a4;
  v13 = 0;
  if (llvm::detail::HelperFunctions::consumeHexStyle((uint64_t)&v14, &v13))
  {
    v6 = v13;
    v16 = 0;
    if (llvm::consumeUnsignedInteger(&v14, 0xAu, &v16))
      v7 = 0;
    else
      v7 = v16;
    if (ZinHWEnumsUtils::IsHWKernelFormatFloat(v6))
      v8 = v7 + 2;
    else
      v8 = v7;
    return llvm::write_hex(a2, *a1, v13, v8, 1);
  }
  if (v15)
  {
    v10 = 0;
    v11 = *v14;
    if (v11 <= 0x63)
    {
      if (v11 != 68)
      {
        if (v11 != 78)
          goto LABEL_20;
        goto LABEL_17;
      }
LABEL_18:
      v10 = 0;
      ++v14;
      goto LABEL_19;
    }
    if (v11 == 100)
      goto LABEL_18;
    if (v11 == 110)
    {
LABEL_17:
      ++v14;
      v10 = 1;
LABEL_19:
      --v15;
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_20:
  v16 = 0;
  if (llvm::consumeUnsignedInteger(&v14, 0xAu, &v16))
    v12 = 0;
  else
    v12 = v16;
  return llvm::write_integer(a2, *a1, v12, v10);
}

void llvm::detail::provider_format_adapter<unsigned long>::~provider_format_adapter()
{
  JUMPOUT(0x20BD002F8);
}

llvm::raw_ostream *llvm::detail::provider_format_adapter<unsigned long>::format(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return llvm::format_provider<unsigned long long,void>::format((unint64_t *)(a1 + 8), a2, a3, a4);
}

void ZinIrInputViewUnitInfo::~ZinIrInputViewUnitInfo(ZinIrInputViewUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrTransposeUnitInfo::~ZinIrTransposeUnitInfo(ZinIrTransposeUnitInfo *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_24C021A98;
  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
  {
    *((_QWORD *)this + 11) = v2;
    operator delete(v2);
  }
  *(_QWORD *)this = off_24C017CA0;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *((_QWORD *)this + 6);
    v5 = (void *)*((_QWORD *)this + 5);
    if (v4 != v3)
    {
      do
      {
        if (*(char *)(v4 - 1) < 0)
          operator delete(*(void **)(v4 - 24));
        v4 -= 24;
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v3;
    operator delete(v5);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_24C021A98;
  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
  {
    *((_QWORD *)this + 11) = v2;
    operator delete(v2);
  }
  *(_QWORD *)this = off_24C017CA0;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *((_QWORD *)this + 6);
    v5 = (void *)*((_QWORD *)this + 5);
    if (v4 != v3)
    {
      do
      {
        if (*(char *)(v4 - 1) < 0)
          operator delete(*(void **)(v4 - 24));
        v4 -= 24;
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v3;
    operator delete(v5);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>,unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::InsertIntoBucket<unsigned long long const&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::grow(a1, v7);
  v8 = *a3;
  v10 = *(_DWORD *)(a1 + 16) - 1;
  v11 = (37 * *a3) & v10;
  a2 = (uint64_t *)(*(_QWORD *)a1 + 16 * v11);
  v12 = *a2;
  if (*a3 != *a2)
  {
    v13 = 0;
    v14 = 1;
    while (v12 != -1)
    {
      if (v13)
        v15 = 0;
      else
        v15 = v12 == -2;
      if (v15)
        v13 = a2;
      v16 = v11 + v14++;
      v11 = v16 & v10;
      a2 = (uint64_t *)(*(_QWORD *)a1 + 16 * (v16 & v10));
      v12 = *a2;
      if (v8 == *a2)
        goto LABEL_4;
    }
    if (v13)
      a2 = v13;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1)
    --*(_DWORD *)(a1 + 12);
  *a2 = *a3;
  a2[1] = 0;
  return a2;
}

_QWORD *llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  int v16;
  llvm *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  _QWORD *v27;
  int v28;
  BOOL v29;
  unsigned int v30;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_39;
      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 2;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -1;
        *v13 = -1;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_39:
        do
        {
          *v10 = -1;
          v10 += 2;
        }
        while (v10 != &result[2 * v11]);
      }
    }
    if ((_DWORD)v3)
    {
      v15 = 0;
      v16 = v11 - 1;
      v17 = v4;
      do
      {
        v24 = *(_QWORD *)v17;
        if (*(_QWORD *)v17 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v25 = (37 * v24) & v16;
          v23 = &result[2 * v25];
          v26 = *v23;
          if (v24 != *v23)
          {
            v27 = 0;
            v28 = 1;
            while (v26 != -1)
            {
              if (v27)
                v29 = 0;
              else
                v29 = v26 == -2;
              if (v29)
                v27 = v23;
              v30 = v25 + v28++;
              v25 = v30 & v16;
              v23 = &result[2 * (v30 & v16)];
              v26 = *v23;
              if (v24 == *v23)
                goto LABEL_23;
            }
            if (v27)
              v23 = v27;
          }
LABEL_23:
          *v23 = v24;
          v23[1] = *((_QWORD *)v17 + 1);
          *(_DWORD *)(a1 + 8) = ++v15;
        }
        v17 = (llvm *)((char *)v17 + 16);
      }
      while (v17 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v18 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v18)
  {
    if (((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_18;
    v19 = ((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[2 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    v20 = result + 2;
    v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v20 - 2) = -1;
      *v20 = -1;
      v20 += 4;
      v21 -= 2;
    }
    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_18:
      v22 = &result[2 * v18];
      do
      {
        *v10 = -1;
        v10 += 2;
      }
      while (v10 != v22);
    }
  }
  return result;
}

void ZinIrPadUnitInfo::~ZinIrPadUnitInfo(ZinIrPadUnitInfo *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C01BAC0;
  v2 = (void *)*((_QWORD *)this + 25);
  if (v2)
  {
    *((_QWORD *)this + 26) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24C01BAC0;
  v2 = (void *)*((_QWORD *)this + 25);
  if (v2)
  {
    *((_QWORD *)this + 26) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
  JUMPOUT(0x20BD002F8);
}

void ZinIrMatrixMultUnitInfo::~ZinIrMatrixMultUnitInfo(ZinIrMatrixMultUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrFlattenUnitInfo::~ZinIrFlattenUnitInfo(ZinIrFlattenUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrUnflattenUnitInfo::~ZinIrUnflattenUnitInfo(ZinIrUnflattenUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrReshapeUnitInfo::~ZinIrReshapeUnitInfo(ZinIrReshapeUnitInfo *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_24C01FAB8;
  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  *(_QWORD *)this = off_24C017CA0;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *((_QWORD *)this + 6);
    v5 = (void *)*((_QWORD *)this + 5);
    if (v4 != v3)
    {
      do
      {
        if (*(char *)(v4 - 1) < 0)
          operator delete(*(void **)(v4 - 24));
        v4 -= 24;
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v3;
    operator delete(v5);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_24C01FAB8;
  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  *(_QWORD *)this = off_24C017CA0;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *((_QWORD *)this + 6);
    v5 = (void *)*((_QWORD *)this + 5);
    if (v4 != v3)
    {
      do
      {
        if (*(char *)(v4 - 1) < 0)
          operator delete(*(void **)(v4 - 24));
        v4 -= 24;
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v3;
    operator delete(v5);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrConcatUnitInfo::~ZinIrConcatUnitInfo(ZinIrConcatUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrInstanceNormUnitInfo::~ZinIrInstanceNormUnitInfo(ZinIrInstanceNormUnitInfo *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C020880;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C020880;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

const __CFString *ZinIrInstanceNormUnitInfo::GetInvalidDimError(ZinIrInstanceNormUnitInfo *this)
{
  return CFSTR("InvalidUnitInstanceNormDimension");
}

const __CFString *ZinIrInstanceNormUnitInfo::GetMissingEpsilonError(ZinIrInstanceNormUnitInfo *this)
{
  return CFSTR("MissingInstanceNormEpsilon");
}

BOOL ZinIrInstanceNormUnitInfo::SupportDim(ZinIrInstanceNormUnitInfo *this, const __CFString *a2)
{
  return !ZinCFStringEquals(a2, CFSTR("Channel")) && !ZinCFStringEquals(a2, CFSTR("Batch"));
}

void ZinIrCropResizeUnitInfo::~ZinIrCropResizeUnitInfo(ZinIrCropResizeUnitInfo *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0221B0;
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
  {
    *((_QWORD *)this + 21) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0221B0;
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
  {
    *((_QWORD *)this + 21) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
  JUMPOUT(0x20BD002F8);
}

void ZinIrGatherUnitInfo::~ZinIrGatherUnitInfo(ZinIrGatherUnitInfo *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C01ED60;
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
  {
    *((_QWORD *)this + 21) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_24C01ED60;
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
  {
    *((_QWORD *)this + 21) = v2;
    operator delete(v2);
  }
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);
  JUMPOUT(0x20BD002F8);
}

void ZinIrArgMinMaxUnitInfo::~ZinIrArgMinMaxUnitInfo(ZinIrArgMinMaxUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrGlobalArgMinMaxUnitInfo::~ZinIrGlobalArgMinMaxUnitInfo(ZinIrGlobalArgMinMaxUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrTileUnitInfo::~ZinIrTileUnitInfo(ZinIrTileUnitInfo *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C01CF68;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C01CF68;
  v2 = (_QWORD *)*((_QWORD *)this + 12);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    operator delete(v4);
  *(_QWORD *)this = off_24C017CA0;
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    v6 = *((_QWORD *)this + 6);
    v7 = (void *)*((_QWORD *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0)
          operator delete(*(void **)(v6 - 24));
        v6 -= 24;
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

_QWORD *std::__hash_table<std::__hash_value_type<ZinIrDimension,int>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,int>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,int>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,int>>>::__emplace_unique_key_args<ZinIrDimension,std::piecewise_construct_t const&,std::tuple<ZinIrDimension&&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t prime;
  unint64_t v19;
  uint8x8_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x18uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = v17;
    else
      prime = v16;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v8 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v8)
      goto LABEL_41;
    if (prime < v8)
    {
      v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (v20 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        v19 = std::__next_prime(v19);
      }
      else
      {
        v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2)
          v19 = v21;
      }
      if (prime <= v19)
        prime = v19;
      if (prime < v8)
LABEL_41:
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(a1, prime);
    }
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *v11 = *v23;
LABEL_55:
    *v23 = v11;
    goto LABEL_56;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v22 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v24 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v24 >= v8)
        v24 %= v8;
    }
    else
    {
      v24 &= v8 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_55;
  }
LABEL_56:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void ZinIrDeQuantUnitInfo::~ZinIrDeQuantUnitInfo(ZinIrDeQuantUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void ZinIrQuantUnitInfo::~ZinIrQuantUnitInfo(ZinIrQuantUnitInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = off_24C017CA0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::T0::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A11Legacy::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A17::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A16::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A12::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A13::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A14::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A15::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

MirInfoChannelAssignment *mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(MirInfoChannelAssignment *this, MirInfoChannelAssignment *a2, uint64_t a3)
{
  MirInfoChannelAssignment *v3;
  unint64_t v4;
  const void *AttrData;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const void *v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  int v14;
  uint64_t v18;
  uint64_t NumNeededNEs;

  v3 = this;
  v18 = a3;
  v4 = a2 - this;
  if (a2 - this >= 257)
  {
    AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v18);
    v7 = v6;
    v8 = v4 >> 4;
    while (1)
    {
      v9 = v8 >> 1;
      NumNeededNEs = MirInfoChannelAssignment::GetNumNeededNEs((MirInfoChannelAssignment *)((char *)v3 + 16 * (v8 >> 1)));
      v10 = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&NumNeededNEs);
      v12 = v11;
      v13 = v7 >= v11 ? v11 : v7;
      if (v13)
      {
        v14 = memcmp(v10, AttrData, v13);
        if (v14)
          break;
      }
      if (v12 == v7)
        return (MirInfoChannelAssignment *)((char *)v3 + 16 * (v8 >> 1));
      if (v12 < v7)
        goto LABEL_3;
LABEL_4:
      v8 = v9;
      if (v9 <= 0)
        return v3;
    }
    if ((v14 & 0x80000000) == 0)
      goto LABEL_4;
LABEL_3:
    v3 = (MirInfoChannelAssignment *)((char *)v3 + 16 * (v8 >> 1) + 16);
    v9 = v8 + ~v9;
    goto LABEL_4;
  }
  if (this == a2)
    return a2;
  while (MirInfoChannelAssignment::GetNumNeededNEs(v3) != a3)
  {
    v3 = (MirInfoChannelAssignment *)((char *)v3 + 16);
    if (v3 == a2)
      return a2;
  }
  return v3;
}

_QWORD *std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;

  v2 = a1[1] - *a1;
  v3 = v2 >> 3;
  v4 = (v2 >> 3) + 1;
  if (v4 >> 61)
    abort();
  v7 = a1[2] - *a1;
  if (v7 >> 2 > v4)
    v4 = v7 >> 2;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
    v8 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v8 = v4;
  if (v8)
  {
    if (v8 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v9 = (char *)operator new(8 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = &v9[8 * v3];
  v11 = &v9[8 * v8];
  v12 = *a2;
  *a2 = 0;
  *(_QWORD *)v10 = v12;
  v13 = v10 + 8;
  v14 = (char *)*a1;
  v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
      goto LABEL_31;
    v17 = (v16 >> 3) + 1;
    v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    v19 = &v15[-v18];
    v10 -= v18;
    v20 = &v9[8 * v3 - 16];
    v21 = v15 - 16;
    v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v24 = *((_OWORD *)v21 - 1);
      v23 = *(_OWORD *)v21;
      *((_OWORD *)v21 - 1) = 0uLL;
      *(_OWORD *)v21 = 0uLL;
      *((_OWORD *)v20 - 1) = v24;
      *(_OWORD *)v20 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        v25 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *(_QWORD *)v15 = 0;
        *((_QWORD *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    v15 = (char *)*a1;
    v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      v28 = *((_QWORD *)v26 - 1);
      v26 -= 8;
      v27 = v28;
      *(_QWORD *)v26 = 0;
      if (v28)
        (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
    }
  }
  if (v15)
    operator delete(v15);
  return v13;
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::ElementwiseAdd>(mlir::LogicalResult (*)(mlir::anec::ElementwiseAdd,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::ElementwiseAdd>(mlir::LogicalResult (*)(mlir::anec::ElementwiseAdd,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseAdd>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseAdd>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseAdd>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::ElementwiseAdd>(mlir::LogicalResult (*)(mlir::anec::ElementwiseAdd,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::ElementwiseMax>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMax,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::ElementwiseMax>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMax,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMax>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMax>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMax>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::ElementwiseMax>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMax,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::ElementwiseMin>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMin,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::ElementwiseMin>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMin,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMin>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMin>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMin>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::ElementwiseMin>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMin,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::ElementwiseMult>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMult,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::ElementwiseMult>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMult,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMult>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMult>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseMult>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::ElementwiseMult>(mlir::LogicalResult (*)(mlir::anec::ElementwiseMult,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::ElementwiseSub>(mlir::LogicalResult (*)(mlir::anec::ElementwiseSub,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::ElementwiseSub>(mlir::LogicalResult (*)(mlir::anec::ElementwiseSub,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseSub>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseSub>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::ElementwiseSub>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::ElementwiseSub>(mlir::LogicalResult (*)(mlir::anec::ElementwiseSub,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::Reshape>(mlir::LogicalResult (*)(mlir::anec::Reshape,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::Reshape>(mlir::LogicalResult (*)(mlir::anec::Reshape,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Reshape>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Reshape>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Reshape>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::Reshape>(mlir::LogicalResult (*)(mlir::anec::Reshape,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

_QWORD *mlir::RewritePatternSet::add<mlir::anec::Transpose>(mlir::LogicalResult (*)(mlir::anec::Transpose,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::anec::Transpose>(mlir::LogicalResult (*)(mlir::anec::Transpose,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Transpose>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Transpose>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Transpose>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::anec::Transpose>(mlir::LogicalResult (*)(mlir::anec::Transpose,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

uint64_t _GLOBAL__sub_I_ANECOps_cpp()
{
  char v1;
  char *v2;
  char *v3;
  __int128 v4;

  *(_QWORD *)&v4 = "Generate ANEC IR ProcedureList (single macho)";
  *((_QWORD *)&v4 + 1) = 45;
  v1 = 0;
  v2 = &v1;
  v3 = &mlir::anec::ANECDialect::enableProcedureList;
  llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>::opt<char [26],llvm::cl::desc,llvm::cl::LocationClass<BOOL>,llvm::cl::initializer<BOOL>>((uint64_t)&mlir::anec::enableProcedureList, (int8x16_t *)"anec-enable-procedurelist", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))llvm::cl::opt<BOOL,true,llvm::cl::parser<BOOL>>::~opt, &mlir::anec::enableProcedureList, &dword_2069AB000);
}

void mlir::anec::computeOpKeyString(mlir::anec *this@<X0>, std::string *a2@<X8>)
{
  uint64_t InherentAttr;
  char v6;
  uint64_t AttrData;
  unint64_t v8;
  const void *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  mlir::StringAttr *Context;
  int v14;
  BOOL v15;
  std::string *v16;
  std::string::size_type size;
  uint64_t v18;
  mlir::StringAttr *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::string *v23;
  uint64_t v24;
  _QWORD v25[4];
  __int16 v26;
  _QWORD v27[4];
  __int16 v28;
  _QWORD v29[4];
  __int16 v30;

  if (*((_BYTE *)this + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)this, (uint64_t)"name", 4), v6))
  {
    if (InherentAttr)
      goto LABEL_4;
  }
  else
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)this + 56, "name", 4uLL);
    if (InherentAttr)
    {
LABEL_4:
      v29[0] = InherentAttr;
      AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v29);
      if (v8 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      v9 = (const void *)AttrData;
      v10 = v8;
      if (v8 >= 0x17)
      {
        v21 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v8 | 7) != 0x17)
          v21 = v8 | 7;
        v22 = v21 + 1;
        v23 = (std::string *)operator new(v21 + 1);
        a2->__r_.__value_.__l.__size_ = v10;
        a2->__r_.__value_.__r.__words[2] = v22 | 0x8000000000000000;
        a2->__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
        a2 = v23;
      }
      else
      {
        *((_BYTE *)&a2->__r_.__value_.__s + 23) = v8;
        if (!v8)
          goto LABEL_18;
      }
      memmove(a2, v9, v10);
LABEL_18:
      a2->__r_.__value_.__s.__data_[v10] = 0;
      return;
    }
  }
  v29[0] = *(_QWORD *)(*((_QWORD *)this + 6) + 8);
  v26 = 1283;
  v25[2] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v29);
  v25[3] = v11;
  v27[0] = v25;
  v27[2] = "_";
  v28 = 770;
  v12 = mlir::anec::ANECIRNetwork::name_counter_++;
  v24 = v12;
  v25[0] = "__";
  v29[0] = v27;
  v29[2] = &v24;
  v30 = 2818;
  llvm::Twine::str((llvm::Twine *)v29, a2);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::anec *)((char *)this + 24));
  v14 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  v15 = v14 < 0;
  v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
  if (v14 >= 0)
    v16 = a2;
  size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  if (v15)
    size = a2->__r_.__value_.__l.__size_;
  v28 = 261;
  v27[0] = v16;
  v27[1] = size;
  v18 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v27);
  v19 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::anec *)((char *)this + 24));
  v30 = 261;
  v29[0] = "name";
  v29[1] = 4;
  v20 = mlir::StringAttr::get(v19, (mlir::MLIRContext *)v29);
  mlir::Operation::setAttr((uint64_t)this, v20, v18);
}

uint64_t mlir::anec::getANECIRDataType(uint64_t a1)
{
  _BYTE v2[40];
  uint64_t v3;
  _BYTE v4[192];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&v3, 8))
    return 0;
  if (mlir::Type::isSignedInteger((mlir::Type *)&v3, 8) || mlir::Type::isSignlessInteger((mlir::Type *)&v3, 8))
    return 1;
  if (mlir::Type::isF16((mlir::Type *)&v3))
    return 2;
  if (!mlir::Type::isF32((mlir::Type *)&v3))
    mlir::anec::getANECIRDataType((mlir::Attribute *)&v3, (uint64_t)v2, (mlir::InFlightDiagnostic *)v4);
  return 3;
}

{
  uint64_t v1;
  uint64_t OperandRange;
  _QWORD v4[2];

  v4[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8));
  v4[1] = v1;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v4);
  return mlir::anec::getANECIRDataType(OperandRange);
}

void mlir::anec::ANECIRInput::Serialize(mlir::anec::ANECIRInput *this@<X0>, uint64_t **a2@<X8>)
{
  uint64_t *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  void *__p;
  char v65;
  std::string v66;
  std::string v67;
  std::string v68;
  uint64_t v69;
  std::__shared_weak_count *v70;

  mlir::anec::ANECDictionary::Create(a2);
  v4 = *a2;
  if (*((char *)this + 31) < 0)
    std::string::__init_copy_ctor_external(&v68, *((const std::string::value_type **)this + 1), *((_QWORD *)this + 2));
  else
    v68 = *(std::string *)((char *)this + 8);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v68, &v69);
  mlir::anec::ANECDictionary::Add(v4, CFSTR("InputName"), &v69);
  v5 = v70;
  if (!v70)
    goto LABEL_8;
  p_shared_owners = (unint64_t *)&v70->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if ((SHIBYTE(v68.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      v8 = *((char *)this + 71);
      if ((v8 & 0x80000000) == 0)
        goto LABEL_10;
      goto LABEL_14;
    }
  }
  else
  {
LABEL_8:
    if ((SHIBYTE(v68.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_9;
  }
  operator delete(v68.__r_.__value_.__l.__data_);
  v8 = *((char *)this + 71);
  if ((v8 & 0x80000000) == 0)
  {
LABEL_10:
    if (!(_BYTE)v8)
      goto LABEL_33;
    goto LABEL_15;
  }
LABEL_14:
  if (!*((_QWORD *)this + 7))
    goto LABEL_33;
LABEL_15:
  v9 = *a2;
  if (*((char *)this + 95) < 0)
    std::string::__init_copy_ctor_external(&v67, *((const std::string::value_type **)this + 9), *((_QWORD *)this + 10));
  else
    v67 = *(std::string *)((_BYTE *)this + 3);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v67, &v69);
  mlir::anec::ANECDictionary::Add(v9, CFSTR("Name"), &v69);
  v10 = v70;
  if (v70)
  {
    v11 = (unint64_t *)&v70->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if ((SHIBYTE(v67.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
LABEL_23:
    operator delete(v67.__r_.__value_.__l.__data_);
LABEL_24:
  v13 = *a2;
  if (*((char *)this + 71) < 0)
    std::string::__init_copy_ctor_external(&v66, *((const std::string::value_type **)this + 6), *((_QWORD *)this + 7));
  else
    v66 = *(std::string *)((_BYTE *)this + 2);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v66, &v69);
  mlir::anec::ANECDictionary::Add(v13, CFSTR("OperationName"), &v69);
  v14 = v70;
  if (v70)
  {
    v15 = (unint64_t *)&v70->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      if ((SHIBYTE(v66.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_33;
      goto LABEL_32;
    }
  }
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
LABEL_32:
    operator delete(v66.__r_.__value_.__l.__data_);
LABEL_33:
  v17 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 17), &v69);
  mlir::anec::ANECDictionary::Add(v17, CFSTR("BatchSize"), &v69);
  v18 = v70;
  if (v70)
  {
    v19 = (unint64_t *)&v70->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 12), &v69);
  mlir::anec::ANECDictionary::Add(v21, CFSTR("InputInterleave"), &v69);
  v22 = v70;
  if (v70)
  {
    v23 = (unint64_t *)&v70->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = *a2;
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v69);
  mlir::anec::ANECDictionary::Add(v25, CFSTR("InputType"), &v69);
  v26 = v70;
  if (v70)
  {
    v27 = (unint64_t *)&v70->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
      if ((v65 & 0x80000000) == 0)
        goto LABEL_49;
      goto LABEL_48;
    }
  }
  if (v65 < 0)
LABEL_48:
    operator delete(__p);
LABEL_49:
  v29 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 15), &v69);
  mlir::anec::ANECDictionary::Add(v29, CFSTR("InputHeight"), &v69);
  v30 = v70;
  if (v70)
  {
    v31 = (unint64_t *)&v70->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 14), &v69);
  mlir::anec::ANECDictionary::Add(v33, CFSTR("InputWidth"), &v69);
  v34 = v70;
  if (v70)
  {
    v35 = (unint64_t *)&v70->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 16), &v69);
  mlir::anec::ANECDictionary::Add(v37, CFSTR("InputChannels"), &v69);
  v38 = v70;
  if (v70)
  {
    v39 = (unint64_t *)&v70->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v41 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 19), &v69);
  mlir::anec::ANECDictionary::Add(v41, CFSTR("InputRowStride"), &v69);
  v42 = v70;
  if (v70)
  {
    v43 = (unint64_t *)&v70->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 20), &v69);
  mlir::anec::ANECDictionary::Add(v45, CFSTR("InputPlaneStride"), &v69);
  v46 = v70;
  if (!v70)
    goto LABEL_73;
  v47 = (unint64_t *)&v70->__shared_owners_;
  do
    v48 = __ldaxr(v47);
  while (__stlxr(v48 - 1, v47));
  if (!v48)
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
    v49 = *((_QWORD *)this + 18);
    if (!v49)
      goto LABEL_82;
  }
  else
  {
LABEL_73:
    v49 = *((_QWORD *)this + 18);
    if (!v49)
      goto LABEL_82;
  }
  v50 = *a2;
  mlir::anec::ANECDictionary::PListEntry(v49, &v69);
  mlir::anec::ANECDictionary::Add(v50, CFSTR("InputDepth"), &v69);
  v51 = v70;
  if (v70)
  {
    v52 = (unint64_t *)&v70->__shared_owners_;
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
LABEL_82:
  v54 = *((_QWORD *)this + 21);
  if (v54)
  {
    v55 = *a2;
    mlir::anec::ANECDictionary::PListEntry(v54, &v69);
    mlir::anec::ANECDictionary::Add(v55, CFSTR("InputDepthStride"), &v69);
    v56 = v70;
    if (v70)
    {
      v57 = (unint64_t *)&v70->__shared_owners_;
      do
        v58 = __ldaxr(v57);
      while (__stlxr(v58 - 1, v57));
      if (!v58)
      {
        ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
        std::__shared_weak_count::__release_weak(v56);
      }
    }
  }
  v59 = *((_QWORD *)this + 22);
  if (v59)
  {
    v60 = *a2;
    mlir::anec::ANECDictionary::PListEntry(v59, &v69);
    mlir::anec::ANECDictionary::Add(v60, CFSTR("InputBatchStride"), &v69);
    v61 = v70;
    if (v70)
    {
      v62 = (unint64_t *)&v70->__shared_owners_;
      do
        v63 = __ldaxr(v62);
      while (__stlxr(v63 - 1, v62));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }
    }
  }
}

void `anonymous namespace'::stringify_to_cfstr(int a1)
{
  __asm { BR              X10 }
}

size_t sub_20711D79C()
{
  _QWORD *v0;
  const char *CStringPtr;
  size_t result;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  CStringPtr = CFStringGetCStringPtr(CFSTR("UInt8"), 0x8000100u);
  result = strlen(CStringPtr);
  if (result > 0x7FFFFFFFFFFFFFF7)
    abort();
  v3 = result;
  if (result >= 0x17)
  {
    v4 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v4 = result | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    v0[1] = v3;
    v0[2] = v5 | 0x8000000000000000;
    *v0 = v6;
    v0 = v6;
  }
  else
  {
    *((_BYTE *)v0 + 23) = result;
    if (!result)
      goto LABEL_9;
  }
  result = (size_t)memmove(v0, CStringPtr, v3);
LABEL_9:
  *((_BYTE *)v0 + v3) = 0;
  return result;
}

void mlir::anec::ANECIROutput::Serialize(mlir::anec::ANECIROutput *this@<X0>, uint64_t **a2@<X8>)
{
  uint64_t *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::string *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  void *__p;
  char v48;
  std::string v49;
  std::string v50;
  std::string v51;
  std::string v52;
  uint64_t v53;
  std::__shared_weak_count *v54;

  mlir::anec::ANECDictionary::Create(a2);
  v4 = *a2;
  if (*((char *)this + 31) < 0)
    std::string::__init_copy_ctor_external(&v52, *((const std::string::value_type **)this + 1), *((_QWORD *)this + 2));
  else
    v52 = *(std::string *)((char *)this + 8);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v52, &v53);
  mlir::anec::ANECDictionary::Add(v4, CFSTR("OutputName"), &v53);
  v5 = v54;
  if (!v54)
    goto LABEL_8;
  p_shared_owners = (unint64_t *)&v54->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      v8 = *((char *)this + 71);
      if ((v8 & 0x80000000) == 0)
        goto LABEL_10;
      goto LABEL_15;
    }
  }
  else
  {
LABEL_8:
    if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_9;
  }
  operator delete(v52.__r_.__value_.__l.__data_);
  v8 = *((char *)this + 71);
  if ((v8 & 0x80000000) == 0)
  {
LABEL_10:
    v9 = *a2;
    if ((_BYTE)v8)
      goto LABEL_11;
LABEL_16:
    if (*((char *)this + 127) < 0)
      std::string::__init_copy_ctor_external(&v51, *((const std::string::value_type **)this + 13), *((_QWORD *)this + 14));
    else
      v51 = *(std::string *)((char *)this + 104);
    mlir::anec::ANECDictionary::PListEntry((uint64_t)&v51, &v53);
    mlir::anec::ANECDictionary::Add(v9, CFSTR("Bottom"), &v53);
    v18 = v54;
    if (!v54)
      goto LABEL_43;
    v19 = (unint64_t *)&v54->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
      if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_48;
    }
    else
    {
LABEL_43:
      if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_48;
    }
    v17 = &v51;
    goto LABEL_47;
  }
LABEL_15:
  v9 = *a2;
  if (!*((_QWORD *)this + 7))
    goto LABEL_16;
LABEL_11:
  if (*((char *)this + 95) < 0)
    std::string::__init_copy_ctor_external(&v50, *((const std::string::value_type **)this + 9), *((_QWORD *)this + 10));
  else
    v50 = *(std::string *)((_BYTE *)this + 3);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v50, &v53);
  mlir::anec::ANECDictionary::Add(v9, CFSTR("Name"), &v53);
  v10 = v54;
  if (!v54)
    goto LABEL_23;
  v11 = (unint64_t *)&v54->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (v12)
  {
LABEL_23:
    if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_25;
    goto LABEL_24;
  }
  ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
  std::__shared_weak_count::__release_weak(v10);
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
LABEL_24:
    operator delete(v50.__r_.__value_.__l.__data_);
LABEL_25:
  v13 = *a2;
  if (*((char *)this + 71) < 0)
    std::string::__init_copy_ctor_external(&v49, *((const std::string::value_type **)this + 6), *((_QWORD *)this + 7));
  else
    v49 = *(std::string *)((_BYTE *)this + 2);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v49, &v53);
  mlir::anec::ANECDictionary::Add(v13, CFSTR("OperationName"), &v53);
  v14 = v54;
  if (!v54)
    goto LABEL_32;
  v15 = (unint64_t *)&v54->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_33;
  }
  else
  {
LABEL_32:
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_33:
      v17 = &v49;
LABEL_47:
      operator delete(v17->__r_.__value_.__l.__data_);
    }
  }
LABEL_48:
  v21 = *a2;
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v53);
  mlir::anec::ANECDictionary::Add(v21, CFSTR("OutputType"), &v53);
  v22 = v54;
  if (v54)
  {
    v23 = (unint64_t *)&v54->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
      if ((v48 & 0x80000000) == 0)
        goto LABEL_54;
      goto LABEL_53;
    }
  }
  if (v48 < 0)
LABEL_53:
    operator delete(__p);
LABEL_54:
  v25 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 17), &v53);
  mlir::anec::ANECDictionary::Add(v25, CFSTR("OutputRowStride"), &v53);
  v26 = v54;
  if (v54)
  {
    v27 = (unint64_t *)&v54->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 18), &v53);
  mlir::anec::ANECDictionary::Add(v29, CFSTR("OutputPlaneStride"), &v53);
  v30 = v54;
  if (v54)
  {
    v31 = (unint64_t *)&v54->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 12), &v53);
  mlir::anec::ANECDictionary::Add(v33, CFSTR("OutputInterleave"), &v53);
  v34 = v54;
  if (v54)
  {
    v35 = (unint64_t *)&v54->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = *((_QWORD *)this + 19);
  if (v37)
  {
    v38 = *a2;
    mlir::anec::ANECDictionary::PListEntry(v37, &v53);
    mlir::anec::ANECDictionary::Add(v38, CFSTR("OutputDepthStride"), &v53);
    v39 = v54;
    if (v54)
    {
      v40 = (unint64_t *)&v54->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }
  v42 = *((_QWORD *)this + 20);
  if (v42)
  {
    v43 = *a2;
    mlir::anec::ANECDictionary::PListEntry(v42, &v53);
    mlir::anec::ANECDictionary::Add(v43, CFSTR("OutputBatchStride"), &v53);
    v44 = v54;
    if (v54)
    {
      v45 = (unint64_t *)&v54->__shared_owners_;
      do
        v46 = __ldaxr(v45);
      while (__stlxr(v46 - 1, v45));
      if (!v46)
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
  }
}

void mlir::anec::ANECIRUnit::Serialize(mlir::anec::ANECIRUnit *this@<X0>, const ZinIrUnitInfo *a2@<X1>, uint64_t **a3@<X8>)
{
  mlir::anec::ANECDictionary *v5;
  uint64_t *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::string __p;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v5 = (mlir::anec::ANECDictionary *)*((_QWORD *)this + 5);
  if (v5)
  {
    mlir::anec::ANECDictionary::Create(v5, a2);
    return;
  }
  mlir::anec::ANECDictionary::Create(a3);
  v6 = *a3;
  mlir::anec::ANECDictionary::PListEntry(*((CFStringRef *)this + 7), &v15);
  mlir::anec::ANECDictionary::Add(v6, CFSTR("Type"), &v15);
  v7 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = *a3;
  if (*((char *)this + 31) < 0)
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 1), *((_QWORD *)this + 2));
  else
    __p = *(std::string *)((char *)this + 8);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v15);
  mlir::anec::ANECDictionary::Add(v10, CFSTR("Name"), &v15);
  v11 = v16;
  if (!v16)
    goto LABEL_15;
  v12 = (unint64_t *)&v16->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (v13)
  {
LABEL_15:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_17;
    goto LABEL_16;
  }
  ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
  std::__shared_weak_count::__release_weak(v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_16:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_17:
  if (*((_BYTE *)this + 48))
}

void mlir::anec::ANECDictionary::Add<std::pair<std::string,mlir::anec::ANECIRDataType>,std::string (*)(std::pair<std::string,mlir::anec::ANECIRDataType> const&)>(uint64_t *a1, CFStringRef theString, uint64_t a3, uint64_t a4, void (*a5)(void **__return_ptr, uint64_t), char a6)
{
  const char *CStringPtr;
  size_t v12;
  size_t v13;
  __int128 *p_dst;
  uint64_t v15;
  uint64_t v16;
  __int128 __dst;
  unint64_t v18;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v12 = strlen(CStringPtr);
  if (v12 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v13 = v12;
  if (v12 >= 0x17)
  {
    v15 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17)
      v15 = v12 | 7;
    v16 = v15 + 1;
    p_dst = (__int128 *)operator new(v15 + 1);
    *((_QWORD *)&__dst + 1) = v13;
    v18 = v16 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v18) = v12;
  p_dst = &__dst;
  if (v12)
LABEL_8:
    memmove(p_dst, CStringPtr, v13);
  *((_BYTE *)p_dst + v13) = 0;
  mlir::anec::ANECDictionary::Add<std::pair<std::string,mlir::anec::ANECIRDataType>,std::string (*)(std::pair<std::string,mlir::anec::ANECIRDataType> const&)>(a1, &__dst, a3, a4, a5, a6);
  if (SHIBYTE(v18) < 0)
    operator delete((void *)__dst);
}

void `anonymous namespace'::get_elem<std::pair<std::string,mlir::anec::ANECIRDataType>,0ul,`anonymous namespace'::identity_xform<std::string>>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
  }
}

void `anonymous namespace'::get_elem<std::pair<std::string,mlir::anec::ANECIRDataType>,1ul,`anonymous namespace'::tensortype_to_string>(uint64_t a1)
{
}

void mlir::anec::ANECDictionary::Add<std::pair<mlir::anec::ANECIRDataType,unsigned long>,std::string (*)(std::pair<mlir::anec::ANECIRDataType,unsigned long> const&)>(uint64_t *a1, CFStringRef theString, uint64_t a3, uint64_t a4, void (*a5)(void **__return_ptr, uint64_t), char a6)
{
  const char *CStringPtr;
  size_t v12;
  size_t v13;
  __int128 *p_dst;
  uint64_t v15;
  uint64_t v16;
  __int128 __dst;
  unint64_t v18;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v12 = strlen(CStringPtr);
  if (v12 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v13 = v12;
  if (v12 >= 0x17)
  {
    v15 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17)
      v15 = v12 | 7;
    v16 = v15 + 1;
    p_dst = (__int128 *)operator new(v15 + 1);
    *((_QWORD *)&__dst + 1) = v13;
    v18 = v16 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v18) = v12;
  p_dst = &__dst;
  if (v12)
LABEL_8:
    memmove(p_dst, CStringPtr, v13);
  *((_BYTE *)p_dst + v13) = 0;
  mlir::anec::ANECDictionary::Add<std::pair<mlir::anec::ANECIRDataType,unsigned long>,std::string (*)(std::pair<mlir::anec::ANECIRDataType,unsigned long> const&)>(a1, &__dst, a3, a4, a5, a6);
  if (SHIBYTE(v18) < 0)
    operator delete((void *)__dst);
}

void `anonymous namespace'::get_elem<std::pair<mlir::anec::ANECIRDataType,unsigned long>,0ul,`anonymous namespace'::tensortype_to_string>(int *a1)
{
}

void mlir::anec::ANECDictionary::Add<std::pair<mlir::anec::ANECIRDataType,unsigned long>,unsigned long (*)(std::pair<mlir::anec::ANECIRDataType,unsigned long> const&)>(uint64_t *a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t), char a6)
{
  const char *CStringPtr;
  size_t v12;
  size_t v13;
  __int128 *p_dst;
  uint64_t v15;
  uint64_t v16;
  __int128 __dst;
  unint64_t v18;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v12 = strlen(CStringPtr);
  if (v12 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v13 = v12;
  if (v12 >= 0x17)
  {
    v15 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17)
      v15 = v12 | 7;
    v16 = v15 + 1;
    p_dst = (__int128 *)operator new(v15 + 1);
    *((_QWORD *)&__dst + 1) = v13;
    v18 = v16 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v18) = v12;
  p_dst = &__dst;
  if (v12)
LABEL_8:
    memmove(p_dst, CStringPtr, v13);
  *((_BYTE *)p_dst + v13) = 0;
  mlir::anec::ANECDictionary::Add<std::pair<mlir::anec::ANECIRDataType,unsigned long>,unsigned long (*)(std::pair<mlir::anec::ANECIRDataType,unsigned long> const&)>(a1, &__dst, a3, a4, a5, a6);
  if (SHIBYTE(v18) < 0)
    operator delete((void *)__dst);
}

uint64_t `anonymous namespace'::get_elem<std::pair<mlir::anec::ANECIRDataType,unsigned long>,1ul,`anonymous namespace'::identity_xform<unsigned long>>(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void mlir::anec::ANECIRGOCUnit::Serialize(mlir::anec::ANECIRGOCUnit *this@<X0>, const ZinIrUnitInfo *a2@<X1>, uint64_t **a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  int v19;
  uint64_t *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t *v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  uint64_t *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t *v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t *v42;
  unint64_t *v43;
  unint64_t v44;
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  uint64_t *v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  uint64_t *v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  uint64_t *v59;
  unint64_t *v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  mlir::anec::ANECDictionary *v74;
  std::__shared_weak_count *v75;
  mlir::anec::ANECDictionary *v76;
  std::__shared_weak_count *v77;
  mlir::anec::ANECDictionary *v78;
  std::__shared_weak_count *v79;
  mlir::anec::ANECDictionary *v80;
  std::__shared_weak_count *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;

  mlir::anec::ANECIRUnit::Serialize(this, a2, a3);
  mlir::anec::ANECDictionary::Create((uint64_t **)&v80);
  mlir::anec::ANECDictionary::Create((uint64_t **)&v78);
  v5 = *((int *)this + 44);
  if ((_DWORD)v5 != 0x80000000)
  {
    v20 = (uint64_t *)v80;
    mlir::anec::ANECDictionary::PListEntry(v5, &v82);
    mlir::anec::ANECDictionary::Add(v20, CFSTR("BiasScalar"), &v82);
    v21 = v83;
    if (v83)
    {
      p_shared_owners = (unint64_t *)&v83->__shared_owners_;
      do
        v23 = __ldaxr(p_shared_owners);
      while (__stlxr(v23 - 1, p_shared_owners));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    goto LABEL_24;
  }
  v6 = *((_QWORD *)this + 25);
  if (!v6)
  {
LABEL_24:
    v19 = 0;
    goto LABEL_25;
  }
  v7 = (uint64_t *)v78;
  mlir::anec::ANECDictionary::PListEntry(v6 / 2, &v82);
  mlir::anec::ANECDictionary::Add(v7, CFSTR("BiasCount"), &v82);
  v8 = v83;
  if (v83)
  {
    v9 = (unint64_t *)&v83->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = (uint64_t *)v78;
  mlir::anec::ANECDictionary::PListEntry(0, &v82);
  mlir::anec::ANECDictionary::Add(v11, CFSTR("BiasIndex"), &v82);
  v12 = v83;
  if (v83)
  {
    v13 = (unint64_t *)&v83->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = (uint64_t *)v78;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 23), &v82);
  mlir::anec::ANECDictionary::Add(v15, CFSTR("BiasOffset"), &v82);
  v16 = v83;
  if (v83)
  {
    v17 = (unint64_t *)&v83->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
  v19 = 1;
LABEL_25:
  v24 = *((int *)this + 45);
  if ((_DWORD)v24 != 0x80000000)
  {
    v38 = (uint64_t *)v80;
    mlir::anec::ANECDictionary::PListEntry(v24, &v82);
    mlir::anec::ANECDictionary::Add(v38, CFSTR("ScaleScalar"), &v82);
    v39 = v83;
    if (v83)
    {
      v40 = (unint64_t *)&v83->__shared_owners_;
      do
        v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
        if (!v19)
          goto LABEL_61;
        goto LABEL_47;
      }
    }
LABEL_46:
    if (!v19)
      goto LABEL_61;
    goto LABEL_47;
  }
  v25 = *((_QWORD *)this + 26);
  if (!v25)
    goto LABEL_46;
  v26 = (uint64_t *)v78;
  mlir::anec::ANECDictionary::PListEntry(v25 / 2, &v82);
  mlir::anec::ANECDictionary::Add(v26, CFSTR("ScaleCount"), &v82);
  v27 = v83;
  if (v83)
  {
    v28 = (unint64_t *)&v83->__shared_owners_;
    do
      v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  v30 = (uint64_t *)v78;
  mlir::anec::ANECDictionary::PListEntry(0, &v82);
  mlir::anec::ANECDictionary::Add(v30, CFSTR("ScaleIndex"), &v82);
  v31 = v83;
  if (v83)
  {
    v32 = (unint64_t *)&v83->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  v34 = (uint64_t *)v78;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 24), &v82);
  mlir::anec::ANECDictionary::Add(v34, CFSTR("ScaleOffset"), &v82);
  v35 = v83;
  if (v83)
  {
    v36 = (unint64_t *)&v83->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
LABEL_47:
  v42 = (uint64_t *)v80;
  v76 = v78;
  v77 = v79;
  if (v79)
  {
    v43 = (unint64_t *)&v79->__shared_owners_;
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
  }
  mlir::anec::ANECDictionary::PListEntry((_QWORD **)&v76, &v82);
  mlir::anec::ANECDictionary::Add(v42, CFSTR("BiasScaleGroupData"), &v82);
  v45 = v83;
  if (v83)
  {
    v46 = (unint64_t *)&v83->__shared_owners_;
    do
      v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  v48 = v77;
  if (v77)
  {
    v49 = (unint64_t *)&v77->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
LABEL_61:
  v51 = (uint64_t *)v80;
  mlir::anec::ANECDictionary::PListEntry(*((char *)this + 216), &v82);
  mlir::anec::ANECDictionary::Add(v51, CFSTR("BiasShift"), &v82);
  v52 = v83;
  if (v83)
  {
    v53 = (unint64_t *)&v83->__shared_owners_;
    do
      v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v55 = (uint64_t *)v80;
  mlir::anec::ANECDictionary::PListEntry(*((char *)this + 217), &v82);
  mlir::anec::ANECDictionary::Add(v55, CFSTR("ScaleShift"), &v82);
  v56 = v83;
  if (v83)
  {
    v57 = (unint64_t *)&v83->__shared_owners_;
    do
      v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }
  v59 = *a3;
  v74 = v80;
  v75 = v81;
  if (v81)
  {
    v60 = (unint64_t *)&v81->__shared_owners_;
    do
      v61 = __ldxr(v60);
    while (__stxr(v61 + 1, v60));
  }
  mlir::anec::ANECDictionary::PListEntry((_QWORD **)&v74, &v82);
  mlir::anec::ANECDictionary::Add(v59, CFSTR("Params"), &v82);
  v62 = v83;
  if (v83)
  {
    v63 = (unint64_t *)&v83->__shared_owners_;
    do
      v64 = __ldaxr(v63);
    while (__stlxr(v64 - 1, v63));
    if (!v64)
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
  }
  v65 = v75;
  if (v75)
  {
    v66 = (unint64_t *)&v75->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  v68 = v79;
  if (v79)
  {
    v69 = (unint64_t *)&v79->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  v71 = v81;
  if (v81)
  {
    v72 = (unint64_t *)&v81->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
}

void mlir::anec::ANECIRConvPoolBase::addParams(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t *v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t *v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    v9 = *a2;
    mlir::anec::ANECDictionary::PListEntry(a5, &v52);
    mlir::anec::ANECDictionary::Add(v9, CFSTR("KernelDepth"), (uint64_t *)&v52);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
    if (*((_QWORD *)&v52 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  v13 = *a2;
  mlir::anec::ANECDictionary::PListEntry(a3, &v52);
  mlir::anec::ANECDictionary::Add(v13, CFSTR("KernelWidth"), (uint64_t *)&v52);
  v14 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v17 = *a2;
  mlir::anec::ANECDictionary::PListEntry(a4, &v52);
  mlir::anec::ANECDictionary::Add(v17, CFSTR("KernelHeight"), (uint64_t *)&v52);
  v18 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (!*((_QWORD *)&v52 + 1))
    goto LABEL_65;
  v19 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
  do
    v20 = __ldaxr(v19);
  while (__stlxr(v20 - 1, v19));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    if (!*(_QWORD *)(a1 + 216))
      goto LABEL_17;
  }
  else
  {
LABEL_65:
    if (!*(_QWORD *)(a1 + 216))
    {
LABEL_17:
      if (!*(_QWORD *)(a1 + 224)
        && !*(_QWORD *)(a1 + 200)
        && !*(_QWORD *)(a1 + 208)
        && !*(_QWORD *)(a1 + 232)
        && !*(_QWORD *)(a1 + 240))
      {
        goto LABEL_59;
      }
    }
  }
  v21 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*(_QWORD *)(a1 + 200), &v52);
  mlir::anec::ANECDictionary::Add(v21, CFSTR("PadTop"), (uint64_t *)&v52);
  v22 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v23 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v25 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*(_QWORD *)(a1 + 208), &v52);
  mlir::anec::ANECDictionary::Add(v25, CFSTR("PadBot"), (uint64_t *)&v52);
  v26 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v27 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  v29 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*(_QWORD *)(a1 + 216), &v52);
  mlir::anec::ANECDictionary::Add(v29, CFSTR("PadLeft"), (uint64_t *)&v52);
  v30 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v31 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  v33 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*(_QWORD *)(a1 + 224), &v52);
  mlir::anec::ANECDictionary::Add(v33, CFSTR("PadRight"), (uint64_t *)&v52);
  v34 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v35 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v37 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*(_QWORD *)(a1 + 232), &v52);
  mlir::anec::ANECDictionary::Add(v37, CFSTR("PadFront"), (uint64_t *)&v52);
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v39 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  v41 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*(_QWORD *)(a1 + 240), &v52);
  mlir::anec::ANECDictionary::Add(v41, CFSTR("PadBack"), (uint64_t *)&v52);
  v42 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v43 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
  v45 = *a2;
  mlir::anec::ANECDictionary::PListEntry(CFSTR("Zero"), &v52);
  mlir::anec::ANECDictionary::Add(v45, CFSTR("PaddingMode"), (uint64_t *)&v52);
  v46 = (std::__shared_weak_count *)*((_QWORD *)&v52 + 1);
  if (*((_QWORD *)&v52 + 1))
  {
    v47 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
LABEL_59:
  v49 = *(_QWORD *)(a1 + 192);
  v50 = *a2;
  v52 = *(_OWORD *)(a1 + 176);
  if (v49)
  {
    v53 = v49;
    v51 = 3;
  }
  else
  {
    v51 = 2;
  }
}

void mlir::anec::ANECDictionary::Add<unsigned long,unsigned long const& (*)(unsigned long const&)>(uint64_t *a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t), char a6)
{
  const char *CStringPtr;
  size_t v12;
  size_t v13;
  __int128 *p_dst;
  uint64_t v15;
  uint64_t v16;
  __int128 __dst;
  unint64_t v18;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v12 = strlen(CStringPtr);
  if (v12 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v13 = v12;
  if (v12 >= 0x17)
  {
    v15 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17)
      v15 = v12 | 7;
    v16 = v15 + 1;
    p_dst = (__int128 *)operator new(v15 + 1);
    *((_QWORD *)&__dst + 1) = v13;
    v18 = v16 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v18) = v12;
  p_dst = &__dst;
  if (v12)
LABEL_8:
    memmove(p_dst, CStringPtr, v13);
  *((_BYTE *)p_dst + v13) = 0;
  mlir::anec::ANECDictionary::Add<unsigned long,unsigned long const& (*)(unsigned long const&)>(a1, &__dst, a3, a4, a5, a6);
  if (SHIBYTE(v18) < 0)
    operator delete((void *)__dst);
}

void mlir::anec::ANECIRNeuron::ActivationToAneIRType(int a1)
{
  __asm { BR              X10 }
}

size_t sub_20711EF54()
{
  _QWORD *v0;
  const char *CStringPtr;
  size_t result;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  CStringPtr = CFStringGetCStringPtr(CFSTR("Ceil"), 0x8000100u);
  result = strlen(CStringPtr);
  if (result > 0x7FFFFFFFFFFFFFF7)
    abort();
  v3 = result;
  if (result >= 0x17)
  {
    v4 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v4 = result | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    v0[1] = v3;
    v0[2] = v5 | 0x8000000000000000;
    *v0 = v6;
    v0 = v6;
  }
  else
  {
    *((_BYTE *)v0 + 23) = result;
    if (!result)
      goto LABEL_9;
  }
  result = (size_t)memmove(v0, CStringPtr, v3);
LABEL_9:
  *((_BYTE *)v0 + v3) = 0;
  return result;
}

void mlir::anec::ANECIRNeuron::Serialize(mlir::anec::ANECIRNeuron *this@<X0>, const ZinIrUnitInfo *a2@<X1>, uint64_t **a3@<X8>)
{
  uint64_t *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t *v13;
  unint64_t *v14;
  uint64_t *v15;
  unint64_t *v16;
  uint64_t *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  unint64_t *v22;
  uint64_t *v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t *v27;
  unint64_t *v28;
  uint64_t *v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t *v33;
  unint64_t *v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  mlir::anec::ANECDictionary *v45;
  std::__shared_weak_count *v46;
  void *__p;
  char v48;
  mlir::anec::ANECDictionary *v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  std::__shared_weak_count *v52;

  mlir::anec::ANECIRUnit::Serialize(this, a2, a3);
  mlir::anec::ANECDictionary::Create((uint64_t **)&v49);
  switch(*((_DWORD *)this + 44))
  {
    case 1:
      v9 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 93), &v51);
      mlir::anec::ANECDictionary::Add(v9, CFSTR("ReluMin"), &v51);
      v10 = v52;
      if (v52)
      {
        p_shared_owners = (unint64_t *)&v52->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      v13 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 92), &v51);
      mlir::anec::ANECDictionary::Add(v13, CFSTR("ReluMax"), &v51);
      v6 = v52;
      if (v52)
      {
        v14 = (unint64_t *)&v52->__shared_owners_;
        do
          v8 = __ldaxr(v14);
        while (__stlxr(v8 - 1, v14));
        goto LABEL_36;
      }
      break;
    case 5:
      v15 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 94), &v51);
      mlir::anec::ANECDictionary::Add(v15, CFSTR("EluAlpha"), &v51);
      v6 = v52;
      if (v52)
      {
        v16 = (unint64_t *)&v52->__shared_owners_;
        do
          v8 = __ldaxr(v16);
        while (__stlxr(v8 - 1, v16));
        goto LABEL_36;
      }
      break;
    case 0xB:
    case 0xD:
    case 0x11:
      v5 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 95), &v51);
      mlir::anec::ANECDictionary::Add(v5, CFSTR("Epsilon"), &v51);
      v6 = v52;
      if (v52)
      {
        v7 = (unint64_t *)&v52->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        goto LABEL_36;
      }
      break;
    case 0xC:
      v17 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 90), &v51);
      mlir::anec::ANECDictionary::Add(v17, CFSTR("ReluOffset"), &v51);
      v18 = v52;
      if (v52)
      {
        v19 = (unint64_t *)&v52->__shared_owners_;
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      v21 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 91), &v51);
      mlir::anec::ANECDictionary::Add(v21, CFSTR("ReluSlope"), &v51);
      v6 = v52;
      if (v52)
      {
        v22 = (unint64_t *)&v52->__shared_owners_;
        do
          v8 = __ldaxr(v22);
        while (__stlxr(v8 - 1, v22));
        goto LABEL_36;
      }
      break;
    case 0xE:
      v23 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 92), &v51);
      mlir::anec::ANECDictionary::Add(v23, CFSTR("ReluMax"), &v51);
      v24 = v52;
      if (v52)
      {
        v25 = (unint64_t *)&v52->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      v27 = (uint64_t *)v49;
      mlir::anec::ANECDictionary::PListEntry(*((__int16 *)this + 91), &v51);
      mlir::anec::ANECDictionary::Add(v27, CFSTR("ReluSlope"), &v51);
      v6 = v52;
      if (v52)
      {
        v28 = (unint64_t *)&v52->__shared_owners_;
        do
          v8 = __ldaxr(v28);
        while (__stlxr(v8 - 1, v28));
LABEL_36:
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      break;
    default:
      break;
  }
  v29 = (uint64_t *)v49;
  mlir::anec::ANECIRNeuron::ActivationToAneIRType(*((_DWORD *)this + 44));
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v51);
  mlir::anec::ANECDictionary::Add(v29, CFSTR("Type"), &v51);
  v30 = v52;
  if (!v52)
    goto LABEL_42;
  v31 = (unint64_t *)&v52->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (v32)
  {
LABEL_42:
    if ((v48 & 0x80000000) == 0)
      goto LABEL_44;
    goto LABEL_43;
  }
  ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
  std::__shared_weak_count::__release_weak(v30);
  if (v48 < 0)
LABEL_43:
    operator delete(__p);
LABEL_44:
  v33 = *a3;
  v45 = v49;
  v46 = v50;
  if (v50)
  {
    v34 = (unint64_t *)&v50->__shared_owners_;
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
  }
  mlir::anec::ANECDictionary::PListEntry((_QWORD **)&v45, &v51);
  mlir::anec::ANECDictionary::Add(v33, CFSTR("Params"), &v51);
  v36 = v52;
  if (v52)
  {
    v37 = (unint64_t *)&v52->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  v39 = v46;
  if (v46)
  {
    v40 = (unint64_t *)&v46->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  v42 = v50;
  if (v50)
  {
    v43 = (unint64_t *)&v50->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }
}

size_t mlir::anec::ANECIRPoolUnit::PoolTypeToAneIRType@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  const __CFString *v3;
  const char *CStringPtr;
  size_t result;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  if (a1)
  {
    if (a1 == 2)
      v3 = CFSTR("L2");
    else
      v3 = CFSTR("Avg");
  }
  else
  {
    v3 = CFSTR("Max");
  }
  CStringPtr = CFStringGetCStringPtr(v3, 0x8000100u);
  result = strlen(CStringPtr);
  if (result > 0x7FFFFFFFFFFFFFF7)
    abort();
  v6 = result;
  if (result >= 0x17)
  {
    v7 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v7 = result | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = result;
    if (!result)
      goto LABEL_14;
  }
  result = (size_t)memmove(a2, CStringPtr, v6);
LABEL_14:
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

void mlir::anec::ANECIRPoolUnit::Serialize(mlir::anec::ANECIRPoolUnit *this@<X0>, const ZinIrUnitInfo *a2@<X1>, uint64_t **a3@<X8>)
{
  uint64_t *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  mlir::anec::ANECDictionary *v29;
  uint64_t *v30;
  uint64_t *v31[2];
  void *__p[2];
  char v33;
  mlir::anec::ANECDictionary *v34;
  uint64_t *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;

  mlir::anec::ANECIRUnit::Serialize(this, a2, a3);
  mlir::anec::ANECDictionary::Create((uint64_t **)&v34);
  v5 = (uint64_t *)v34;
  mlir::anec::ANECIRPoolUnit::PoolTypeToAneIRType(*((_DWORD *)this + 62), __p);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)__p, &v36);
  mlir::anec::ANECDictionary::Add(v5, CFSTR("Type"), &v36);
  v6 = v37;
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      if ((v33 & 0x80000000) == 0)
        goto LABEL_7;
      goto LABEL_6;
    }
  }
  if (v33 < 0)
LABEL_6:
    operator delete(__p[0]);
LABEL_7:
  v9 = (uint64_t *)v34;
  mlir::anec::ANECDictionary::PListEntry(*((_BYTE *)this + 280) == 0, &v36);
  mlir::anec::ANECDictionary::Add(v9, CFSTR("AverageCountExcludePadding"), &v36);
  v10 = v37;
  if (v37)
  {
    v11 = (unint64_t *)&v37->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = (std::__shared_weak_count *)v35;
  v31[0] = (uint64_t *)v34;
  v31[1] = v35;
  if (v35)
  {
    v14 = (unint64_t *)(v35 + 1);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    mlir::anec::ANECIRConvPoolBase::addParams((uint64_t)this, v31, *((_QWORD *)this + 32), *((_QWORD *)this + 33), *((_QWORD *)this + 34));
    do
      v16 = __ldaxr(v14);
    while (__stlxr(v16 - 1, v14));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  else
  {
    mlir::anec::ANECIRConvPoolBase::addParams((uint64_t)this, v31, *((_QWORD *)this + 32), *((_QWORD *)this + 33), *((_QWORD *)this + 34));
  }
  v17 = *a3;
  v29 = v34;
  v30 = v35;
  if (v35)
  {
    v18 = (unint64_t *)(v35 + 1);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  mlir::anec::ANECDictionary::PListEntry((_QWORD **)&v29, &v36);
  mlir::anec::ANECDictionary::Add(v17, CFSTR("Params"), &v36);
  v20 = v37;
  if (!v37)
    goto LABEL_27;
  v21 = (unint64_t *)&v37->__shared_owners_;
  do
    v22 = __ldaxr(v21);
  while (__stlxr(v22 - 1, v21));
  if (!v22)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
    v23 = (std::__shared_weak_count *)v30;
    if (!v30)
      goto LABEL_35;
  }
  else
  {
LABEL_27:
    v23 = (std::__shared_weak_count *)v30;
    if (!v30)
      goto LABEL_35;
  }
  v24 = (unint64_t *)&v23->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
LABEL_35:
  v26 = (std::__shared_weak_count *)v35;
  if (v35)
  {
    v27 = (unint64_t *)(v35 + 1);
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
}

uint64_t mlir::anec::ANECIRConstant::SetWeight(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_QWORD *)(result + 40) = a2;
  *(_DWORD *)(result + 48) = a3;
  *(_QWORD *)(result + 88) = a8;
  *(_QWORD *)(result + 96) = a9;
  *(_QWORD *)(result + 72) = a6;
  *(_QWORD *)(result + 80) = a7;
  *(_QWORD *)(result + 56) = a4;
  *(_QWORD *)(result + 64) = a5;
  return result;
}

void mlir::anec::ANECIRConstant::Serialize(mlir::anec::ANECIRConstant *this@<X0>, uint64_t **a2@<X8>)
{
  uint64_t *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t *v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t *v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  void *__p;
  char v41;
  std::string v42;
  uint64_t v43;
  std::__shared_weak_count *v44;

  mlir::anec::ANECDictionary::Create(a2);
  v4 = *a2;
  if (*((char *)this + 31) < 0)
    std::string::__init_copy_ctor_external(&v42, *((const std::string::value_type **)this + 1), *((_QWORD *)this + 2));
  else
    v42 = *(std::string *)((char *)this + 8);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v42, &v43);
  mlir::anec::ANECDictionary::Add(v4, CFSTR("ConstantName"), &v43);
  v5 = v44;
  if (v44)
  {
    p_shared_owners = (unint64_t *)&v44->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_10;
      goto LABEL_9;
    }
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
LABEL_9:
    operator delete(v42.__r_.__value_.__l.__data_);
LABEL_10:
  v8 = *a2;
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v43);
  mlir::anec::ANECDictionary::Add(v8, CFSTR("ConstantType"), &v43);
  v9 = v44;
  if (v44)
  {
    v10 = (unint64_t *)&v44->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
      if ((v41 & 0x80000000) == 0)
        goto LABEL_16;
      goto LABEL_15;
    }
  }
  if (v41 < 0)
LABEL_15:
    operator delete(__p);
LABEL_16:
  v12 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 5), &v43);
  mlir::anec::ANECDictionary::Add(v12, CFSTR("ConstantByteOffset"), &v43);
  v13 = v44;
  if (v44)
  {
    v14 = (unint64_t *)&v44->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v16 = *a2;
  mlir::anec::ANECDictionary::PListEntry(1, &v43);
  mlir::anec::ANECDictionary::Add(v16, CFSTR("ConstantInterleave"), &v43);
  v17 = v44;
  if (v44)
  {
    v18 = (unint64_t *)&v44->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
  v20 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 12), &v43);
  mlir::anec::ANECDictionary::Add(v20, CFSTR("ConstantWidth"), &v43);
  v21 = v44;
  if (v44)
  {
    v22 = (unint64_t *)&v44->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 11), &v43);
  mlir::anec::ANECDictionary::Add(v24, CFSTR("ConstantHeight"), &v43);
  v25 = v44;
  if (v44)
  {
    v26 = (unint64_t *)&v44->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v28 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 10), &v43);
  mlir::anec::ANECDictionary::Add(v28, CFSTR("ConstantChannels"), &v43);
  v29 = v44;
  if (v44)
  {
    v30 = (unint64_t *)&v44->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  v32 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 9), &v43);
  mlir::anec::ANECDictionary::Add(v32, CFSTR("ConstantDepth"), &v43);
  v33 = v44;
  if (v44)
  {
    v34 = (unint64_t *)&v44->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  v36 = *a2;
  mlir::anec::ANECDictionary::PListEntry(*((_QWORD *)this + 8), &v43);
  mlir::anec::ANECDictionary::Add(v36, CFSTR("ConstantBatchSize"), &v43);
  v37 = v44;
  if (v44)
  {
    v38 = (unint64_t *)&v44->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

_QWORD *mlir::anec::ANECIRNetwork::Serialize@<X0>(mlir::anec::ANECIRNetwork *this@<X0>, uint64_t **a2@<X8>)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  _QWORD *result;
  uint64_t v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  mlir::anec::ANECDictionary::Create(a2);
  v4 = *a2;
  v5 = (uint64_t *)*((_QWORD *)this + 1);
  v6 = *((unsigned int *)this + 4);
  v30[0] = &off_24C05A290;
  v31 = v30;
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRInput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(v4, CFSTR("Inputs"), v5, v6, v30);
  v7 = v31;
  if (v31 == v30)
  {
    v8 = 4;
    v7 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v9 = *a2;
  v10 = (uint64_t *)*((_QWORD *)this + 13);
  v11 = *((unsigned int *)this + 28);
  v28[0] = &unk_24C05A2D8;
  v29 = v28;
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIROutput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(v9, CFSTR("Outputs"), v10, v11, v28);
  v12 = v29;
  if (v29 == v28)
  {
    v13 = 4;
    v12 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_11;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_11:
  v14 = *a2;
  v15 = (uint64_t *)*((_QWORD *)this + 28);
  v16 = (uint64_t)(*((_QWORD *)this + 29) - (_QWORD)v15) >> 4;
  v26[0] = &unk_24C05A248;
  v27 = v26;
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRUnit,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(v14, CFSTR("Units"), v15, v16, v26);
  v17 = v27;
  if (v27 == v26)
  {
    v18 = 4;
    v17 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_16;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_16:
  v19 = *a2;
  v20 = (uint64_t *)*((_QWORD *)this + 31);
  v21 = (uint64_t)(*((_QWORD *)this + 32) - (_QWORD)v20) >> 4;
  v24[0] = &unk_24C05A320;
  v25 = v24;
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRConstant,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(v19, CFSTR("Constants"), v20, v21, v24);
  result = v25;
  if (v25 == v24)
  {
    v23 = 4;
    result = v24;
  }
  else
  {
    if (!v25)
      return result;
    v23 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v23))();
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRInput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, CFStringRef theString, uint64_t *a3, uint64_t a4, _QWORD *a5)
{
  const char *CStringPtr;
  size_t v10;
  size_t v11;
  void *p_p;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 __p;
  unint64_t v21;
  _BYTE v22[24];
  _BYTE *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v10 = strlen(CStringPtr);
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v11 = v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    p_p = operator new(v13 + 1);
    *((_QWORD *)&__p + 1) = v11;
    v21 = v14 | 0x8000000000000000;
    *(_QWORD *)&__p = p_p;
    goto LABEL_8;
  }
  HIBYTE(v21) = v10;
  p_p = &__p;
  if (v10)
LABEL_8:
    memmove(p_p, CStringPtr, v11);
  *((_BYTE *)p_p + v11) = 0;
  v15 = (_QWORD *)a5[3];
  if (v15)
  {
    if (v15 == a5)
    {
      v23 = v22;
      (*(void (**)(_QWORD *, _BYTE *))(*a5 + 24))(a5, v22);
    }
    else
    {
      v23 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v15 + 16))(v15);
    }
  }
  else
  {
    v23 = 0;
  }
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRInput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(a1, &__p, a3, a4, (uint64_t)v22);
  v18 = v23;
  if (v23 == v22)
  {
    v19 = 4;
    v18 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_19;
    v19 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v18 + 8 * v19))(v18, v16, v17);
LABEL_19:
  if (SHIBYTE(v21) < 0)
    operator delete((void *)__p);
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIROutput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, CFStringRef theString, uint64_t *a3, uint64_t a4, _QWORD *a5)
{
  const char *CStringPtr;
  size_t v10;
  size_t v11;
  void *p_p;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 __p;
  unint64_t v21;
  _BYTE v22[24];
  _BYTE *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v10 = strlen(CStringPtr);
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v11 = v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    p_p = operator new(v13 + 1);
    *((_QWORD *)&__p + 1) = v11;
    v21 = v14 | 0x8000000000000000;
    *(_QWORD *)&__p = p_p;
    goto LABEL_8;
  }
  HIBYTE(v21) = v10;
  p_p = &__p;
  if (v10)
LABEL_8:
    memmove(p_p, CStringPtr, v11);
  *((_BYTE *)p_p + v11) = 0;
  v15 = (_QWORD *)a5[3];
  if (v15)
  {
    if (v15 == a5)
    {
      v23 = v22;
      (*(void (**)(_QWORD *, _BYTE *))(*a5 + 24))(a5, v22);
    }
    else
    {
      v23 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v15 + 16))(v15);
    }
  }
  else
  {
    v23 = 0;
  }
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIROutput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(a1, &__p, a3, a4, (uint64_t)v22);
  v18 = v23;
  if (v23 == v22)
  {
    v19 = 4;
    v18 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_19;
    v19 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v18 + 8 * v19))(v18, v16, v17);
LABEL_19:
  if (SHIBYTE(v21) < 0)
    operator delete((void *)__p);
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRUnit,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, CFStringRef theString, uint64_t *a3, uint64_t a4, _QWORD *a5)
{
  const char *CStringPtr;
  size_t v10;
  size_t v11;
  void *p_p;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 __p;
  unint64_t v21;
  _BYTE v22[24];
  _BYTE *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v10 = strlen(CStringPtr);
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v11 = v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    p_p = operator new(v13 + 1);
    *((_QWORD *)&__p + 1) = v11;
    v21 = v14 | 0x8000000000000000;
    *(_QWORD *)&__p = p_p;
    goto LABEL_8;
  }
  HIBYTE(v21) = v10;
  p_p = &__p;
  if (v10)
LABEL_8:
    memmove(p_p, CStringPtr, v11);
  *((_BYTE *)p_p + v11) = 0;
  v15 = (_QWORD *)a5[3];
  if (v15)
  {
    if (v15 == a5)
    {
      v23 = v22;
      (*(void (**)(_QWORD *, _BYTE *))(*a5 + 24))(a5, v22);
    }
    else
    {
      v23 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v15 + 16))(v15);
    }
  }
  else
  {
    v23 = 0;
  }
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRUnit,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(a1, &__p, a3, a4, (uint64_t)v22);
  v18 = v23;
  if (v23 == v22)
  {
    v19 = 4;
    v18 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_19;
    v19 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v18 + 8 * v19))(v18, v16, v17);
LABEL_19:
  if (SHIBYTE(v21) < 0)
    operator delete((void *)__p);
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRConstant,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, CFStringRef theString, uint64_t *a3, uint64_t a4, _QWORD *a5)
{
  const char *CStringPtr;
  size_t v10;
  size_t v11;
  void *p_p;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  __int128 __p;
  unint64_t v21;
  _BYTE v22[24];
  _BYTE *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v10 = strlen(CStringPtr);
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v11 = v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    p_p = operator new(v13 + 1);
    *((_QWORD *)&__p + 1) = v11;
    v21 = v14 | 0x8000000000000000;
    *(_QWORD *)&__p = p_p;
    goto LABEL_8;
  }
  HIBYTE(v21) = v10;
  p_p = &__p;
  if (v10)
LABEL_8:
    memmove(p_p, CStringPtr, v11);
  *((_BYTE *)p_p + v11) = 0;
  v15 = (_QWORD *)a5[3];
  if (v15)
  {
    if (v15 == a5)
    {
      v23 = v22;
      (*(void (**)(_QWORD *, _BYTE *))(*a5 + 24))(a5, v22);
    }
    else
    {
      v23 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v15 + 16))(v15);
    }
  }
  else
  {
    v23 = 0;
  }
  mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRConstant,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(a1, &__p, a3, a4, (uint64_t)v22);
  v18 = v23;
  if (v23 == v22)
  {
    v19 = 4;
    v18 = v22;
  }
  else
  {
    if (!v23)
      goto LABEL_19;
    v19 = 5;
  }
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v18 + 8 * v19))(v18, v16, v17);
LABEL_19:
  if (SHIBYTE(v21) < 0)
    operator delete((void *)__p);
}

void mlir::anec::ANECIRNetwork::getUnits(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *i;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  __int128 v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  char *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v2 = *(uint64_t **)(a1 + 224);
  for (i = *(uint64_t **)(a1 + 232); v2 != i; v2 += 2)
  {
    v5 = (std::__shared_weak_count *)v2[1];
    v21 = *v2;
    v22 = v5;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    v8 = *(unsigned int *)(a2 + 8);
    v9 = *(_QWORD *)a2;
    if (v8 >= *(_DWORD *)(a2 + 12))
    {
      v18 = v8 + 1;
      v19 = v9 + 16 * v8 > (unint64_t)&v21;
      if (v9 <= (unint64_t)&v21 && v19)
      {
        v20 = (char *)&v21 - v9;
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(a2, v18);
        v9 = *(_QWORD *)a2;
        v10 = &v20[*(_QWORD *)a2];
        goto LABEL_9;
      }
      llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(a2, v18);
      v9 = *(_QWORD *)a2;
    }
    v10 = (char *)&v21;
LABEL_9:
    v11 = *(unsigned int *)(a2 + 8);
    v12 = *(_OWORD *)v10;
    *(_OWORD *)(v9 + 16 * v11) = *(_OWORD *)v10;
    if (*((_QWORD *)&v12 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      LODWORD(v11) = *(_DWORD *)(a2 + 8);
    }
    *(_DWORD *)(a2 + 8) = v11 + 1;
    v15 = v22;
    if (v22)
    {
      v16 = (unint64_t *)&v22->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
}

void mlir::anec::ANECIRNetwork::getConstants(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *i;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  __int128 v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  char *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  v2 = *(uint64_t **)(a1 + 248);
  for (i = *(uint64_t **)(a1 + 256); v2 != i; v2 += 2)
  {
    v5 = (std::__shared_weak_count *)v2[1];
    v21 = *v2;
    v22 = v5;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    v8 = *(unsigned int *)(a2 + 8);
    v9 = *(_QWORD *)a2;
    if (v8 >= *(_DWORD *)(a2 + 12))
    {
      v18 = v8 + 1;
      v19 = v9 + 16 * v8 > (unint64_t)&v21;
      if (v9 <= (unint64_t)&v21 && v19)
      {
        v20 = (char *)&v21 - v9;
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(a2, v18);
        v9 = *(_QWORD *)a2;
        v10 = &v20[*(_QWORD *)a2];
        goto LABEL_9;
      }
      llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(a2, v18);
      v9 = *(_QWORD *)a2;
    }
    v10 = (char *)&v21;
LABEL_9:
    v11 = *(unsigned int *)(a2 + 8);
    v12 = *(_OWORD *)v10;
    *(_OWORD *)(v9 + 16 * v11) = *(_OWORD *)v10;
    if (*((_QWORD *)&v12 + 1))
    {
      v13 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
      LODWORD(v11) = *(_DWORD *)(a2 + 8);
    }
    *(_DWORD *)(a2 + 8) = v11 + 1;
    v15 = v22;
    if (v22)
    {
      v16 = (unint64_t *)&v22->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
}

void mlir::anec::ANECIRNetwork::getInputs(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  __int128 v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  char *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;

  v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2)
  {
    v4 = *(uint64_t **)(a1 + 8);
    v5 = &v4[2 * v2];
    do
    {
      v6 = (std::__shared_weak_count *)v4[1];
      v22 = *v4;
      v23 = v6;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }
      v9 = *(unsigned int *)(a2 + 8);
      v10 = *(_QWORD *)a2;
      if (v9 >= *(_DWORD *)(a2 + 12))
      {
        v19 = v9 + 1;
        v20 = v10 + 16 * v9 > (unint64_t)&v22;
        if (v10 <= (unint64_t)&v22 && v20)
        {
          v21 = (char *)&v22 - v10;
          llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(a2, v19);
          v10 = *(_QWORD *)a2;
          v11 = &v21[*(_QWORD *)a2];
          goto LABEL_9;
        }
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(a2, v19);
        v10 = *(_QWORD *)a2;
      }
      v11 = (char *)&v22;
LABEL_9:
      v12 = *(unsigned int *)(a2 + 8);
      v13 = *(_OWORD *)v11;
      *(_OWORD *)(v10 + 16 * v12) = *(_OWORD *)v11;
      if (*((_QWORD *)&v13 + 1))
      {
        v14 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
        LODWORD(v12) = *(_DWORD *)(a2 + 8);
      }
      *(_DWORD *)(a2 + 8) = v12 + 1;
      v16 = v23;
      if (v23)
      {
        v17 = (unint64_t *)&v23->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v4 += 2;
    }
    while (v4 != v5);
  }
}

void mlir::anec::ANECIROperation::Serialize(mlir::anec::ANECIROperation *this@<X0>, uint64_t **a2@<X8>)
{
  uint64_t *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::string __p;
  std::string v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  mlir::anec::ANECDictionary::Create(a2);
  v4 = *a2;
  if (*((char *)this + 23) < 0)
    std::string::__init_copy_ctor_external(&v13, *(const std::string::value_type **)this, *((_QWORD *)this + 1));
  else
    v13 = *(std::string *)this;
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v13, &v14);
  mlir::anec::ANECDictionary::Add(v4, CFSTR("OperationName"), &v14);
  v5 = v15;
  if (!v15)
    goto LABEL_8;
  p_shared_owners = (unint64_t *)&v15->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (v7)
  {
LABEL_8:
    if ((SHIBYTE(v13.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
LABEL_9:
    operator delete(v13.__r_.__value_.__l.__data_);
LABEL_10:
  v8 = *a2;
  if (*((char *)this + 47) < 0)
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 3), *((_QWORD *)this + 4));
  else
    __p = *(std::string *)((_BYTE *)this + 1);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v14);
  mlir::anec::ANECDictionary::Add(v8, CFSTR("NetworkName"), &v14);
  v9 = v15;
  if (!v15)
    goto LABEL_17;
  v10 = (unint64_t *)&v15->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (v11)
  {
LABEL_17:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_18;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_18:
    operator delete(__p.__r_.__value_.__l.__data_);
}

void mlir::anec::ANECIRProcedure::Serialize(mlir::anec::ANECIRProcedure *this@<X0>, uint64_t **a2@<X8>)
{
  uint64_t v4;
  mlir::anec::ANECIROutput **v5;
  mlir::anec::ANECIROutput **v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _OWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  uint64_t *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  mlir::anec::ANECIRInput **v29;
  mlir::anec::ANECIRInput **v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  _OWORD *v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t *v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  mlir::anec::ANECIROperation **v52;
  mlir::anec::ANECIROperation **v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  _OWORD *v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  uint64_t *v66;
  unint64_t *v67;
  unint64_t v68;
  std::__shared_weak_count *v69;
  unint64_t *v70;
  unint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  uint64_t *v75;
  std::__shared_weak_count *v76;
  unint64_t *v77;
  unint64_t v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  std::__shared_weak_count *v82;
  unint64_t *v83;
  unint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  std::string __p;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  std::__shared_weak_count *v94;
  __int128 v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  uint64_t *v98;
  std::__shared_weak_count *v99;

  mlir::anec::ANECDictionary::Create(a2);
  plist::PListArray::Create(&v96);
  v4 = *((unsigned int *)this + 28);
  if ((_DWORD)v4)
  {
    v5 = (mlir::anec::ANECIROutput **)*((_QWORD *)this + 13);
    v6 = &v5[2 * v4];
    do
    {
      mlir::anec::ANECIROutput::Serialize(*v5, &v98);
      v7 = v96;
      mlir::anec::ANECDictionary::PListEntry(&v98, &v95);
      v8 = *(_QWORD **)(v7 + 16);
      if ((unint64_t)v8 >= *(_QWORD *)(v7 + 24))
      {
        v12 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v7 + 8, &v95);
      }
      else
      {
        *v8 = v95;
        v9 = *((_QWORD *)&v95 + 1);
        v8[1] = *((_QWORD *)&v95 + 1);
        if (v9)
        {
          v10 = (unint64_t *)(v9 + 8);
          do
            v11 = __ldxr(v10);
          while (__stxr(v11 + 1, v10));
        }
        v12 = v8 + 2;
      }
      *(_QWORD *)(v7 + 16) = v12;
      v13 = (std::__shared_weak_count *)*((_QWORD *)&v95 + 1);
      if (!*((_QWORD *)&v95 + 1))
        goto LABEL_14;
      v14 = (unint64_t *)(*((_QWORD *)&v95 + 1) + 8);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
        v16 = v99;
        if (v99)
        {
LABEL_15:
          p_shared_owners = (unint64_t *)&v16->__shared_owners_;
          do
            v18 = __ldaxr(p_shared_owners);
          while (__stlxr(v18 - 1, p_shared_owners));
          if (!v18)
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
        }
      }
      else
      {
LABEL_14:
        v16 = v99;
        if (v99)
          goto LABEL_15;
      }
      v5 += 2;
    }
    while (v5 != v6);
  }
  v19 = *a2;
  v93 = v96;
  v94 = v97;
  if (v97)
  {
    v20 = (unint64_t *)&v97->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  mlir::anec::ANECDictionary::PListEntry(&v93, &v98);
  mlir::anec::ANECDictionary::Add(v19, CFSTR("OutputList"), (uint64_t *)&v98);
  v22 = v99;
  if (!v99)
    goto LABEL_28;
  v23 = (unint64_t *)&v99->__shared_owners_;
  do
    v24 = __ldaxr(v23);
  while (__stlxr(v24 - 1, v23));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
    v25 = v94;
    if (!v94)
      goto LABEL_34;
  }
  else
  {
LABEL_28:
    v25 = v94;
    if (!v94)
      goto LABEL_34;
  }
  v26 = (unint64_t *)&v25->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
LABEL_34:
  plist::PListArray::Create(&v95);
  v28 = *((unsigned int *)this + 4);
  if ((_DWORD)v28)
  {
    v29 = (mlir::anec::ANECIRInput **)*((_QWORD *)this + 1);
    v30 = &v29[2 * v28];
    do
    {
      mlir::anec::ANECIRInput::Serialize(*v29, &v98);
      v31 = v95;
      mlir::anec::ANECDictionary::PListEntry(&v98, &v92);
      v32 = *(_QWORD **)(v31 + 16);
      if ((unint64_t)v32 >= *(_QWORD *)(v31 + 24))
      {
        v36 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v31 + 8, &v92);
      }
      else
      {
        *v32 = v92;
        v33 = *((_QWORD *)&v92 + 1);
        v32[1] = *((_QWORD *)&v92 + 1);
        if (v33)
        {
          v34 = (unint64_t *)(v33 + 8);
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
        }
        v36 = v32 + 2;
      }
      *(_QWORD *)(v31 + 16) = v36;
      v37 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
      if (!*((_QWORD *)&v92 + 1))
        goto LABEL_47;
      v38 = (unint64_t *)(*((_QWORD *)&v92 + 1) + 8);
      do
        v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
        v40 = v99;
        if (v99)
        {
LABEL_48:
          v41 = (unint64_t *)&v40->__shared_owners_;
          do
            v42 = __ldaxr(v41);
          while (__stlxr(v42 - 1, v41));
          if (!v42)
          {
            ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
            std::__shared_weak_count::__release_weak(v40);
          }
        }
      }
      else
      {
LABEL_47:
        v40 = v99;
        if (v99)
          goto LABEL_48;
      }
      v29 += 2;
    }
    while (v29 != v30);
  }
  v43 = *a2;
  v91 = v95;
  if (*((_QWORD *)&v95 + 1))
  {
    v44 = (unint64_t *)(*((_QWORD *)&v95 + 1) + 8);
    do
      v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
  }
  mlir::anec::ANECDictionary::PListEntry(&v91, &v98);
  mlir::anec::ANECDictionary::Add(v43, CFSTR("InputList"), (uint64_t *)&v98);
  v46 = v99;
  if (!v99)
    goto LABEL_61;
  v47 = (unint64_t *)&v99->__shared_owners_;
  do
    v48 = __ldaxr(v47);
  while (__stlxr(v48 - 1, v47));
  if (!v48)
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
    v49 = (std::__shared_weak_count *)*((_QWORD *)&v91 + 1);
    if (*((_QWORD *)&v91 + 1))
      goto LABEL_62;
  }
  else
  {
LABEL_61:
    v49 = (std::__shared_weak_count *)*((_QWORD *)&v91 + 1);
    if (*((_QWORD *)&v91 + 1))
    {
LABEL_62:
      v50 = (unint64_t *)&v49->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
  }
  plist::PListArray::Create(&v92);
  v52 = (mlir::anec::ANECIROperation **)*((_QWORD *)this + 34);
  v53 = (mlir::anec::ANECIROperation **)*((_QWORD *)this + 35);
  while (v52 != v53)
  {
    mlir::anec::ANECIROperation::Serialize(*v52, &v98);
    v54 = v92;
    mlir::anec::ANECDictionary::PListEntry(&v98, &v90);
    v55 = *(_QWORD **)(v54 + 16);
    if ((unint64_t)v55 >= *(_QWORD *)(v54 + 24))
    {
      v59 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v54 + 8, &v90);
    }
    else
    {
      *v55 = v90;
      v56 = *((_QWORD *)&v90 + 1);
      v55[1] = *((_QWORD *)&v90 + 1);
      if (v56)
      {
        v57 = (unint64_t *)(v56 + 8);
        do
          v58 = __ldxr(v57);
        while (__stxr(v58 + 1, v57));
      }
      v59 = v55 + 2;
    }
    *(_QWORD *)(v54 + 16) = v59;
    v60 = (std::__shared_weak_count *)*((_QWORD *)&v90 + 1);
    if (!*((_QWORD *)&v90 + 1))
      goto LABEL_80;
    v61 = (unint64_t *)(*((_QWORD *)&v90 + 1) + 8);
    do
      v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
      v63 = v99;
      if (!v99)
        goto LABEL_68;
    }
    else
    {
LABEL_80:
      v63 = v99;
      if (!v99)
        goto LABEL_68;
    }
    v64 = (unint64_t *)&v63->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
LABEL_68:
    v52 += 2;
  }
  v66 = *a2;
  v89 = v92;
  if (*((_QWORD *)&v92 + 1))
  {
    v67 = (unint64_t *)(*((_QWORD *)&v92 + 1) + 8);
    do
      v68 = __ldxr(v67);
    while (__stxr(v68 + 1, v67));
  }
  mlir::anec::ANECDictionary::PListEntry(&v89, &v98);
  mlir::anec::ANECDictionary::Add(v66, CFSTR("OperationList"), (uint64_t *)&v98);
  v69 = v99;
  if (!v99)
    goto LABEL_94;
  v70 = (unint64_t *)&v99->__shared_owners_;
  do
    v71 = __ldaxr(v70);
  while (__stlxr(v71 - 1, v70));
  if (!v71)
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
    v72 = (std::__shared_weak_count *)*((_QWORD *)&v89 + 1);
    if (*((_QWORD *)&v89 + 1))
    {
LABEL_95:
      v73 = (unint64_t *)&v72->__shared_owners_;
      do
        v74 = __ldaxr(v73);
      while (__stlxr(v74 - 1, v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }
  }
  else
  {
LABEL_94:
    v72 = (std::__shared_weak_count *)*((_QWORD *)&v89 + 1);
    if (*((_QWORD *)&v89 + 1))
      goto LABEL_95;
  }
  v75 = *a2;
  if (*((char *)this + 223) < 0)
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 25), *((_QWORD *)this + 26));
  else
    __p = *(std::string *)((char *)this + 200);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v98);
  mlir::anec::ANECDictionary::Add(v75, CFSTR("Name"), (uint64_t *)&v98);
  v76 = v99;
  if (!v99)
    goto LABEL_107;
  v77 = (unint64_t *)&v99->__shared_owners_;
  do
    v78 = __ldaxr(v77);
  while (__stlxr(v78 - 1, v77));
  if (!v78)
  {
    ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
    std::__shared_weak_count::__release_weak(v76);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_111;
LABEL_108:
    v79 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
    if (!*((_QWORD *)&v92 + 1))
      goto LABEL_115;
LABEL_112:
    v80 = (unint64_t *)&v79->__shared_owners_;
    do
      v81 = __ldaxr(v80);
    while (__stlxr(v81 - 1, v80));
    if (v81)
      goto LABEL_115;
    ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
    std::__shared_weak_count::__release_weak(v79);
    v82 = (std::__shared_weak_count *)*((_QWORD *)&v95 + 1);
    if (*((_QWORD *)&v95 + 1))
    {
LABEL_116:
      v83 = (unint64_t *)&v82->__shared_owners_;
      do
        v84 = __ldaxr(v83);
      while (__stlxr(v84 - 1, v83));
      if (!v84)
      {
        ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
        std::__shared_weak_count::__release_weak(v82);
      }
    }
  }
  else
  {
LABEL_107:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_108;
LABEL_111:
    operator delete(__p.__r_.__value_.__l.__data_);
    v79 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
    if (*((_QWORD *)&v92 + 1))
      goto LABEL_112;
LABEL_115:
    v82 = (std::__shared_weak_count *)*((_QWORD *)&v95 + 1);
    if (*((_QWORD *)&v95 + 1))
      goto LABEL_116;
  }
  v85 = v97;
  if (v97)
  {
    v86 = (unint64_t *)&v97->__shared_owners_;
    do
      v87 = __ldaxr(v86);
    while (__stlxr(v87 - 1, v86));
    if (!v87)
    {
      ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
      std::__shared_weak_count::__release_weak(v85);
    }
  }
}

void mlir::anec::ANECIRTop::deriveWeightsFileName(std::string *this@<X0>, char *a2@<X8>)
{
  int v4;
  std::string *v5;
  std::string::size_type v6;
  size_t v7;
  std::string::size_type size;
  std::string *v9;
  size_t v10;
  void **p_dst;
  uint64_t v12;
  uint64_t v13;
  std::string::size_type v14;
  int v15;
  std::string *v16;
  size_t v17;
  void *p_p;
  uint64_t v19;
  uint64_t v20;
  int v21;
  size_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  const void *v27;
  void *__p;
  size_t v29;
  int64_t v30;
  void **__dst;
  unint64_t v32;

  v4 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if (v4 < 0)
  {
    if (this->__r_.__value_.__l.__size_ != 1)
      goto LABEL_8;
    v5 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v5 = this;
    if (v4 != 1)
      goto LABEL_8;
  }
  if (v5->__r_.__value_.__s.__data_[0] == 45)
  {
    a2[23] = 15;
    strcpy(a2, "network.weights");
    return;
  }
LABEL_8:
  v6 = std::string::rfind(this, 46, 0xFFFFFFFFFFFFFFFFLL);
  v7 = v6;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    size = this->__r_.__value_.__l.__size_;
    if (size < v6)
      goto LABEL_56;
    v9 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v9 = this;
    if (v6 > size)
      goto LABEL_56;
  }
  v10 = size - v6;
  if (size - v6 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_56;
  if (v10 >= 0x17)
  {
    v12 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v12 = v10 | 7;
    v13 = v12 + 1;
    p_dst = (void **)operator new(v12 + 1);
    __dst = p_dst;
    v32 = v13 | 0x8000000000000000;
    goto LABEL_20;
  }
  HIBYTE(v32) = size - v6;
  p_dst = (void **)&__dst;
  if (size != v6)
LABEL_20:
    memmove(p_dst, (char *)v9 + v7, v10);
  *((_BYTE *)p_dst + v10) = 0;
  v14 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  v15 = (char)v14;
  if ((v14 & 0x80u) != 0)
    v14 = this->__r_.__value_.__l.__size_;
  if (v15 >= 0)
    v16 = this;
  else
    v16 = (std::string *)this->__r_.__value_.__r.__words[0];
  if (v14 >= v7)
    v17 = v7;
  else
    v17 = v14;
  if (v17 > 0x7FFFFFFFFFFFFFF7)
LABEL_56:
    abort();
  if (v17 >= 0x17)
  {
    v19 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17)
      v19 = v17 | 7;
    v20 = v19 + 1;
    p_p = operator new(v19 + 1);
    v29 = v17;
    v30 = v20 | 0x8000000000000000;
    __p = p_p;
    goto LABEL_36;
  }
  HIBYTE(v30) = v17;
  p_p = &__p;
  if (v17)
LABEL_36:
    memmove(p_p, v16, v17);
  *((_BYTE *)p_p + v17) = 0;
  v21 = SHIBYTE(v30);
  if (v30 >= 0)
    v22 = HIBYTE(v30);
  else
    v22 = v29;
  v23 = v22 + 8;
  if (v22 + 8 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_56;
  if (v23 >= 0x17)
  {
    v24 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17)
      v24 = v23 | 7;
    v25 = v24 + 1;
    v26 = (char *)operator new(v24 + 1);
    *((_QWORD *)a2 + 1) = v23;
    *((_QWORD *)a2 + 2) = v25 | 0x8000000000000000;
    *(_QWORD *)a2 = v26;
    a2 = v26;
  }
  else
  {
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    a2[23] = v23;
    if (!v22)
      goto LABEL_51;
  }
  if (v21 >= 0)
    v27 = &__p;
  else
    v27 = __p;
  memmove(a2, v27, v22);
LABEL_51:
  strcpy(&a2[v22], ".weights");
  if ((v21 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v32) & 0x80000000) == 0)
      return;
LABEL_55:
    operator delete(__dst);
    return;
  }
  operator delete(__p);
  if (SHIBYTE(v32) < 0)
    goto LABEL_55;
}

void mlir::anec::ANECIRTop::Serialize(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, const void *a4@<X3>, std::string::size_type a5@<X4>, uint64_t **a6@<X8>)
{
  uint64_t *v11;
  std::__shared_weak_count *size;
  unint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  const char *CStringPtr;
  size_t v18;
  size_t v19;
  __int128 *p_dst;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  mlir::anec::ANECIRNetwork **v24;
  mlir::anec::ANECIRNetwork **v25;
  std::string *v26;
  mlir::anec::ANECIRNetwork *v27;
  std::string::size_type v28;
  std::string::size_type v29;
  int v30;
  uint64_t *v31;
  std::string::size_type v32;
  std::string *v33;
  std::string::size_type v34;
  std::string::size_type v35;
  std::string *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  const char *v40;
  size_t v41;
  void *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  _OWORD *v52;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *p_shared_owners;
  unint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  std::__shared_weak_count *v67;
  unint64_t *v68;
  unint64_t v69;
  std::__shared_weak_count *v70;
  unint64_t *v71;
  unint64_t v72;
  std::__shared_weak_count *v73;
  unint64_t *v74;
  unint64_t v75;
  uint64_t v76;
  mlir::anec::ANECIRProcedure **v77;
  mlir::anec::ANECIRProcedure **v78;
  std::string::size_type v79;
  void **v80;
  char *v81;
  unint64_t *v82;
  unint64_t v83;
  _OWORD *v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  std::__shared_weak_count *v88;
  unint64_t *v89;
  unint64_t v90;
  uint64_t *v91;
  unint64_t *v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  unint64_t *v95;
  unint64_t v96;
  std::__shared_weak_count *v97;
  unint64_t *v98;
  unint64_t v99;
  std::__shared_weak_count *v100;
  unint64_t *v101;
  unint64_t v102;
  uint64_t v103;
  std::string *v104;
  char v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  std::string *v109;
  std::__shared_weak_count *v110;
  unint64_t *v111;
  unint64_t v112;
  const void *AttrData;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  std::string::size_type v117;
  std::string::size_type v118;
  std::string::size_type v119;
  char *v120;
  std::string *v121;
  std::string::size_type v122;
  std::string::size_type v123;
  std::string::value_type *v124;
  _OWORD *v125;
  __int128 *v126;
  unint64_t v127;
  __int128 v128;
  std::string::value_type v129;
  uint64_t v130;
  _QWORD *v131;
  std::string *v132;
  std::__shared_weak_count *v133;
  unint64_t *v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t *v137;
  unint64_t v138;
  std::__shared_weak_count *v139;
  unint64_t *v140;
  unint64_t v141;
  uint64_t v142;
  std::__shared_weak_count *v143;
  unint64_t *v144;
  unint64_t v145;
  std::__shared_weak_count *v146;
  unint64_t *v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t *v150;
  unint64_t v151;
  std::__shared_weak_count *v152;
  unint64_t *v153;
  unint64_t v154;
  uint64_t v155;
  _QWORD *v156;
  std::__shared_weak_count *v157;
  unint64_t *v158;
  unint64_t v159;
  uint64_t v160;
  _QWORD *v161;
  std::__shared_weak_count *v162;
  unint64_t *v163;
  unint64_t v164;
  uint64_t v165;
  unint64_t *v166;
  unint64_t v167;
  std::__shared_weak_count *v168;
  unint64_t *v169;
  unint64_t v170;
  uint64_t *v171;
  unint64_t *v172;
  unint64_t v173;
  std::__shared_weak_count *v174;
  unint64_t *v175;
  unint64_t v176;
  std::__shared_weak_count *v177;
  unint64_t *v178;
  unint64_t v179;
  std::__shared_weak_count *v180;
  unint64_t *v181;
  unint64_t v182;
  std::__shared_weak_count *v183;
  unint64_t *v184;
  unint64_t v185;
  std::__shared_weak_count *v186;
  unint64_t *v187;
  unint64_t v188;
  std::__shared_weak_count *v189;
  unint64_t *v190;
  unint64_t v191;
  const void *v192;
  std::string::size_type v193;
  uint64_t **v194;
  uint64_t v195;
  uint64_t *v196;
  uint64_t v197;
  char v198;
  __int128 v199;
  __int128 v200;
  std::string v201;
  uint64_t v202;
  __int128 __dst;
  unint64_t v204;
  __int128 v205;
  __int128 v206;
  std::string v207;
  void *__p[2];
  unint64_t v209;
  std::string v210;
  std::string v211;
  uint64_t v212;
  __int128 v213;
  __int128 v214;
  std::string v215;
  uint64_t v216;

  v216 = *MEMORY[0x24BDAC8D0];
  v202 = a3;
  mlir::anec::ANECDictionary::Create(a6);
  v11 = *a6;
  if (*(char *)(a1 + 71) < 0)
    std::string::__init_copy_ctor_external(&v201, *(const std::string::value_type **)(a1 + 48), *(_QWORD *)(a1 + 56));
  else
    v201 = *(std::string *)(a1 + 48);
  mlir::anec::ANECDictionary::PListEntry((uint64_t)&v201, &v211);
  mlir::anec::ANECDictionary::Add(v11, CFSTR("Version"), (uint64_t *)&v211);
  size = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
  if (!v211.__r_.__value_.__l.__size_)
    goto LABEL_8;
  v13 = (unint64_t *)(v211.__r_.__value_.__l.__size_ + 8);
  do
    v14 = __ldaxr(v13);
  while (__stlxr(v14 - 1, v13));
  if (v14)
  {
LABEL_8:
    if ((SHIBYTE(v201.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
  std::__shared_weak_count::__release_weak(size);
  if (SHIBYTE(v201.__r_.__value_.__r.__words[2]) < 0)
LABEL_9:
    operator delete(v201.__r_.__value_.__l.__data_);
LABEL_10:
  v15 = *a6;
  v196 = *(uint64_t **)(a1 + 72);
  v16 = *(unsigned int *)(a1 + 80);
  CStringPtr = CFStringGetCStringPtr(CFSTR("Networks"), 0x8000100u);
  v18 = strlen(CStringPtr);
  if (v18 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_285;
  v19 = v18;
  v198 = a2;
  v193 = a5;
  v194 = a6;
  v192 = a4;
  if (v18 >= 0x17)
  {
    v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17)
      v21 = v18 | 7;
    v22 = v21 + 1;
    p_dst = (__int128 *)operator new(v21 + 1);
    v23 = v22 | 0x8000000000000000;
    a2 = v198;
    *((_QWORD *)&__dst + 1) = v19;
    v204 = v23;
    *(_QWORD *)&__dst = p_dst;
  }
  else
  {
    HIBYTE(v204) = v18;
    p_dst = &__dst;
    if (!v18)
      goto LABEL_18;
  }
  memmove(p_dst, CStringPtr, v19);
LABEL_18:
  *((_BYTE *)p_dst + v19) = 0;
  v195 = v16;
  if ((_DWORD)v16)
  {
    v24 = (mlir::anec::ANECIRNetwork **)v196;
    v25 = (mlir::anec::ANECIRNetwork **)&v196[2 * v16];
    v26 = (std::string *)(a1 + 24);
    v197 = a1;
    while (1)
    {
      v27 = *v24;
      mlir::anec::ANECIRNetwork::Serialize(*v24, (uint64_t **)&v205);
      if ((a2 & 1) != 0)
        goto LABEL_93;
      v28 = std::string::rfind(v26, 47, 0xFFFFFFFFFFFFFFFFLL);
      v29 = v28;
      if (*(char *)(a1 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(&v207, *(const std::string::value_type **)(a1 + 24), *(_QWORD *)(a1 + 32));
        if (v29 == -1)
        {
LABEL_24:
          v30 = SHIBYTE(v207.__r_.__value_.__r.__words[2]);
          if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0)
            goto LABEL_44;
          goto LABEL_25;
        }
      }
      else
      {
        v207 = *v26;
        if (v28 == -1)
          goto LABEL_24;
      }
      if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0)
      {
        v32 = v207.__r_.__value_.__l.__size_;
        if (v207.__r_.__value_.__l.__size_ <= v29)
          goto LABEL_285;
        v33 = (std::string *)v207.__r_.__value_.__r.__words[0];
      }
      else
      {
        v32 = HIBYTE(v207.__r_.__value_.__r.__words[2]);
        if (v29 >= HIBYTE(v207.__r_.__value_.__r.__words[2]))
          goto LABEL_285;
        v33 = &v207;
      }
      v34 = v29 + 1;
      v35 = v32 - (v29 + 1);
      if (v35 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_285;
      if (v35 >= 0x17)
        break;
      *((_BYTE *)&v211.__r_.__value_.__s + 23) = v35;
      v36 = &v211;
      if (v32 != v34)
        goto LABEL_40;
LABEL_41:
      v36->__r_.__value_.__s.__data_[v35] = 0;
      if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v207.__r_.__value_.__l.__data_);
      v207 = v211;
      a1 = v197;
      v30 = SHIBYTE(v211.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0)
      {
LABEL_44:
        if (!v207.__r_.__value_.__l.__size_)
          goto LABEL_92;
        v31 = (uint64_t *)v205;
        std::string::__init_copy_ctor_external(&v215, v207.__r_.__value_.__l.__data_, v207.__r_.__value_.__l.__size_);
        goto LABEL_46;
      }
LABEL_25:
      if (!v30)
        goto LABEL_93;
      v31 = (uint64_t *)v205;
      v215 = v207;
LABEL_46:
      v40 = CFStringGetCStringPtr(CFSTR("Weights"), 0x8000100u);
      v41 = strlen(v40);
      if (v41 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_285;
      v42 = (void *)v41;
      if (v41 >= 0x17)
      {
        v44 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v41 | 7) != 0x17)
          v44 = v41 | 7;
        v45 = v44 + 1;
        v43 = operator new(v44 + 1);
        v46 = v45 | 0x8000000000000000;
        a1 = v197;
        __p[1] = v42;
        v209 = v46;
        __p[0] = v43;
LABEL_53:
        memmove(v43, v40, (size_t)v42);
        goto LABEL_54;
      }
      HIBYTE(v209) = v41;
      v43 = __p;
      if (v41)
        goto LABEL_53;
LABEL_54:
      *((_BYTE *)v42 + (_QWORD)v43) = 0;
      plist::PListArray::Create(&v214);
      v47 = v214;
      if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v210, v215.__r_.__value_.__l.__data_, v215.__r_.__value_.__l.__size_);
      else
        v210 = v215;
      a2 = v198;
      v211 = v210;
      memset(&v210, 0, sizeof(v210));
      mlir::anec::ANECDictionary::PListEntry((uint64_t)&v211, &v213);
      v48 = *(_QWORD **)(v47 + 16);
      if ((unint64_t)v48 >= *(_QWORD *)(v47 + 24))
      {
        v52 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v47 + 8, &v213);
      }
      else
      {
        *v48 = v213;
        v49 = *((_QWORD *)&v213 + 1);
        v48[1] = *((_QWORD *)&v213 + 1);
        if (v49)
        {
          v50 = (unint64_t *)(v49 + 8);
          do
            v51 = __ldxr(v50);
          while (__stxr(v51 + 1, v50));
        }
        v52 = v48 + 2;
      }
      *(_QWORD *)(v47 + 16) = v52;
      v53 = (std::__shared_weak_count *)*((_QWORD *)&v213 + 1);
      if (!*((_QWORD *)&v213 + 1))
        goto LABEL_67;
      v54 = (unint64_t *)(*((_QWORD *)&v213 + 1) + 8);
      do
        v55 = __ldaxr(v54);
      while (__stlxr(v55 - 1, v54));
      if (!v55)
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
        if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0)
        {
LABEL_82:
          operator delete(v211.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_69;
          goto LABEL_83;
        }
      }
      else
      {
LABEL_67:
        if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_82;
      }
      if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_69;
LABEL_83:
      operator delete(v210.__r_.__value_.__l.__data_);
LABEL_69:
      v213 = v214;
      if (*((_QWORD *)&v214 + 1))
      {
        v56 = (unint64_t *)(*((_QWORD *)&v214 + 1) + 8);
        do
          v57 = __ldxr(v56);
        while (__stxr(v57 + 1, v56));
      }
      mlir::anec::ANECDictionary::PListEntry(&v213, &v211);
      mlir::anec::ANECDictionary::Add(v31, (__int128 *)__p, (uint64_t *)&v211);
      v58 = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
      if (!v211.__r_.__value_.__l.__size_)
        goto LABEL_76;
      v59 = (unint64_t *)(v211.__r_.__value_.__l.__size_ + 8);
      do
        v60 = __ldaxr(v59);
      while (__stlxr(v60 - 1, v59));
      if (!v60)
      {
        ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
        std::__shared_weak_count::__release_weak(v58);
        v61 = (std::__shared_weak_count *)*((_QWORD *)&v213 + 1);
        if (!*((_QWORD *)&v213 + 1))
          goto LABEL_85;
      }
      else
      {
LABEL_76:
        v61 = (std::__shared_weak_count *)*((_QWORD *)&v213 + 1);
        if (!*((_QWORD *)&v213 + 1))
          goto LABEL_85;
      }
      p_shared_owners = (unint64_t *)&v61->__shared_owners_;
      do
        v63 = __ldaxr(p_shared_owners);
      while (__stlxr(v63 - 1, p_shared_owners));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
        std::__shared_weak_count::__release_weak(v61);
      }
LABEL_85:
      v64 = (std::__shared_weak_count *)*((_QWORD *)&v214 + 1);
      if (!*((_QWORD *)&v214 + 1))
        goto LABEL_89;
      v65 = (unint64_t *)(*((_QWORD *)&v214 + 1) + 8);
      do
        v66 = __ldaxr(v65);
      while (__stlxr(v66 - 1, v65));
      if (!v66)
      {
        ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
        std::__shared_weak_count::__release_weak(v64);
        if (SHIBYTE(v209) < 0)
        {
LABEL_109:
          operator delete(__p[0]);
          if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0)
          {
LABEL_110:
            operator delete(v215.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v207.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_93;
LABEL_92:
            operator delete(v207.__r_.__value_.__l.__data_);
            goto LABEL_93;
          }
          goto LABEL_91;
        }
      }
      else
      {
LABEL_89:
        if (SHIBYTE(v209) < 0)
          goto LABEL_109;
      }
      if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_110;
LABEL_91:
      if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_92;
LABEL_93:
      v206 = v205;
      v205 = 0uLL;
      mlir::anec::ANECDictionary::PListEntry((_QWORD **)&v206, &v211);
      mlir::anec::ANECDictionary::Add(v15, (__int128 *)((char *)v27 + 200), (uint64_t *)&v211);
      v67 = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
      if (!v211.__r_.__value_.__l.__size_)
        goto LABEL_97;
      v68 = (unint64_t *)(v211.__r_.__value_.__l.__size_ + 8);
      do
        v69 = __ldaxr(v68);
      while (__stlxr(v69 - 1, v68));
      if (!v69)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
        v70 = (std::__shared_weak_count *)*((_QWORD *)&v206 + 1);
        if (*((_QWORD *)&v206 + 1))
        {
LABEL_98:
          v71 = (unint64_t *)&v70->__shared_owners_;
          do
            v72 = __ldaxr(v71);
          while (__stlxr(v72 - 1, v71));
          if (!v72)
          {
            ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
            std::__shared_weak_count::__release_weak(v70);
          }
        }
      }
      else
      {
LABEL_97:
        v70 = (std::__shared_weak_count *)*((_QWORD *)&v206 + 1);
        if (*((_QWORD *)&v206 + 1))
          goto LABEL_98;
      }
      v73 = (std::__shared_weak_count *)*((_QWORD *)&v205 + 1);
      if (*((_QWORD *)&v205 + 1))
      {
        v74 = (unint64_t *)(*((_QWORD *)&v205 + 1) + 8);
        do
          v75 = __ldaxr(v74);
        while (__stlxr(v75 - 1, v74));
        if (!v75)
        {
          ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
          std::__shared_weak_count::__release_weak(v73);
        }
      }
      v24 += 2;
      if (v24 == v25)
        goto LABEL_112;
    }
    v37 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17)
      v37 = v35 | 7;
    v38 = v37 + 1;
    v36 = (std::string *)operator new(v37 + 1);
    v39 = v38 | 0x8000000000000000;
    a2 = v198;
    v211.__r_.__value_.__l.__size_ = v35;
    v211.__r_.__value_.__r.__words[2] = v39;
    v211.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
LABEL_40:
    memmove(v36, (char *)v33 + v34, v35);
    goto LABEL_41;
  }
LABEL_112:
  mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRNetwork>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRNetwork>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRNetwork>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRNetwork> const&)#1}>(v15, &__dst, v196, v195, 1);
  if (SHIBYTE(v204) < 0)
    operator delete((void *)__dst);
  if (!*(_DWORD *)(a1 + 112))
    goto LABEL_152;
  plist::PListArray::Create(&v210);
  v76 = *(unsigned int *)(a1 + 112);
  if ((_DWORD)v76)
  {
    v77 = *(mlir::anec::ANECIRProcedure ***)(a1 + 104);
    v78 = &v77[2 * v76];
    do
    {
      mlir::anec::ANECIRProcedure::Serialize(*v77, (uint64_t **)&v211);
      v79 = v210.__r_.__value_.__r.__words[0];
      mlir::anec::ANECDictionary::PListEntry(&v211, __p);
      v80 = *(void ***)(v79 + 16);
      if ((unint64_t)v80 >= *(_QWORD *)(v79 + 24))
      {
        v84 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v79 + 8, (__int128 *)__p);
      }
      else
      {
        *v80 = __p[0];
        v81 = (char *)__p[1];
        v80[1] = __p[1];
        if (v81)
        {
          v82 = (unint64_t *)(v81 + 8);
          do
            v83 = __ldxr(v82);
          while (__stxr(v83 + 1, v82));
        }
        v84 = v80 + 2;
      }
      *(_QWORD *)(v79 + 16) = v84;
      v85 = (std::__shared_weak_count *)__p[1];
      if (!__p[1])
        goto LABEL_128;
      v86 = (unint64_t *)((char *)__p[1] + 8);
      do
        v87 = __ldaxr(v86);
      while (__stlxr(v87 - 1, v86));
      if (!v87)
      {
        ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
        std::__shared_weak_count::__release_weak(v85);
        v88 = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
        if (v211.__r_.__value_.__l.__size_)
        {
LABEL_129:
          v89 = (unint64_t *)&v88->__shared_owners_;
          do
            v90 = __ldaxr(v89);
          while (__stlxr(v90 - 1, v89));
          if (!v90)
          {
            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
            std::__shared_weak_count::__release_weak(v88);
          }
        }
      }
      else
      {
LABEL_128:
        v88 = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
        if (v211.__r_.__value_.__l.__size_)
          goto LABEL_129;
      }
      v77 += 2;
    }
    while (v77 != v78);
  }
  v91 = *v194;
  v200 = *(_OWORD *)&v210.__r_.__value_.__l.__data_;
  if (v210.__r_.__value_.__l.__size_)
  {
    v92 = (unint64_t *)(v210.__r_.__value_.__l.__size_ + 8);
    do
      v93 = __ldxr(v92);
    while (__stxr(v93 + 1, v92));
  }
  mlir::anec::ANECDictionary::PListEntry(&v200, &v211);
  mlir::anec::ANECDictionary::Add(v91, CFSTR("ProcedureList"), (uint64_t *)&v211);
  v94 = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
  if (v211.__r_.__value_.__l.__size_)
  {
    v95 = (unint64_t *)(v211.__r_.__value_.__l.__size_ + 8);
    do
      v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }
  v97 = (std::__shared_weak_count *)*((_QWORD *)&v200 + 1);
  if (*((_QWORD *)&v200 + 1))
  {
    v98 = (unint64_t *)(*((_QWORD *)&v200 + 1) + 8);
    do
      v99 = __ldaxr(v98);
    while (__stlxr(v99 - 1, v98));
    if (!v99)
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
    }
  }
  v100 = (std::__shared_weak_count *)v210.__r_.__value_.__l.__size_;
  if (!v210.__r_.__value_.__l.__size_)
    goto LABEL_152;
  v101 = (unint64_t *)(v210.__r_.__value_.__l.__size_ + 8);
  do
    v102 = __ldaxr(v101);
  while (__stlxr(v102 - 1, v101));
  if (!v102)
  {
    ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
    std::__shared_weak_count::__release_weak(v100);
    if (!v193)
      return;
  }
  else
  {
LABEL_152:
    if (!v193)
      return;
  }
  plist::PListDict::Create((uint64_t *)&v207);
  plist::PListDict::Create((uint64_t *)&v215);
  plist::PListDict::Create((uint64_t *)&__dst);
  v103 = __dst;
  if (v192)
  {
    if (v193 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_285;
    if (v193 >= 0x17)
    {
      v106 = (v193 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v193 | 7) != 0x17)
        v106 = v193 | 7;
      v107 = v106 + 1;
      v104 = (std::string *)operator new(v106 + 1);
      v211.__r_.__value_.__l.__size_ = v193;
      v211.__r_.__value_.__r.__words[2] = v107 | 0x8000000000000000;
      v211.__r_.__value_.__r.__words[0] = (std::string::size_type)v104;
    }
    else
    {
      *((_BYTE *)&v211.__r_.__value_.__s + 23) = v193;
      v104 = &v211;
    }
    memmove(v104, v192, v193);
    v104->__r_.__value_.__s.__data_[v193] = 0;
    v105 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
  }
  else
  {
    v105 = 0;
    memset(&v211, 0, sizeof(v211));
  }
  v108 = operator new(0x38uLL);
  v108[2] = 0;
  *v108 = &off_24C05C870;
  v108[1] = 0;
  v109 = (std::string *)(v108 + 4);
  v108[3] = off_24C052D20;
  if (v105 < 0)
  {
    std::string::__init_copy_ctor_external(v109, v211.__r_.__value_.__l.__data_, v211.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v109->__r_.__value_.__l.__data_ = *(_OWORD *)&v211.__r_.__value_.__l.__data_;
    v108[6] = *((_QWORD *)&v211.__r_.__value_.__l + 2);
  }
  v210.__r_.__value_.__r.__words[0] = (std::string::size_type)(v108 + 3);
  v210.__r_.__value_.__l.__size_ = (std::string::size_type)v108;
  plist::PListDict::insert(v103, CFSTR("ModelBundleName"), (uint64_t *)&v210);
  v110 = (std::__shared_weak_count *)v210.__r_.__value_.__l.__size_;
  if (!v210.__r_.__value_.__l.__size_)
    goto LABEL_171;
  v111 = (unint64_t *)(v210.__r_.__value_.__l.__size_ + 8);
  do
    v112 = __ldaxr(v111);
  while (__stlxr(v112 - 1, v111));
  if (v112)
  {
LABEL_171:
    if ((SHIBYTE(v211.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_173;
    goto LABEL_172;
  }
  ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
  std::__shared_weak_count::__release_weak(v110);
  if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0)
LABEL_172:
    operator delete(v211.__r_.__value_.__l.__data_);
LABEL_173:
  v210.__r_.__value_.__r.__words[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v202);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v210);
  __p[0] = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v202);
  v114 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__p);
  *(_OWORD *)&v211.__r_.__value_.__r.__words[1] = 0uLL;
  v211.__r_.__value_.__r.__words[0] = (std::string::size_type)&v212;
  v116 = v114 + v115 - (_QWORD)AttrData;
  if ((const void *)(v114 + v115) == AttrData)
  {
    v117 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v211, &v212, v116, 1);
    memcpy((void *)(v211.__r_.__value_.__r.__words[0] + v211.__r_.__value_.__l.__size_), AttrData, v116);
    v117 = v211.__r_.__value_.__l.__size_;
  }
  v211.__r_.__value_.__l.__size_ = v117 + v116;
  llvm::sys::fs::make_absolute((uint64_t)&v211);
  v118 = v211.__r_.__value_.__l.__size_;
  if (v211.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7)
LABEL_285:
    abort();
  v119 = v211.__r_.__value_.__r.__words[0];
  if (v211.__r_.__value_.__l.__size_ >= 0x17)
  {
    v122 = (v211.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v211.__r_.__value_.__l.__size_ | 7) != 0x17)
      v122 = v211.__r_.__value_.__l.__size_ | 7;
    v123 = v122 + 1;
    v120 = (char *)operator new(v122 + 1);
    v210.__r_.__value_.__l.__size_ = v118;
    v210.__r_.__value_.__r.__words[2] = v123 | 0x8000000000000000;
    v210.__r_.__value_.__r.__words[0] = (std::string::size_type)v120;
  }
  else
  {
    *((_BYTE *)&v210.__r_.__value_.__s + 23) = v211.__r_.__value_.__s.__data_[8];
    v120 = (char *)&v210;
    if (!v211.__r_.__value_.__l.__size_)
    {
      v121 = &v210;
      goto LABEL_191;
    }
  }
  if (v118 < 0x20 || (unint64_t)&v120[-v119] < 0x20)
  {
    v124 = (std::string::value_type *)v119;
    v121 = (std::string *)v120;
  }
  else
  {
    v124 = (std::string::value_type *)(v119 + (v118 & 0xFFFFFFFFFFFFFFE0));
    v121 = (std::string *)&v120[v118 & 0xFFFFFFFFFFFFFFE0];
    v125 = v120 + 16;
    v126 = (__int128 *)(v119 + 16);
    v127 = v118 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v128 = *v126;
      *(v125 - 1) = *(v126 - 1);
      *v125 = v128;
      v125 += 2;
      v126 += 2;
      v127 -= 32;
    }
    while (v127);
    if (v118 == (v118 & 0xFFFFFFFFFFFFFFE0))
      goto LABEL_191;
  }
  do
  {
    v129 = *v124++;
    v121->__r_.__value_.__s.__data_[0] = v129;
    v121 = (std::string *)((char *)v121 + 1);
  }
  while (v124 != (std::string::value_type *)(v119 + v118));
LABEL_191:
  v121->__r_.__value_.__s.__data_[0] = 0;
  v130 = __dst;
  v131 = operator new(0x38uLL);
  v131[1] = 0;
  v131[2] = 0;
  *v131 = &off_24C05C870;
  v132 = (std::string *)(v131 + 4);
  v131[3] = off_24C052D20;
  if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v132, v210.__r_.__value_.__l.__data_, v210.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v132->__r_.__value_.__l.__data_ = *(_OWORD *)&v210.__r_.__value_.__l.__data_;
    v131[6] = *((_QWORD *)&v210.__r_.__value_.__l + 2);
  }
  __p[0] = v131 + 3;
  __p[1] = v131;
  plist::PListDict::insert(v130, CFSTR("ModelPath"), (uint64_t *)__p);
  v133 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v134 = (unint64_t *)((char *)__p[1] + 8);
    do
      v135 = __ldaxr(v134);
    while (__stlxr(v135 - 1, v134));
    if (!v135)
    {
      ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
      std::__shared_weak_count::__release_weak(v133);
    }
  }
  v136 = v215.__r_.__value_.__r.__words[0];
  *(_OWORD *)__p = __dst;
  if (*((_QWORD *)&__dst + 1))
  {
    v137 = (unint64_t *)(*((_QWORD *)&__dst + 1) + 8);
    do
      v138 = __ldxr(v137);
    while (__stxr(v138 + 1, v137));
  }
  plist::PListDict::insert(v136, CFSTR("ModelSourceInformation"), (uint64_t *)__p);
  v139 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v140 = (unint64_t *)((char *)__p[1] + 8);
    do
      v141 = __ldaxr(v140);
    while (__stlxr(v141 - 1, v140));
    if (!v141)
    {
      ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
      std::__shared_weak_count::__release_weak(v139);
    }
  }
  v142 = v215.__r_.__value_.__r.__words[0];
  *(_QWORD *)&v213 = CFSTR("OnTheFly");
  std::allocate_shared[abi:nn180100]<plist::PListString,std::allocator<plist::PListString>,__CFString const*,void>((CFStringRef *)&v213, &v214);
  *(_OWORD *)__p = v214;
  v214 = 0uLL;
  plist::PListDict::insert(v142, CFSTR("ModelCompilationMethod"), (uint64_t *)__p);
  v143 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v144 = (unint64_t *)((char *)__p[1] + 8);
    do
      v145 = __ldaxr(v144);
    while (__stlxr(v145 - 1, v144));
    if (!v145)
    {
      ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
      std::__shared_weak_count::__release_weak(v143);
    }
  }
  v146 = (std::__shared_weak_count *)*((_QWORD *)&v214 + 1);
  if (*((_QWORD *)&v214 + 1))
  {
    v147 = (unint64_t *)(*((_QWORD *)&v214 + 1) + 8);
    do
      v148 = __ldaxr(v147);
    while (__stlxr(v148 - 1, v147));
    if (!v148)
    {
      ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
      std::__shared_weak_count::__release_weak(v146);
    }
  }
  v149 = v207.__r_.__value_.__r.__words[0];
  *(_OWORD *)__p = *(_OWORD *)&v215.__r_.__value_.__l.__data_;
  if (v215.__r_.__value_.__l.__size_)
  {
    v150 = (unint64_t *)(v215.__r_.__value_.__l.__size_ + 8);
    do
      v151 = __ldxr(v150);
    while (__stxr(v151 + 1, v150));
  }
  plist::PListDict::insert(v149, CFSTR("ModelInformation"), (uint64_t *)__p);
  v152 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v153 = (unint64_t *)((char *)__p[1] + 8);
    do
      v154 = __ldaxr(v153);
    while (__stlxr(v154 - 1, v153));
    if (!v154)
    {
      ((void (*)(std::__shared_weak_count *))v152->__on_zero_shared)(v152);
      std::__shared_weak_count::__release_weak(v152);
    }
  }
  plist::PListDict::Create((uint64_t *)&v214);
  v155 = v214;
  v156 = operator new(0x38uLL);
  v156[1] = 0;
  v156[2] = 0;
  *v156 = &off_24C05C870;
  std::allocator<plist::PListString>::construct[abi:nn180100]<plist::PListString,char const(&)[19]>((int)__p, v156 + 3, "com.apple.mlir-mps");
  __p[0] = v156 + 3;
  __p[1] = v156;
  plist::PListDict::insert(v155, CFSTR("ModuleBundleName"), (uint64_t *)__p);
  v157 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v158 = (unint64_t *)((char *)__p[1] + 8);
    do
      v159 = __ldaxr(v158);
    while (__stlxr(v159 - 1, v158));
    if (!v159)
    {
      ((void (*)(std::__shared_weak_count *))v157->__on_zero_shared)(v157);
      std::__shared_weak_count::__release_weak(v157);
    }
  }
  v160 = v214;
  v161 = operator new(0x38uLL);
  v161[1] = 0;
  v161[2] = 0;
  *v161 = &off_24C05C870;
  std::allocator<plist::PListString>::construct[abi:nn180100]<plist::PListString,char const(&)[19]>((int)__p, v161 + 3, "1.0.0git");
  __p[0] = v161 + 3;
  __p[1] = v161;
  plist::PListDict::insert(v160, CFSTR("ModuleVersion"), (uint64_t *)__p);
  v162 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v163 = (unint64_t *)((char *)__p[1] + 8);
    do
      v164 = __ldaxr(v163);
    while (__stlxr(v164 - 1, v163));
    if (!v164)
    {
      ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
      std::__shared_weak_count::__release_weak(v162);
    }
  }
  v165 = v207.__r_.__value_.__r.__words[0];
  *(_OWORD *)__p = v214;
  if (*((_QWORD *)&v214 + 1))
  {
    v166 = (unint64_t *)(*((_QWORD *)&v214 + 1) + 8);
    do
      v167 = __ldxr(v166);
    while (__stxr(v167 + 1, v166));
  }
  plist::PListDict::insert(v165, CFSTR("ModuleInformation"), (uint64_t *)__p);
  v168 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v169 = (unint64_t *)((char *)__p[1] + 8);
    do
      v170 = __ldaxr(v169);
    while (__stlxr(v170 - 1, v169));
    if (!v170)
    {
      ((void (*)(std::__shared_weak_count *))v168->__on_zero_shared)(v168);
      std::__shared_weak_count::__release_weak(v168);
    }
  }
  v171 = *v194;
  v199 = *(_OWORD *)&v207.__r_.__value_.__l.__data_;
  if (v207.__r_.__value_.__l.__size_)
  {
    v172 = (unint64_t *)(v207.__r_.__value_.__l.__size_ + 8);
    do
      v173 = __ldxr(v172);
    while (__stxr(v173 + 1, v172));
  }
  mlir::anec::ANECDictionary::PListEntry(&v199, __p);
  mlir::anec::ANECDictionary::Add(v171, CFSTR("ModelDebugInformation"), (uint64_t *)__p);
  v174 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    v175 = (unint64_t *)((char *)__p[1] + 8);
    do
      v176 = __ldaxr(v175);
    while (__stlxr(v176 - 1, v175));
    if (!v176)
    {
      ((void (*)(std::__shared_weak_count *))v174->__on_zero_shared)(v174);
      std::__shared_weak_count::__release_weak(v174);
    }
  }
  v177 = (std::__shared_weak_count *)*((_QWORD *)&v199 + 1);
  if (*((_QWORD *)&v199 + 1))
  {
    v178 = (unint64_t *)(*((_QWORD *)&v199 + 1) + 8);
    do
      v179 = __ldaxr(v178);
    while (__stlxr(v179 - 1, v178));
    if (!v179)
    {
      ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
      std::__shared_weak_count::__release_weak(v177);
    }
  }
  v180 = (std::__shared_weak_count *)*((_QWORD *)&v214 + 1);
  if (*((_QWORD *)&v214 + 1))
  {
    v181 = (unint64_t *)(*((_QWORD *)&v214 + 1) + 8);
    do
      v182 = __ldaxr(v181);
    while (__stlxr(v182 - 1, v181));
    if (!v182)
    {
      ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
      std::__shared_weak_count::__release_weak(v180);
      if ((SHIBYTE(v210.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_262;
      goto LABEL_261;
    }
  }
  if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
LABEL_261:
    operator delete(v210.__r_.__value_.__l.__data_);
LABEL_262:
  if ((uint64_t *)v211.__r_.__value_.__l.__data_ != &v212)
    free(v211.__r_.__value_.__l.__data_);
  v183 = (std::__shared_weak_count *)*((_QWORD *)&__dst + 1);
  if (*((_QWORD *)&__dst + 1))
  {
    v184 = (unint64_t *)(*((_QWORD *)&__dst + 1) + 8);
    do
      v185 = __ldaxr(v184);
    while (__stlxr(v185 - 1, v184));
    if (!v185)
    {
      ((void (*)(std::__shared_weak_count *))v183->__on_zero_shared)(v183);
      std::__shared_weak_count::__release_weak(v183);
    }
  }
  v186 = (std::__shared_weak_count *)v215.__r_.__value_.__l.__size_;
  if (v215.__r_.__value_.__l.__size_)
  {
    v187 = (unint64_t *)(v215.__r_.__value_.__l.__size_ + 8);
    do
      v188 = __ldaxr(v187);
    while (__stlxr(v188 - 1, v187));
    if (!v188)
    {
      ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
      std::__shared_weak_count::__release_weak(v186);
    }
  }
  v189 = (std::__shared_weak_count *)v207.__r_.__value_.__l.__size_;
  if (v207.__r_.__value_.__l.__size_)
  {
    v190 = (unint64_t *)(v207.__r_.__value_.__l.__size_ + 8);
    do
      v191 = __ldaxr(v190);
    while (__stlxr(v191 - 1, v190));
    if (!v191)
    {
      ((void (*)(std::__shared_weak_count *))v189->__on_zero_shared)(v189);
      std::__shared_weak_count::__release_weak(v189);
    }
  }
}

BOOL plist::PListDict::insert(uint64_t a1, CFStringRef theString, uint64_t *a3)
{
  const char *CStringPtr;
  size_t v6;
  void *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  void *__dst[2];
  unint64_t v23;
  void **v24;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v6 = strlen(CStringPtr);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = (void *)v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    v23 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v23) = v6;
  v8 = __dst;
  if (v6)
LABEL_8:
    memmove(v8, CStringPtr, (size_t)v7);
  *((_BYTE *)v7 + (_QWORD)v8) = 0;
  v11 = a1 + 8;
  v12 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>((_QWORD *)(a1 + 8), (uint64_t)__dst);
  if (!v12)
  {
    v24 = __dst;
    v14 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v11, (uint64_t)__dst, (uint64_t)&std::piecewise_construct, (__int128 **)&v24);
    v16 = *a3;
    v15 = a3[1];
    if (v15)
    {
      v17 = (unint64_t *)(v15 + 8);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
    v19 = (std::__shared_weak_count *)*((_QWORD *)v14 + 6);
    *((_QWORD *)v14 + 5) = v16;
    *((_QWORD *)v14 + 6) = v15;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
  if (SHIBYTE(v23) < 0)
    operator delete(__dst[0]);
  return v12 == 0;
}

uint64_t mlir::anec::ANECIRTop::Write(uint64_t a1, llvm::raw_ostream *a2, char a3, uint64_t a4, const void *a5, std::string::size_type a6)
{
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  mlir::anec::ANECDictionary *v12;
  std::__shared_weak_count *v13;

  mlir::anec::ANECIRTop::Serialize(a1, a3, a4, a5, a6, (uint64_t **)&v12);
  v7 = mlir::anec::ANECDictionary::WriteToStream(v12, a2);
  v8 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v7;
}

void mlir::anec::ANECIRGOCUnit::~ANECIRGOCUnit(mlir::anec::ANECIRGOCUnit *this)
{
  mlir::anec::ANECIRUnit::~ANECIRUnit(this);
  JUMPOUT(0x20BD002F8);
}

void mlir::anec::ANECIRNeuron::~ANECIRNeuron(mlir::anec::ANECIRNeuron *this)
{
  mlir::anec::ANECIRUnit::~ANECIRUnit(this);
  JUMPOUT(0x20BD002F8);
}

void mlir::anec::ANECIRPoolUnit::~ANECIRPoolUnit(mlir::anec::ANECIRPoolUnit *this)
{
  mlir::anec::ANECIRUnit::~ANECIRUnit(this);
  JUMPOUT(0x20BD002F8);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>(_QWORD *a1, uint64_t a2)
{
  _BYTE *v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int8x8_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v2 = (_BYTE *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v5 = v4;
  }
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v21, (uint64_t *)a2, v5);
  v7 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v7)
    return 0;
  v8 = v6;
  v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *(_QWORD *)&v7)
      v11 = v6 % *(_QWORD *)&v7;
  }
  else
  {
    v11 = (*(_QWORD *)&v7 - 1) & v6;
  }
  v12 = *(uint64_t ***)(*a1 + 8 * v11);
  if (!v12)
    return 0;
  v13 = *v12;
  if (*v12)
  {
    v14 = v2[23];
    if (v14 >= 0)
      v15 = v2[23];
    else
      v15 = *((_QWORD *)v2 + 1);
    if (v14 < 0)
      v2 = *(_BYTE **)v2;
    do
    {
      v16 = v13[1];
      if (v8 == v16)
      {
        v17 = *((unsigned __int8 *)v13 + 39);
        if ((v17 & 0x80u) == 0)
          v18 = *((unsigned __int8 *)v13 + 39);
        else
          v18 = v13[3];
        if (v18 == v15)
        {
          if ((v17 & 0x80) != 0)
          {
            if (!memcmp((const void *)v13[2], v2, v13[3]))
              return v13;
          }
          else
          {
            if (!*((_BYTE *)v13 + 39))
              return v13;
            v19 = 0;
            while (*((unsigned __int8 *)v13 + v19 + 16) == v2[v19])
            {
              if (v17 == ++v19)
                return v13;
            }
          }
        }
      }
      else
      {
        if (v10 <= 1)
        {
          v16 &= *(_QWORD *)&v7 - 1;
        }
        else if (v16 >= *(_QWORD *)&v7)
        {
          v16 %= *(_QWORD *)&v7;
        }
        if (v16 != v11)
          return 0;
      }
      v13 = (uint64_t *)*v13;
    }
    while (v13);
  }
  return v13;
}

{
  _BYTE *v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int8x8_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v2 = (_BYTE *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v5 = v4;
  }
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v21, (uint64_t *)a2, v5);
  v7 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v7)
    return 0;
  v8 = v6;
  v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    v11 = v6;
    if (v6 >= *(_QWORD *)&v7)
      v11 = v6 % *(_QWORD *)&v7;
  }
  else
  {
    v11 = (*(_QWORD *)&v7 - 1) & v6;
  }
  v12 = *(uint64_t ***)(*a1 + 8 * v11);
  if (!v12)
    return 0;
  v13 = *v12;
  if (*v12)
  {
    v14 = v2[23];
    if (v14 >= 0)
      v15 = v2[23];
    else
      v15 = *((_QWORD *)v2 + 1);
    if (v14 < 0)
      v2 = *(_BYTE **)v2;
    do
    {
      v16 = v13[1];
      if (v16 == v8)
      {
        v17 = *((unsigned __int8 *)v13 + 39);
        if ((v17 & 0x80u) == 0)
          v18 = *((unsigned __int8 *)v13 + 39);
        else
          v18 = v13[3];
        if (v18 == v15)
        {
          if ((v17 & 0x80) != 0)
          {
            if (!memcmp((const void *)v13[2], v2, v13[3]))
              return v13;
          }
          else
          {
            if (!*((_BYTE *)v13 + 39))
              return v13;
            v19 = 0;
            while (*((unsigned __int8 *)v13 + v19 + 16) == v2[v19])
            {
              if (v17 == ++v19)
                return v13;
            }
          }
        }
      }
      else
      {
        if (v10 <= 1)
        {
          v16 &= *(_QWORD *)&v7 - 1;
        }
        else if (v16 >= *(_QWORD *)&v7)
        {
          v16 %= *(_QWORD *)&v7;
        }
        if (v16 != v11)
          return 0;
      }
      v13 = (uint64_t *)*v13;
    }
    while (v13);
  }
  return v13;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;

  if (a3 > 0x20)
  {
    if (a3 <= 0x40)
    {
      v6 = *(uint64_t *)((char *)a2 + a3 - 16);
      v7 = *a2 - 0x3C5A37A36834CED9 * (v6 + a3);
      v9 = a2[2];
      v8 = a2[3];
      v10 = __ROR8__(v7 + v8, 52);
      v11 = v7 + a2[1];
      v12 = __ROR8__(v11, 7);
      v13 = v11 + v9;
      v14 = *(uint64_t *)((char *)a2 + a3 - 32) + v9;
      v15 = *(uint64_t *)((char *)a2 + a3 - 8) + v8;
      v16 = __ROR8__(v15 + v14, 52);
      v17 = v12 + __ROR8__(*a2 - 0x3C5A37A36834CED9 * (v6 + a3), 37) + v10 + __ROR8__(v13, 31);
      v18 = *(uint64_t *)((char *)a2 + a3 - 24) + v14 + v6;
      v19 = v18 + v15;
      v20 = 0x9AE16A3B2F90404FLL;
      v21 = 0xC3A5C85C97CB3127 * (v19 + v17)
          - 0x651E95C4D06FBFB1
          * (v13
           + v8
           + __ROR8__(v14, 37)
           + __ROR8__(*(uint64_t *)((char *)a2 + a3 - 24) + v14, 7)
           + v16
           + __ROR8__(v18, 31));
      v22 = v17 - 0x3C5A37A36834CED9 * (v21 ^ (v21 >> 47));
      return (v22 ^ (v22 >> 47)) * v20;
    }
    v29 = *(uint64_t *)((char *)a2 + a3 - 48);
    v30 = *(uint64_t *)((char *)a2 + a3 - 40);
    v31 = *(uint64_t *)((char *)a2 + a3 - 24);
    v33 = *(uint64_t *)((char *)a2 + a3 - 64);
    v32 = *(uint64_t *)((char *)a2 + a3 - 56);
    v34 = *(uint64_t *)((char *)a2 + a3 - 16);
    v35 = *(uint64_t *)((char *)a2 + a3 - 8);
    v36 = v32 + v34;
    v37 = 0x9DDFEA08EB382D69
        * (v31 ^ ((0x9DDFEA08EB382D69 * (v31 ^ (v29 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v31 ^ (v29 + a3))));
    v38 = 0x9DDFEA08EB382D69 * (v37 ^ (v37 >> 47));
    v39 = v33 + a3 + v32 + v29;
    v40 = v39 + v30;
    v41 = __ROR8__(v39, 44) + v33 + a3 + __ROR8__(v30 + v33 + a3 - 0x622015F714C7D297 * (v37 ^ (v37 >> 47)), 21);
    v42 = v32 + v34 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
    v43 = v42 + v31 + v34;
    v44 = __ROR8__(v43, 44);
    v45 = v43 + v35;
    v46 = v44 + v42 + __ROR8__(v42 + v30 + v35, 21);
    v48 = *a2;
    v47 = a2 + 4;
    v49 = v48 - 0x4B6D499041670D8DLL * v30;
    v50 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      v51 = *(v47 - 3);
      v52 = v49 + v40 + v36 + v51;
      v53 = v47[2];
      v54 = v47[3];
      v55 = v47[1];
      v36 = v55 + v40 - 0x4B6D499041670D8DLL * __ROR8__(v36 + v41 + v53, 42);
      v56 = v38 + v45;
      v57 = *(v47 - 2);
      v58 = *(v47 - 1);
      v59 = *(v47 - 4) - 0x4B6D499041670D8DLL * v41;
      v60 = v59 + v45 + v58;
      v61 = v59 + v51 + v57;
      v40 = v61 + v58;
      v62 = __ROR8__(v61, 44) + v59;
      v63 = (0xB492B66FBE98F273 * __ROR8__(v52, 37)) ^ v46;
      v49 = 0xB492B66FBE98F273 * __ROR8__(v56, 33);
      v41 = v62 + __ROR8__(v60 + v63, 21);
      v64 = v49 + v46 + *v47;
      v45 = v64 + v55 + v53 + v54;
      v46 = __ROR8__(v64 + v55 + v53, 44) + v64 + __ROR8__(v36 + v57 + v64 + v54, 21);
      v47 += 8;
      v38 = v63;
      v50 += 64;
    }
    while (v50);
    v65 = v49
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v46 ^ ((0x9DDFEA08EB382D69 * (v46 ^ v41)) >> 47) ^ (0x9DDFEA08EB382D69 * (v46 ^ v41)))) ^ ((0x9DDFEA08EB382D69 * (v46 ^ ((0x9DDFEA08EB382D69 * (v46 ^ v41)) >> 47) ^ (0x9DDFEA08EB382D69 * (v46 ^ v41)))) >> 47));
    v66 = 0x9DDFEA08EB382D69
        * (v65 ^ (v63
                - 0x4B6D499041670D8DLL * (v36 ^ (v36 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v45 ^ ((0x9DDFEA08EB382D69 * (v45 ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * (v45 ^ v40)))) ^ ((0x9DDFEA08EB382D69 * (v45 ^ ((0x9DDFEA08EB382D69 * (v45 ^ v40)) >> 47) ^ (0x9DDFEA08EB382D69 * (v45 ^ v40)))) >> 47))));
    return 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v65 ^ (v66 >> 47) ^ v66)) ^ ((0x9DDFEA08EB382D69 * (v65 ^ (v66 >> 47) ^ v66)) >> 47));
  }
  else
  {
    if (a3 > 0x10)
    {
      v23 = a2[1];
      v24 = 0xB492B66FBE98F273 * *a2;
      v25 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a2 + a3 - 8), 30) + __ROR8__(v24 - v23, 43);
      v26 = v24
          + a3
          + __ROR8__(v23 ^ 0xC949D7C7509E6557, 20)
          - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a2 + a3 - 8);
      v20 = 0x9DDFEA08EB382D69;
      v27 = 0x9DDFEA08EB382D69 * ((v25 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a2 + a3 - 16)) ^ v26);
      v28 = v26 ^ (v27 >> 47) ^ v27;
LABEL_8:
      v22 = 0x9DDFEA08EB382D69 * v28;
      return (v22 ^ (v22 >> 47)) * v20;
    }
    if (a3 >= 9)
    {
      v3 = *(uint64_t *)((char *)a2 + a3 - 8);
      v4 = __ROR8__(v3 + a3, a3);
      return (0x9DDFEA08EB382D69
            * ((0x9DDFEA08EB382D69
              * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *a2)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *a2)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *a2)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *a2)))) >> 47))) ^ v3;
    }
    if (a3 >= 4)
    {
      v67 = *(unsigned int *)((char *)a2 + a3 - 4);
      v20 = 0x9DDFEA08EB382D69;
      v68 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a2) + a3) ^ v67);
      v28 = v67 ^ (v68 >> 47) ^ v68;
      goto LABEL_8;
    }
    result = 0x9AE16A3B2F90404FLL;
    if (a3)
    {
      v69 = (0xC949D7C7509E6557 * (a3 + 4 * *((unsigned __int8 *)a2 + a3 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                     * (*(unsigned __int8 *)a2 | ((unint64_t)*((unsigned __int8 *)a2 + (a3 >> 1)) << 8)));
      return 0x9AE16A3B2F90404FLL * (v69 ^ (v69 >> 47));
    }
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _BYTE *v6;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  void **v15;
  unsigned __int8 *v16;
  char v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::string *v23;
  __int128 *v24;
  __int128 v25;
  float v26;
  float v27;
  _BOOL8 v28;
  unint64_t v29;
  unint64_t v30;
  size_t prime;
  int8x8_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  char v40;

  v6 = (_BYTE *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v9 = v8;
  }
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v40, (uint64_t *)a2, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      v16 = (unsigned __int8 *)*v15;
      if (*v15)
      {
        v17 = v6[23];
        if (v17 >= 0)
          v18 = v6[23];
        else
          v18 = *((_QWORD *)v6 + 1);
        if (v17 < 0)
          v6 = *(_BYTE **)v6;
        do
        {
          v19 = *((_QWORD *)v16 + 1);
          if (v19 == v11)
          {
            v20 = v16[39];
            if ((v20 & 0x80u) == 0)
              v21 = v16[39];
            else
              v21 = *((_QWORD *)v16 + 3);
            if (v21 == v18)
            {
              if ((v20 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v16 + 2), v6, *((_QWORD *)v16 + 3)))
                  return v16;
              }
              else
              {
                if (!v16[39])
                  return v16;
                v22 = 0;
                while (v16[v22 + 16] == v6[v22])
                {
                  if (v20 == ++v22)
                    return v16;
                }
              }
            }
          }
          else
          {
            if (v14 <= 1)
            {
              v19 &= v12 - 1;
            }
            else if (v19 >= v12)
            {
              v19 %= v12;
            }
            if (v19 != v4)
              break;
          }
          v16 = *(unsigned __int8 **)v16;
        }
        while (v16);
      }
    }
  }
  v16 = (unsigned __int8 *)operator new(0x38uLL);
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v11;
  v23 = (std::string *)(v16 + 16);
  v24 = *a4;
  if (*((char *)*a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v23, *(const std::string::value_type **)v24, *((_QWORD *)v24 + 1));
  }
  else
  {
    v25 = *v24;
    *((_QWORD *)v16 + 4) = *((_QWORD *)v24 + 2);
    *(_OWORD *)&v23->__r_.__value_.__l.__data_ = v25;
  }
  *((_QWORD *)v16 + 5) = 0;
  *((_QWORD *)v16 + 6) = 0;
  v26 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v27 = *(float *)(a1 + 32);
  if (!v12 || (float)(v27 * (float)v12) < v26)
  {
    v28 = 1;
    if (v12 >= 3)
      v28 = (v12 & (v12 - 1)) != 0;
    v29 = v28 | (2 * v12);
    v30 = vcvtps_u32_f32(v26 / v27);
    if (v29 <= v30)
      prime = v30;
    else
      prime = v29;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v32 = *(int8x8_t *)(a1 + 8);
    if (prime > *(_QWORD *)&v32)
      goto LABEL_62;
    if (prime < *(_QWORD *)&v32)
    {
      v33 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(_QWORD *)&v32 < 3uLL || (v34 = (uint8x8_t)vcnt_s8(v32), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        v33 = std::__next_prime(v33);
      }
      else
      {
        v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2)
          v33 = v35;
      }
      if (prime <= v33)
        prime = v33;
      if (prime < *(_QWORD *)&v32)
LABEL_62:
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(a1, prime);
    }
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v36 = *(_QWORD *)a1;
  v37 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v37)
  {
    *(_QWORD *)v16 = *v37;
LABEL_76:
    *v37 = v16;
    goto LABEL_77;
  }
  *(_QWORD *)v16 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v16;
  *(_QWORD *)(v36 + 8 * v4) = a1 + 16;
  if (*(_QWORD *)v16)
  {
    v38 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v38 >= v12)
        v38 %= v12;
    }
    else
    {
      v38 &= v12 - 1;
    }
    v37 = (_QWORD *)(*(_QWORD *)a1 + 8 * v38);
    goto LABEL_76;
  }
LABEL_77:
  ++*(_QWORD *)(a1 + 24);
  return v16;
}

void mlir::anec::ANECDictionary::Add(uint64_t *a1, CFStringRef theString, uint64_t *a3)
{
  const char *CStringPtr;
  size_t v6;
  size_t v7;
  __int128 *p_dst;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  __int128 __dst;
  unint64_t v20;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v6 = strlen(CStringPtr);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_dst = (__int128 *)operator new(v9 + 1);
    *((_QWORD *)&__dst + 1) = v7;
    v20 = v10 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v20) = v6;
  p_dst = &__dst;
  if (v6)
LABEL_8:
    memmove(p_dst, CStringPtr, v7);
  *((_BYTE *)p_dst + v7) = 0;
  v11 = a3[1];
  v17 = *a3;
  v18 = (std::__shared_weak_count *)v11;
  if (v11)
  {
    v12 = (unint64_t *)(v11 + 8);
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  mlir::anec::ANECDictionary::Add(a1, &__dst, &v17);
  v14 = v18;
  if (!v18)
    goto LABEL_16;
  p_shared_owners = (unint64_t *)&v18->__shared_owners_;
  do
    v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (v16)
  {
LABEL_16:
    if ((SHIBYTE(v20) & 0x80000000) == 0)
      return;
    goto LABEL_17;
  }
  ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
  std::__shared_weak_count::__release_weak(v14);
  if (SHIBYTE(v20) < 0)
LABEL_17:
    operator delete((void *)__dst);
}

void mlir::anec::ANECDictionary::PListEntry(CFStringRef theString@<X1>, _QWORD *a2@<X8>)
{
  const char *CStringPtr;
  size_t v5;
  void *v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  void *__dst[2];
  unint64_t v11;

  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  v5 = strlen(CStringPtr);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v6 = (void *)v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    v7 = (void **)operator new(v8 + 1);
    __dst[1] = v6;
    v11 = v9 | 0x8000000000000000;
    __dst[0] = v7;
    goto LABEL_8;
  }
  HIBYTE(v11) = v5;
  v7 = __dst;
  if (v5)
LABEL_8:
    memmove(v7, CStringPtr, (size_t)v6);
  *((_BYTE *)v6 + (_QWORD)v7) = 0;
  mlir::anec::ANECDictionary::PListEntry((uint64_t)__dst, a2);
  if (SHIBYTE(v11) < 0)
    operator delete(__dst[0]);
}

void mlir::anec::ANECDictionary::Add<std::pair<std::string,mlir::anec::ANECIRDataType>,std::string (*)(std::pair<std::string,mlir::anec::ANECIRDataType> const&)>(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t a4, void (*a5)(void **__return_ptr, uint64_t), char a6)
{
  uint64_t v8;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  _OWORD *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  void *__p;
  std::__shared_weak_count *v38;
  char v39;
  __int128 v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  void *v43[2];
  char v44;

  if (a4)
  {
    v8 = a3;
    if (a4 != 1 || (a6 & 1) != 0)
    {
      plist::PListArray::Create(&v41);
      v14 = v8 + 32 * a4;
      do
      {
        v15 = v41;
        a5(&__p, v8);
        mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v40);
        v16 = *(_QWORD **)(v15 + 16);
        if ((unint64_t)v16 >= *(_QWORD *)(v15 + 24))
        {
          v20 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v15 + 8, &v40);
        }
        else
        {
          *v16 = v40;
          v17 = *((_QWORD *)&v40 + 1);
          v16[1] = *((_QWORD *)&v40 + 1);
          if (v17)
          {
            v18 = (unint64_t *)(v17 + 8);
            do
              v19 = __ldxr(v18);
            while (__stxr(v19 + 1, v18));
          }
          v20 = v16 + 2;
        }
        *(_QWORD *)(v15 + 16) = v20;
        v21 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
        if (*((_QWORD *)&v40 + 1))
        {
          v22 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
          do
            v23 = __ldaxr(v22);
          while (__stlxr(v23 - 1, v22));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }
        if (v39 < 0)
          operator delete(__p);
        v8 += 32;
      }
      while (v8 != v14);
      v35 = v41;
      v36 = v42;
      if (v42)
      {
        p_shared_owners = (unint64_t *)&v42->__shared_owners_;
        do
          v25 = __ldxr(p_shared_owners);
        while (__stxr(v25 + 1, p_shared_owners));
      }
      mlir::anec::ANECDictionary::PListEntry(&v35, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      v26 = v38;
      if (v38)
      {
        v27 = (unint64_t *)&v38->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v36;
      if (v36)
      {
        v30 = (unint64_t *)&v36->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
      v32 = v42;
      if (v42)
      {
        v33 = (unint64_t *)&v42->__shared_owners_;
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
    }
    else
    {
      a5(v43, a3);
      mlir::anec::ANECDictionary::PListEntry((uint64_t)v43, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      v11 = v38;
      if (!v38)
        goto LABEL_8;
      v12 = (unint64_t *)&v38->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
        if ((v44 & 0x80000000) == 0)
          return;
      }
      else
      {
LABEL_8:
        if ((v44 & 0x80000000) == 0)
          return;
      }
      operator delete(v43[0]);
    }
  }
}

void mlir::anec::ANECDictionary::Add<std::pair<mlir::anec::ANECIRDataType,unsigned long>,std::string (*)(std::pair<mlir::anec::ANECIRDataType,unsigned long> const&)>(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t a4, void (*a5)(void **__return_ptr, uint64_t), char a6)
{
  uint64_t v8;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  _OWORD *v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  void *__p;
  std::__shared_weak_count *v38;
  char v39;
  __int128 v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  void *v43[2];
  char v44;

  if (a4)
  {
    v8 = a3;
    if (a4 != 1 || (a6 & 1) != 0)
    {
      plist::PListArray::Create(&v41);
      v14 = v8 + 16 * a4;
      do
      {
        v15 = v41;
        a5(&__p, v8);
        mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v40);
        v16 = *(_QWORD **)(v15 + 16);
        if ((unint64_t)v16 >= *(_QWORD *)(v15 + 24))
        {
          v20 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v15 + 8, &v40);
        }
        else
        {
          *v16 = v40;
          v17 = *((_QWORD *)&v40 + 1);
          v16[1] = *((_QWORD *)&v40 + 1);
          if (v17)
          {
            v18 = (unint64_t *)(v17 + 8);
            do
              v19 = __ldxr(v18);
            while (__stxr(v19 + 1, v18));
          }
          v20 = v16 + 2;
        }
        *(_QWORD *)(v15 + 16) = v20;
        v21 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
        if (*((_QWORD *)&v40 + 1))
        {
          v22 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
          do
            v23 = __ldaxr(v22);
          while (__stlxr(v23 - 1, v22));
          if (!v23)
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }
        if (v39 < 0)
          operator delete(__p);
        v8 += 16;
      }
      while (v8 != v14);
      v35 = v41;
      v36 = v42;
      if (v42)
      {
        p_shared_owners = (unint64_t *)&v42->__shared_owners_;
        do
          v25 = __ldxr(p_shared_owners);
        while (__stxr(v25 + 1, p_shared_owners));
      }
      mlir::anec::ANECDictionary::PListEntry(&v35, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      v26 = v38;
      if (v38)
      {
        v27 = (unint64_t *)&v38->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v36;
      if (v36)
      {
        v30 = (unint64_t *)&v36->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
      v32 = v42;
      if (v42)
      {
        v33 = (unint64_t *)&v42->__shared_owners_;
        do
          v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }
    }
    else
    {
      a5(v43, a3);
      mlir::anec::ANECDictionary::PListEntry((uint64_t)v43, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      v11 = v38;
      if (!v38)
        goto LABEL_8;
      v12 = (unint64_t *)&v38->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
        if ((v44 & 0x80000000) == 0)
          return;
      }
      else
      {
LABEL_8:
        if ((v44 & 0x80000000) == 0)
          return;
      }
      operator delete(v43[0]);
    }
  }
}

void mlir::anec::ANECDictionary::Add<std::pair<mlir::anec::ANECIRDataType,unsigned long>,unsigned long (*)(std::pair<mlir::anec::ANECIRDataType,unsigned long> const&)>(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t), char a6)
{
  uint64_t v8;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _OWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  __int128 v39;

  if (a4)
  {
    v8 = a3;
    if (a4 == 1 && (a6 & 1) == 0)
    {
      v11 = a5(a3);
      mlir::anec::ANECDictionary::PListEntry(v11, &v39);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&v39);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (!*((_QWORD *)&v39 + 1))
        return;
      v13 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      goto LABEL_37;
    }
    plist::PListArray::Create(&v37);
    v15 = v8 + 16 * a4;
    do
    {
      v16 = v37;
      v17 = a5(v8);
      mlir::anec::ANECDictionary::PListEntry(v17, &v39);
      v18 = *(_QWORD **)(v16 + 16);
      if ((unint64_t)v18 >= *(_QWORD *)(v16 + 24))
      {
        v22 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v16 + 8, &v39);
      }
      else
      {
        *v18 = v39;
        v19 = *((_QWORD *)&v39 + 1);
        v18[1] = *((_QWORD *)&v39 + 1);
        if (v19)
        {
          v20 = (unint64_t *)(v19 + 8);
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        v22 = v18 + 2;
      }
      *(_QWORD *)(v16 + 16) = v22;
      v23 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v8 += 16;
    }
    while (v8 != v15);
    v35 = v37;
    v36 = v38;
    if (v38)
    {
      p_shared_owners = (unint64_t *)&v38->__shared_owners_;
      do
        v27 = __ldxr(p_shared_owners);
      while (__stxr(v27 + 1, p_shared_owners));
    }
    mlir::anec::ANECDictionary::PListEntry(&v35, &v39);
    mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&v39);
    v28 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1))
    {
      v29 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v36;
    if (v36)
    {
      v32 = (unint64_t *)&v36->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v12 = v38;
    if (v38)
    {
      v34 = (unint64_t *)&v38->__shared_owners_;
      do
        v14 = __ldaxr(v34);
      while (__stlxr(v14 - 1, v34));
LABEL_37:
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void mlir::anec::ANECDictionary::Add<unsigned long,unsigned long const& (*)(unsigned long const&)>(uint64_t *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t), char a6)
{
  uint64_t v8;
  uint64_t *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _OWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  __int128 v39;

  if (a4)
  {
    v8 = a3;
    if (a4 == 1 && (a6 & 1) == 0)
    {
      v11 = (uint64_t *)a5(a3);
      mlir::anec::ANECDictionary::PListEntry(*v11, &v39);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&v39);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (!*((_QWORD *)&v39 + 1))
        return;
      v13 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      goto LABEL_37;
    }
    plist::PListArray::Create(&v37);
    v15 = v8 + 8 * a4;
    do
    {
      v16 = v37;
      v17 = (uint64_t *)a5(v8);
      mlir::anec::ANECDictionary::PListEntry(*v17, &v39);
      v18 = *(_QWORD **)(v16 + 16);
      if ((unint64_t)v18 >= *(_QWORD *)(v16 + 24))
      {
        v22 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v16 + 8, &v39);
      }
      else
      {
        *v18 = v39;
        v19 = *((_QWORD *)&v39 + 1);
        v18[1] = *((_QWORD *)&v39 + 1);
        if (v19)
        {
          v20 = (unint64_t *)(v19 + 8);
          do
            v21 = __ldxr(v20);
          while (__stxr(v21 + 1, v20));
        }
        v22 = v18 + 2;
      }
      *(_QWORD *)(v16 + 16) = v22;
      v23 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
      if (*((_QWORD *)&v39 + 1))
      {
        v24 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v8 += 8;
    }
    while (v8 != v15);
    v35 = v37;
    v36 = v38;
    if (v38)
    {
      p_shared_owners = (unint64_t *)&v38->__shared_owners_;
      do
        v27 = __ldxr(p_shared_owners);
      while (__stxr(v27 + 1, p_shared_owners));
    }
    mlir::anec::ANECDictionary::PListEntry(&v35, &v39);
    mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&v39);
    v28 = (std::__shared_weak_count *)*((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1))
    {
      v29 = (unint64_t *)(*((_QWORD *)&v39 + 1) + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = v36;
    if (v36)
    {
      v32 = (unint64_t *)&v36->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    v12 = v38;
    if (v38)
    {
      v34 = (unint64_t *)&v38->__shared_owners_;
      do
        v14 = __ldaxr(v34);
      while (__stlxr(v14 - 1, v34));
LABEL_37:
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRInput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  mlir::anec::ANECIRInput **v10;
  mlir::anec::ANECIRInput **v11;
  mlir::anec::ANECIRInput *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  __int128 *v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  uint64_t *v28;
  std::__shared_weak_count *v29;
  _QWORD *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;

  if (!a4)
  {
LABEL_20:
    mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRInput>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRInput>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRInput>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRInput> const&)#1}>(a1, a2, a3, a4, 1);
    return;
  }
  v10 = (mlir::anec::ANECIRInput **)&a3[2 * a4];
  v11 = (mlir::anec::ANECIRInput **)a3;
  while (1)
  {
    v12 = *v11;
    mlir::anec::ANECIRInput::Serialize(*v11, &v28);
    v13 = *(_QWORD *)(a5 + 24);
    if (!v13)
      break;
    (*(void (**)(_QWORD **__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)v13 + 48))(&v30, v13, &v28);
    mlir::anec::ANECDictionary::PListEntry(&v30, &v32);
    mlir::anec::ANECDictionary::Add(a1, (__int128 *)((char *)v12 + 8), &v32);
    v14 = v33;
    if (!v33)
      goto LABEL_9;
    p_shared_owners = (unint64_t *)&v33->__shared_owners_;
    do
      v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      v17 = v31;
      if (v31)
      {
LABEL_10:
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
    else
    {
LABEL_9:
      v17 = v31;
      if (v31)
        goto LABEL_10;
    }
    v20 = v29;
    if (v29)
    {
      v21 = (unint64_t *)&v29->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v11 += 2;
    if (v11 == v10)
      goto LABEL_20;
  }
  v23 = (uint64_t *)std::__throw_bad_function_call[abi:nn180100]();
  mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRInput>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRInput>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRInput>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRInput> const&)#1}>(v23, v24, v25, v26, v27);
}

void mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRInput>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRInput>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRInput>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRInput> const&)#1}>(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t *v6;
  uint64_t v9;
  __int128 v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  _OWORD *v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *size;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  std::string __p;
  __int128 v40;
  uint64_t v41;
  std::__shared_weak_count *v42;
  std::string v43;

  if (a4)
  {
    v6 = a3;
    if (a4 != 1 || (a5 & 1) != 0)
    {
      plist::PListArray::Create(&v41);
      v11 = &v6[2 * a4];
      do
      {
        v12 = v41;
        v13 = *v6;
        if (*(char *)(*v6 + 31) < 0)
        {
          std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v13 + 8), *(_QWORD *)(v13 + 16));
        }
        else
        {
          v14 = *(_OWORD *)(v13 + 8);
          __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v13 + 24);
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
        }
        mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v40);
        v15 = *(_QWORD **)(v12 + 16);
        if ((unint64_t)v15 >= *(_QWORD *)(v12 + 24))
        {
          v19 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v12 + 8, &v40);
        }
        else
        {
          *v15 = v40;
          v16 = *((_QWORD *)&v40 + 1);
          v15[1] = *((_QWORD *)&v40 + 1);
          if (v16)
          {
            v17 = (unint64_t *)(v16 + 8);
            do
              v18 = __ldxr(v17);
            while (__stxr(v18 + 1, v17));
          }
          v19 = v15 + 2;
        }
        *(_QWORD *)(v12 + 16) = v19;
        v20 = (std::__shared_weak_count *)*((_QWORD *)&v40 + 1);
        if (*((_QWORD *)&v40 + 1))
        {
          v21 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
          do
            v22 = __ldaxr(v21);
          while (__stlxr(v22 - 1, v21));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v6 += 2;
      }
      while (v6 != v11);
      v37 = v41;
      v38 = v42;
      if (v42)
      {
        p_shared_owners = (unint64_t *)&v42->__shared_owners_;
        do
          v24 = __ldxr(p_shared_owners);
        while (__stxr(v24 + 1, p_shared_owners));
      }
      mlir::anec::ANECDictionary::PListEntry(&v37, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_)
      {
        v26 = (unint64_t *)(__p.__r_.__value_.__l.__size_ + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
          std::__shared_weak_count::__release_weak(size);
        }
      }
      v28 = v38;
      if (v38)
      {
        v29 = (unint64_t *)&v38->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      v31 = v42;
      if (v42)
      {
        v32 = (unint64_t *)&v42->__shared_owners_;
        do
          v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
    }
    else
    {
      v9 = *a3;
      if (*(char *)(*a3 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v43, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v43.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v10;
      }
      mlir::anec::ANECDictionary::PListEntry((uint64_t)&v43, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      v34 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (!__p.__r_.__value_.__l.__size_)
        goto LABEL_47;
      v35 = (unint64_t *)(__p.__r_.__value_.__l.__size_ + 8);
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (v36)
      {
LABEL_47:
        if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          return;
        goto LABEL_48;
      }
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
LABEL_48:
        operator delete(v43.__r_.__value_.__l.__data_);
    }
  }
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_11ANECIRInputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_ED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_11ANECIRInputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24C05A290;
  return result;
}

void _ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_11ANECIRInputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEPNS0_6__baseISA_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24C05A290;
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_11ANECIRInputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_EclEOS9_(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIROutput,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  mlir::anec::ANECIROutput **v10;
  mlir::anec::ANECIROutput **i;
  mlir::anec::ANECIROutput *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  std::__shared_weak_count *v24;
  _QWORD *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;

  if (a4)
  {
    v10 = (mlir::anec::ANECIROutput **)&a3[2 * a4];
    for (i = (mlir::anec::ANECIROutput **)a3; i != v10; i += 2)
    {
      v12 = *i;
      mlir::anec::ANECIROutput::Serialize(*i, &v23);
      v13 = *(_QWORD *)(a5 + 24);
      if (!v13)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        JUMPOUT(0x207124408);
      }
      (*(void (**)(_QWORD **__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)v13 + 48))(&v25, v13, &v23);
      mlir::anec::ANECDictionary::PListEntry(&v25, &v27);
      mlir::anec::ANECDictionary::Add(a1, (__int128 *)((char *)v12 + 8), &v27);
      v14 = v28;
      if (!v28)
        goto LABEL_9;
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
        v17 = v26;
        if (v26)
        {
LABEL_10:
          v18 = (unint64_t *)&v17->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
      else
      {
LABEL_9:
        v17 = v26;
        if (v26)
          goto LABEL_10;
      }
      v20 = v24;
      if (v24)
      {
        v21 = (unint64_t *)&v24->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }
  mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRInput>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRInput>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRInput>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRInput> const&)#1}>(a1, a2, a3, a4, 1);
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_12ANECIROutputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_ED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_12ANECIROutputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_24C05A2D8;
  return result;
}

void _ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_12ANECIROutputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEPNS0_6__baseISA_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_24C05A2D8;
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_12ANECIROutputENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_EclEOS9_(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRUnit,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v10;
  uint64_t *i;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  _QWORD *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;

  if (a4)
  {
    v10 = &a3[2 * a4];
    for (i = a3; i != v10; i += 2)
    {
      v12 = *i;
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)*i + 16))(&v23, *i);
      v13 = *(_QWORD *)(a5 + 24);
      if (!v13)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        JUMPOUT(0x207124614);
      }
      (*(void (**)(_QWORD **__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v13 + 48))(&v25, v13, &v23);
      mlir::anec::ANECDictionary::PListEntry(&v25, &v27);
      mlir::anec::ANECDictionary::Add(a1, (__int128 *)(v12 + 8), &v27);
      v14 = v28;
      if (!v28)
        goto LABEL_9;
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
        v17 = v26;
        if (v26)
        {
LABEL_10:
          v18 = (unint64_t *)&v17->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
      else
      {
LABEL_9:
        v17 = v26;
        if (v26)
          goto LABEL_10;
      }
      v20 = v24;
      if (v24)
      {
        v21 = (unint64_t *)&v24->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }
  mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRInput>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRInput>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRInput>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRInput> const&)#1}>(a1, a2, a3, a4, 1);
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_10ANECIRUnitENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_ED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_10ANECIRUnitENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_24C05A248;
  return result;
}

void _ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_10ANECIRUnitENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEPNS0_6__baseISA_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_24C05A248;
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_10ANECIRUnitENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_EclEOS9_(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void mlir::anec::ANECDictionary::AddLayers<mlir::anec::ANECIRConstant,std::function<std::shared_ptr<mlir::anec::ANECDictionary> ()(std::shared_ptr<mlir::anec::ANECDictionary>)>>(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  mlir::anec::ANECIRConstant **v10;
  mlir::anec::ANECIRConstant **i;
  mlir::anec::ANECIRConstant *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  std::__shared_weak_count *v24;
  _QWORD *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  std::__shared_weak_count *v28;

  if (a4)
  {
    v10 = (mlir::anec::ANECIRConstant **)&a3[2 * a4];
    for (i = (mlir::anec::ANECIRConstant **)a3; i != v10; i += 2)
    {
      v12 = *i;
      mlir::anec::ANECIRConstant::Serialize(*i, &v23);
      v13 = *(_QWORD *)(a5 + 24);
      if (!v13)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        JUMPOUT(0x207124818);
      }
      (*(void (**)(_QWORD **__return_ptr, uint64_t, uint64_t **))(*(_QWORD *)v13 + 48))(&v25, v13, &v23);
      mlir::anec::ANECDictionary::PListEntry(&v25, &v27);
      mlir::anec::ANECDictionary::Add(a1, (__int128 *)((char *)v12 + 8), &v27);
      v14 = v28;
      if (!v28)
        goto LABEL_9;
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v16 = __ldaxr(p_shared_owners);
      while (__stlxr(v16 - 1, p_shared_owners));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
        v17 = v26;
        if (v26)
        {
LABEL_10:
          v18 = (unint64_t *)&v17->__shared_owners_;
          do
            v19 = __ldaxr(v18);
          while (__stlxr(v19 - 1, v18));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
      else
      {
LABEL_9:
        v17 = v26;
        if (v26)
          goto LABEL_10;
      }
      v20 = v24;
      if (v24)
      {
        v21 = (unint64_t *)&v24->__shared_owners_;
        do
          v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }
  mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRInput>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRInput>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRInput>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRInput> const&)#1}>(a1, a2, a3, a4, 1);
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_14ANECIRConstantENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_ED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_14ANECIRConstantENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_24C05A320;
  return result;
}

void _ZNKSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_14ANECIRConstantENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_E7__cloneEPNS0_6__baseISA_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_24C05A320;
}

void _ZNSt3__110__function6__funcIZN4mlir4anec14ANECDictionary9AddLayersINS3_14ANECIRConstantENS_8functionIFNS_10shared_ptrIS4_EES9_EEEEEvPK10__CFStringN4llvm8ArrayRefINS8_IT_EEEET0_Ed_UlRKS9_E_NS_9allocatorISN_EESA_EclEOS9_(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void mlir::anec::ANECDictionary::Add<std::shared_ptr<mlir::anec::ANECIRNetwork>,void mlir::anec::ANECDictionary::AddLayerNames<mlir::anec::ANECIRNetwork>(std::string const&,llvm::ArrayRef<std::shared_ptr<mlir::anec::ANECIRNetwork>>)::{lambda(std::shared_ptr<mlir::anec::ANECIRNetwork> const&)#1}>(uint64_t *a1, __int128 *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t *v6;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _OWORD *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *size;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  std::string __p;
  __int128 v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  std::string v41;

  if (a4)
  {
    v6 = a3;
    if (a4 != 1 || (a5 & 1) != 0)
    {
      plist::PListArray::Create(&v39);
      v10 = &v6[2 * a4];
      do
      {
        v11 = v39;
        v12 = *v6;
        if (*(char *)(*v6 + 223) < 0)
          std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v12 + 200), *(_QWORD *)(v12 + 208));
        else
          __p = *(std::string *)(v12 + 200);
        mlir::anec::ANECDictionary::PListEntry((uint64_t)&__p, &v38);
        v13 = *(_QWORD **)(v11 + 16);
        if ((unint64_t)v13 >= *(_QWORD *)(v11 + 24))
        {
          v17 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v11 + 8, &v38);
        }
        else
        {
          *v13 = v38;
          v14 = *((_QWORD *)&v38 + 1);
          v13[1] = *((_QWORD *)&v38 + 1);
          if (v14)
          {
            v15 = (unint64_t *)(v14 + 8);
            do
              v16 = __ldxr(v15);
            while (__stxr(v16 + 1, v15));
          }
          v17 = v13 + 2;
        }
        *(_QWORD *)(v11 + 16) = v17;
        v18 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
        if (*((_QWORD *)&v38 + 1))
        {
          v19 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
          do
            v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v6 += 2;
      }
      while (v6 != v10);
      v35 = v39;
      v36 = v40;
      if (v40)
      {
        p_shared_owners = (unint64_t *)&v40->__shared_owners_;
        do
          v22 = __ldxr(p_shared_owners);
        while (__stxr(v22 + 1, p_shared_owners));
      }
      mlir::anec::ANECDictionary::PListEntry(&v35, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_)
      {
        v24 = (unint64_t *)(__p.__r_.__value_.__l.__size_ + 8);
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
          std::__shared_weak_count::__release_weak(size);
        }
      }
      v26 = v36;
      if (v36)
      {
        v27 = (unint64_t *)&v36->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v40;
      if (v40)
      {
        v30 = (unint64_t *)&v40->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    else
    {
      v9 = *a3;
      if (*(char *)(*a3 + 223) < 0)
        std::string::__init_copy_ctor_external(&v41, *(const std::string::value_type **)(v9 + 200), *(_QWORD *)(v9 + 208));
      else
        v41 = *(std::string *)(v9 + 200);
      mlir::anec::ANECDictionary::PListEntry((uint64_t)&v41, &__p);
      mlir::anec::ANECDictionary::Add(a1, a2, (uint64_t *)&__p);
      v32 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (!__p.__r_.__value_.__l.__size_)
        goto LABEL_47;
      v33 = (unint64_t *)(__p.__r_.__value_.__l.__size_ + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (v34)
      {
LABEL_47:
        if ((SHIBYTE(v41.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          return;
        goto LABEL_48;
      }
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
LABEL_48:
        operator delete(v41.__r_.__value_.__l.__data_);
    }
  }
}

void std::__shared_ptr_emplace<plist::PListString>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C870;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<plist::PListString>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C870;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_emplace<plist::PListString>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

size_t std::allocate_shared[abi:nn180100]<plist::PListString,std::allocator<plist::PListString>,__CFString const*,void>@<X0>(CFStringRef *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  const char *CStringPtr;
  size_t result;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  v4 = operator new(0x38uLL);
  v4[2] = 0;
  *v4 = &off_24C05C870;
  v4[1] = 0;
  v4[3] = off_24C052D20;
  CStringPtr = CFStringGetCStringPtr(*a1, 0x8000100u);
  result = strlen(CStringPtr);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = result;
  if (result >= 0x17)
  {
    v9 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v9 = result | 7;
    v10 = v9 + 1;
    v8 = operator new(v9 + 1);
    v4[5] = v7;
    v4[6] = v10 | 0x8000000000000000;
    v4[4] = v8;
  }
  else
  {
    v8 = v4 + 4;
    *((_BYTE *)v4 + 55) = result;
    if (!result)
      goto LABEL_9;
  }
  result = (size_t)memmove(v8, CStringPtr, v7);
LABEL_9:
  *((_BYTE *)v8 + v7) = 0;
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void std::allocator<plist::PListString>::construct[abi:nn180100]<plist::PListString,char const(&)[19]>(int a1, _QWORD *a2, char *__s)
{
  size_t v5;
  size_t v6;
  __int128 *p_dst;
  uint64_t v8;
  uint64_t v9;
  std::string *v10;
  void *v11;
  __int128 __dst;
  unint64_t v13;

  v5 = strlen(__s);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v6 = v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    p_dst = (__int128 *)operator new(v8 + 1);
    *((_QWORD *)&__dst + 1) = v6;
    v13 = v9 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v13) = v5;
  p_dst = &__dst;
  if (v5)
LABEL_8:
    memcpy(p_dst, __s, v6);
  *((_BYTE *)p_dst + v6) = 0;
  *a2 = off_24C052D20;
  v10 = (std::string *)(a2 + 1);
  if (SHIBYTE(v13) < 0)
  {
    v11 = (void *)__dst;
    std::string::__init_copy_ctor_external(v10, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    operator delete(v11);
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = __dst;
    v10->__r_.__value_.__r.__words[2] = v13;
  }
}

BOOL mlir::anec::ANECIRWeights::hasConstant(mlir::anec::ANECIRWeights *this, mlir::Operation *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  int v11;
  int v12;
  void *v14[2];
  _QWORD v15[2];

  v15[1] = *MEMORY[0x24BDAC8D0];
  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v4))
  {
    v14[0] = v15;
    v14[1] = (void *)0x100000000;
    mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v14);
    v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v14[0] & 0xFFFFFFFFFFFFFFF8));
    if (v14[0] != v15)
      free(v14[0]);
  }
  else
  {
    v5 = 0;
  }
  v6 = *((_QWORD *)this + 1);
  v7 = *((unsigned int *)this + 6);
  if (!(_DWORD)v7)
  {
LABEL_11:
    v9 = (uint64_t **)(v6 + 16 * v7);
    return v9 != (uint64_t **)(v6 + 16 * v7);
  }
  LODWORD(v8) = (v7 - 1) & ((v5 >> 4) ^ (v5 >> 9));
  v9 = (uint64_t **)(v6 + 16 * v8);
  v10 = *v9;
  if (*v9 != v5)
  {
    v11 = 1;
    while (v10 != (uint64_t *)-4096)
    {
      v12 = v8 + v11++;
      v8 = v12 & (v7 - 1);
      v10 = *(uint64_t **)(v6 + 16 * v8);
      if (v10 == v5)
      {
        v9 = (uint64_t **)(v6 + 16 * v8);
        return v9 != (uint64_t **)(v6 + 16 * v7);
      }
    }
    goto LABEL_11;
  }
  return v9 != (uint64_t **)(v6 + 16 * v7);
}

uint64_t mlir::anec::ANECIRWeights::addConstant(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  int v12;
  uint64_t v13;
  _BOOL4 isF32;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int *v23;
  int v25;
  int v26;
  uint64_t ArgOperands;
  uint64_t v28;
  char v29[8];
  _QWORD v30[2];

  v30[0] = a2;
  v30[1] = a3;
  v5 = (uint64_t)(a1 + 1);
  v4 = a1[1];
  v6 = *((unsigned int *)a1 + 6);
  v7 = a2 >> 4;
  if ((_DWORD)v6)
  {
    LODWORD(v8) = (v6 - 1) & (v7 ^ (a2 >> 9));
    v9 = *(_QWORD *)(v4 + 16 * v8);
    if (v9 == a2)
    {
      if ((_DWORD)v8 != (_DWORD)v6)
      {
        v10 = (_QWORD *)(v4 + 16 * v6);
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    v11 = 1;
    while (v9 != -4096)
    {
      v12 = v8 + v11++;
      v8 = v12 & (v6 - 1);
      v9 = *(_QWORD *)(v4 + 16 * v8);
      if (v9 == a2)
        goto LABEL_10;
    }
  }
  v8 = *((unsigned int *)a1 + 6);
LABEL_10:
  if (v8 != v6)
  {
    v10 = (_QWORD *)(v4 + 16 * v6);
    v19 = v10;
    if (!(_DWORD)v6)
    {
LABEL_20:
      v23 = (unsigned int *)(a1 + 5);
      if (v19 != v10)
        v23 = (unsigned int *)(v19 + 1);
      return *(_QWORD *)(a1[4] + 16 * *v23 + 8);
    }
LABEL_19:
    v20 = v7 ^ (a2 >> 9);
    v21 = v6 - 1;
    LODWORD(v6) = v20 & (v6 - 1);
    v19 = (_QWORD *)(v4 + 16 * v6);
    v22 = *v19;
    if (*v19 != a2)
    {
      v25 = 1;
      while (v22 != -4096)
      {
        v26 = v6 + v25++;
        v6 = v26 & v21;
        v22 = *(_QWORD *)(v4 + 16 * v6);
        if (v22 == a2)
        {
          v19 = (_QWORD *)(v4 + 16 * v6);
          goto LABEL_20;
        }
      }
      v19 = v10;
    }
    goto LABEL_20;
  }
LABEL_11:
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30);
  v28 = v13;
  *(_QWORD *)v29 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  isF32 = mlir::Type::isF32((mlir::Type *)v29);
  v15 = -4;
  if (!isF32)
    v15 = -1;
  v16 = *a1;
  v17 = 3;
  if (!isF32)
    v17 = 0;
  v18 = (v17 + v16) & v15;
  llvm::raw_ostream::write((llvm::raw_ostream *)a1[6], v29, v18 - v16);
  ArgOperands = v30[0];
  v28 = v18;
  llvm::MapVector<void const*,unsigned long long,llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>,llvm::SmallVector<std::pair<void const*,unsigned long long>,0u>>::try_emplace<unsigned long long>(v5, &ArgOperands, &v28);
  if (mlir::ElementsAttr::getType((mlir::ElementsAttr *)v30))
    mlir::TypeID::get<mlir::ShapedType>();
  *a1 = mlir::writeConstantData((llvm::raw_ostream *)a1[6]);
  return v18;
}

uint64_t mlir::anec::ANECIRWeights::addConstant(mlir::anec::ANECIRWeights *this, mlir::Operation *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void *v9[2];
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v4))
  {
    v9[0] = v10;
    v9[1] = (void *)0x100000000;
    mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v9);
    v6 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v9[0] & 0xFFFFFFFFFFFFFFF8));
    if (v6)
      v7 = v5;
    else
      v7 = 0;
    if (v9[0] != v10)
      free(v9[0]);
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  return mlir::anec::ANECIRWeights::addConstant((uint64_t *)this, (uint64_t)v6, v7);
}

uint64_t mlir::anec::ANECIRWeights::lookupConstant(mlir::anec::ANECIRWeights *this, mlir::Operation *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t *v10;
  int v11;
  int v12;
  BOOL v13;
  unsigned int *v14;
  void *v16[2];
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v4))
  {
    v16[0] = v17;
    v16[1] = (void *)0x100000000;
    mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v16);
    v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v16[0] & 0xFFFFFFFFFFFFFFF8));
    if (v16[0] != v17)
      free(v16[0]);
  }
  else
  {
    v5 = 0;
  }
  v6 = *((_QWORD *)this + 1);
  v7 = *((unsigned int *)this + 6);
  if ((_DWORD)v7)
  {
    LODWORD(v8) = (v7 - 1) & ((v5 >> 4) ^ (v5 >> 9));
    v9 = (_QWORD *)(v6 + 16 * v8);
    v10 = (uint64_t *)*v9;
    if ((uint64_t *)*v9 == v5)
      goto LABEL_12;
    v11 = 1;
    while (v10 != (uint64_t *)-4096)
    {
      v12 = v8 + v11++;
      v8 = v12 & (v7 - 1);
      v10 = *(uint64_t **)(v6 + 16 * v8);
      if (v10 == v5)
      {
        v9 = (_QWORD *)(v6 + 16 * v8);
        goto LABEL_12;
      }
    }
  }
  v9 = (_QWORD *)(v6 + 16 * v7);
LABEL_12:
  v13 = v9 == (_QWORD *)(v6 + 16 * v7);
  v14 = (unsigned int *)((char *)this + 40);
  if (!v13)
    v14 = (unsigned int *)(v9 + 1);
  return *(_QWORD *)(*((_QWORD *)this + 4) + 16 * *v14 + 8);
}

uint64_t llvm::MapVector<void const*,unsigned long long,llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>,llvm::SmallVector<std::pair<void const*,unsigned long long>,0u>>::try_emplace<unsigned long long>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t inserted;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unsigned int v20;
  _QWORD *v21;
  int v22;
  BOOL v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;

  v6 = *a2;
  v28 = *a2;
  v29 = 0;
  v7 = *(_DWORD *)(a1 + 16);
  if (v7)
  {
    v8 = *(_QWORD *)a1;
    v9 = v7 - 1;
    v10 = (v7 - 1) & ((v6 >> 4) ^ (v6 >> 9));
    v11 = (_QWORD *)(*(_QWORD *)a1 + 16 * v10);
    v12 = *v11;
    if (v6 == *v11)
      return *(_QWORD *)(a1 + 24) + 16 * *(unsigned int *)(v8 + 16 * v10 + 8);
    v21 = 0;
    v22 = 1;
    while (v12 != -4096)
    {
      if (v21)
        v23 = 0;
      else
        v23 = v12 == -8192;
      if (v23)
        v21 = v11;
      v24 = v10 + v22++;
      v10 = v24 & v9;
      v11 = (_QWORD *)(v8 + 16 * v10);
      v12 = *v11;
      if (v6 == *v11)
        return *(_QWORD *)(a1 + 24) + 16 * *(unsigned int *)(v8 + 16 * v10 + 8);
    }
    if (v21)
      v14 = (uint64_t)v21;
    else
      v14 = (uint64_t)v11;
  }
  else
  {
    v14 = 0;
  }
  inserted = llvm::DenseMapBase<llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>,void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::InsertIntoBucket<void const*,unsigned int>(a1, v14, &v28, &v29);
  v16 = (uint64_t *)(a1 + 24);
  v17 = *(unsigned int *)(a1 + 32);
  *(_DWORD *)(inserted + 8) = v17;
  if (v17 >= *(_DWORD *)(a1 + 36))
  {
    v25 = *a2;
    v26 = *a3;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v16, (void *)(a1 + 40), v17 + 1, 16);
    v27 = (uint64_t *)(*(_QWORD *)(a1 + 24) + 16 * *(unsigned int *)(a1 + 32));
    *v27 = v25;
    v27[1] = v26;
    LODWORD(v17) = *(_DWORD *)(a1 + 32);
    v18 = *(_QWORD *)(a1 + 24);
  }
  else
  {
    v18 = *v16;
    v19 = (uint64_t *)(*v16 + 16 * v17);
    *v19 = *a2;
    v19[1] = *a3;
  }
  v20 = v17 + 1;
  *(_DWORD *)(a1 + 32) = v20;
  return v18 + 16 * v20 - 16;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>,void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::InsertIntoBucket<void const*,unsigned int>(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  unsigned int v18;

  v8 = *(_DWORD *)(a1 + 8);
  v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
LABEL_3:
    v10 = *(_QWORD *)a2;
    goto LABEL_4;
  }
  llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::grow(a1, v9);
  v10 = *a3;
  v12 = *(_DWORD *)(a1 + 16) - 1;
  v13 = ((*a3 >> 4) ^ (*a3 >> 9)) & v12;
  a2 = *(_QWORD *)a1 + 16 * v13;
  v14 = *(_QWORD *)a2;
  if (*a3 != *(_QWORD *)a2)
  {
    v15 = 0;
    v16 = 1;
    while (v14 != -4096)
    {
      if (v15)
        v17 = 0;
      else
        v17 = v14 == -8192;
      if (v17)
        v15 = a2;
      v18 = v13 + v16++;
      v13 = v18 & v12;
      a2 = *(_QWORD *)a1 + 16 * (v18 & v12);
      v14 = *(_QWORD *)a2;
      if (v10 == *(_QWORD *)a2)
        goto LABEL_4;
    }
    if (v15)
      a2 = v15;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v10 != -4096)
    --*(_DWORD *)(a1 + 12);
  *(_QWORD *)a2 = *a3;
  *(_DWORD *)(a2 + 8) = *a4;
  return a2;
}

_QWORD *llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  llvm *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  unsigned int v30;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_10;
      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 2;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_10:
        v15 = &result[2 * v11];
        do
        {
          *v10 = -4096;
          v10 += 2;
        }
        while (v10 != v15);
      }
    }
    if ((_DWORD)v3)
    {
      v16 = v4;
      do
      {
        v23 = *(_QWORD *)v16;
        if ((*(_QWORD *)v16 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v24 = *(_DWORD *)(a1 + 16) - 1;
          v25 = v24 & ((v23 >> 4) ^ (v23 >> 9));
          v22 = *(_QWORD *)a1 + 16 * v25;
          v26 = *(_QWORD *)v22;
          if (v23 != *(_QWORD *)v22)
          {
            v27 = 0;
            v28 = 1;
            while (v26 != -4096)
            {
              if (v27)
                v29 = 0;
              else
                v29 = v26 == -8192;
              if (v29)
                v27 = v22;
              v30 = v25 + v28++;
              v25 = v30 & v24;
              v22 = *(_QWORD *)a1 + 16 * (v30 & v24);
              v26 = *(_QWORD *)v22;
              if (v23 == *(_QWORD *)v22)
                goto LABEL_24;
            }
            if (v27)
              v22 = v27;
          }
LABEL_24:
          *(_QWORD *)v22 = v23;
          *(_DWORD *)(v22 + 8) = *((_DWORD *)v16 + 2);
          ++*(_DWORD *)(a1 + 8);
        }
        v16 = (llvm *)((char *)v16 + 16);
      }
      while (v16 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v17 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v17)
  {
    if (((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_19;
    v18 = ((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[2 * (v18 & 0x1FFFFFFFFFFFFFFELL)];
    v19 = result + 2;
    v20 = v18 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v19 - 2) = -4096;
      *v19 = -4096;
      v19 += 4;
      v20 -= 2;
    }
    while (v20);
    if (v18 != (v18 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_19:
      v21 = &result[2 * v17];
      do
      {
        *v10 = -4096;
        v10 += 2;
      }
      while (v10 != v21);
    }
  }
  return result;
}

uint64_t *mlir::anec::ANECDictionary::Create@<X0>(uint64_t **a1@<X8>)
{
  uint64_t *v3;
  uint64_t *result;

  v3 = (uint64_t *)operator new();
  plist::PListDict::Create(v3);
  *a1 = v3;
  result = (uint64_t *)operator new();
  *result = (uint64_t)&off_24C05DA98;
  result[1] = 0;
  result[2] = 0;
  result[3] = (uint64_t)v3;
  a1[1] = result;
  return result;
}

void mlir::anec::ANECDictionary::Create(mlir::anec::ANECDictionary *this, const ZinIrUnitInfo *a2)
{
  __asm { BR              X10 }
}

void sub_20712584C(const ZinIrConvUnitInfo *a1)
{
  uint64_t **v1;
  __CFDictionary *ConvUnit;
  uint64_t *v3;
  uint64_t *v4;

  ConvUnit = ZinCreateConvUnit(a1);
  v3 = (uint64_t *)operator new();
  plist::PListDict::Create(v3);
  *v1 = v3;
  v4 = (uint64_t *)operator new();
  *v4 = (uint64_t)&off_24C05DA98;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = (uint64_t)v3;
  v1[1] = v4;
  CFDictionaryApplyFunction(ConvUnit, (CFDictionaryApplierFunction)mlir::anec::ANECDictionary::Create(ZinIrUnitInfo const&)::$_0::__invoke, v3);
  CFRelease(ConvUnit);
}

void mlir::anec::ANECDictionary::Add(uint64_t *a1, __int128 *a2, uint64_t *a3)
{
  std::__shared_weak_count *v6;
  __int128 *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  _QWORD *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  __int128 *v19;
  std::__shared_weak_count *v20;

  plist::PListDict::GetValueForKey(*a1, (uint64_t)a2, &v19);
  v7 = v19;
  v6 = v20;
  if (!v20)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (v7)
      return;
  }
  else
  {
LABEL_5:
    if (v7)
      return;
  }
  v10 = (_QWORD *)(*a1 + 8);
  if (!std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>(v10, (uint64_t)a2))
  {
    v19 = a2;
    v11 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v10, (uint64_t)a2, (uint64_t)&std::piecewise_construct, &v19);
    v13 = *a3;
    v12 = a3[1];
    if (v12)
    {
      v14 = (unint64_t *)(v12 + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v16 = (std::__shared_weak_count *)*((_QWORD *)v11 + 6);
    *((_QWORD *)v11 + 5) = v13;
    *((_QWORD *)v11 + 6) = v12;
    if (v16)
    {
      v17 = (unint64_t *)&v16->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
}

uint64_t mlir::anec::ANECDictionary::WriteToStream(mlir::anec::ANECDictionary *this, llvm::raw_ostream *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  uint64_t v10;
  void **v11;
  size_t v12;
  void *__p[2];
  unsigned __int8 v15;
  uint64_t v16;
  uint64_t v17[8];
  void *v18[2];
  __int128 v19;
  int v20;
  uint64_t v21[19];

  v4 = MEMORY[0x24BEDB870];
  v5 = MEMORY[0x24BEDB870] + 64;
  v6 = (uint64_t *)MEMORY[0x24BEDB800];
  v7 = *(_QWORD *)(MEMORY[0x24BEDB800] + 8);
  v8 = *(_QWORD *)(MEMORY[0x24BEDB800] + 16);
  v21[0] = MEMORY[0x24BEDB870] + 64;
  v16 = v7;
  *(uint64_t *)((char *)&v17[-1] + *(_QWORD *)(v7 - 24)) = v8;
  v9 = (std::ios_base *)((char *)&v17[-1] + *(_QWORD *)(v16 - 24));
  std::ios_base::init(v9, v17);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v16 = v4 + 24;
  v21[0] = v5;
  std::streambuf::basic_streambuf();
  v10 = MEMORY[0x24BEDB848] + 16;
  v17[0] = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)v18 = 0u;
  v19 = 0u;
  v20 = 16;
  plist::PListDict::Dump(*(_QWORD *)this, &v16, 0, 4);
  std::stringbuf::str();
  if ((v15 & 0x80u) == 0)
    v11 = __p;
  else
    v11 = (void **)__p[0];
  if ((v15 & 0x80u) == 0)
    v12 = v15;
  else
    v12 = (size_t)__p[1];
  llvm::raw_ostream::write(a2, (const char *)v11, v12);
  if ((char)v15 < 0)
    operator delete(__p[0]);
  v16 = *v6;
  *(uint64_t *)((char *)&v17[-1] + *(_QWORD *)(v16 - 24)) = v6[3];
  v17[0] = v10;
  if (SBYTE7(v19) < 0)
    operator delete(v18[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x20BD0022C](v21);
  return 0;
}

_QWORD *mlir::anec::ANECDictionary::PListEntry@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v5;
  _QWORD *result;

  v5 = (_QWORD *)operator new();
  *v5 = &off_24C052D48;
  v5[1] = a1;
  *a2 = v5;
  result = (_QWORD *)operator new();
  *result = &off_24C05DBE8;
  result[1] = 0;
  result[2] = 0;
  result[3] = v5;
  a2[1] = result;
  return result;
}

{
  _QWORD *v4;
  std::string *v5;
  _QWORD *result;

  v4 = (_QWORD *)operator new();
  *v4 = off_24C052D20;
  v5 = (std::string *)(v4 + 1);
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    v4[3] = *(_QWORD *)(a1 + 16);
  }
  *a2 = v4;
  result = (_QWORD *)operator new();
  *result = &off_24C05DBB0;
  result[1] = 0;
  result[2] = 0;
  result[3] = v4;
  a2[1] = result;
  return result;
}

_QWORD *mlir::anec::ANECDictionary::PListEntry@<X0>(int a1@<W1>, _QWORD *a2@<X8>)
{
  _QWORD *v5;
  _QWORD *result;

  v5 = (_QWORD *)operator new();
  *v5 = &off_24C052D48;
  v5[1] = a1;
  *a2 = v5;
  result = (_QWORD *)operator new();
  *result = &off_24C05DBE8;
  result[1] = 0;
  result[2] = 0;
  result[3] = v5;
  a2[1] = result;
  return result;
}

_QWORD *mlir::anec::ANECDictionary::PListEntry@<X0>(char a1@<W1>, uint64_t *a2@<X8>)
{
  uint64_t v5;
  _QWORD *result;

  v5 = operator new();
  *(_QWORD *)v5 = &off_24C052D70;
  *(_BYTE *)(v5 + 8) = a1;
  *a2 = v5;
  result = (_QWORD *)operator new();
  *result = &off_24C05DC20;
  result[1] = 0;
  result[2] = 0;
  result[3] = v5;
  a2[1] = (uint64_t)result;
  return result;
}

void mlir::anec::ANECDictionary::PListEntry(_QWORD **a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = (*a1)[1];
  *a2 = **a1;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void mlir::anec::ANECDictionary::PListEntry(_QWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
}

void mlir::anec::ANECDictionary::Create(ZinIrUnitInfo const&)::$_0::__invoke(const __CFString *a1, const __CFString *a2, uint64_t *a3)
{
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  plist::PListReal *v8;
  std::__shared_weak_count *v9;
  __int128 __p;
  uint64_t v11;

  __p = 0uLL;
  v11 = 0;
  ZinGetString(a1, (uint64_t)&__p);
  plist::PListType::PListFromCF(&v8, a2);
  mlir::anec::ANECDictionary::Add(a3, &__p, (uint64_t *)&v8);
  v5 = v9;
  if (!v9)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (v7)
  {
LABEL_5:
    if ((SHIBYTE(v11) & 0x80000000) == 0)
      return;
    goto LABEL_6;
  }
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  if (SHIBYTE(v11) < 0)
LABEL_6:
    operator delete((void *)__p);
}

void std::__shared_ptr_pointer<mlir::anec::ANECDictionary *,std::shared_ptr<mlir::anec::ANECDictionary>::__shared_ptr_default_delete<mlir::anec::ANECDictionary,mlir::anec::ANECDictionary>,std::allocator<mlir::anec::ANECDictionary>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<mlir::anec::ANECDictionary *,std::shared_ptr<mlir::anec::ANECDictionary>::__shared_ptr_default_delete<mlir::anec::ANECDictionary,mlir::anec::ANECDictionary>,std::allocator<mlir::anec::ANECDictionary>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    JUMPOUT(0x20BD002F8);
  }
  return result;
}

void std::__shared_ptr_pointer<plist::PListInt *,std::shared_ptr<plist::PListType>::__shared_ptr_default_delete<plist::PListType,plist::PListInt>,std::allocator<plist::PListInt>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<plist::PListInt *,std::shared_ptr<plist::PListType>::__shared_ptr_default_delete<plist::PListType,plist::PListInt>,std::allocator<plist::PListInt>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<plist::PListBool *,std::shared_ptr<plist::PListType>::__shared_ptr_default_delete<plist::PListType,plist::PListBool>,std::allocator<plist::PListBool>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<plist::PListBool *,std::shared_ptr<plist::PListType>::__shared_ptr_default_delete<plist::PListType,plist::PListBool>,std::allocator<plist::PListBool>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<plist::PListString *,std::shared_ptr<plist::PListType>::__shared_ptr_default_delete<plist::PListType,plist::PListString>,std::allocator<plist::PListString>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<plist::PListString *,std::shared_ptr<plist::PListType>::__shared_ptr_default_delete<plist::PListType,plist::PListString>,std::allocator<plist::PListString>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void plist::PListType::PListFromCF(plist::PListReal **__return_ptr a1@<X8>, const __CFString *this@<X0>)
{
  CFTypeID v5;
  _QWORD *v6;
  std::string *v7;
  uint64_t v8;
  CFTypeID v9;
  BOOL v10;
  _QWORD *v11;
  CFTypeID v12;
  CFNumberType Type;
  int IsFloatType;
  CFIndex ByteSize;
  _QWORD *v16;
  plist::PListReal *v17;
  double v18;
  int v19;
  CFTypeID v20;
  _QWORD *v21;
  plist::PListReal *v22;
  CFTypeID v23;
  _QWORD *v24;
  double *v25;
  double v26;
  double v27;
  void *__p[2];
  uint64_t v29;
  CFRange v30;

  if (!this)
    goto LABEL_18;
  v5 = CFGetTypeID(this);
  if (v5 == CFStringGetTypeID())
  {
    __p[0] = 0;
    __p[1] = 0;
    v29 = 0;
    ZinGetString(this, (uint64_t)__p);
    v6 = operator new(0x38uLL);
    v6[1] = 0;
    v6[2] = 0;
    *v6 = &off_24C05C870;
    v7 = (std::string *)(v6 + 4);
    v6[3] = off_24C052D20;
    v8 = (uint64_t)(v6 + 3);
    if (SHIBYTE(v29) < 0)
    {
      std::string::__init_copy_ctor_external(v7, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      v19 = SHIBYTE(v29);
      *a1 = (plist::PListReal *)v8;
      a1[1] = (plist::PListReal *)v6;
      if (v19 < 0)
        operator delete(__p[0]);
    }
    else
    {
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
      v6[6] = v29;
      *a1 = (plist::PListReal *)v8;
      a1[1] = (plist::PListReal *)v6;
    }
    return;
  }
  v9 = CFGetTypeID(this);
  if (v9 == CFBooleanGetTypeID())
  {
    v10 = CFBooleanGetValue((CFBooleanRef)this) != 0;
    v11 = operator new(0x28uLL);
    v11[1] = 0;
    v11[2] = 0;
    *v11 = &off_24C05C8E0;
    *((_BYTE *)v11 + 32) = v10;
    a1[1] = (plist::PListReal *)v11;
    v11[3] = &off_24C052D70;
    *a1 = (plist::PListReal *)(v11 + 3);
    return;
  }
  v12 = CFGetTypeID(this);
  if (v12 != CFNumberGetTypeID())
  {
    v20 = CFGetTypeID(this);
    if (v20 == CFDictionaryGetTypeID())
    {
      v21 = (_QWORD *)operator new();
      *v21 = &off_24C052D98;
      *(_OWORD *)(v21 + 1) = 0u;
      *(_OWORD *)(v21 + 3) = 0u;
      *((_DWORD *)v21 + 10) = 1065353216;
      v22 = (plist::PListReal *)operator new();
      *(_QWORD *)v22 = &off_24C05DC58;
      *((_QWORD *)v22 + 1) = 0;
      *((_QWORD *)v22 + 2) = 0;
      *((_QWORD *)v22 + 3) = v21;
      CFDictionaryApplyFunction((CFDictionaryRef)this, (CFDictionaryApplierFunction)plist::PListType::PListFromCF(void const*)::$_0::__invoke, v21);
LABEL_17:
      *a1 = (plist::PListReal *)v21;
      a1[1] = v22;
      return;
    }
    v23 = CFGetTypeID(this);
    if (v23 == CFArrayGetTypeID())
    {
      v21 = (_QWORD *)operator new();
      *v21 = &off_24C052CF8;
      v21[1] = 0;
      v21[2] = 0;
      v21[3] = 0;
      v22 = (plist::PListReal *)operator new();
      *(_QWORD *)v22 = &off_24C05DB78;
      *((_QWORD *)v22 + 1) = 0;
      *((_QWORD *)v22 + 2) = 0;
      *((_QWORD *)v22 + 3) = v21;
      v30.length = CFArrayGetCount((CFArrayRef)this);
      v30.location = 0;
      CFArrayApplyFunction((CFArrayRef)this, v30, (CFArrayApplierFunction)plist::PListType::PListFromCF(void const*)::$_1::__invoke, v21);
      goto LABEL_17;
    }
LABEL_18:
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  Type = CFNumberGetType((CFNumberRef)this);
  v27 = 0.0;
  CFNumberGetValue((CFNumberRef)this, Type, &v27);
  IsFloatType = CFNumberIsFloatType((CFNumberRef)this);
  ByteSize = CFNumberGetByteSize((CFNumberRef)this);
  if (IsFloatType)
  {
    if (ByteSize == 4)
    {
      v16 = operator new(0x38uLL);
      v16[1] = 0;
      v16[2] = 0;
      *v16 = &off_24C05C918;
      v17 = (plist::PListReal *)(v16 + 3);
      v18 = *(float *)&v27;
    }
    else
    {
      CFNumberGetByteSize((CFNumberRef)this);
      v16 = operator new(0x38uLL);
      v16[1] = 0;
      v16[2] = 0;
      *v16 = &off_24C05C918;
      v17 = (plist::PListReal *)(v16 + 3);
      v18 = v27;
    }
    *a1 = plist::PListReal::PListReal(v17, v18);
    a1[1] = (plist::PListReal *)v16;
  }
  else if (ByteSize == 1)
  {
    v24 = operator new(0x28uLL);
    v24[1] = 0;
    v24[2] = 0;
    *v24 = &off_24C05C8A8;
    v24[4] = SLOBYTE(v27);
    a1[1] = (plist::PListReal *)v24;
    v24[3] = &off_24C052D48;
    *a1 = (plist::PListReal *)(v24 + 3);
  }
  else
  {
    if (CFNumberGetByteSize((CFNumberRef)this) == 2)
    {
      v25 = (double *)operator new(0x28uLL);
      v25[1] = 0.0;
      v25[2] = 0.0;
      *(_QWORD *)v25 = &off_24C05C8A8;
      *(_QWORD *)&v26 = SLOWORD(v27);
    }
    else if (CFNumberGetByteSize((CFNumberRef)this) == 4)
    {
      v25 = (double *)operator new(0x28uLL);
      v25[1] = 0.0;
      v25[2] = 0.0;
      *(_QWORD *)v25 = &off_24C05C8A8;
      *(_QWORD *)&v26 = SLODWORD(v27);
    }
    else
    {
      CFNumberGetByteSize((CFNumberRef)this);
      v25 = (double *)operator new(0x28uLL);
      v25[1] = 0.0;
      v25[2] = 0.0;
      *(_QWORD *)v25 = &off_24C05C8A8;
      v26 = v27;
    }
    v25[4] = v26;
    a1[1] = (plist::PListReal *)v25;
    *((_QWORD *)v25 + 3) = &off_24C052D48;
    *a1 = (plist::PListReal *)(v25 + 3);
    __p[0] = 0;
    __p[1] = 0;
    std::shared_ptr<ZinIrConstData>::~shared_ptr[abi:ne180100]((uint64_t)__p);
  }
}

_QWORD *plist::PListDict::Create@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = operator new();
  *(_QWORD *)v3 = &off_24C052D98;
  *(_OWORD *)(v3 + 8) = 0u;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_DWORD *)(v3 + 40) = 1065353216;
  *a1 = v3;
  result = (_QWORD *)operator new();
  *result = &off_24C05DC58;
  result[1] = 0;
  result[2] = 0;
  result[3] = v3;
  a1[1] = (uint64_t)result;
  return result;
}

_QWORD *plist::PListArray::Create@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  _QWORD *result;

  v3 = (_QWORD *)operator new();
  *v3 = &off_24C052CF8;
  v3[1] = 0;
  v3[2] = 0;
  v3[3] = 0;
  *a1 = v3;
  result = (_QWORD *)operator new();
  *result = &off_24C05DB78;
  result[1] = 0;
  result[2] = 0;
  result[3] = v3;
  a1[1] = result;
  return result;
}

_QWORD *plist::PListString::DoPrint(uint64_t a1, _QWORD *a2, size_t __len)
{
  void **p_b;
  size_t v7;
  size_t v8;
  void **v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  void *__p[2];
  char v23;
  void *v24[2];
  char v25;
  void **__b;
  size_t v27;
  int64_t v28;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    p_b = (void **)operator new(v7 + 1);
    v27 = __len;
    v28 = v8 | 0x8000000000000000;
    __b = p_b;
    goto LABEL_8;
  }
  HIBYTE(v28) = __len;
  p_b = (void **)&__b;
  if (__len)
LABEL_8:
    memset(p_b, 32, __len);
  *((_BYTE *)p_b + __len) = 0;
  if (v28 >= 0)
    v9 = (void **)&__b;
  else
    v9 = __b;
  if (v28 >= 0)
    v10 = HIBYTE(v28);
  else
    v10 = v27;
  v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v9, v10);
  v25 = 8;
  strcpy((char *)v24, "<string>");
  v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)v24, 8);
  v15 = *(_QWORD *)(a1 + 8);
  v14 = a1 + 8;
  v13 = v15;
  v16 = *(char *)(v14 + 23);
  if (v16 >= 0)
    v17 = v14;
  else
    v17 = v13;
  if (v16 >= 0)
    v18 = *(unsigned __int8 *)(v14 + 23);
  else
    v18 = *(_QWORD *)(v14 + 8);
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, v17, v18);
  v23 = 10;
  strcpy((char *)__p, "</string>\n");
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)__p, 10);
  if ((v23 & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_23;
LABEL_26:
    operator delete(v24[0]);
    if ((SHIBYTE(v28) & 0x80000000) == 0)
      return v20;
LABEL_27:
    operator delete(__b);
    return v20;
  }
  operator delete(__p[0]);
  if (v25 < 0)
    goto LABEL_26;
LABEL_23:
  if (SHIBYTE(v28) < 0)
    goto LABEL_27;
  return v20;
}

plist::PListReal *plist::PListReal::PListReal(plist::PListReal *this, double a2)
{
  char *v3;
  const char *v5;
  int v7;
  char *begin;
  size_t v9;
  std::vector<char> v10;

  *(_QWORD *)this = off_24C052DC0;
  *((_QWORD *)this + 1) = 0;
  v3 = (char *)this + 8;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  if (a2 == -INFINITY)
  {
    v5 = "-infinity";
LABEL_7:
    MEMORY[0x20BCFFE00]((char *)this + 8, v5);
    return this;
  }
  if (a2 == INFINITY)
  {
    v5 = "+infinity";
    goto LABEL_7;
  }
  if (a2 == 0.0)
  {
    v5 = "0.0";
    goto LABEL_7;
  }
  memset(&v10, 0, sizeof(v10));
  v7 = snprintf(0, 0, "%.*g", 17, a2);
  begin = 0;
  v9 = v7 + 1;
  if (v7 != -1)
  {
    std::vector<char>::__append(&v10, v7 + 1);
    begin = v10.__begin_;
  }
  snprintf(begin, v9, "%.*g", 17, a2);
  MEMORY[0x20BCFFE00](v3, v10.__begin_);
  if (v10.__begin_)
  {
    v10.__end_ = v10.__begin_;
    operator delete(v10.__begin_);
  }
  return this;
}

_QWORD *plist::PListReal::DoPrint(uint64_t a1, _QWORD *a2, size_t __len)
{
  void **p_b;
  size_t v7;
  size_t v8;
  void **v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  void *__p[2];
  char v23;
  void *v24[2];
  char v25;
  void **__b;
  size_t v27;
  int64_t v28;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    p_b = (void **)operator new(v7 + 1);
    v27 = __len;
    v28 = v8 | 0x8000000000000000;
    __b = p_b;
    goto LABEL_8;
  }
  HIBYTE(v28) = __len;
  p_b = (void **)&__b;
  if (__len)
LABEL_8:
    memset(p_b, 32, __len);
  *((_BYTE *)p_b + __len) = 0;
  if (v28 >= 0)
    v9 = (void **)&__b;
  else
    v9 = __b;
  if (v28 >= 0)
    v10 = HIBYTE(v28);
  else
    v10 = v27;
  v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v9, v10);
  v25 = 6;
  strcpy((char *)v24, "<real>");
  v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)v24, 6);
  v15 = *(_QWORD *)(a1 + 8);
  v14 = a1 + 8;
  v13 = v15;
  v16 = *(char *)(v14 + 23);
  if (v16 >= 0)
    v17 = v14;
  else
    v17 = v13;
  if (v16 >= 0)
    v18 = *(unsigned __int8 *)(v14 + 23);
  else
    v18 = *(_QWORD *)(v14 + 8);
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, v17, v18);
  v23 = 8;
  strcpy((char *)__p, "</real>\n");
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)__p, 8);
  if ((v23 & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_23;
LABEL_26:
    operator delete(v24[0]);
    if ((SHIBYTE(v28) & 0x80000000) == 0)
      return v20;
LABEL_27:
    operator delete(__b);
    return v20;
  }
  operator delete(__p[0]);
  if (v25 < 0)
    goto LABEL_26;
LABEL_23:
  if (SHIBYTE(v28) < 0)
    goto LABEL_27;
  return v20;
}

_QWORD *plist::PListInt::DoPrint(uint64_t a1, _QWORD *a2, size_t __len)
{
  void **p_b;
  size_t v7;
  size_t v8;
  void **v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  std::string *v13;
  std::string::size_type size;
  _QWORD *v15;
  _QWORD *v16;
  void *v18[2];
  char v19;
  std::string v20;
  void *__p[2];
  char v22;
  void **__b;
  size_t v24;
  int64_t v25;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    p_b = (void **)operator new(v7 + 1);
    v24 = __len;
    v25 = v8 | 0x8000000000000000;
    __b = p_b;
    goto LABEL_8;
  }
  HIBYTE(v25) = __len;
  p_b = (void **)&__b;
  if (__len)
LABEL_8:
    memset(p_b, 32, __len);
  *((_BYTE *)p_b + __len) = 0;
  if (v25 >= 0)
    v9 = (void **)&__b;
  else
    v9 = __b;
  if (v25 >= 0)
    v10 = HIBYTE(v25);
  else
    v10 = v24;
  v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v9, v10);
  v22 = 9;
  strcpy((char *)__p, "<integer>");
  v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)__p, 9);
  std::to_string(&v20, *(_QWORD *)(a1 + 8));
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = &v20;
  else
    v13 = (std::string *)v20.__r_.__value_.__r.__words[0];
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
  else
    size = v20.__r_.__value_.__l.__size_;
  v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)v13, size);
  v19 = 11;
  strcpy((char *)v18, "</integer>\n");
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)v18, 11);
  if (v19 < 0)
  {
    operator delete(v18[0]);
    if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_23:
      if ((v22 & 0x80000000) == 0)
        goto LABEL_24;
LABEL_28:
      operator delete(__p[0]);
      if ((SHIBYTE(v25) & 0x80000000) == 0)
        return v16;
LABEL_29:
      operator delete(__b);
      return v16;
    }
  }
  else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_23;
  }
  operator delete(v20.__r_.__value_.__l.__data_);
  if (v22 < 0)
    goto LABEL_28;
LABEL_24:
  if (SHIBYTE(v25) < 0)
    goto LABEL_29;
  return v16;
}

_QWORD *plist::PListBool::DoPrint(uint64_t a1, _QWORD *a2, size_t __len)
{
  __int128 *p_b;
  size_t v7;
  size_t v8;
  __int128 *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 __b;
  int64_t v15;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    p_b = (__int128 *)operator new(v7 + 1);
    *((_QWORD *)&__b + 1) = __len;
    v15 = v8 | 0x8000000000000000;
    *(_QWORD *)&__b = p_b;
    goto LABEL_8;
  }
  HIBYTE(v15) = __len;
  p_b = &__b;
  if (__len)
LABEL_8:
    memset(p_b, 32, __len);
  *((_BYTE *)p_b + __len) = 0;
  if (v15 >= 0)
    v9 = &__b;
  else
    v9 = (__int128 *)__b;
  if (v15 >= 0)
    v10 = HIBYTE(v15);
  else
    v10 = *((_QWORD *)&__b + 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v9, v10);
  if (SHIBYTE(v15) < 0)
  {
    operator delete((void *)__b);
    if (*(_BYTE *)(a1 + 8))
      goto LABEL_17;
  }
  else if (*(_BYTE *)(a1 + 8))
  {
LABEL_17:
    HIBYTE(v15) = 8;
    strcpy((char *)&__b, "<true/>\n");
    v11 = a2;
    v12 = 8;
    goto LABEL_20;
  }
  HIBYTE(v15) = 9;
  strcpy((char *)&__b, "<false/>\n");
  v11 = a2;
  v12 = 9;
LABEL_20:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)&__b, v12);
  if (SHIBYTE(v15) < 0)
    operator delete((void *)__b);
  return a2;
}

_QWORD *plist::PListDict::DoPrint(uint64_t a1, _QWORD *a2, size_t __len, uint64_t a4)
{
  void **p_b;
  size_t v9;
  size_t v10;
  void **v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t **v14;
  size_t v15;
  size_t v16;
  size_t v17;
  void **v18;
  void **v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  void **v27;
  size_t v28;
  size_t v29;
  void **v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v35;
  void *v36[2];
  char v37;
  void *__p[2];
  char v39;
  void **__b;
  size_t v41;
  int64_t v42;

  if (__len > 0x7FFFFFFFFFFFFFF7)
LABEL_68:
    abort();
  if (__len >= 0x17)
  {
    v9 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v9 = __len | 7;
    v10 = v9 + 1;
    p_b = (void **)operator new(v9 + 1);
    v41 = __len;
    v42 = v10 | 0x8000000000000000;
    __b = p_b;
    goto LABEL_8;
  }
  HIBYTE(v42) = __len;
  p_b = (void **)&__b;
  if (__len)
LABEL_8:
    memset(p_b, 32, __len);
  *((_BYTE *)p_b + __len) = 0;
  if (v42 >= 0)
    v11 = (void **)&__b;
  else
    v11 = __b;
  if (v42 >= 0)
    v12 = HIBYTE(v42);
  else
    v12 = v41;
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v11, v12);
  v39 = 7;
  strcpy((char *)__p, "<dict>\n");
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)__p, 7);
  if (v39 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v42) < 0)
  {
    operator delete(__b);
    v14 = *(uint64_t ***)(a1 + 24);
    if (!v14)
      goto LABEL_50;
    goto LABEL_21;
  }
  v14 = *(uint64_t ***)(a1 + 24);
  if (v14)
  {
LABEL_21:
    v15 = a4 + __len;
    v16 = ((a4 + __len) & 0xFFFFFFFFFFFFFFF8) + 8;
    if (((a4 + __len) | 7) != 0x17)
      v16 = (a4 + __len) | 7;
    v17 = v16 + 1;
    v35 = (v16 + 1) | 0x8000000000000000;
    while (1)
    {
      if (v15 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_68;
      if (v15 >= 0x17)
        break;
      HIBYTE(v42) = a4 + __len;
      v18 = (void **)&__b;
      if (v15)
        goto LABEL_30;
LABEL_31:
      *((_BYTE *)v18 + v15) = 0;
      if (v42 >= 0)
        v19 = (void **)&__b;
      else
        v19 = __b;
      if (v42 >= 0)
        v20 = HIBYTE(v42);
      else
        v20 = v41;
      v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v19, v20);
      v39 = 5;
      strcpy((char *)__p, "<key>");
      v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)__p, 5);
      v23 = *((char *)v14 + 39);
      if (v23 >= 0)
        v24 = (uint64_t)(v14 + 2);
      else
        v24 = (uint64_t)v14[2];
      if (v23 >= 0)
        v25 = *((unsigned __int8 *)v14 + 39);
      else
        v25 = (uint64_t)v14[3];
      v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, v24, v25);
      v37 = 7;
      strcpy((char *)v36, "</key>\n");
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)v36, 7);
      if (v37 < 0)
      {
        operator delete(v36[0]);
        if ((v39 & 0x80000000) == 0)
        {
LABEL_45:
          if (SHIBYTE(v42) < 0)
            goto LABEL_49;
          goto LABEL_24;
        }
      }
      else if ((v39 & 0x80000000) == 0)
      {
        goto LABEL_45;
      }
      operator delete(__p[0]);
      if (SHIBYTE(v42) < 0)
LABEL_49:
        operator delete(__b);
LABEL_24:
      (*(void (**)(uint64_t *, _QWORD *, size_t, uint64_t))(*v14[5] + 16))(v14[5], a2, v15, a4);
      v14 = (uint64_t **)*v14;
      if (!v14)
        goto LABEL_50;
    }
    v18 = (void **)operator new(v17);
    v41 = a4 + __len;
    v42 = v35;
    __b = v18;
LABEL_30:
    memset(v18, 32, v15);
    goto LABEL_31;
  }
LABEL_50:
  if (__len >= 0x17)
  {
    v28 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v28 = __len | 7;
    v29 = v28 + 1;
    v27 = (void **)operator new(v28 + 1);
    v41 = __len;
    v42 = v29 | 0x8000000000000000;
    __b = v27;
    goto LABEL_56;
  }
  HIBYTE(v42) = __len;
  v27 = (void **)&__b;
  if (__len)
LABEL_56:
    memset(v27, 32, __len);
  *((_BYTE *)v27 + __len) = 0;
  if (v42 >= 0)
    v30 = (void **)&__b;
  else
    v30 = __b;
  if (v42 >= 0)
    v31 = HIBYTE(v42);
  else
    v31 = v41;
  v32 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v30, v31);
  v39 = 8;
  strcpy((char *)__p, "</dict>\n");
  v33 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)__p, 8);
  if (v39 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v42) & 0x80000000) == 0)
      return v33;
LABEL_67:
    operator delete(__b);
    return v33;
  }
  if (SHIBYTE(v42) < 0)
    goto LABEL_67;
  return v33;
}

_QWORD *plist::PListDict::Dump(uint64_t a1, _QWORD *a2, size_t a3, uint64_t a4)
{
  char *v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  const std::locale::facet *v12;
  void *__p[2];
  char v15;
  std::locale v16;

  v8 = (char *)operator new(0x28uLL);
  strcpy(v8, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v8, 39);
  operator delete(v8);
  v9 = (char *)operator new(0x68uLL);
  strcpy(v9, "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n");
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v9, 103);
  operator delete(v9);
  v10 = (char *)operator new(0x20uLL);
  strcpy(v10, "<plist version=\"1.0.2\">\n");
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v10, 24);
  operator delete(v10);
  plist::PListDict::DoPrint(a1, a2, a3, a4);
  v15 = 8;
  strcpy((char *)__p, "</plist>");
  v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)__p, 8);
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(_QWORD *)(*v11 - 24)));
  v12 = std::locale::use_facet(&v16, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(&v16);
  std::ostream::put();
  std::ostream::flush();
  if (v15 < 0)
    operator delete(__p[0]);
  return a2;
}

uint64_t *plist::PListDict::GetValueForKey@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  result = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>((_QWORD *)(a1 + 8), a2);
  if (result)
  {
    v5 = result[6];
    *a3 = result[5];
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

_QWORD *plist::PListArray::DoPrint(uint64_t a1, _QWORD *a2, size_t __len, uint64_t a4)
{
  void **p_b;
  size_t v9;
  size_t v10;
  void **v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  void **v17;
  size_t v18;
  size_t v19;
  void **v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *__p[2];
  char v26;
  void **__b;
  size_t v28;
  int64_t v29;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v9 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v9 = __len | 7;
    v10 = v9 + 1;
    p_b = (void **)operator new(v9 + 1);
    v28 = __len;
    v29 = v10 | 0x8000000000000000;
    __b = p_b;
    goto LABEL_8;
  }
  HIBYTE(v29) = __len;
  p_b = (void **)&__b;
  if (__len)
LABEL_8:
    memset(p_b, 32, __len);
  *((_BYTE *)p_b + __len) = 0;
  if (v29 >= 0)
    v11 = (void **)&__b;
  else
    v11 = __b;
  if (v29 >= 0)
    v12 = HIBYTE(v29);
  else
    v12 = v28;
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v11, v12);
  v26 = 8;
  strcpy((char *)__p, "<array>\n");
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)__p, 8);
  if (v26 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v29) & 0x80000000) == 0)
      goto LABEL_17;
  }
  else if ((SHIBYTE(v29) & 0x80000000) == 0)
  {
    goto LABEL_17;
  }
  operator delete(__b);
LABEL_17:
  v14 = *(uint64_t **)(a1 + 8);
  v15 = *(uint64_t **)(a1 + 16);
  while (v14 != v15)
  {
    v16 = *v14;
    v14 += 2;
    (*(void (**)(uint64_t, _QWORD *, size_t, uint64_t))(*(_QWORD *)v16 + 16))(v16, a2, a4 + __len, a4);
  }
  if (__len >= 0x17)
  {
    v18 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v18 = __len | 7;
    v19 = v18 + 1;
    v17 = (void **)operator new(v18 + 1);
    v28 = __len;
    v29 = v19 | 0x8000000000000000;
    __b = v17;
    goto LABEL_25;
  }
  HIBYTE(v29) = __len;
  v17 = (void **)&__b;
  if (__len)
LABEL_25:
    memset(v17, 32, __len);
  *((_BYTE *)v17 + __len) = 0;
  if (v29 >= 0)
    v20 = (void **)&__b;
  else
    v20 = __b;
  if (v29 >= 0)
    v21 = HIBYTE(v29);
  else
    v21 = v28;
  v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v20, v21);
  v26 = 9;
  strcpy((char *)__p, "</array>\n");
  v23 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)__p, 9);
  if (v26 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v29) & 0x80000000) == 0)
      return v23;
LABEL_38:
    operator delete(__b);
    return v23;
  }
  if (SHIBYTE(v29) < 0)
    goto LABEL_38;
  return v23;
}

void plist::PListString::~PListString(void **this)
{
  *this = off_24C052D20;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24C052D20;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BD002F8);
}

void plist::PListInt::~PListInt(plist::PListInt *this)
{
  JUMPOUT(0x20BD002F8);
}

void plist::PListBool::~PListBool(plist::PListBool *this)
{
  JUMPOUT(0x20BD002F8);
}

void plist::PListArray::~PListArray(plist::PListArray *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  *(_QWORD *)this = &off_24C052CF8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = *((_QWORD *)this + 2);
    v4 = (void *)*((_QWORD *)this + 1);
    if (v3 != v2)
    {
      do
      {
        v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v2;
    operator delete(v4);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  *(_QWORD *)this = &off_24C052CF8;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = *((_QWORD *)this + 2);
    v4 = (void *)*((_QWORD *)this + 1);
    if (v3 != v2)
    {
      do
      {
        v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v2;
    operator delete(v4);
  }
  JUMPOUT(0x20BD002F8);
}

void plist::PListDict::~PListDict(plist::PListDict *this)
{
  *(_QWORD *)this = &off_24C052D98;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::~__hash_table((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_24C052D98;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::~__hash_table((uint64_t)this + 8);
  JUMPOUT(0x20BD002F8);
}

void plist::PListReal::~PListReal(void **this)
{
  *this = off_24C052DC0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24C052DC0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BD002F8);
}

void plist::PListType::PListFromCF(void const*)::$_0::__invoke(const __CFString *a1, plist::PListType *a2, uint64_t a3)
{
  const void *v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  unsigned __int8 *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  void *__p[2];
  uint64_t v21;
  void **v22;

  __p[0] = 0;
  __p[1] = 0;
  v21 = 0;
  ZinGetString(a1, (uint64_t)__p);
  plist::PListType::PListFromCF(&v18, a2, v5);
  v6 = (_QWORD *)(a3 + 8);
  if (!std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>(v6, (uint64_t)__p))
  {
    v22 = __p;
    v10 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v6, (uint64_t)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v22);
    v12 = v18;
    v11 = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    v15 = (std::__shared_weak_count *)*((_QWORD *)v10 + 6);
    *((_QWORD *)v10 + 5) = v12;
    *((_QWORD *)v10 + 6) = v11;
    if (v15)
    {
      v16 = (unint64_t *)&v15->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  v7 = v19;
  if (!v19)
    goto LABEL_6;
  v8 = (unint64_t *)&v19->__shared_owners_;
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 - 1, v8));
  if (v9)
  {
LABEL_6:
    if ((SHIBYTE(v21) & 0x80000000) == 0)
      return;
    goto LABEL_7;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if (SHIBYTE(v21) < 0)
LABEL_7:
    operator delete(__p[0]);
}

void plist::PListType::PListFromCF(void const*)::$_1::__invoke(plist::PListType *a1, _QWORD *a2)
{
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _OWORD *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v10;

  plist::PListType::PListFromCF((uint64_t *)&v10, a1, a2);
  v3 = (_QWORD *)a2[2];
  if ((unint64_t)v3 >= a2[3])
  {
    v7 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>((uint64_t)(a2 + 1), &v10);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
    a2[2] = v7;
    if (!v4)
      return;
    goto LABEL_8;
  }
  *v3 = v10;
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
  v3[1] = *((_QWORD *)&v10 + 1);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  a2[2] = v3 + 2;
  if (v4)
  {
LABEL_8:
    v8 = (unint64_t *)&v4->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::~__hash_table(uint64_t a1)
{
  char *v2;
  void *v3;
  char *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      v5 = *(char **)v2;
      v6 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          v8 = __ldaxr(p_shared_owners);
        while (__stlxr(v8 - 1, p_shared_owners));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      if (v2[39] < 0)
        operator delete(*((void **)v2 + 2));
      operator delete(v2);
      v2 = v5;
    }
    while (v5);
  }
  v3 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v3)
    operator delete(v3);
  return a1;
}

_QWORD *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const std::locale::facet *v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x20BCFFEFC](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = a2 + a3;
    if ((*(_DWORD *)(v6 + 8) & 0xB0) == 0x20)
      v9 = v8;
    else
      v9 = a2;
    v10 = *(_DWORD *)(v6 + 144);
    if (v10 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v11 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v10;
    }
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v9, v8, v6, (char)v10))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x20BCFFF08](v13);
  return a1;
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  size_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *__b[2];
  int64_t v22;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      if (v12 >= 0x17)
      {
        v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17)
          v14 = v12 | 7;
        v15 = v14 + 1;
        v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        v22 = v15 | 0x8000000000000000;
        __b[0] = v13;
      }
      else
      {
        HIBYTE(v22) = v12;
        v13 = __b;
      }
      memset(v13, __c, v12);
      *((_BYTE *)v13 + v12) = 0;
      if (v22 >= 0)
        v16 = __b;
      else
        v16 = (void **)__b[0];
      v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(_QWORD *)v6 + 96))(v6, v16, v12);
      v18 = v17;
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12)
          return 0;
      }
      else if (v17 != v12)
      {
        return 0;
      }
    }
    v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v19) == v19)
    {
      *(_QWORD *)(a5 + 24) = 0;
      return v6;
    }
    return 0;
  }
  return v6;
}

void std::__shared_ptr_emplace<plist::PListBool>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C8E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<plist::PListBool>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C8E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_emplace<plist::PListBool>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<plist::PListReal>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C918;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<plist::PListReal>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C918;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_emplace<plist::PListReal>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<plist::PListInt>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C8A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<plist::PListInt>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C8A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_emplace<plist::PListInt>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_pointer<plist::PListDict *,std::shared_ptr<plist::PListDict>::__shared_ptr_default_delete<plist::PListDict,plist::PListDict>,std::allocator<plist::PListDict>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<plist::PListDict *,std::shared_ptr<plist::PListDict>::__shared_ptr_default_delete<plist::PListDict,plist::PListDict>,std::allocator<plist::PListDict>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<plist::PListArray *,std::shared_ptr<plist::PListArray>::__shared_ptr_default_delete<plist::PListArray,plist::PListArray>,std::allocator<plist::PListArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<plist::PListArray *,std::shared_ptr<plist::PListArray>::__shared_ptr_default_delete<plist::PListArray,plist::PListArray>,std::allocator<plist::PListArray>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void mlir::anec::getANECCanonicalizeQuantPatterns(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  _QWORD *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  _QWORD *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  uint64_t *v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  char *v115;
  _QWORD *v116;
  char *v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  uint64_t *v123;
  char *v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  char *v129;
  char *v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  uint64_t v134;
  char *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  char *v149;
  _QWORD *v150;
  char *v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  unint64_t v155;
  char *v156;
  uint64_t *v157;
  char *v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  char *v162;
  char *v163;
  char *v164;
  uint64_t v165;
  __int128 v166;
  __int128 v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  char *v183;
  _QWORD *v184;
  char *v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  unint64_t v189;
  char *v190;
  uint64_t *v191;
  char *v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  char *v196;
  char *v197;
  char *v198;
  uint64_t v199;
  __int128 v200;
  __int128 v201;
  uint64_t v202;
  char *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  unint64_t v208;
  unint64_t v209;
  uint64_t v210;
  unint64_t v211;
  uint64_t v212;
  uint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  char *v217;
  _QWORD *v218;
  char *v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t v222;
  unint64_t v223;
  char *v224;
  uint64_t *v225;
  char *v226;
  unint64_t v227;
  uint64_t v228;
  uint64_t v229;
  char *v230;
  char *v231;
  char *v232;
  uint64_t v233;
  __int128 v234;
  __int128 v235;
  uint64_t v236;
  char *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  unint64_t v245;
  uint64_t v246;
  uint64_t v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  char *v251;
  _QWORD *v252;
  char *v253;
  uint64_t v254;
  unint64_t v255;
  uint64_t v256;
  unint64_t v257;
  char *v258;
  uint64_t *v259;
  char *v260;
  unint64_t v261;
  uint64_t v262;
  uint64_t v263;
  char *v264;
  char *v265;
  char *v266;
  uint64_t v267;
  __int128 v268;
  __int128 v269;
  uint64_t v270;
  char *v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t v278;
  unint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  char *v285;
  _QWORD *v286;
  char *v287;
  uint64_t v288;
  unint64_t v289;
  uint64_t v290;
  unint64_t v291;
  char *v292;
  uint64_t *v293;
  char *v294;
  unint64_t v295;
  uint64_t v296;
  uint64_t v297;
  char *v298;
  char *v299;
  char *v300;
  uint64_t v301;
  __int128 v302;
  __int128 v303;
  uint64_t v304;
  char *v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  unint64_t v310;
  unint64_t v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  uint64_t v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  char *v319;
  _QWORD *v320;
  char *v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  unint64_t v325;
  char *v326;
  uint64_t *v327;
  char *v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  char *v332;
  char *v333;
  char *v334;
  uint64_t v335;
  __int128 v336;
  __int128 v337;
  uint64_t v338;
  char *v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  unint64_t v344;
  unint64_t v345;
  uint64_t v346;
  unint64_t v347;
  uint64_t v348;
  uint64_t v349;
  unint64_t v350;
  unint64_t v351;
  unint64_t v352;
  char *v353;
  _QWORD *v354;
  char *v355;
  uint64_t v356;
  unint64_t v357;
  uint64_t v358;
  unint64_t v359;
  char *v360;
  uint64_t *v361;
  char *v362;
  unint64_t v363;
  uint64_t v364;
  uint64_t v365;
  char *v366;
  char *v367;
  char *v368;
  uint64_t v369;
  __int128 v370;
  __int128 v371;
  uint64_t v372;
  char *v373;
  uint64_t v374;
  uint64_t v375;
  __int16 v376;
  __int128 v377;
  __int128 v378;
  uint64_t v379;

  v379 = *MEMORY[0x24BDAC8D0];
  v2 = *a1;
  v3 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v377, 4);
  mlir::Pattern::Pattern(v3 + 8, (uint64_t)"anec.gain_offset_control", 24, v377, v2, 0, 0);
  *(_QWORD *)v3 = &off_24C050E70;
  if (!*(_QWORD *)(v3 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_AddGocs]";
    *((_QWORD *)&v377 + 1) = 97;
    v4 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v4)
      v5 = v4;
    else
      v5 = *((_QWORD *)&v377 + 1);
    v6 = v377 + v5;
    v7 = *((_QWORD *)&v377 + 1) - v5;
    if (*((_QWORD *)&v377 + 1) - v5 >= 0x12)
      v8 = 18;
    else
      v8 = *((_QWORD *)&v377 + 1) - v5;
    v9 = v6 + v8;
    v10 = v7 - v8;
    if (v10 >= v10 - 1)
      --v10;
    *(_QWORD *)(v3 + 64) = v9;
    *(_QWORD *)(v3 + 72) = v10;
  }
  v11 = *(unsigned int *)(v3 + 88);
  if (v11 > *(_DWORD *)(v3 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 80, (void *)(v3 + 96), v11, 16);
    LODWORD(v11) = *(_DWORD *)(v3 + 88);
  }
  *(_DWORD *)(v3 + 88) = v11;
  v13 = (char *)a1[2];
  v12 = a1[3];
  if ((unint64_t)v13 >= v12)
  {
    v15 = (char *)a1[1];
    v16 = (v13 - v15) >> 3;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      goto LABEL_431;
    v18 = v12 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        goto LABEL_432;
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = (uint64_t *)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v3;
    v14 = v21 + 1;
    if (v13 == v15)
    {
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
    }
    else
    {
      v23 = v13 - v15 - 8;
      if (v23 < 0x78
        || &v13[-(v23 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v21
        && &v20[v13 - v15 - (v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v13)
      {
        goto LABEL_435;
      }
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v26 = &v13[-v25];
      v21 = (uint64_t *)((char *)v21 - v25);
      v27 = &v20[8 * v16 - 16];
      v28 = v13 - 16;
      v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v31 = *((_OWORD *)v28 - 1);
        v30 = *(_OWORD *)v28;
        *((_OWORD *)v28 - 1) = 0uLL;
        *(_OWORD *)v28 = 0uLL;
        *((_OWORD *)v27 - 1) = v31;
        *(_OWORD *)v27 = v30;
        v27 -= 32;
        v28 -= 32;
        v29 -= 4;
      }
      while (v29);
      v13 = v26;
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_435:
        do
        {
          v32 = *((_QWORD *)v13 - 1);
          v13 -= 8;
          *(_QWORD *)v13 = 0;
          *--v21 = v32;
        }
        while (v13 != v15);
      }
      v13 = (char *)a1[1];
      v33 = (char *)a1[2];
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
      while (v33 != v13)
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        v34 = v35;
        *(_QWORD *)v33 = 0;
        if (v35)
          (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
      }
    }
    if (v13)
      operator delete(v13);
  }
  else
  {
    *(_QWORD *)v13 = v3;
    v14 = v13 + 8;
  }
  a1[2] = (uint64_t)v14;
  v36 = *a1;
  v37 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 12);
  v377 = xmmword_24C0607E0;
  v378 = *(_OWORD *)&off_24C0607F0;
  mlir::Pattern::Pattern(v37 + 8, (uint64_t)"anec.convolution", 16, v376, v36, &v377, 2uLL);
  *(_QWORD *)v37 = &off_24C051238;
  if (!*(_QWORD *)(v37 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_ConvFilterGOC]";
    *((_QWORD *)&v377 + 1) = 103;
    v38 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v38)
      v39 = v38;
    else
      v39 = *((_QWORD *)&v377 + 1);
    v40 = v377 + v39;
    v41 = *((_QWORD *)&v377 + 1) - v39;
    if (*((_QWORD *)&v377 + 1) - v39 >= 0x12)
      v42 = 18;
    else
      v42 = *((_QWORD *)&v377 + 1) - v39;
    v43 = v40 + v42;
    v44 = v41 - v42;
    if (v44 >= v44 - 1)
      --v44;
    *(_QWORD *)(v37 + 64) = v43;
    *(_QWORD *)(v37 + 72) = v44;
  }
  v45 = *(unsigned int *)(v37 + 88);
  if (v45 > *(_DWORD *)(v37 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v37 + 80, (void *)(v37 + 96), v45, 16);
    LODWORD(v45) = *(_DWORD *)(v37 + 88);
  }
  *(_DWORD *)(v37 + 88) = v45;
  v47 = (char *)a1[2];
  v46 = a1[3];
  if ((unint64_t)v47 >= v46)
  {
    v49 = (char *)a1[1];
    v50 = (v47 - v49) >> 3;
    v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61)
      goto LABEL_431;
    v52 = v46 - (_QWORD)v49;
    if (v52 >> 2 > v51)
      v51 = v52 >> 2;
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8)
      v53 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v53 = v51;
    if (v53)
    {
      if (v53 >> 61)
        goto LABEL_432;
      v54 = (char *)operator new(8 * v53);
    }
    else
    {
      v54 = 0;
    }
    v55 = (uint64_t *)&v54[8 * v50];
    v56 = &v54[8 * v53];
    *v55 = v37;
    v48 = v55 + 1;
    if (v47 == v49)
    {
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
    }
    else
    {
      v57 = v47 - v49 - 8;
      if (v57 < 0x78
        || &v47[-(v57 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v55
        && &v54[v47 - v49 - (v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v47)
      {
        goto LABEL_436;
      }
      v58 = (v57 >> 3) + 1;
      v59 = 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      v60 = &v47[-v59];
      v55 = (uint64_t *)((char *)v55 - v59);
      v61 = &v54[8 * v50 - 16];
      v62 = v47 - 16;
      v63 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v65 = *((_OWORD *)v62 - 1);
        v64 = *(_OWORD *)v62;
        *((_OWORD *)v62 - 1) = 0uLL;
        *(_OWORD *)v62 = 0uLL;
        *((_OWORD *)v61 - 1) = v65;
        *(_OWORD *)v61 = v64;
        v61 -= 32;
        v62 -= 32;
        v63 -= 4;
      }
      while (v63);
      v47 = v60;
      if (v58 != (v58 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_436:
        do
        {
          v66 = *((_QWORD *)v47 - 1);
          v47 -= 8;
          *(_QWORD *)v47 = 0;
          *--v55 = v66;
        }
        while (v47 != v49);
      }
      v47 = (char *)a1[1];
      v67 = (char *)a1[2];
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
      while (v67 != v47)
      {
        v69 = *((_QWORD *)v67 - 1);
        v67 -= 8;
        v68 = v69;
        *(_QWORD *)v67 = 0;
        if (v69)
          (*(void (**)(uint64_t))(*(_QWORD *)v68 + 8))(v68);
      }
    }
    if (v47)
      operator delete(v47);
  }
  else
  {
    *(_QWORD *)v47 = v37;
    v48 = v47 + 8;
  }
  a1[2] = (uint64_t)v48;
  v70 = *a1;
  v71 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 12);
  v377 = xmmword_24C0607E0;
  v378 = *(_OWORD *)&off_24C0607F0;
  mlir::Pattern::Pattern(v71 + 8, (uint64_t)"anec.convolution", 16, v376, v70, &v377, 2uLL);
  *(_QWORD *)v71 = &off_24C051310;
  if (!*(_QWORD *)(v71 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_ConvFilterMult]";
    *((_QWORD *)&v377 + 1) = 104;
    v72 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v72)
      v73 = v72;
    else
      v73 = *((_QWORD *)&v377 + 1);
    v74 = v377 + v73;
    v75 = *((_QWORD *)&v377 + 1) - v73;
    if (*((_QWORD *)&v377 + 1) - v73 >= 0x12)
      v76 = 18;
    else
      v76 = *((_QWORD *)&v377 + 1) - v73;
    v77 = v74 + v76;
    v78 = v75 - v76;
    if (v78 >= v78 - 1)
      --v78;
    *(_QWORD *)(v71 + 64) = v77;
    *(_QWORD *)(v71 + 72) = v78;
  }
  v79 = *(unsigned int *)(v71 + 88);
  if (v79 > *(_DWORD *)(v71 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v71 + 80, (void *)(v71 + 96), v79, 16);
    LODWORD(v79) = *(_DWORD *)(v71 + 88);
  }
  *(_DWORD *)(v71 + 88) = v79;
  v81 = (char *)a1[2];
  v80 = a1[3];
  if ((unint64_t)v81 >= v80)
  {
    v83 = (char *)a1[1];
    v84 = (v81 - v83) >> 3;
    v85 = v84 + 1;
    if ((unint64_t)(v84 + 1) >> 61)
      goto LABEL_431;
    v86 = v80 - (_QWORD)v83;
    if (v86 >> 2 > v85)
      v85 = v86 >> 2;
    if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8)
      v87 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v87 = v85;
    if (v87)
    {
      if (v87 >> 61)
        goto LABEL_432;
      v88 = (char *)operator new(8 * v87);
    }
    else
    {
      v88 = 0;
    }
    v89 = (uint64_t *)&v88[8 * v84];
    v90 = &v88[8 * v87];
    *v89 = v71;
    v82 = v89 + 1;
    if (v81 == v83)
    {
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
    }
    else
    {
      v91 = v81 - v83 - 8;
      if (v91 < 0x78
        || &v81[-(v91 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v89
        && &v88[v81 - v83 - (v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v81)
      {
        goto LABEL_437;
      }
      v92 = (v91 >> 3) + 1;
      v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
      v94 = &v81[-v93];
      v89 = (uint64_t *)((char *)v89 - v93);
      v95 = &v88[8 * v84 - 16];
      v96 = v81 - 16;
      v97 = v92 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v99 = *((_OWORD *)v96 - 1);
        v98 = *(_OWORD *)v96;
        *((_OWORD *)v96 - 1) = 0uLL;
        *(_OWORD *)v96 = 0uLL;
        *((_OWORD *)v95 - 1) = v99;
        *(_OWORD *)v95 = v98;
        v95 -= 32;
        v96 -= 32;
        v97 -= 4;
      }
      while (v97);
      v81 = v94;
      if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_437:
        do
        {
          v100 = *((_QWORD *)v81 - 1);
          v81 -= 8;
          *(_QWORD *)v81 = 0;
          *--v89 = v100;
        }
        while (v81 != v83);
      }
      v81 = (char *)a1[1];
      v101 = (char *)a1[2];
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
      while (v101 != v81)
      {
        v103 = *((_QWORD *)v101 - 1);
        v101 -= 8;
        v102 = v103;
        *(_QWORD *)v101 = 0;
        if (v103)
          (*(void (**)(uint64_t))(*(_QWORD *)v102 + 8))(v102);
      }
    }
    if (v81)
      operator delete(v81);
  }
  else
  {
    *(_QWORD *)v81 = v71;
    v82 = v81 + 8;
  }
  a1[2] = (uint64_t)v82;
  v104 = *a1;
  v105 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 12);
  v377 = xmmword_24C0607E0;
  v378 = *(_OWORD *)&off_24C0607F0;
  mlir::Pattern::Pattern(v105 + 8, (uint64_t)"anec.convolution", 16, v376, v104, &v377, 2uLL);
  *(_QWORD *)v105 = &off_24C050FC8;
  if (!*(_QWORD *)(v105 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_ConvInputGOC]";
    *((_QWORD *)&v377 + 1) = 102;
    v106 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v106)
      v107 = v106;
    else
      v107 = *((_QWORD *)&v377 + 1);
    v108 = v377 + v107;
    v109 = *((_QWORD *)&v377 + 1) - v107;
    if (*((_QWORD *)&v377 + 1) - v107 >= 0x12)
      v110 = 18;
    else
      v110 = *((_QWORD *)&v377 + 1) - v107;
    v111 = v108 + v110;
    v112 = v109 - v110;
    if (v112 >= v112 - 1)
      --v112;
    *(_QWORD *)(v105 + 64) = v111;
    *(_QWORD *)(v105 + 72) = v112;
  }
  v113 = *(unsigned int *)(v105 + 88);
  if (v113 > *(_DWORD *)(v105 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v105 + 80, (void *)(v105 + 96), v113, 16);
    LODWORD(v113) = *(_DWORD *)(v105 + 88);
  }
  *(_DWORD *)(v105 + 88) = v113;
  v115 = (char *)a1[2];
  v114 = a1[3];
  if ((unint64_t)v115 >= v114)
  {
    v117 = (char *)a1[1];
    v118 = (v115 - v117) >> 3;
    v119 = v118 + 1;
    if ((unint64_t)(v118 + 1) >> 61)
      goto LABEL_431;
    v120 = v114 - (_QWORD)v117;
    if (v120 >> 2 > v119)
      v119 = v120 >> 2;
    if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF8)
      v121 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v121 = v119;
    if (v121)
    {
      if (v121 >> 61)
        goto LABEL_432;
      v122 = (char *)operator new(8 * v121);
    }
    else
    {
      v122 = 0;
    }
    v123 = (uint64_t *)&v122[8 * v118];
    v124 = &v122[8 * v121];
    *v123 = v105;
    v116 = v123 + 1;
    if (v115 == v117)
    {
      a1[1] = (uint64_t)v123;
      a1[2] = (uint64_t)v116;
      a1[3] = (uint64_t)v124;
    }
    else
    {
      v125 = v115 - v117 - 8;
      if (v125 < 0x78
        || &v115[-(v125 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v123
        && &v122[v115 - v117 - (v125 & 0xFFFFFFFFFFFFFFF8) - 8] < v115)
      {
        goto LABEL_438;
      }
      v126 = (v125 >> 3) + 1;
      v127 = 8 * (v126 & 0x3FFFFFFFFFFFFFFCLL);
      v128 = &v115[-v127];
      v123 = (uint64_t *)((char *)v123 - v127);
      v129 = &v122[8 * v118 - 16];
      v130 = v115 - 16;
      v131 = v126 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v133 = *((_OWORD *)v130 - 1);
        v132 = *(_OWORD *)v130;
        *((_OWORD *)v130 - 1) = 0uLL;
        *(_OWORD *)v130 = 0uLL;
        *((_OWORD *)v129 - 1) = v133;
        *(_OWORD *)v129 = v132;
        v129 -= 32;
        v130 -= 32;
        v131 -= 4;
      }
      while (v131);
      v115 = v128;
      if (v126 != (v126 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_438:
        do
        {
          v134 = *((_QWORD *)v115 - 1);
          v115 -= 8;
          *(_QWORD *)v115 = 0;
          *--v123 = v134;
        }
        while (v115 != v117);
      }
      v115 = (char *)a1[1];
      v135 = (char *)a1[2];
      a1[1] = (uint64_t)v123;
      a1[2] = (uint64_t)v116;
      a1[3] = (uint64_t)v124;
      while (v135 != v115)
      {
        v137 = *((_QWORD *)v135 - 1);
        v135 -= 8;
        v136 = v137;
        *(_QWORD *)v135 = 0;
        if (v137)
          (*(void (**)(uint64_t))(*(_QWORD *)v136 + 8))(v136);
      }
    }
    if (v115)
      operator delete(v115);
  }
  else
  {
    *(_QWORD *)v115 = v105;
    v116 = v115 + 8;
  }
  a1[2] = (uint64_t)v116;
  v138 = *a1;
  v139 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 12);
  v377 = xmmword_24C060800;
  v378 = *(_OWORD *)&off_24C060810;
  mlir::Pattern::Pattern(v139 + 8, (uint64_t)"anec.deconvolution", 18, v376, v138, &v377, 2uLL);
  *(_QWORD *)v139 = &off_24C051390;
  if (!*(_QWORD *)(v139 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_DeconvFilterGOC]";
    *((_QWORD *)&v377 + 1) = 105;
    v140 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v140)
      v141 = v140;
    else
      v141 = *((_QWORD *)&v377 + 1);
    v142 = v377 + v141;
    v143 = *((_QWORD *)&v377 + 1) - v141;
    if (*((_QWORD *)&v377 + 1) - v141 >= 0x12)
      v144 = 18;
    else
      v144 = *((_QWORD *)&v377 + 1) - v141;
    v145 = v142 + v144;
    v146 = v143 - v144;
    if (v146 >= v146 - 1)
      --v146;
    *(_QWORD *)(v139 + 64) = v145;
    *(_QWORD *)(v139 + 72) = v146;
  }
  v147 = *(unsigned int *)(v139 + 88);
  if (v147 > *(_DWORD *)(v139 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v139 + 80, (void *)(v139 + 96), v147, 16);
    LODWORD(v147) = *(_DWORD *)(v139 + 88);
  }
  *(_DWORD *)(v139 + 88) = v147;
  v149 = (char *)a1[2];
  v148 = a1[3];
  if ((unint64_t)v149 >= v148)
  {
    v151 = (char *)a1[1];
    v152 = (v149 - v151) >> 3;
    v153 = v152 + 1;
    if ((unint64_t)(v152 + 1) >> 61)
      goto LABEL_431;
    v154 = v148 - (_QWORD)v151;
    if (v154 >> 2 > v153)
      v153 = v154 >> 2;
    if ((unint64_t)v154 >= 0x7FFFFFFFFFFFFFF8)
      v155 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v155 = v153;
    if (v155)
    {
      if (v155 >> 61)
        goto LABEL_432;
      v156 = (char *)operator new(8 * v155);
    }
    else
    {
      v156 = 0;
    }
    v157 = (uint64_t *)&v156[8 * v152];
    v158 = &v156[8 * v155];
    *v157 = v139;
    v150 = v157 + 1;
    if (v149 == v151)
    {
      a1[1] = (uint64_t)v157;
      a1[2] = (uint64_t)v150;
      a1[3] = (uint64_t)v158;
    }
    else
    {
      v159 = v149 - v151 - 8;
      if (v159 < 0x78
        || &v149[-(v159 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v157
        && &v156[v149 - v151 - (v159 & 0xFFFFFFFFFFFFFFF8) - 8] < v149)
      {
        goto LABEL_439;
      }
      v160 = (v159 >> 3) + 1;
      v161 = 8 * (v160 & 0x3FFFFFFFFFFFFFFCLL);
      v162 = &v149[-v161];
      v157 = (uint64_t *)((char *)v157 - v161);
      v163 = &v156[8 * v152 - 16];
      v164 = v149 - 16;
      v165 = v160 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v167 = *((_OWORD *)v164 - 1);
        v166 = *(_OWORD *)v164;
        *((_OWORD *)v164 - 1) = 0uLL;
        *(_OWORD *)v164 = 0uLL;
        *((_OWORD *)v163 - 1) = v167;
        *(_OWORD *)v163 = v166;
        v163 -= 32;
        v164 -= 32;
        v165 -= 4;
      }
      while (v165);
      v149 = v162;
      if (v160 != (v160 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_439:
        do
        {
          v168 = *((_QWORD *)v149 - 1);
          v149 -= 8;
          *(_QWORD *)v149 = 0;
          *--v157 = v168;
        }
        while (v149 != v151);
      }
      v149 = (char *)a1[1];
      v169 = (char *)a1[2];
      a1[1] = (uint64_t)v157;
      a1[2] = (uint64_t)v150;
      a1[3] = (uint64_t)v158;
      while (v169 != v149)
      {
        v171 = *((_QWORD *)v169 - 1);
        v169 -= 8;
        v170 = v171;
        *(_QWORD *)v169 = 0;
        if (v171)
          (*(void (**)(uint64_t))(*(_QWORD *)v170 + 8))(v170);
      }
    }
    if (v149)
      operator delete(v149);
  }
  else
  {
    *(_QWORD *)v149 = v139;
    v150 = v149 + 8;
  }
  a1[2] = (uint64_t)v150;
  v172 = *a1;
  v173 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 12);
  v377 = xmmword_24C060800;
  v378 = *(_OWORD *)&off_24C060810;
  mlir::Pattern::Pattern(v173 + 8, (uint64_t)"anec.deconvolution", 18, v376, v172, &v377, 2uLL);
  *(_QWORD *)v173 = &off_24C0513D0;
  if (!*(_QWORD *)(v173 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_DeconvFilterMult]";
    *((_QWORD *)&v377 + 1) = 106;
    v174 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v174)
      v175 = v174;
    else
      v175 = *((_QWORD *)&v377 + 1);
    v176 = v377 + v175;
    v177 = *((_QWORD *)&v377 + 1) - v175;
    if (*((_QWORD *)&v377 + 1) - v175 >= 0x12)
      v178 = 18;
    else
      v178 = *((_QWORD *)&v377 + 1) - v175;
    v179 = v176 + v178;
    v180 = v177 - v178;
    if (v180 >= v180 - 1)
      --v180;
    *(_QWORD *)(v173 + 64) = v179;
    *(_QWORD *)(v173 + 72) = v180;
  }
  v181 = *(unsigned int *)(v173 + 88);
  if (v181 > *(_DWORD *)(v173 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v173 + 80, (void *)(v173 + 96), v181, 16);
    LODWORD(v181) = *(_DWORD *)(v173 + 88);
  }
  *(_DWORD *)(v173 + 88) = v181;
  v183 = (char *)a1[2];
  v182 = a1[3];
  if ((unint64_t)v183 >= v182)
  {
    v185 = (char *)a1[1];
    v186 = (v183 - v185) >> 3;
    v187 = v186 + 1;
    if ((unint64_t)(v186 + 1) >> 61)
      goto LABEL_431;
    v188 = v182 - (_QWORD)v185;
    if (v188 >> 2 > v187)
      v187 = v188 >> 2;
    if ((unint64_t)v188 >= 0x7FFFFFFFFFFFFFF8)
      v189 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v189 = v187;
    if (v189)
    {
      if (v189 >> 61)
        goto LABEL_432;
      v190 = (char *)operator new(8 * v189);
    }
    else
    {
      v190 = 0;
    }
    v191 = (uint64_t *)&v190[8 * v186];
    v192 = &v190[8 * v189];
    *v191 = v173;
    v184 = v191 + 1;
    if (v183 == v185)
    {
      a1[1] = (uint64_t)v191;
      a1[2] = (uint64_t)v184;
      a1[3] = (uint64_t)v192;
    }
    else
    {
      v193 = v183 - v185 - 8;
      if (v193 < 0x78
        || &v183[-(v193 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v191
        && &v190[v183 - v185 - (v193 & 0xFFFFFFFFFFFFFFF8) - 8] < v183)
      {
        goto LABEL_440;
      }
      v194 = (v193 >> 3) + 1;
      v195 = 8 * (v194 & 0x3FFFFFFFFFFFFFFCLL);
      v196 = &v183[-v195];
      v191 = (uint64_t *)((char *)v191 - v195);
      v197 = &v190[8 * v186 - 16];
      v198 = v183 - 16;
      v199 = v194 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v201 = *((_OWORD *)v198 - 1);
        v200 = *(_OWORD *)v198;
        *((_OWORD *)v198 - 1) = 0uLL;
        *(_OWORD *)v198 = 0uLL;
        *((_OWORD *)v197 - 1) = v201;
        *(_OWORD *)v197 = v200;
        v197 -= 32;
        v198 -= 32;
        v199 -= 4;
      }
      while (v199);
      v183 = v196;
      if (v194 != (v194 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_440:
        do
        {
          v202 = *((_QWORD *)v183 - 1);
          v183 -= 8;
          *(_QWORD *)v183 = 0;
          *--v191 = v202;
        }
        while (v183 != v185);
      }
      v183 = (char *)a1[1];
      v203 = (char *)a1[2];
      a1[1] = (uint64_t)v191;
      a1[2] = (uint64_t)v184;
      a1[3] = (uint64_t)v192;
      while (v203 != v183)
      {
        v205 = *((_QWORD *)v203 - 1);
        v203 -= 8;
        v204 = v205;
        *(_QWORD *)v203 = 0;
        if (v205)
          (*(void (**)(uint64_t))(*(_QWORD *)v204 + 8))(v204);
      }
    }
    if (v183)
      operator delete(v183);
  }
  else
  {
    *(_QWORD *)v183 = v173;
    v184 = v183 + 8;
  }
  a1[2] = (uint64_t)v184;
  v206 = *a1;
  v207 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 12);
  v377 = xmmword_24C060800;
  v378 = *(_OWORD *)&off_24C060810;
  mlir::Pattern::Pattern(v207 + 8, (uint64_t)"anec.deconvolution", 18, v376, v206, &v377, 2uLL);
  *(_QWORD *)v207 = &off_24C051350;
  if (!*(_QWORD *)(v207 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_DeconvInputGOC]";
    *((_QWORD *)&v377 + 1) = 104;
    v208 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v208)
      v209 = v208;
    else
      v209 = *((_QWORD *)&v377 + 1);
    v210 = v377 + v209;
    v211 = *((_QWORD *)&v377 + 1) - v209;
    if (*((_QWORD *)&v377 + 1) - v209 >= 0x12)
      v212 = 18;
    else
      v212 = *((_QWORD *)&v377 + 1) - v209;
    v213 = v210 + v212;
    v214 = v211 - v212;
    if (v214 >= v214 - 1)
      --v214;
    *(_QWORD *)(v207 + 64) = v213;
    *(_QWORD *)(v207 + 72) = v214;
  }
  v215 = *(unsigned int *)(v207 + 88);
  if (v215 > *(_DWORD *)(v207 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v207 + 80, (void *)(v207 + 96), v215, 16);
    LODWORD(v215) = *(_DWORD *)(v207 + 88);
  }
  *(_DWORD *)(v207 + 88) = v215;
  v217 = (char *)a1[2];
  v216 = a1[3];
  if ((unint64_t)v217 >= v216)
  {
    v219 = (char *)a1[1];
    v220 = (v217 - v219) >> 3;
    v221 = v220 + 1;
    if ((unint64_t)(v220 + 1) >> 61)
      goto LABEL_431;
    v222 = v216 - (_QWORD)v219;
    if (v222 >> 2 > v221)
      v221 = v222 >> 2;
    if ((unint64_t)v222 >= 0x7FFFFFFFFFFFFFF8)
      v223 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v223 = v221;
    if (v223)
    {
      if (v223 >> 61)
        goto LABEL_432;
      v224 = (char *)operator new(8 * v223);
    }
    else
    {
      v224 = 0;
    }
    v225 = (uint64_t *)&v224[8 * v220];
    v226 = &v224[8 * v223];
    *v225 = v207;
    v218 = v225 + 1;
    if (v217 == v219)
    {
      a1[1] = (uint64_t)v225;
      a1[2] = (uint64_t)v218;
      a1[3] = (uint64_t)v226;
    }
    else
    {
      v227 = v217 - v219 - 8;
      if (v227 < 0x78
        || &v217[-(v227 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v225
        && &v224[v217 - v219 - (v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v217)
      {
        goto LABEL_441;
      }
      v228 = (v227 >> 3) + 1;
      v229 = 8 * (v228 & 0x3FFFFFFFFFFFFFFCLL);
      v230 = &v217[-v229];
      v225 = (uint64_t *)((char *)v225 - v229);
      v231 = &v224[8 * v220 - 16];
      v232 = v217 - 16;
      v233 = v228 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v235 = *((_OWORD *)v232 - 1);
        v234 = *(_OWORD *)v232;
        *((_OWORD *)v232 - 1) = 0uLL;
        *(_OWORD *)v232 = 0uLL;
        *((_OWORD *)v231 - 1) = v235;
        *(_OWORD *)v231 = v234;
        v231 -= 32;
        v232 -= 32;
        v233 -= 4;
      }
      while (v233);
      v217 = v230;
      if (v228 != (v228 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_441:
        do
        {
          v236 = *((_QWORD *)v217 - 1);
          v217 -= 8;
          *(_QWORD *)v217 = 0;
          *--v225 = v236;
        }
        while (v217 != v219);
      }
      v217 = (char *)a1[1];
      v237 = (char *)a1[2];
      a1[1] = (uint64_t)v225;
      a1[2] = (uint64_t)v218;
      a1[3] = (uint64_t)v226;
      while (v237 != v217)
      {
        v239 = *((_QWORD *)v237 - 1);
        v237 -= 8;
        v238 = v239;
        *(_QWORD *)v237 = 0;
        if (v239)
          (*(void (**)(uint64_t))(*(_QWORD *)v238 + 8))(v238);
      }
    }
    if (v217)
      operator delete(v217);
  }
  else
  {
    *(_QWORD *)v217 = v207;
    v218 = v217 + 8;
  }
  a1[2] = (uint64_t)v218;
  v240 = *a1;
  v241 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v377, 3);
  mlir::Pattern::Pattern(v241 + 8, (uint64_t)"anec.mult", 9, v377, v240, 0, 0);
  *(_QWORD *)v241 = &off_24C050DF0;
  if (!*(_QWORD *)(v241 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_GOCDiv]";
    *((_QWORD *)&v377 + 1) = 96;
    v242 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v242)
      v243 = v242;
    else
      v243 = *((_QWORD *)&v377 + 1);
    v244 = v377 + v243;
    v245 = *((_QWORD *)&v377 + 1) - v243;
    if (*((_QWORD *)&v377 + 1) - v243 >= 0x12)
      v246 = 18;
    else
      v246 = *((_QWORD *)&v377 + 1) - v243;
    v247 = v244 + v246;
    v248 = v245 - v246;
    if (v248 >= v248 - 1)
      --v248;
    *(_QWORD *)(v241 + 64) = v247;
    *(_QWORD *)(v241 + 72) = v248;
  }
  v249 = *(unsigned int *)(v241 + 88);
  if (v249 > *(_DWORD *)(v241 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v241 + 80, (void *)(v241 + 96), v249, 16);
    LODWORD(v249) = *(_DWORD *)(v241 + 88);
  }
  *(_DWORD *)(v241 + 88) = v249;
  v251 = (char *)a1[2];
  v250 = a1[3];
  if ((unint64_t)v251 >= v250)
  {
    v253 = (char *)a1[1];
    v254 = (v251 - v253) >> 3;
    v255 = v254 + 1;
    if ((unint64_t)(v254 + 1) >> 61)
      goto LABEL_431;
    v256 = v250 - (_QWORD)v253;
    if (v256 >> 2 > v255)
      v255 = v256 >> 2;
    if ((unint64_t)v256 >= 0x7FFFFFFFFFFFFFF8)
      v257 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v257 = v255;
    if (v257)
    {
      if (v257 >> 61)
        goto LABEL_432;
      v258 = (char *)operator new(8 * v257);
    }
    else
    {
      v258 = 0;
    }
    v259 = (uint64_t *)&v258[8 * v254];
    v260 = &v258[8 * v257];
    *v259 = v241;
    v252 = v259 + 1;
    if (v251 == v253)
    {
      a1[1] = (uint64_t)v259;
      a1[2] = (uint64_t)v252;
      a1[3] = (uint64_t)v260;
    }
    else
    {
      v261 = v251 - v253 - 8;
      if (v261 < 0x78
        || &v251[-(v261 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v259
        && &v258[v251 - v253 - (v261 & 0xFFFFFFFFFFFFFFF8) - 8] < v251)
      {
        goto LABEL_442;
      }
      v262 = (v261 >> 3) + 1;
      v263 = 8 * (v262 & 0x3FFFFFFFFFFFFFFCLL);
      v264 = &v251[-v263];
      v259 = (uint64_t *)((char *)v259 - v263);
      v265 = &v258[8 * v254 - 16];
      v266 = v251 - 16;
      v267 = v262 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v269 = *((_OWORD *)v266 - 1);
        v268 = *(_OWORD *)v266;
        *((_OWORD *)v266 - 1) = 0uLL;
        *(_OWORD *)v266 = 0uLL;
        *((_OWORD *)v265 - 1) = v269;
        *(_OWORD *)v265 = v268;
        v265 -= 32;
        v266 -= 32;
        v267 -= 4;
      }
      while (v267);
      v251 = v264;
      if (v262 != (v262 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_442:
        do
        {
          v270 = *((_QWORD *)v251 - 1);
          v251 -= 8;
          *(_QWORD *)v251 = 0;
          *--v259 = v270;
        }
        while (v251 != v253);
      }
      v251 = (char *)a1[1];
      v271 = (char *)a1[2];
      a1[1] = (uint64_t)v259;
      a1[2] = (uint64_t)v252;
      a1[3] = (uint64_t)v260;
      while (v271 != v251)
      {
        v273 = *((_QWORD *)v271 - 1);
        v271 -= 8;
        v272 = v273;
        *(_QWORD *)v271 = 0;
        if (v273)
          (*(void (**)(uint64_t))(*(_QWORD *)v272 + 8))(v272);
      }
    }
    if (v251)
      operator delete(v251);
  }
  else
  {
    *(_QWORD *)v251 = v241;
    v252 = v251 + 8;
  }
  a1[2] = (uint64_t)v252;
  v274 = *a1;
  v275 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v377, 2);
  mlir::Pattern::Pattern(v275 + 8, (uint64_t)"anec.gain_offset_control", 24, v377, v274, 0, 0);
  *(_QWORD *)v275 = &off_24C050E30;
  if (!*(_QWORD *)(v275 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_GOCGOC]";
    *((_QWORD *)&v377 + 1) = 96;
    v276 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v276)
      v277 = v276;
    else
      v277 = *((_QWORD *)&v377 + 1);
    v278 = v377 + v277;
    v279 = *((_QWORD *)&v377 + 1) - v277;
    if (*((_QWORD *)&v377 + 1) - v277 >= 0x12)
      v280 = 18;
    else
      v280 = *((_QWORD *)&v377 + 1) - v277;
    v281 = v278 + v280;
    v282 = v279 - v280;
    if (v282 >= v282 - 1)
      --v282;
    *(_QWORD *)(v275 + 64) = v281;
    *(_QWORD *)(v275 + 72) = v282;
  }
  v283 = *(unsigned int *)(v275 + 88);
  if (v283 > *(_DWORD *)(v275 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v275 + 80, (void *)(v275 + 96), v283, 16);
    LODWORD(v283) = *(_DWORD *)(v275 + 88);
  }
  *(_DWORD *)(v275 + 88) = v283;
  v285 = (char *)a1[2];
  v284 = a1[3];
  if ((unint64_t)v285 >= v284)
  {
    v287 = (char *)a1[1];
    v288 = (v285 - v287) >> 3;
    v289 = v288 + 1;
    if ((unint64_t)(v288 + 1) >> 61)
      goto LABEL_431;
    v290 = v284 - (_QWORD)v287;
    if (v290 >> 2 > v289)
      v289 = v290 >> 2;
    if ((unint64_t)v290 >= 0x7FFFFFFFFFFFFFF8)
      v291 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v291 = v289;
    if (v291)
    {
      if (v291 >> 61)
        goto LABEL_432;
      v292 = (char *)operator new(8 * v291);
    }
    else
    {
      v292 = 0;
    }
    v293 = (uint64_t *)&v292[8 * v288];
    v294 = &v292[8 * v291];
    *v293 = v275;
    v286 = v293 + 1;
    if (v285 == v287)
    {
      a1[1] = (uint64_t)v293;
      a1[2] = (uint64_t)v286;
      a1[3] = (uint64_t)v294;
    }
    else
    {
      v295 = v285 - v287 - 8;
      if (v295 < 0x78
        || &v285[-(v295 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v293
        && &v292[v285 - v287 - (v295 & 0xFFFFFFFFFFFFFFF8) - 8] < v285)
      {
        goto LABEL_443;
      }
      v296 = (v295 >> 3) + 1;
      v297 = 8 * (v296 & 0x3FFFFFFFFFFFFFFCLL);
      v298 = &v285[-v297];
      v293 = (uint64_t *)((char *)v293 - v297);
      v299 = &v292[8 * v288 - 16];
      v300 = v285 - 16;
      v301 = v296 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v303 = *((_OWORD *)v300 - 1);
        v302 = *(_OWORD *)v300;
        *((_OWORD *)v300 - 1) = 0uLL;
        *(_OWORD *)v300 = 0uLL;
        *((_OWORD *)v299 - 1) = v303;
        *(_OWORD *)v299 = v302;
        v299 -= 32;
        v300 -= 32;
        v301 -= 4;
      }
      while (v301);
      v285 = v298;
      if (v296 != (v296 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_443:
        do
        {
          v304 = *((_QWORD *)v285 - 1);
          v285 -= 8;
          *(_QWORD *)v285 = 0;
          *--v293 = v304;
        }
        while (v285 != v287);
      }
      v285 = (char *)a1[1];
      v305 = (char *)a1[2];
      a1[1] = (uint64_t)v293;
      a1[2] = (uint64_t)v286;
      a1[3] = (uint64_t)v294;
      while (v305 != v285)
      {
        v307 = *((_QWORD *)v305 - 1);
        v305 -= 8;
        v306 = v307;
        *(_QWORD *)v305 = 0;
        if (v307)
          (*(void (**)(uint64_t))(*(_QWORD *)v306 + 8))(v306);
      }
    }
    if (v285)
      operator delete(v285);
  }
  else
  {
    *(_QWORD *)v285 = v275;
    v286 = v285 + 8;
  }
  a1[2] = (uint64_t)v286;
  v308 = *a1;
  v309 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v376, 2);
  v377 = xmmword_24C060820;
  v378 = *(_OWORD *)&off_24C060830;
  mlir::Pattern::Pattern(v309 + 8, (uint64_t)"anec.gain_offset_control", 24, v376, v308, &v377, 2uLL);
  *(_QWORD *)v309 = &off_24C050EB0;
  if (!*(_QWORD *)(v309 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_GOCRelu]";
    *((_QWORD *)&v377 + 1) = 97;
    v310 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v310)
      v311 = v310;
    else
      v311 = *((_QWORD *)&v377 + 1);
    v312 = v377 + v311;
    v313 = *((_QWORD *)&v377 + 1) - v311;
    if (*((_QWORD *)&v377 + 1) - v311 >= 0x12)
      v314 = 18;
    else
      v314 = *((_QWORD *)&v377 + 1) - v311;
    v315 = v312 + v314;
    v316 = v313 - v314;
    if (v316 >= v316 - 1)
      --v316;
    *(_QWORD *)(v309 + 64) = v315;
    *(_QWORD *)(v309 + 72) = v316;
  }
  v317 = *(unsigned int *)(v309 + 88);
  if (v317 > *(_DWORD *)(v309 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v309 + 80, (void *)(v309 + 96), v317, 16);
    LODWORD(v317) = *(_DWORD *)(v309 + 88);
  }
  *(_DWORD *)(v309 + 88) = v317;
  v319 = (char *)a1[2];
  v318 = a1[3];
  if ((unint64_t)v319 >= v318)
  {
    v321 = (char *)a1[1];
    v322 = (v319 - v321) >> 3;
    v323 = v322 + 1;
    if ((unint64_t)(v322 + 1) >> 61)
      goto LABEL_431;
    v324 = v318 - (_QWORD)v321;
    if (v324 >> 2 > v323)
      v323 = v324 >> 2;
    if ((unint64_t)v324 >= 0x7FFFFFFFFFFFFFF8)
      v325 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v325 = v323;
    if (v325)
    {
      if (v325 >> 61)
        goto LABEL_432;
      v326 = (char *)operator new(8 * v325);
    }
    else
    {
      v326 = 0;
    }
    v327 = (uint64_t *)&v326[8 * v322];
    v328 = &v326[8 * v325];
    *v327 = v309;
    v320 = v327 + 1;
    if (v319 == v321)
    {
      a1[1] = (uint64_t)v327;
      a1[2] = (uint64_t)v320;
      a1[3] = (uint64_t)v328;
    }
    else
    {
      v329 = v319 - v321 - 8;
      if (v329 < 0x78
        || &v319[-(v329 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v327
        && &v326[v319 - v321 - (v329 & 0xFFFFFFFFFFFFFFF8) - 8] < v319)
      {
        goto LABEL_444;
      }
      v330 = (v329 >> 3) + 1;
      v331 = 8 * (v330 & 0x3FFFFFFFFFFFFFFCLL);
      v332 = &v319[-v331];
      v327 = (uint64_t *)((char *)v327 - v331);
      v333 = &v326[8 * v322 - 16];
      v334 = v319 - 16;
      v335 = v330 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v337 = *((_OWORD *)v334 - 1);
        v336 = *(_OWORD *)v334;
        *((_OWORD *)v334 - 1) = 0uLL;
        *(_OWORD *)v334 = 0uLL;
        *((_OWORD *)v333 - 1) = v337;
        *(_OWORD *)v333 = v336;
        v333 -= 32;
        v334 -= 32;
        v335 -= 4;
      }
      while (v335);
      v319 = v332;
      if (v330 != (v330 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_444:
        do
        {
          v338 = *((_QWORD *)v319 - 1);
          v319 -= 8;
          *(_QWORD *)v319 = 0;
          *--v327 = v338;
        }
        while (v319 != v321);
      }
      v319 = (char *)a1[1];
      v339 = (char *)a1[2];
      a1[1] = (uint64_t)v327;
      a1[2] = (uint64_t)v320;
      a1[3] = (uint64_t)v328;
      while (v339 != v319)
      {
        v341 = *((_QWORD *)v339 - 1);
        v339 -= 8;
        v340 = v341;
        *(_QWORD *)v339 = 0;
        if (v341)
          (*(void (**)(uint64_t))(*(_QWORD *)v340 + 8))(v340);
      }
    }
    if (v319)
      operator delete(v319);
  }
  else
  {
    *(_QWORD *)v319 = v309;
    v320 = v319 + 8;
  }
  a1[2] = (uint64_t)v320;
  v342 = *a1;
  v343 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v377, 1);
  mlir::Pattern::Pattern(v343 + 8, (uint64_t)"anec.concat", 11, v377, v342, 0, 0);
  *(_QWORD *)v343 = &off_24C0512B8;
  if (!*(_QWORD *)(v343 + 72))
  {
    *(_QWORD *)&v377 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::CanonicalizeConcat]";
    *((_QWORD *)&v377 + 1) = 103;
    v344 = llvm::StringRef::find((uint64_t *)&v377, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v377 + 1) >= v344)
      v345 = v344;
    else
      v345 = *((_QWORD *)&v377 + 1);
    v346 = v377 + v345;
    v347 = *((_QWORD *)&v377 + 1) - v345;
    if (*((_QWORD *)&v377 + 1) - v345 >= 0x12)
      v348 = 18;
    else
      v348 = *((_QWORD *)&v377 + 1) - v345;
    v349 = v346 + v348;
    v350 = v347 - v348;
    if (v350 >= v350 - 1)
      --v350;
    *(_QWORD *)(v343 + 64) = v349;
    *(_QWORD *)(v343 + 72) = v350;
  }
  v351 = *(unsigned int *)(v343 + 88);
  if (v351 > *(_DWORD *)(v343 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v343 + 80, (void *)(v343 + 96), v351, 16);
    LODWORD(v351) = *(_DWORD *)(v343 + 88);
  }
  *(_DWORD *)(v343 + 88) = v351;
  v353 = (char *)a1[2];
  v352 = a1[3];
  if ((unint64_t)v353 < v352)
  {
    *(_QWORD *)v353 = v343;
    v354 = v353 + 8;
    goto LABEL_430;
  }
  v355 = (char *)a1[1];
  v356 = (v353 - v355) >> 3;
  v357 = v356 + 1;
  if ((unint64_t)(v356 + 1) >> 61)
LABEL_431:
    abort();
  v358 = v352 - (_QWORD)v355;
  if (v358 >> 2 > v357)
    v357 = v358 >> 2;
  if ((unint64_t)v358 >= 0x7FFFFFFFFFFFFFF8)
    v359 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v359 = v357;
  if (!v359)
  {
    v360 = 0;
    goto LABEL_415;
  }
  if (v359 >> 61)
LABEL_432:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v360 = (char *)operator new(8 * v359);
LABEL_415:
  v361 = (uint64_t *)&v360[8 * v356];
  v362 = &v360[8 * v359];
  *v361 = v343;
  v354 = v361 + 1;
  if (v353 == v355)
  {
    a1[1] = (uint64_t)v361;
    a1[2] = (uint64_t)v354;
    a1[3] = (uint64_t)v362;
  }
  else
  {
    v363 = v353 - v355 - 8;
    if (v363 < 0x78
      || &v353[-(v363 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v361
      && &v360[v353 - v355 - (v363 & 0xFFFFFFFFFFFFFFF8) - 8] < v353)
    {
      goto LABEL_445;
    }
    v364 = (v363 >> 3) + 1;
    v365 = 8 * (v364 & 0x3FFFFFFFFFFFFFFCLL);
    v366 = &v353[-v365];
    v361 = (uint64_t *)((char *)v361 - v365);
    v367 = &v360[8 * v356 - 16];
    v368 = v353 - 16;
    v369 = v364 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v371 = *((_OWORD *)v368 - 1);
      v370 = *(_OWORD *)v368;
      *((_OWORD *)v368 - 1) = 0uLL;
      *(_OWORD *)v368 = 0uLL;
      *((_OWORD *)v367 - 1) = v371;
      *(_OWORD *)v367 = v370;
      v367 -= 32;
      v368 -= 32;
      v369 -= 4;
    }
    while (v369);
    v353 = v366;
    if (v364 != (v364 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_445:
      do
      {
        v372 = *((_QWORD *)v353 - 1);
        v353 -= 8;
        *(_QWORD *)v353 = 0;
        *--v361 = v372;
      }
      while (v353 != v355);
    }
    v353 = (char *)a1[1];
    v373 = (char *)a1[2];
    a1[1] = (uint64_t)v361;
    a1[2] = (uint64_t)v354;
    a1[3] = (uint64_t)v362;
    while (v373 != v353)
    {
      v375 = *((_QWORD *)v373 - 1);
      v373 -= 8;
      v374 = v375;
      *(_QWORD *)v373 = 0;
      if (v375)
        (*(void (**)(uint64_t))(*(_QWORD *)v374 + 8))(v374);
    }
  }
  if (v353)
    operator delete(v353);
LABEL_430:
  a1[2] = (uint64_t)v354;
}

void mlir::anec::`anonymous namespace'::ANEC_AddGocs::~ANEC_AddGocs(mlir::anec::_anonymous_namespace_::ANEC_AddGocs *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_AddGocs *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t DefiningOp;
  uint64_t v7;
  void *v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(int, uint64_t);
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **);
  void **v15;
  mlir::Operation *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  BOOL v20;
  void *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t ODSOperands;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  BOOL v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  float *v49;
  float v50;
  BOOL v51;
  BOOL v52;
  uint64_t v53;
  float *v54;
  float v55;
  BOOL v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  float *v69;
  float v70;
  BOOL v71;
  BOOL v72;
  uint64_t v73;
  float *v74;
  float v75;
  BOOL v76;
  BOOL v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  uint64_t v88;
  float *v89;
  float v90;
  BOOL v91;
  BOOL v92;
  uint64_t v93;
  float *v94;
  float v95;
  BOOL v96;
  BOOL v97;
  uint64_t *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t *Shape;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  _QWORD *v115;
  _QWORD *v116;
  unint64_t v117;
  unint64_t *v118;
  _QWORD *v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t (*v129)(int, uint64_t);
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  mlir::Operation *v144;
  uint64_t v145;
  mlir::Operation *v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  uint64_t v150;
  void *v151;
  uint64_t v152;
  _QWORD v153[4];
  void *ArgOperands;
  uint64_t v155;
  _QWORD v156[6];
  _QWORD v157[3];

  v157[1] = *MEMORY[0x24BDAC8D0];
  v147 = 0;
  v148 = 0;
  v145 = 0;
  v151 = v153;
  v153[0] = a2;
  v152 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v144 = v5;
  v146 = v5;
  ArgOperands = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v144, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (!DefiningOp)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_230;
    v16 = v144;
    if (mlir::RewriterBase::Listener::classof(v11))
    {
      v12 = *((_QWORD *)v16 + 3);
      v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64);
      v15 = &ArgOperands;
      goto LABEL_25;
    }
    goto LABEL_229;
  }
  v7 = DefiningOp;
  v8 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v9 = v8 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    v10 = (void *)DefiningOp;
  else
    v10 = 0;
  ArgOperands = v10;
  if (!v9)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_230;
    if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
    {
      v12 = *(_QWORD *)(v7 + 24);
LABEL_12:
      v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64);
      v15 = &v149;
LABEL_25:
      v22 = v14(v11, v12, v13, v15);
LABEL_26:
      v11 = v22;
      goto LABEL_230;
    }
    goto LABEL_229;
  }
  v145 = DefiningOp;
  v149 = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ArgOperands, 0) + 24);
  v17 = mlir::Value::getDefiningOp((mlir::Value *)&v149);
  if (!v17)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_230;
    v23 = ArgOperands;
    if (mlir::RewriterBase::Listener::classof(v11))
    {
      v12 = v23[3];
      goto LABEL_12;
    }
    goto LABEL_229;
  }
  v18 = v17;
  v19 = *(void **)(*(_QWORD *)(v17 + 48) + 16);
  v20 = v19 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id;
  if (v19 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v21 = (void *)v17;
  else
    v21 = 0;
  v149 = v21;
  if (!v20)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_230;
    if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
    {
      v12 = *(_QWORD *)(v18 + 24);
      goto LABEL_24;
    }
LABEL_229:
    v11 = 0;
    goto LABEL_230;
  }
  v148 = v17;
  ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v149, 0);
  v25 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v149, 1u);
  v26 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v149, 2u);
  v27 = v152;
  if (v152 >= HIDWORD(v152))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v153, v152 + 1, 8);
    v27 = v152;
  }
  *((_QWORD *)v151 + v27) = v18;
  LODWORD(v152) = v152 + 1;
  v149 = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ArgOperands, 1u) + 24);
  v28 = mlir::Value::getDefiningOp((mlir::Value *)&v149);
  if (!v28)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_230;
    v33 = ArgOperands;
    if (mlir::RewriterBase::Listener::classof(v11))
    {
      v12 = v33[3];
      goto LABEL_12;
    }
    goto LABEL_229;
  }
  v29 = v28;
  v30 = *(void **)(*(_QWORD *)(v28 + 48) + 16);
  v31 = v30 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id;
  if (v30 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v32 = (void *)v28;
  else
    v32 = 0;
  v149 = v32;
  if (!v31)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_230;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_229;
    v12 = *(_QWORD *)(v29 + 24);
LABEL_24:
    v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64);
    v15 = (void **)v157;
    goto LABEL_25;
  }
  v147 = v28;
  v142 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v149, 0);
  v143 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v149, 1u);
  v34 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v149, 2u);
  v35 = v152;
  if (v152 >= HIDWORD(v152))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v153, v152 + 1, 8);
    v35 = v152;
  }
  *((_QWORD *)v151 + v35) = v29;
  v36 = (v152 + 1);
  LODWORD(v152) = v36;
  if (v36 >= HIDWORD(v152))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v153, v36 + 1, 8);
    LODWORD(v36) = v152;
  }
  *((_QWORD *)v151 + v36) = v7;
  LODWORD(v152) = v152 + 1;
  v37 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v144, 1u);
  v38 = *(_QWORD *)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v144, 2u) + 24);
  v149 = 0;
  v150 = 0;
  v157[0] = v38;
  v39 = mlir::Value::getDefiningOp((mlir::Value *)v157);
  if (!v39)
    goto LABEL_199;
  v40 = v39;
  v41 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v40 + 48) + 32))(*(_QWORD *)(v40 + 48), v41))
    goto LABEL_199;
  v141 = v37;
  ArgOperands = v156;
  v155 = 0x100000000;
  mlir::Operation::fold(v40, 0, 0, (uint64_t)&ArgOperands);
  v42 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
  v44 = v42;
  if (v42)
  {
    v149 = v42;
    v150 = v43;
  }
  if (ArgOperands != v156)
    free(ArgOperands);
  if (!v44)
    goto LABEL_199;
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v149);
  v155 = v45;
  v46 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                 + 136);
  if (v46 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v46 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    ArgOperands = v156;
    v155 = 0xC00000000;
    mlir::getIntValues<float>((uint64_t)v149, v150, (uint64_t)&ArgOperands, 0);
    if ((_DWORD)v155)
    {
      v53 = 4 * v155 - 4;
      v54 = (float *)ArgOperands;
      do
      {
        v55 = *v54++;
        v56 = v55 == 0.0;
        v57 = v55 != 0.0 || v53 == 0;
        v53 -= 4;
      }
      while (!v57);
    }
    else
    {
      v56 = 1;
    }
    if (ArgOperands != v156)
      free(ArgOperands);
    if (!v56)
      goto LABEL_199;
  }
  else
  {
    ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v149);
    v155 = v47;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                      + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      goto LABEL_199;
    ArgOperands = v156;
    v155 = 0xC00000000;
    mlir::getIntValues<float>((uint64_t)v149, v150, (uint64_t)&ArgOperands, 0);
    if ((_DWORD)v155)
    {
      v48 = 4 * v155 - 4;
      v49 = (float *)ArgOperands;
      do
      {
        v50 = *v49++;
        v51 = v50 == 0.0;
        v52 = v50 != 0.0 || v48 == 0;
        v48 -= 4;
      }
      while (!v52);
    }
    else
    {
      v51 = 1;
    }
    if (ArgOperands != v156)
      free(ArgOperands);
    if (!v51)
    {
LABEL_199:
      v127 = *((_QWORD *)a3 + 2);
      if (!v127 || !mlir::RewriterBase::Listener::classof(v127))
        goto LABEL_229;
      v128 = *((_QWORD *)a2 + 3);
LABEL_202:
      v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v127 + 64))(v127, v128, v129, &ArgOperands);
      goto LABEL_26;
    }
  }
  v58 = *(_QWORD *)(v26 + 24);
  v149 = 0;
  v150 = 0;
  v157[0] = v58;
  v59 = mlir::Value::getDefiningOp((mlir::Value *)v157);
  if (!v59)
    goto LABEL_212;
  v60 = v59;
  v61 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v60 + 48) + 32))(*(_QWORD *)(v60 + 48), v61))
    goto LABEL_212;
  ArgOperands = v156;
  v155 = 0x100000000;
  mlir::Operation::fold(v60, 0, 0, (uint64_t)&ArgOperands);
  v62 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
  v64 = v62;
  if (v62)
  {
    v149 = v62;
    v150 = v63;
  }
  if (ArgOperands != v156)
    free(ArgOperands);
  if (!v64)
  {
LABEL_212:
    v127 = *((_QWORD *)a3 + 2);
    if (!v127 || !mlir::RewriterBase::Listener::classof(v127))
      goto LABEL_229;
    v128 = *((_QWORD *)a2 + 3);
    goto LABEL_202;
  }
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v149);
  v155 = v65;
  v66 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                 + 136);
  if (v66 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v66 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    ArgOperands = v156;
    v155 = 0xC00000000;
    mlir::getIntValues<float>((uint64_t)v149, v150, (uint64_t)&ArgOperands, 0);
    if ((_DWORD)v155)
    {
      v73 = 4 * v155 - 4;
      v74 = (float *)ArgOperands;
      do
      {
        v75 = *v74++;
        v76 = v75 == 0.0;
        v77 = v75 != 0.0 || v73 == 0;
        v73 -= 4;
      }
      while (!v77);
    }
    else
    {
      v76 = 1;
    }
    if (ArgOperands != v156)
      free(ArgOperands);
    if (!v76)
      goto LABEL_212;
  }
  else
  {
    ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v149);
    v155 = v67;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                      + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      goto LABEL_212;
    ArgOperands = v156;
    v155 = 0xC00000000;
    mlir::getIntValues<float>((uint64_t)v149, v150, (uint64_t)&ArgOperands, 0);
    if ((_DWORD)v155)
    {
      v68 = 4 * v155 - 4;
      v69 = (float *)ArgOperands;
      do
      {
        v70 = *v69++;
        v71 = v70 == 0.0;
        v72 = v70 != 0.0 || v68 == 0;
        v68 -= 4;
      }
      while (!v72);
    }
    else
    {
      v71 = 1;
    }
    if (ArgOperands != v156)
      free(ArgOperands);
    if (!v71)
      goto LABEL_212;
  }
  v78 = *(_QWORD *)(v34 + 24);
  v149 = 0;
  v150 = 0;
  v157[0] = v78;
  v79 = mlir::Value::getDefiningOp((mlir::Value *)v157);
  if (!v79)
    goto LABEL_226;
  v80 = v79;
  v81 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v80 + 48) + 32))(*(_QWORD *)(v80 + 48), v81))
    goto LABEL_226;
  ArgOperands = v156;
  v155 = 0x100000000;
  mlir::Operation::fold(v80, 0, 0, (uint64_t)&ArgOperands);
  v82 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
  v84 = v82;
  if (v82)
  {
    v149 = v82;
    v150 = v83;
  }
  if (ArgOperands != v156)
    free(ArgOperands);
  if (!v84)
  {
LABEL_226:
    v127 = *((_QWORD *)a3 + 2);
    if (!v127 || !mlir::RewriterBase::Listener::classof(v127))
      goto LABEL_229;
    v128 = *((_QWORD *)a2 + 3);
    goto LABEL_202;
  }
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v149);
  v155 = v85;
  v86 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                 + 136);
  if (v86 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v86 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    ArgOperands = v156;
    v155 = 0xC00000000;
    mlir::getIntValues<float>((uint64_t)v149, v150, (uint64_t)&ArgOperands, 0);
    if ((_DWORD)v155)
    {
      v93 = 4 * v155 - 4;
      v94 = (float *)ArgOperands;
      do
      {
        v95 = *v94++;
        v96 = v95 == 0.0;
        v97 = v95 != 0.0 || v93 == 0;
        v93 -= 4;
      }
      while (!v97);
    }
    else
    {
      v96 = 1;
    }
    if (ArgOperands != v156)
      free(ArgOperands);
    if (!v96)
      goto LABEL_226;
  }
  else
  {
    ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v149);
    v155 = v87;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                      + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      goto LABEL_226;
    ArgOperands = v156;
    v155 = 0xC00000000;
    mlir::getIntValues<float>((uint64_t)v149, v150, (uint64_t)&ArgOperands, 0);
    if ((_DWORD)v155)
    {
      v88 = 4 * v155 - 4;
      v89 = (float *)ArgOperands;
      do
      {
        v90 = *v89++;
        v91 = v90 == 0.0;
        v92 = v90 != 0.0 || v88 == 0;
        v88 -= 4;
      }
      while (!v92);
    }
    else
    {
      v91 = 1;
    }
    if (ArgOperands != v156)
      free(ArgOperands);
    if (!v91)
      goto LABEL_226;
  }
  v98 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v141 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v98)
    goto LABEL_176;
  v99 = *v98;
  v100 = mlir::TypeID::get<mlir::ShapedType>();
  v101 = *(unsigned int *)(v99 + 16);
  if (!(_DWORD)v101)
    goto LABEL_176;
  v102 = *(_QWORD **)(v99 + 8);
  v103 = &v102[2 * v101];
  do
  {
    v104 = v101 >> 1;
    v105 = &v102[2 * (v101 >> 1)];
    v107 = *v105;
    v106 = v105 + 2;
    v101 += ~(v101 >> 1);
    if (v107 < v100)
      v102 = v106;
    else
      v101 = v104;
  }
  while (v101);
  if (v102 != v103 && *v102 == v100)
    v108 = v102[1];
  else
LABEL_176:
    v108 = 0;
  ArgOperands = v98;
  v155 = v108;
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
  if (mlir::ShapedType::getNumElements(Shape, v110) != 1)
  {
    v127 = *((_QWORD *)a3 + 2);
    if (!v127 || !mlir::RewriterBase::Listener::classof(v127))
      goto LABEL_229;
    v128 = *((_QWORD *)a2 + 3);
    goto LABEL_202;
  }
  v111 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v25 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v111)
    goto LABEL_187;
  v112 = *v111;
  v113 = mlir::TypeID::get<mlir::ShapedType>();
  v114 = *(unsigned int *)(v112 + 16);
  if (!(_DWORD)v114)
    goto LABEL_187;
  v115 = *(_QWORD **)(v112 + 8);
  v116 = &v115[2 * v114];
  do
  {
    v117 = v114 >> 1;
    v118 = &v115[2 * (v114 >> 1)];
    v120 = *v118;
    v119 = v118 + 2;
    v114 += ~(v114 >> 1);
    if (v120 < v113)
      v115 = v119;
    else
      v114 = v117;
  }
  while (v114);
  if (v115 != v116 && *v115 == v113)
    v121 = v115[1];
  else
LABEL_187:
    v121 = 0;
  ArgOperands = v111;
  v155 = v121;
  v122 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
  if (mlir::ShapedType::getNumElements(v122, v123) == 1)
  {
    v149 = (void *)(*(_QWORD *)(*(_QWORD *)(v143 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    ArgOperands = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v149);
    v155 = v124;
    v125 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (mlir::ShapedType::getNumElements(v125, v126) == 1)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                     + 8) & 0xFFFFFFFFFFFFFFF8))
                        + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v142 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                          + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        {
          ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v146, 0);
          NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
          if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
                            + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
          {
            v132 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v145, 0);
            v133 = mlir::detail::OpResultImpl::getNextResultAtOffset(v132, 0);
            ArgOperands = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v133 + 8) & 0xFFFFFFFFFFFFFFF8));
            if (mlir::Type::isF16((mlir::Type *)&ArgOperands))
            {
              v134 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v148, 0);
              v135 = mlir::detail::OpResultImpl::getNextResultAtOffset(v134, 0);
              ArgOperands = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v135 + 8) & 0xFFFFFFFFFFFFFFF8));
              if (mlir::Type::isF16((mlir::Type *)&ArgOperands))
              {
                v136 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v147, 0);
                v137 = mlir::detail::OpResultImpl::getNextResultAtOffset(v136, 0);
                ArgOperands = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v137 + 8) & 0xFFFFFFFFFFFFFFF8));
                if (mlir::Type::isF16((mlir::Type *)&ArgOperands))
                {
                  v138 = *(_QWORD *)(*((_QWORD *)v151 + 1) + 24);
                  ArgOperands = *(void **)(*(_QWORD *)v151 + 24);
                  v155 = v138;
                  v139 = *(_QWORD *)(*((_QWORD *)v151 + 3) + 24);
                  v156[0] = *(_QWORD *)(*((_QWORD *)v151 + 2) + 24);
                  v156[1] = v139;
                  mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&ArgOperands, (mlir::MLIRContext *)4, 0);
                }
              }
              else
              {
              }
            }
            else
            {
            }
          }
          else
          {
          }
        }
        else
        {
        }
      }
      else
      {
      }
    }
    else
    {
    }
  }
  else
  {
  }
LABEL_230:
  if (v151 != v153)
    free(v151);
  return v11;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#13}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#14}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#15}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#16}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#17}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#18}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

char *mlir::anec::`anonymous namespace'::canonicalizeAddGocs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Loc;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t *v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  float v36;
  float v37;
  mlir::Float32Type **v38;
  mlir::MLIRContext *v39;
  uint64_t F32Type;
  _QWORD *v41;
  mlir::MLIRContext *v42;
  uint64_t F16Type;
  uint64_t v44;
  uint64_t v45;
  mlir::MLIRContext *v46;
  uint64_t v47;
  uint64_t v48;
  mlir::MLIRContext *v49;
  uint64_t v50;
  uint64_t v51;
  ZinIrHalH13g *v53;
  ZinIrHalH13g *v54;
  ZinIrHalH13g *v55;
  ZinIrHalH13g *v56;
  uint64_t v57;
  float v58;
  float v59;
  uint64_t v60[2];
  uint64_t v61[2];
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  v64 = a3;
  v65 = a2;
  v62 = a6;
  v63 = a4;
  Loc = mlir::Value::getLoc((mlir::Value *)&v65);
  v14 = (uint64_t *)(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_10;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_10;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_10:
    v24 = 0;
  v61[0] = (uint64_t)v14;
  v61[1] = v24;
  v25 = (uint64_t *)(*(_QWORD *)(v65 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v25)
    goto LABEL_20;
  v26 = *v25;
  v27 = mlir::TypeID::get<mlir::ShapedType>();
  v28 = *(unsigned int *)(v26 + 16);
  if (!(_DWORD)v28)
    goto LABEL_20;
  v29 = *(_QWORD **)(v26 + 8);
  v30 = &v29[2 * v28];
  do
  {
    v31 = v28 >> 1;
    v32 = &v29[2 * (v28 >> 1)];
    v34 = *v32;
    v33 = v32 + 2;
    v28 += ~(v28 >> 1);
    if (v34 < v27)
      v29 = v33;
    else
      v28 = v31;
  }
  while (v28);
  if (v29 != v30 && *v29 == v27)
    v35 = v29[1];
  else
LABEL_20:
    v35 = 0;
  v60[0] = (uint64_t)v25;
  v60[1] = v35;
  v36 = COERCE_FLOAT(mlir::matchSplatConstantWithFloatValue<float>(a5));
  v37 = COERCE_FLOAT(mlir::matchSplatConstantWithFloatValue<float>(a7));
  v58 = v36 * v37;
  v59 = COERCE_FLOAT(mlir::matchSplatConstantWithFloatValue<float>(a8)) / v37;
  v66 = xmmword_207AB5500;
  v67 = unk_207AB5510;
  v38 = (mlir::Float32Type **)(a1 + 8);
  F32Type = mlir::Builder::getF32Type(v38, v39);
  v41 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v66, 4, F32Type, 0);
  v66 = xmmword_207AB5500;
  v67 = unk_207AB5510;
  F16Type = mlir::Builder::getF16Type(v38, v42);
  v57 = mlir::MemRefType::get((uint64_t *)&v66, (mlir::AffineMap *)4, F16Type, 0, 0, 0);
  *(_QWORD *)&v66 = mlir::createRawElementsAttr(v41, &v59, (const void *)4);
  *((_QWORD *)&v66 + 1) = v44;
  v56 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)v38, Loc, &v57, (_QWORD **)&v66);
  *(_QWORD *)&v66 = mlir::createRawElementsAttr(v41, &v58, (const void *)4);
  *((_QWORD *)&v66 + 1) = v45;
  v55 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)v38, Loc, &v57, (_QWORD **)&v66);
  v47 = mlir::Builder::getF16Type(v38, v46);
  LOBYTE(v66) = 0;
  LOBYTE(v67) = 0;
  *(_QWORD *)&v66 = mlir::ShapedType::cloneWith(v61, &v66, v47);
  *((_QWORD *)&v66 + 1) = v48;
  v54 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType,mlir::Value &,mlir::mps::ConstantOp &,mlir::Value &>((mlir::OpBuilder *)v38, Loc, (uint64_t *)&v66, &v63, &v56, &v62);
  v50 = mlir::Builder::getF16Type(v38, v49);
  LOBYTE(v66) = 0;
  LOBYTE(v67) = 0;
  *(_QWORD *)&v66 = mlir::ShapedType::cloneWith(v60, &v66, v50);
  *((_QWORD *)&v66 + 1) = v51;
  v53 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ShapedType,mlir::Value &,mlir::anec::GOC &>((mlir::OpBuilder *)v38, Loc, (uint64_t *)&v66, &v64, &v54);
  return (char *)mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::anec::ElementwiseAdd &,mlir::mps::ConstantOp &,mlir::Value &>((mlir::OpBuilder *)v38, Loc, v60, &v53, &v55, &v62)- 16;
}

_QWORD *llvm::SmallVector<mlir::Value,4u>::SmallVector(_QWORD *a1, const void *a2, uint64_t a3)
{
  size_t v6;
  unsigned int v7;

  *a1 = a1 + 2;
  a1[1] = 0x400000000;
  v6 = 8 * a3;
  if ((unint64_t)(8 * a3) >= 0x21)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, (8 * a3) >> 3, 8);
    v7 = *((_DWORD *)a1 + 2);
    if (!a3)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = 0;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + (v6 >> 3);
  return a1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::ElementwiseAdd type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp1");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp2 is not ::mlir::anec::GOC type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp1");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp2 is not ::mlir::anec::GOC type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'scale' failed to satisfy constraint: 'has only one element'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_scale' failed to satisfy constraint: 'has only one element'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_scale' failed to satisfy constraint: 'has only one element'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#13}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs' failed to satisfy constraint: 'is constant >= 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#14}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs' failed to satisfy constraint: 'is constant >= 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#15}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is constant >= 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#16}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'add' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#17}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_goc' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_AddGocs::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#18}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_goc' failed to satisfy constraint: 'is FP16 value'");
}

unint64_t mlir::matchSplatConstantWithFloatValue<float>(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t SplatFloat;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  void *v14[2];
  _QWORD v15[2];

  v15[1] = *MEMORY[0x24BDAC8D0];
  v13 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (!DefiningOp)
    goto LABEL_10;
  v2 = DefiningOp;
  v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3))
    goto LABEL_10;
  v14[0] = v15;
  v14[1] = (void *)0x100000000;
  mlir::Operation::fold(v2, 0, 0, (uint64_t)v14);
  v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v14[0] & 0xFFFFFFFFFFFFFFF8));
  v6 = v5 ? v4 : 0;
  if (v14[0] != v15)
    free(v14[0]);
  if (v5)
  {
    SplatFloat = mlir::getSplatFloatValue<float>((uint64_t)v5, v6);
    v8 = SplatFloat & 0xFFFFFF0000000000;
    v9 = SplatFloat & 0xFF00000000;
    v10 = SplatFloat & 0xFFFFFF00;
    v11 = SplatFloat;
  }
  else
  {
LABEL_10:
    v8 = 0;
    v9 = 0;
    v11 = 0;
    v10 = 0;
  }
  return v9 | v8 | v11 | v10;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType,mlir::Value &,mlir::mps::ConstantOp &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.gain_offset_control";
    v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4, *a5 - 16, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ShapedType,mlir::Value &,mlir::anec::GOC &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.add";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::ElementwiseAdd::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5 - 16);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::anec::ElementwiseAdd &,mlir::mps::ConstantOp &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.gain_offset_control";
    v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4 - 16, *a5 - 16, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::~ANEC_ConvFilterGOC(mlir::anec::_anonymous_namespace_::ANEC_ConvFilterGOC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_ConvFilterGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  mlir::Operation *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  void *v9;
  uint64_t ODSOperands;
  uint64_t v11;
  int v12;
  uint64_t InherentAttr;
  char v14;
  uint64_t v15;
  uint64_t v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t IntegerAttr;
  char v29;
  uint64_t IntegerType;
  uint64_t v31;
  char v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(int, uint64_t);
  uint64_t v40;
  char v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  mlir::detail::OpResultImpl *v50;
  mlir::Operation *Owner;
  uint64_t v52;
  _QWORD *v53;
  void *v55;
  mlir::Operation *v56;
  uint64_t v57;
  void *v58;
  mlir::Operation *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67[10];
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD v71[6];

  v71[4] = *MEMORY[0x24BDAC8D0];
  v65 = 0;
  v66 = 0;
  v63 = 0;
  v64 = 0;
  v61 = 0;
  v62 = 0;
  v60 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
    v5 = *((_QWORD *)a2 + 9);
  else
    v5 = 0;
  v57 = 0;
  v58 = 0;
  v69 = v71;
  v71[0] = a2;
  v70 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v56 = v6;
  v59 = v6;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v56, 0);
  v67[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v56, 1u) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v67);
  if (!DefiningOp)
  {
    v16 = *((_QWORD *)a3 + 2);
    if (!v16)
      goto LABEL_95;
    v17 = v56;
    if (mlir::RewriterBase::Listener::classof(v16))
    {
LABEL_72:
      v16 = v18;
      goto LABEL_95;
    }
    goto LABEL_94;
  }
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v67[0] = v9;
  if (v9)
  {
    v58 = v9;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v67, 0);
    v5 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v67, 1u);
    v11 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v67, 2u);
  }
  else
  {
    v40 = *((_QWORD *)a3 + 2);
    if (!v40)
      goto LABEL_94;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_94;
    v11 = v5;
    ODSOperands = v5;
    if (!v41)
      goto LABEL_94;
  }
  v12 = v70;
  if (v70 >= HIDWORD(v70))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 8);
    v12 = v70;
  }
  v69[v12] = v8;
  LODWORD(v70) = v70 + 1;
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), v14))
  {
    v15 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_58;
  }
  else
  {
    v15 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
    if (!v15)
    {
LABEL_58:
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
LABEL_71:
        v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v37 + 64))(v37, v38, v39, v67);
        goto LABEL_72;
      }
      goto LABEL_94;
    }
  }
  if ((mlir::DenseIntElementsAttr::classof(v15) & 1) == 0)
    goto LABEL_58;
  v57 = v15;
  if (!*((_BYTE *)a2 + 47) || (v19 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v20))
    v19 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  v21 = v19;
  if (v19 && (mlir::DenseIntElementsAttr::classof(v19) & 1) != 0)
  {
    v60 = v21;
    if (!*((_BYTE *)a2 + 47) || (v22 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v23))
      v22 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
    v24 = v22;
    if (v22 && (mlir::DenseIntElementsAttr::classof(v22) & 1) != 0)
    {
      v63 = v24;
      if (!*((_BYTE *)a2 + 47)
        || (v25 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v26))
      {
        v25 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
      }
      v27 = v25;
      if (!v25 || (mlir::anec::PaddingModeAttr::classof(v25) & 1) == 0)
        v27 = mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
      v61 = v27;
      if (!*((_BYTE *)a2 + 47)
        || (IntegerAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v29))
      {
        IntegerAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
      }
      if (!IntegerAttr
        || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
        IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
      }
      v62 = IntegerAttr;
      if (!*((_BYTE *)a2 + 47)
        || (v31 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v32))
      {
        v31 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
      }
      if (!v31 || *(_UNKNOWN **)(*(_QWORD *)v31 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v31 = 0;
      v64 = v31;
      if (!*((_BYTE *)a2 + 47)
        || (v33 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v34))
      {
        v33 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
      }
      v35 = v33;
      if (v33)
      {
        if (mlir::DenseFPElementsAttr::classof(v33))
          v36 = v35;
        else
          v36 = 0;
      }
      else
      {
        v36 = 0;
      }
      v65 = v36;
      if (!*((_BYTE *)a2 + 47)
        || (v42 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v43))
      {
        v42 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
      }
      v44 = v42;
      if (v42 && !mlir::DenseIntElementsAttr::classof(v42))
        v44 = 0;
      v66 = v44;
      ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v59, 0);
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
      v67[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)v67))
      {
        v67[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
        if (mlir::Type::isF16((mlir::Type *)v67)
          && (v47 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0),
              v48 = mlir::detail::OpResultImpl::getNextResultAtOffset(v47, 0),
              *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8))
                           + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
        {
        }
        else
        {
          v49 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v59, 0);
          v50 = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getNextResultAtOffset(v49, 0);
          Owner = (mlir::Operation *)mlir::detail::OpResultImpl::getOwner(v50);
          {
            {
              if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                             + 8) & 0xFFFFFFFFFFFFFFF8))
                                + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
              {
LABEL_89:
                if (v36)
                {
                }
                else
                {
                  if (!v44)
                  {
                    v55 = *(void **)(v69[1] + 24);
                    v67[0] = *(void **)(*v69 + 24);
                    v67[1] = v55;
                    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v67, (mlir::MLIRContext *)2, 0);
                  }
                }
              }
              else
              {
                v52 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v59, 0);
                v53 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v52, 0);
                while (1)
                {
                  v53 = (_QWORD *)*v53;
                  if (!v53)
                    break;
                  if (*(_UNKNOWN **)(*(_QWORD *)(v53[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
                    goto LABEL_89;
                }
              }
            }
            else
            {
            }
          }
          else
          {
          }
        }
        goto LABEL_72;
      }
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
    else
    {
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
  }
  else
  {
    v37 = *((_QWORD *)a3 + 2);
    if (v37 && mlir::RewriterBase::Listener::classof(v37))
    {
      v38 = *((_QWORD *)a2 + 3);
      goto LABEL_71;
    }
  }
LABEL_94:
  v16 = 0;
LABEL_95:
  if (v69 != v71)
    free(v69);
  return v16;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::anec::`anonymous namespace'::isKernelScaleGOCCompatible(mlir::Operation *a1, _QWORD *a2)
{
  void *v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t *v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t NumElements;
  uint64_t v32;
  uint64_t v33;
  mlir::Operation *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t *v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  unint64_t v54;
  unint64_t *v55;
  _QWORD *v56;
  unint64_t v57;
  uint64_t v58;
  mlir::Operation *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  _QWORD *v63;
  _QWORD *v64;
  unint64_t v65;
  unint64_t *v66;
  _QWORD *v67;
  unint64_t v68;
  mlir::Operation *v69;
  uint64_t *Shape;
  uint64_t v71;
  unsigned int Groups;
  _BOOL8 v73;
  uint64_t v74;
  mlir::Operation *v75[2];
  _QWORD *v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  mlir::Operation *v80;

  v3 = *(void **)(*((_QWORD *)a1 + 6) + 16);
  if (!a1 || v3 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
  {
    if (v3 == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
      v34 = a1;
    else
      v34 = 0;
    v80 = v34;
    v78 = a2;
    result = mlir::Value::getDefiningOp((mlir::Value *)&v78);
    if (!result)
      return result;
    v35 = result;
    v36 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v35 + 48) + 32))(*(_QWORD *)(v35 + 48), v36);
    if (!(_DWORD)result)
      return result;
    v37 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v80) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v37)
      goto LABEL_45;
    v38 = *v37;
    v39 = mlir::TypeID::get<mlir::ShapedType>();
    v40 = *(unsigned int *)(v38 + 16);
    if (!(_DWORD)v40)
      goto LABEL_45;
    v41 = *(_QWORD **)(v38 + 8);
    v42 = &v41[2 * v40];
    do
    {
      v43 = v40 >> 1;
      v44 = &v41[2 * (v40 >> 1)];
      v46 = *v44;
      v45 = v44 + 2;
      v40 += ~(v40 >> 1);
      if (v46 < v39)
        v41 = v45;
      else
        v40 = v43;
    }
    while (v40);
    if (v41 != v42 && *v41 == v39)
      v47 = v41[1];
    else
LABEL_45:
      v47 = 0;
    v78 = v37;
    v79 = v47;
    v48 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v80) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v48)
      goto LABEL_55;
    v49 = *v48;
    v50 = mlir::TypeID::get<mlir::ShapedType>();
    v51 = *(unsigned int *)(v49 + 16);
    if (!(_DWORD)v51)
      goto LABEL_55;
    v52 = *(_QWORD **)(v49 + 8);
    v53 = &v52[2 * v51];
    do
    {
      v54 = v51 >> 1;
      v55 = &v52[2 * (v51 >> 1)];
      v57 = *v55;
      v56 = v55 + 2;
      v51 += ~(v51 >> 1);
      if (v57 < v50)
        v52 = v56;
      else
        v51 = v54;
    }
    while (v51);
    if (v52 != v53 && *v52 == v50)
      v58 = v52[1];
    else
LABEL_55:
      v58 = 0;
    v76 = v48;
    v77 = v58;
    v59 = (mlir::Operation *)(a2[1] & 0xFFFFFFFFFFFFFFF8);
    if (!v59)
      goto LABEL_65;
    v60 = *(_QWORD *)v59;
    v61 = mlir::TypeID::get<mlir::ShapedType>();
    v62 = *(unsigned int *)(v60 + 16);
    if (!(_DWORD)v62)
      goto LABEL_65;
    v63 = *(_QWORD **)(v60 + 8);
    v64 = &v63[2 * v62];
    do
    {
      v65 = v62 >> 1;
      v66 = &v63[2 * (v62 >> 1)];
      v68 = *v66;
      v67 = v66 + 2;
      v62 += ~(v62 >> 1);
      if (v68 < v61)
        v63 = v67;
      else
        v62 = v65;
    }
    while (v62);
    if (v63 != v64 && *v63 == v61)
      v69 = (mlir::Operation *)v63[1];
    else
LABEL_65:
      v69 = 0;
    v75[0] = v59;
    v75[1] = v69;
    Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v75);
    NumElements = mlir::ShapedType::getNumElements(Shape, v71);
    Groups = mlir::anec::Convolution::getGroups(&v80);
    if (*(_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v78) == Groups)
    {
      v73 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)&v78) + 8) != 1;
      if (NumElements != 1)
      {
LABEL_68:
        if (*(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)&v76) + 8) == NumElements)
        {
          mlir::ShapedType::getShape((mlir::ShapedType *)v75);
          if (v74 == 4)
          {
            v33 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)v75) + 8 * v73);
            return v33 == NumElements;
          }
        }
        return 0;
      }
    }
    else
    {
      v73 = 1;
      if (NumElements != 1)
        goto LABEL_68;
    }
    return 1;
  }
  v75[0] = a1;
  v78 = a2;
  result = mlir::Value::getDefiningOp((mlir::Value *)&v78);
  if (result)
  {
    v5 = result;
    v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 48) + 32))(*(_QWORD *)(v5 + 48), v6);
    if ((_DWORD)result)
    {
      if (*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v75) + 8) >= 8uLL)
        mlir::TypeID::get<mlir::ShapedType>();
      v7 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v75) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v7)
        goto LABEL_16;
      v8 = *v7;
      v9 = mlir::TypeID::get<mlir::ShapedType>();
      v10 = *(unsigned int *)(v8 + 16);
      if (!(_DWORD)v10)
        goto LABEL_16;
      v11 = *(_QWORD **)(v8 + 8);
      v12 = &v11[2 * v10];
      do
      {
        v13 = v10 >> 1;
        v14 = &v11[2 * (v10 >> 1)];
        v16 = *v14;
        v15 = v14 + 2;
        v10 += ~(v10 >> 1);
        if (v16 < v9)
          v11 = v15;
        else
          v10 = v13;
      }
      while (v10);
      if (v11 != v12 && *v11 == v9)
        v17 = v11[1];
      else
LABEL_16:
        v17 = 0;
      v78 = v7;
      v79 = v17;
      v18 = (_QWORD *)(a2[1] & 0xFFFFFFFFFFFFFFF8);
      if (!v18)
        goto LABEL_26;
      v19 = *v18;
      v20 = mlir::TypeID::get<mlir::ShapedType>();
      v21 = *(unsigned int *)(v19 + 16);
      if (!(_DWORD)v21)
        goto LABEL_26;
      v22 = *(_QWORD **)(v19 + 8);
      v23 = &v22[2 * v21];
      do
      {
        v24 = v21 >> 1;
        v25 = &v22[2 * (v21 >> 1)];
        v27 = *v25;
        v26 = v25 + 2;
        v21 += ~(v21 >> 1);
        if (v27 < v20)
          v22 = v26;
        else
          v21 = v24;
      }
      while (v21);
      if (v22 != v23 && *v22 == v20)
        v28 = v22[1];
      else
LABEL_26:
        v28 = 0;
      v76 = v18;
      v77 = v28;
      v29 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
      NumElements = mlir::ShapedType::getNumElements(v29, v30);
      mlir::anec::Convolution::getGroups(v75);
      if (NumElements != 1)
      {
        if (*(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)&v78) + 8) == NumElements)
        {
          mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
          if (v32 == 4)
          {
            v33 = *(_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
            return v33 == NumElements;
          }
        }
        return 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

BOOL mlir::anec::`anonymous namespace'::checkConstantPred<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(double)#1}>(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  _BOOL8 v6;
  uint64_t v7;
  void *v8;
  BOOL v17;
  _QWORD *v18;
  uint64_t v19;
  float *v20;
  float v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v25;
  float *v26;
  float v27;
  BOOL v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  void *ArgOperands;
  uint64_t v33;
  _QWORD v34[7];

  v34[6] = *MEMORY[0x24BDAC8D0];
  v29 = 0;
  v30 = 0;
  v31 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31);
  if (!DefiningOp)
    return 0;
  v2 = DefiningOp;
  v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3))
    return 0;
  ArgOperands = v34;
  v33 = 0x100000000;
  mlir::Operation::fold(v2, 0, 0, (uint64_t)&ArgOperands);
  v4 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
  v6 = (_BOOL8)v4;
  if (v4)
  {
    v29 = v4;
    v30 = v5;
  }
  if (ArgOperands != v34)
    free(ArgOperands);
  if (v6)
  {
    ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v29);
    v33 = v7;
    v8 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                  + 136);
    v17 = v8 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
       || v8 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id;
    if (v17
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      ArgOperands = v34;
      v33 = 0xC00000000;
      mlir::getIntValues<float>((uint64_t)v29, v30, (uint64_t)&ArgOperands, 0);
      v18 = ArgOperands;
      if ((_DWORD)v33)
      {
        v19 = 4 * v33 - 4;
        v20 = (float *)ArgOperands;
        do
        {
          v21 = *v20++;
          v6 = v21 == 0.0;
          v22 = v21 != 0.0 || v19 == 0;
          v19 -= 4;
        }
        while (!v22);
        goto LABEL_59;
      }
    }
    else
    {
      ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v29);
      v33 = v23;
      if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                        + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        return 0;
      ArgOperands = v34;
      v33 = 0xC00000000;
      mlir::getIntValues<float>((uint64_t)v29, v30, (uint64_t)&ArgOperands, 0);
      v18 = ArgOperands;
      if ((_DWORD)v33)
      {
        v25 = 4 * v33 - 4;
        v26 = (float *)ArgOperands;
        do
        {
          v27 = *v26++;
          v6 = v27 == 0.0;
          v28 = v27 != 0.0 || v25 == 0;
          v25 -= 4;
        }
        while (!v28);
        goto LABEL_59;
      }
    }
    v6 = 1;
LABEL_59:
    if (v18 != v34)
      free(v18);
  }
  return v6;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::UnitAttr &,mlir::DenseFPElementsAttr &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  uint64_t *Context;
  uint64_t v21;
  char v22;
  ZinIrHalH13g *v23;
  ZinIrHalH13g *v24;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _QWORD v31[40];

  v31[38] = *MEMORY[0x24BDAC8D0];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v22)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"anec.convolution";
    v29[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v21);
  mlir::anec::Convolution::build(a1, (uint64_t)v31, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12);
  v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v23 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v24 = v23;
  else
    v24 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v24;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.gain_offset_control";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t *llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::operator llvm::SmallVector<mlir::Value,4u><llvm::SmallVector<mlir::Value,4u>,void>@<X0>(uint64_t *result@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v4 = *result;
  v3 = result[1];
  *a2 = a2 + 2;
  a2[1] = 0x400000000;
  if (v3 < 5)
  {
    if (!v3)
    {
      v8 = 0;
      goto LABEL_9;
    }
    v5 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a2, a2 + 2, v3, 8);
    v5 = *((unsigned int *)a2 + 2);
  }
  v6 = 0;
  v7 = *a2 + 8 * v5;
  do
  {
    result = (uint64_t *)mlir::detail::OpResultImpl::getNextResultAtOffset(v4, v6);
    *(_QWORD *)(v7 + 8 * v6++) = result;
  }
  while (v3 != v6);
  v8 = *((_DWORD *)a2 + 2);
LABEL_9:
  *((_DWORD *)a2 + 2) = v8 + v3;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::GOC &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::GOC type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, w_out' failed to satisfy constraint: ''");
}

uint64_t mlir::matchPattern<mlir::detail::constant_op_matcher>(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v4 = a1;
  result = mlir::Value::getDefiningOp((mlir::Value *)&v4);
  if (result)
  {
    v2 = result;
    v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out, w_scale' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w_bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'");
}

void mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::~ANEC_ConvFilterMult(mlir::anec::_anonymous_namespace_::ANEC_ConvFilterMult *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_ConvFilterMult *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  mlir::Operation *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  void *v9;
  uint64_t ODSOperands;
  int v11;
  uint64_t InherentAttr;
  char v13;
  uint64_t v14;
  uint64_t v15;
  mlir::Operation *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t IntegerAttr;
  char v28;
  uint64_t IntegerType;
  uint64_t v30;
  char v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(int, uint64_t);
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  mlir::detail::OpResultImpl *v49;
  mlir::Operation *Owner;
  uint64_t v51;
  _QWORD *v52;
  void *v54;
  mlir::Operation *v55;
  uint64_t v56;
  void *v57;
  mlir::Operation *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66[10];
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  _QWORD v70[7];

  v70[4] = *MEMORY[0x24BDAC8D0];
  v64 = 0;
  v65 = 0;
  v62 = 0;
  v63 = 0;
  v60 = 0;
  v61 = 0;
  v59 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
    v5 = *((_QWORD *)a2 + 9);
  else
    v5 = 0;
  v56 = 0;
  v57 = 0;
  v68 = v70;
  v70[0] = a2;
  v69 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  v58 = v6;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v55, 0);
  v66[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v55, 1u) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v66);
  if (!DefiningOp)
  {
    v15 = *((_QWORD *)a3 + 2);
    if (!v15)
      goto LABEL_94;
    v16 = v55;
    if (mlir::RewriterBase::Listener::classof(v15))
    {
LABEL_72:
      v15 = v17;
      goto LABEL_94;
    }
    goto LABEL_93;
  }
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v66[0] = v9;
  if (v9)
  {
    v57 = v9;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v66, 0);
    v5 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v66, 1u);
  }
  else
  {
    v39 = *((_QWORD *)a3 + 2);
    if (!v39)
      goto LABEL_93;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_93;
    ODSOperands = v5;
    if (!v40)
      goto LABEL_93;
  }
  v11 = v69;
  if (v69 >= HIDWORD(v69))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v70, v69 + 1, 8);
    v11 = v69;
  }
  v68[v11] = v8;
  LODWORD(v69) = v69 + 1;
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), v13))
  {
    v14 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_58;
  }
  else
  {
    v14 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
    if (!v14)
    {
LABEL_58:
      v36 = *((_QWORD *)a3 + 2);
      if (v36 && mlir::RewriterBase::Listener::classof(v36))
      {
        v37 = *((_QWORD *)a2 + 3);
LABEL_71:
        v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v36 + 64))(v36, v37, v38, v66);
        goto LABEL_72;
      }
      goto LABEL_93;
    }
  }
  if ((mlir::DenseIntElementsAttr::classof(v14) & 1) == 0)
    goto LABEL_58;
  v56 = v14;
  if (!*((_BYTE *)a2 + 47) || (v18 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v19))
    v18 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  v20 = v18;
  if (v18 && (mlir::DenseIntElementsAttr::classof(v18) & 1) != 0)
  {
    v59 = v20;
    if (!*((_BYTE *)a2 + 47) || (v21 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v22))
      v21 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
    v23 = v21;
    if (v21 && (mlir::DenseIntElementsAttr::classof(v21) & 1) != 0)
    {
      v63 = v23;
      if (!*((_BYTE *)a2 + 47)
        || (v24 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v25))
      {
        v24 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
      }
      v26 = v24;
      if (!v24 || (mlir::anec::PaddingModeAttr::classof(v24) & 1) == 0)
        v26 = mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
      v62 = v26;
      if (!*((_BYTE *)a2 + 47)
        || (IntegerAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v28))
      {
        IntegerAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
      }
      if (!IntegerAttr
        || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
        IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
      }
      v61 = IntegerAttr;
      if (!*((_BYTE *)a2 + 47)
        || (v30 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v31))
      {
        v30 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
      }
      if (!v30 || *(_UNKNOWN **)(*(_QWORD *)v30 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v30 = 0;
      v60 = v30;
      if (!*((_BYTE *)a2 + 47)
        || (v32 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v33))
      {
        v32 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
      }
      v34 = v32;
      if (v32)
      {
        if (mlir::DenseFPElementsAttr::classof(v32))
          v35 = v34;
        else
          v35 = 0;
      }
      else
      {
        v35 = 0;
      }
      v64 = v35;
      if (!*((_BYTE *)a2 + 47)
        || (v41 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v42))
      {
        v41 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
      }
      v43 = v41;
      if (v41 && !mlir::DenseIntElementsAttr::classof(v41))
        v43 = 0;
      v65 = v43;
      ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
      v66[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)v66))
      {
        v66[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
        if (mlir::Type::isF16((mlir::Type *)v66)
          && (v46 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v57, 0),
              v47 = mlir::detail::OpResultImpl::getNextResultAtOffset(v46, 0),
              *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v47 + 8) & 0xFFFFFFFFFFFFFFF8))
                           + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
        {
        }
        else
        {
          v48 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
          v49 = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getNextResultAtOffset(v48, 0);
          Owner = (mlir::Operation *)mlir::detail::OpResultImpl::getOwner(v49);
          {
            if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                           + 8) & 0xFFFFFFFFFFFFFFF8))
                              + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
            {
LABEL_88:
              if (v35)
              {
              }
              else
              {
                if (!v43)
                {
                  v54 = *(void **)(v68[1] + 24);
                  v66[0] = *(void **)(*v68 + 24);
                  v66[1] = v54;
                  mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v66, (mlir::MLIRContext *)2, 0);
                }
              }
            }
            else
            {
              v51 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
              v52 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v51, 0);
              while (1)
              {
                v52 = (_QWORD *)*v52;
                if (!v52)
                  break;
                if (*(_UNKNOWN **)(*(_QWORD *)(v52[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
                  goto LABEL_88;
              }
            }
          }
          else
          {
          }
        }
        goto LABEL_72;
      }
      v36 = *((_QWORD *)a3 + 2);
      if (v36 && mlir::RewriterBase::Listener::classof(v36))
      {
        v37 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
    else
    {
      v36 = *((_QWORD *)a3 + 2);
      if (v36 && mlir::RewriterBase::Listener::classof(v36))
      {
        v37 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
  }
  else
  {
    v36 = *((_QWORD *)a3 + 2);
    if (v36 && mlir::RewriterBase::Listener::classof(v36))
    {
      v37 = *((_QWORD *)a2 + 3);
      goto LABEL_71;
    }
  }
LABEL_93:
  v15 = 0;
LABEL_94:
  if (v68 != v70)
    free(v68);
  return v15;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

char *mlir::anec::`anonymous namespace'::reshapeConstantToGOCScale(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t NumElements;
  mlir::Float16Type **v11;
  uint64_t Loc;
  mlir::MLIRContext *v13;
  uint64_t F16Type;
  uint64_t v15;
  uint64_t OperandRange;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t *v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  int64x2_t v31;
  _QWORD v32[2];
  _QWORD *v33[2];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[2];
  int64x2_t v39;
  uint64_t v40;
  uint64_t v41;
  int64x2_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v36 = 0;
  v37 = a2;
  v35 = 0;
  v38[0] = a2;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v38);
  if (!DefiningOp)
    return 0;
  v4 = DefiningOp;
  v5 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 32))(*(_QWORD *)(v4 + 48), v5))
    return 0;
  v40 = (uint64_t)&v42;
  v41 = 0x100000000;
  mlir::Operation::fold(v4, 0, 0, (uint64_t)&v40);
  v6 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v40 & 0xFFFFFFFFFFFFFFF8));
  v8 = (uint64_t)v6;
  if (v6)
  {
    v9 = v7;
    v35 = v6;
    v36 = v7;
  }
  else
  {
    v9 = 0;
  }
  if ((int64x2_t *)v40 != &v42)
    free((void *)v40);
  if (!v8)
    return 0;
  NumElements = mlir::ElementsAttr::getNumElements(v8, v9);
  v11 = (mlir::Float16Type **)(a1 + 8);
  Loc = mlir::Value::getLoc((mlir::Value *)&v37);
  v40 = 1;
  v41 = NumElements;
  v31 = vdupq_n_s64(1uLL);
  v42 = v31;
  F16Type = mlir::Builder::getF16Type(v11, v13);
  v34 = mlir::MemRefType::get(&v40, (mlir::AffineMap *)4, F16Type, 0, 0, 0);
  v38[0] = 1;
  v38[1] = NumElements;
  v39 = v31;
  v32[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35);
  v32[1] = v15;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v32);
  v17 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v38, 4, OperandRange, 0);
  v18 = (uint64_t)v17;
  if (!v17)
    goto LABEL_18;
  v19 = *v17;
  v20 = mlir::TypeID::get<mlir::ShapedType>();
  v21 = *(unsigned int *)(v19 + 16);
  if (!(_DWORD)v21)
    goto LABEL_18;
  v22 = *(_QWORD **)(v19 + 8);
  v23 = &v22[2 * v21];
  do
  {
    v24 = v21 >> 1;
    v25 = &v22[2 * (v21 >> 1)];
    v27 = *v25;
    v26 = v25 + 2;
    v21 += ~(v21 >> 1);
    if (v27 < v20)
      v22 = v26;
    else
      v21 = v24;
  }
  while (v21);
  if (v22 != v23 && *v22 == v20)
    v28 = v22[1];
  else
LABEL_18:
    v28 = 0;
  v33[0] = mlir::reshapeElementsAttr(v8, v9, v18, v28);
  v33[1] = v29;
  return (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)v11, Loc, &v34, v33)- 16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::ElementwiseMult &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::ElementwiseMult type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, w_out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out, w_scale' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'");
}

void mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::~ANEC_ConvInputGOC(mlir::anec::_anonymous_namespace_::ANEC_ConvInputGOC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_ConvInputGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  mlir::Operation *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  void *v9;
  uint64_t ODSOperands;
  uint64_t v11;
  int v12;
  uint64_t InherentAttr;
  char v14;
  uint64_t v15;
  uint64_t v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t IntegerAttr;
  char v29;
  uint64_t IntegerType;
  uint64_t v31;
  char v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(int, uint64_t);
  uint64_t v40;
  char v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  void *v52;
  mlir::Operation *v53;
  mlir::Operation *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64[10];
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD v68[6];

  v68[4] = *MEMORY[0x24BDAC8D0];
  v62 = 0;
  v63 = 0;
  v60 = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v56 = 0;
  v57 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
    v5 = *((_QWORD *)a2 + 9);
  else
    v5 = 0;
  v55 = 0;
  v66 = v68;
  v68[0] = a2;
  v67 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v53 = v6;
  v54 = v6;
  v64[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v53, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v64);
  if (!DefiningOp)
  {
    v16 = *((_QWORD *)a3 + 2);
    if (!v16)
      goto LABEL_95;
    v17 = v53;
    if (mlir::RewriterBase::Listener::classof(v16))
    {
LABEL_72:
      v16 = v18;
      goto LABEL_95;
    }
    goto LABEL_94;
  }
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v64[0] = v9;
  if (v9)
  {
    v55 = v9;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v64, 0);
    v11 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v64, 1u);
    v5 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v64, 2u);
  }
  else
  {
    v40 = *((_QWORD *)a3 + 2);
    if (!v40)
      goto LABEL_94;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_94;
    ODSOperands = v5;
    v11 = v5;
    if (!v41)
      goto LABEL_94;
  }
  v12 = v67;
  if (v67 >= HIDWORD(v67))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
    v12 = v67;
  }
  v66[v12] = v8;
  LODWORD(v67) = v67 + 1;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v53, 1u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), v14))
  {
    v15 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_58;
  }
  else
  {
    v15 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
    if (!v15)
    {
LABEL_58:
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
LABEL_71:
        v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v37 + 64))(v37, v38, v39, v64);
        goto LABEL_72;
      }
      goto LABEL_94;
    }
  }
  if ((mlir::DenseIntElementsAttr::classof(v15) & 1) == 0)
    goto LABEL_58;
  v56 = v15;
  if (!*((_BYTE *)a2 + 47) || (v19 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v20))
    v19 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  v21 = v19;
  if (v19 && (mlir::DenseIntElementsAttr::classof(v19) & 1) != 0)
  {
    v57 = v21;
    if (!*((_BYTE *)a2 + 47) || (v22 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v23))
      v22 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
    v24 = v22;
    if (v22 && (mlir::DenseIntElementsAttr::classof(v22) & 1) != 0)
    {
      v60 = v24;
      if (!*((_BYTE *)a2 + 47)
        || (v25 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v26))
      {
        v25 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
      }
      v27 = v25;
      if (!v25 || (mlir::anec::PaddingModeAttr::classof(v25) & 1) == 0)
        v27 = mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
      v58 = v27;
      if (!*((_BYTE *)a2 + 47)
        || (IntegerAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v29))
      {
        IntegerAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
      }
      if (!IntegerAttr
        || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
        IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
      }
      v59 = IntegerAttr;
      if (!*((_BYTE *)a2 + 47)
        || (v31 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v32))
      {
        v31 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
      }
      if (!v31 || *(_UNKNOWN **)(*(_QWORD *)v31 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v31 = 0;
      v61 = v31;
      if (!*((_BYTE *)a2 + 47)
        || (v33 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v34))
      {
        v33 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
      }
      v35 = v33;
      if (v33)
      {
        if (mlir::DenseFPElementsAttr::classof(v33))
          v36 = v35;
        else
          v36 = 0;
      }
      else
      {
        v36 = 0;
      }
      v62 = v36;
      if (!*((_BYTE *)a2 + 47)
        || (v42 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v43))
      {
        v42 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
      }
      v44 = v42;
      if (v42 && !mlir::DenseIntElementsAttr::classof(v42))
        v44 = 0;
      v63 = v44;
      ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v54, 0);
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
      v64[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)v64))
      {
        v64[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
        if (mlir::Type::isF16((mlir::Type *)v64)
          && (v47 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v55, 0),
              v48 = mlir::detail::OpResultImpl::getNextResultAtOffset(v47, 0),
              *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8))
                           + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
        {
        }
        {
          {
            if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                           + 8) & 0xFFFFFFFFFFFFFFF8))
                              + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
            {
LABEL_89:
              if (v36)
              {
              }
              else
              {
                if (!v44)
                {
                  v52 = *(void **)(v66[1] + 24);
                  v64[0] = *(void **)(*v66 + 24);
                  v64[1] = v52;
                  mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v64, (mlir::MLIRContext *)2, 0);
                }
              }
            }
            else
            {
              v49 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v54, 0);
              v50 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v49, 0);
              while (1)
              {
                v50 = (_QWORD *)*v50;
                if (!v50)
                  break;
                if (*(_UNKNOWN **)(*(_QWORD *)(v50[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
                  goto LABEL_89;
              }
            }
          }
          else
          {
          }
        }
        else
        {
        }
        goto LABEL_72;
      }
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
    else
    {
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
  }
  else
  {
    v37 = *((_QWORD *)a3 + 2);
    if (v37 && mlir::RewriterBase::Listener::classof(v37))
    {
      v38 = *((_QWORD *)a2 + 3);
      goto LABEL_71;
    }
  }
LABEL_94:
  v16 = 0;
LABEL_95:
  if (v66 != v68)
    free(v66);
  return v16;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::anec::`anonymous namespace'::isSplatConst(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11[2];
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  v8 = 0;
  v9 = 0;
  v10 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  if (!DefiningOp)
    return 0;
  v2 = DefiningOp;
  v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3))
    return 0;
  v11[0] = v12;
  v11[1] = (void *)0x100000000;
  mlir::Operation::fold(v2, 0, 0, (uint64_t)v11);
  v4 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v11[0] & 0xFFFFFFFFFFFFFFF8));
  v6 = v4;
  if (v4)
  {
    v8 = v4;
    v9 = v5;
  }
  if (v11[0] != v12)
    free(v11[0]);
  if (v6)
    return mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v8);
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

char *mlir::anec::`anonymous namespace'::reduceSplatConst(uint64_t a1, char *a2)
{
  char *v2;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *Shape;
  uint64_t v16;
  uint64_t DefiningOp;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t *v25;
  uint64_t OperandRange;
  void *v27;
  uint64_t v28;
  uint64_t canMapOperands;
  uint64_t *v30;
  mlir::OpBuilder *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46[2];
  uint64_t *v47;
  uint64_t v48;
  _QWORD v49[2];
  char *v50;
  void *__b;
  uint64_t v52;
  _QWORD v53[6];

  v2 = a2;
  v53[5] = *MEMORY[0x24BDAC8D0];
  v50 = a2;
  v4 = (uint64_t *)(*((_QWORD *)a2 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v4)
    goto LABEL_10;
  v5 = *v4;
  v6 = mlir::TypeID::get<mlir::ShapedType>();
  v7 = *(unsigned int *)(v5 + 16);
  if (!(_DWORD)v7)
    goto LABEL_10;
  v8 = *(_QWORD **)(v5 + 8);
  v9 = &v8[2 * v7];
  do
  {
    v10 = v7 >> 1;
    v11 = &v8[2 * (v7 >> 1)];
    v13 = *v11;
    v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6)
      v8 = v12;
    else
      v7 = v10;
  }
  while (v7);
  if (v8 != v9 && *v8 == v6)
    v14 = v8[1];
  else
LABEL_10:
    v14 = 0;
  v49[0] = v4;
  v49[1] = v14;
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v49);
  if (mlir::ShapedType::getNumElements(Shape, v16) != 1)
  {
    v47 = 0;
    v48 = 0;
    v46[0] = (uint64_t)v2;
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v46);
    if (DefiningOp)
    {
      v18 = DefiningOp;
      v19 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v18 + 48) + 32))(*(_QWORD *)(v18 + 48), v19))
      {
        __b = v53;
        v52 = 0x100000000;
        mlir::Operation::fold(v18, 0, 0, (uint64_t)&__b);
        v20 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)__b & 0xFFFFFFFFFFFFFFF8));
        if (v20)
        {
          v47 = v20;
          v48 = v21;
        }
        if (__b != v53)
          free(__b);
      }
    }
    v46[0] = mlir::ElementsAttr::getSplatValue<mlir::TypedAttr>((mlir::CallOpInterface *)&v47);
    v46[1] = v22;
    mlir::ShapedType::getShape((mlir::ShapedType *)v49);
    v24 = v23;
    __b = v53;
    HIDWORD(v52) = 5;
    if (v23 < 6)
    {
      if (v23)
        memset_pattern16(v53, &unk_207A80400, 8 * v23);
      v25 = v53;
    }
    else
    {
      LODWORD(v52) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v53, v23, 8);
      v25 = (uint64_t *)__b;
      memset_pattern16(__b, &unk_207A80400, 8 * v24);
    }
    LODWORD(v52) = v24;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v49);
    v45 = mlir::MemRefType::get(v25, (mlir::AffineMap *)v24, OperandRange, 0, 0, 0);
    v27 = __b;
    v28 = v52;
    canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)v46);
    v30 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v27, v28, canMapOperands, 0);
    v31 = (mlir::OpBuilder *)(a1 + 8);
    v32 = *(_QWORD *)(mlir::Value::getDefiningOp((mlir::Value *)&v50) + 24);
    if (!v30)
      goto LABEL_32;
    v33 = *v30;
    v34 = mlir::TypeID::get<mlir::ShapedType>();
    v35 = *(unsigned int *)(v33 + 16);
    if (!(_DWORD)v35)
      goto LABEL_32;
    v36 = *(_QWORD **)(v33 + 8);
    v37 = &v36[2 * v35];
    do
    {
      v38 = v35 >> 1;
      v39 = &v36[2 * (v35 >> 1)];
      v41 = *v39;
      v40 = v39 + 2;
      v35 += ~(v35 >> 1);
      if (v41 < v34)
        v36 = v40;
      else
        v35 = v38;
    }
    while (v35);
    if (v36 != v37 && *v36 == v34)
      v42 = v36[1];
    else
LABEL_32:
      v42 = 0;
    v44 = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v30, v42, v46, 1uLL);
    v2 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>(v31, v32, &v45, &v44)- 16;
    if (__b != v53)
      free(__b);
  }
  return v2;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_2(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::GOC &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::GOC type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.convolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x, x_out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x_scale' failed to satisfy constraint: 'splat constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x_bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_ConvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'");
}

uint64_t mlir::ElementsAttr::getSplatValue<mlir::TypedAttr>(mlir::CallOpInterface *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;
  char v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[8];
  uint64_t v13;
  __int128 v14;
  char v15;
  uint64_t v16;

  mlir::ElementsAttr::getValues<mlir::TypedAttr,void>(a1, (uint64_t)v12);
  v8 = v12[0];
  v9 = v12[1];
  if (v12[0])
    v10 = v13;
  else
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v13 + 16))(&v10);
  v11 = v14;
  if (!v15)
  {
    v1 = v16;
    v16 = 0;
    if (v1)
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  }
  if (!v12[0])
  {
    v2 = v13;
    v13 = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  if (v9)
    v3 = 0;
  else
    v3 = v11;
  if (v8)
    v4 = *(_QWORD *)(v10 + 8 * v3);
  else
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)v10 + 24))();
  v5 = (*((uint64_t (**)(uint64_t))&v11 + 1))(v4);
  if (!v8)
  {
    v6 = v10;
    v10 = 0;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  return v5;
}

uint64_t mlir::ElementsAttr::getValues<mlir::TypedAttr,void>@<X0>(mlir::CallOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t ArgOperands;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  char v11[8];
  uint64_t v12;
  char v13;
  uint64_t v14;
  _BYTE v15[8];
  uint64_t v16;
  __int128 v17;
  unsigned __int8 v18;
  char v19;
  _BYTE v20[24];

  ArgOperands = mlir::CallOpInterface::getArgOperands(a1);
  v6 = v5;
  mlir::ElementsAttr::getValues<mlir::Attribute>((uint64_t *)a1, (uint64_t)v11);
  result = llvm::map_range<mlir::detail::ElementsAttrRange<mlir::detail::ElementsAttrIterator<mlir::Attribute>>,mlir::TypedAttr (*)(mlir::Attribute)>(v11, (uint64_t)_ZZNK4mlir12ElementsAttr9getValuesINS_9TypedAttrEvEENS_6detail17ElementsAttrRangeIN4llvm15mapped_iteratorINS3_20ElementsAttrIteratorINS_9AttributeEEEPFT_S8_EDTclclsr3stdE7declvalISC_EEdeclL_ZNSt3__17declvalB8nn180100IS9_EEDTclsr3stdE9__declvalISA_ELi0EEEvEEEEEEEEvENUlS8_E_8__invokeES8_, (uint64_t)v15);
  v8 = v15[0];
  *(_BYTE *)a2 = v15[0];
  *(_BYTE *)(a2 + 1) = v15[1];
  if (v8)
    *(_QWORD *)(a2 + 8) = v16;
  else
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
  *(_OWORD *)(a2 + 16) = v17;
  v9 = v18;
  *(_BYTE *)(a2 + 32) = v18;
  *(_BYTE *)(a2 + 33) = v19;
  if (v9)
  {
    *(_OWORD *)(a2 + 40) = *(_OWORD *)v20;
    *(_QWORD *)(a2 + 56) = *(_QWORD *)&v20[16];
    *(_QWORD *)(a2 + 64) = ArgOperands;
    *(_QWORD *)(a2 + 72) = v6;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v20 + 16))(*(_QWORD *)v20);
    v10 = v18;
    *(_OWORD *)(a2 + 48) = *(_OWORD *)&v20[8];
    *(_QWORD *)(a2 + 64) = ArgOperands;
    *(_QWORD *)(a2 + 72) = v6;
    if (!v10)
    {
      result = *(_QWORD *)v20;
      *(_QWORD *)v20 = 0;
      if (result)
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  if (!v15[0])
  {
    result = v16;
    v16 = 0;
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  if (!v13)
  {
    result = v14;
    v14 = 0;
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  if (!v11[0])
  {
    result = v12;
    v12 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t llvm::map_range<mlir::detail::ElementsAttrRange<mlir::detail::ElementsAttrIterator<mlir::Attribute>>,mlir::TypedAttr (*)(mlir::Attribute)>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  uint64_t v21;
  uint64_t v22;

  v19 = *a1;
  v6 = a1[1];
  v20 = v6;
  if (v19)
  {
    v7 = *((_QWORD *)a1 + 2);
    v21 = *((_QWORD *)a1 + 1);
    v22 = v7;
    v8 = 1;
    v9 = v21;
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)a1 + 1) + 16))(&v21);
    v6 = v20;
    v7 = *((_QWORD *)a1 + 2);
    v22 = v7;
    v8 = 0;
    v9 = v21;
    v21 = 0;
  }
  v10 = a1[25];
  v16 = v10;
  if (a1[24])
  {
    v11 = *((_QWORD *)a1 + 5);
    v17 = *((_QWORD *)a1 + 4);
    v18 = v11;
    v12 = 0;
    result = v17;
    v14 = 1;
    v15 = v17;
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)a1 + 4) + 16))(&v17);
    v10 = v16;
    v11 = *((_QWORD *)a1 + 5);
    v18 = v11;
    v14 = 0;
    result = 0;
    v15 = v17;
    v17 = 0;
    v12 = 1;
  }
  *(_BYTE *)a3 = v8;
  *(_BYTE *)(a3 + 1) = v6;
  *(_QWORD *)(a3 + 8) = v9;
  *(_QWORD *)(a3 + 16) = v7;
  *(_QWORD *)(a3 + 24) = a2;
  *(_BYTE *)(a3 + 32) = v14;
  *(_BYTE *)(a3 + 33) = v10;
  *(_QWORD *)(a3 + 40) = v15;
  *(_QWORD *)(a3 + 48) = v11;
  *(_QWORD *)(a3 + 56) = a2;
  if (v12)
  {
    v17 = 0;
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  if (!v19)
  {
    result = v21;
    v21 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::ElementsAttr::getValues<mlir::Attribute>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t ArgOperands;
  uint64_t v5;
  uint64_t v6;
  uint64_t NumElements;
  uint64_t result;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12[8];
  uint64_t v13;

  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)a1);
  v6 = v5;
  mlir::ElementsAttr::value_begin<mlir::Attribute>((mlir::BranchOpInterface *)a1, (uint64_t)v12);
  NumElements = mlir::ElementsAttr::getNumElements(*a1, a1[1]);
  v9 = 257;
  v10 = 0;
  v11 = NumElements;
  result = mlir::detail::ElementsAttrRange<mlir::detail::ElementsAttrIterator<mlir::Attribute>>::ElementsAttrRange(a2, ArgOperands, v6, v12, (char *)&v9);
  if (!(_BYTE)v9)
  {
    result = v10;
    v10 = 0;
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  if (!v12[0])
  {
    result = v13;
    v13 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::ElementsAttr::value_begin<mlir::Attribute>@<X0>(mlir::BranchOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  char v8;
  _BYTE v9[8];
  uint64_t v10;
  char v11;

  v4 = mlir::TypeID::get<mlir::Attribute>();
  result = mlir::BranchOpInterface::getSuccessorOperands(a1, v4);
  if (!v11)
    mlir::ElementsAttr::value_begin<mlir::Attribute>((llvm *)v9, (uint64_t *)a1);
  v6 = v9[1];
  if (v9[0])
  {
    v7 = v10;
    v8 = 1;
  }
  else
  {
    v8 = 0;
    v7 = v10;
  }
  *(_BYTE *)a2 = v8;
  *(_BYTE *)(a2 + 1) = v6;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) = 0;
  return result;
}

uint64_t mlir::detail::ElementsAttrRange<mlir::detail::ElementsAttrIterator<mlir::Attribute>>::ElementsAttrRange(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, char *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v19;
  char v20;
  _QWORD v21[2];
  unsigned __int8 v22;
  char v23;
  uint64_t v24;
  uint64_t v25;

  v22 = *a4;
  v23 = a4[1];
  if (v22)
    v24 = *((_QWORD *)a4 + 1);
  else
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)a4 + 1) + 16))(&v24);
  v25 = *((_QWORD *)a4 + 2);
  v19 = *a5;
  v20 = a5[1];
  if (*a5)
    v21[0] = *((_QWORD *)a5 + 1);
  else
    (*(void (**)(_QWORD *__return_ptr))(**((_QWORD **)a5 + 1) + 16))(v21);
  v10 = *((_QWORD *)a5 + 2);
  v21[1] = v10;
  v11 = v22;
  v12 = v24;
  if (!v22)
    v24 = 0;
  v13 = v23;
  v14 = v21[0];
  if (!v19)
    v21[0] = 0;
  v15 = v25;
  *(_BYTE *)a1 = v22;
  *(_BYTE *)(a1 + 1) = v13;
  if (v11)
    *(_QWORD *)(a1 + 8) = v12;
  else
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
  *(_QWORD *)(a1 + 16) = v15;
  *(_BYTE *)(a1 + 24) = v19;
  *(_BYTE *)(a1 + 25) = v20;
  if (v19)
  {
    *(_QWORD *)(a1 + 32) = v14;
    *(_QWORD *)(a1 + 40) = v10;
    *(_QWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 56) = a3;
    if (v11)
      goto LABEL_20;
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 16))(v14);
    *(_QWORD *)(a1 + 40) = v10;
    *(_QWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 56) = a3;
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
    if (v11)
      goto LABEL_20;
  }
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
LABEL_20:
  if (!v19)
  {
    v16 = v21[0];
    v21[0] = 0;
    if (v16)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  }
  if (!v22)
  {
    v17 = v24;
    v24 = 0;
    if (v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  }
  return a1;
}

llvm::raw_ostream *mlir::operator<<(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  mlir::Attribute::print((mlir::Attribute *)&v4, a1, 0);
  return a1;
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *a1, char *__s)
{
  size_t v4;
  void *v5;

  if (__s)
  {
    v4 = strlen(__s);
    v5 = (void *)*((_QWORD *)a1 + 4);
    if (v4 > *((_QWORD *)a1 + 3) - (_QWORD)v5)
      return llvm::raw_ostream::write(a1, __s, v4);
    if (v4)
    {
      memcpy(v5, __s, v4);
      *((_QWORD *)a1 + 4) += v4;
    }
  }
  return a1;
}

llvm::raw_ostream *llvm::raw_ostream::operator<<(llvm::raw_ostream *this, const char *a2, size_t a3)
{
  void *v5;
  uint64_t v6;

  v6 = *((_QWORD *)this + 3);
  v5 = (void *)*((_QWORD *)this + 4);
  if (a3 > v6 - (uint64_t)v5)
    return llvm::raw_ostream::write(this, a2, a3);
  if (a3)
  {
    memcpy(v5, a2, a3);
    *((_QWORD *)this + 4) += a3;
  }
  return this;
}

const char *llvm::getTypeName<mlir::Attribute>()
{
  unint64_t v0;
  unint64_t v1;
  const char *v2;
  uint64_t v3;
  const char *v5;
  unint64_t v6;

  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::Attribute]";
  v6 = 65;
  v0 = llvm::StringRef::find((uint64_t *)&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
    v1 = v0;
  else
    v1 = v6;
  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
    v3 = 18;
  else
    v3 = v6 - v1;
  return &v2[v3];
}

uint64_t mlir::TypeID::get<mlir::Attribute>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::Attribute]";
      v12 = 65;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::Attribute,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[266];
}

uint64_t *_ZZNK4mlir12ElementsAttr9getValuesINS_9TypedAttrEvEENS_6detail17ElementsAttrRangeIN4llvm15mapped_iteratorINS3_20ElementsAttrIteratorINS_9AttributeEEEPFT_S8_EDTclclsr3stdE7declvalISC_EEdeclL_ZNSt3__17declvalB8nn180100IS9_EEDTclsr3stdE9__declvalISA_ELi0EEEvEEEEEEEEvENUlS8_E_8__invokeES8_(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t *v7;
  _QWORD *v8;
  unint64_t v9;

  if (a1)
  {
    v2 = *a1;
    v3 = mlir::TypeID::get<mlir::TypedAttr>();
    v4 = *(unsigned int *)(v2 + 16);
    if ((_DWORD)v4)
    {
      v5 = *(_QWORD **)(v2 + 8);
      do
      {
        v6 = v4 >> 1;
        v7 = &v5[2 * (v4 >> 1)];
        v9 = *v7;
        v8 = v7 + 2;
        v4 += ~(v4 >> 1);
        if (v9 < v3)
          v5 = v8;
        else
          v4 = v6;
      }
      while (v4);
    }
  }
  return a1;
}

uint64_t mlir::TypeID::get<mlir::TypedAttr>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr]";
      v12 = 65;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[268];
}

void mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::~ANEC_DeconvFilterGOC(mlir::anec::_anonymous_namespace_::ANEC_DeconvFilterGOC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_DeconvFilterGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  mlir::Operation *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  void *v9;
  uint64_t ODSOperands;
  uint64_t v11;
  int v12;
  uint64_t InherentAttr;
  char v14;
  uint64_t v15;
  uint64_t v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t IntegerAttr;
  char v29;
  uint64_t IntegerType;
  uint64_t v31;
  char v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(int, uint64_t);
  uint64_t v40;
  char v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  mlir::detail::OpResultImpl *v50;
  mlir::Operation *Owner;
  uint64_t v52;
  _QWORD *v53;
  void *v55;
  mlir::Operation *v56;
  uint64_t v57;
  void *v58;
  mlir::Operation *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67[10];
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD v71[6];

  v71[4] = *MEMORY[0x24BDAC8D0];
  v65 = 0;
  v66 = 0;
  v63 = 0;
  v64 = 0;
  v61 = 0;
  v62 = 0;
  v60 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
    v5 = *((_QWORD *)a2 + 9);
  else
    v5 = 0;
  v57 = 0;
  v58 = 0;
  v69 = v71;
  v71[0] = a2;
  v70 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v56 = v6;
  v59 = v6;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v56, 0);
  v67[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v56, 1u) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v67);
  if (!DefiningOp)
  {
    v16 = *((_QWORD *)a3 + 2);
    if (!v16)
      goto LABEL_95;
    v17 = v56;
    if (mlir::RewriterBase::Listener::classof(v16))
    {
LABEL_72:
      v16 = v18;
      goto LABEL_95;
    }
    goto LABEL_94;
  }
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v67[0] = v9;
  if (v9)
  {
    v58 = v9;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v67, 0);
    v5 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v67, 1u);
    v11 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v67, 2u);
  }
  else
  {
    v40 = *((_QWORD *)a3 + 2);
    if (!v40)
      goto LABEL_94;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_94;
    v11 = v5;
    ODSOperands = v5;
    if (!v41)
      goto LABEL_94;
  }
  v12 = v70;
  if (v70 >= HIDWORD(v70))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 8);
    v12 = v70;
  }
  v69[v12] = v8;
  LODWORD(v70) = v70 + 1;
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), v14))
  {
    v15 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_58;
  }
  else
  {
    v15 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
    if (!v15)
    {
LABEL_58:
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
LABEL_71:
        v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v37 + 64))(v37, v38, v39, v67);
        goto LABEL_72;
      }
      goto LABEL_94;
    }
  }
  if ((mlir::DenseIntElementsAttr::classof(v15) & 1) == 0)
    goto LABEL_58;
  v57 = v15;
  if (!*((_BYTE *)a2 + 47) || (v19 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v20))
    v19 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  v21 = v19;
  if (v19 && (mlir::DenseIntElementsAttr::classof(v19) & 1) != 0)
  {
    v60 = v21;
    if (!*((_BYTE *)a2 + 47) || (v22 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v23))
      v22 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
    v24 = v22;
    if (v22 && (mlir::DenseIntElementsAttr::classof(v22) & 1) != 0)
    {
      v63 = v24;
      if (!*((_BYTE *)a2 + 47)
        || (v25 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v26))
      {
        v25 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
      }
      v27 = v25;
      if (!v25 || (mlir::anec::PaddingModeAttr::classof(v25) & 1) == 0)
        v27 = mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
      v61 = v27;
      if (!*((_BYTE *)a2 + 47)
        || (IntegerAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v29))
      {
        IntegerAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
      }
      if (!IntegerAttr
        || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
        IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
      }
      v62 = IntegerAttr;
      if (!*((_BYTE *)a2 + 47)
        || (v31 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v32))
      {
        v31 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
      }
      if (!v31 || *(_UNKNOWN **)(*(_QWORD *)v31 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v31 = 0;
      v64 = v31;
      if (!*((_BYTE *)a2 + 47)
        || (v33 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v34))
      {
        v33 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
      }
      v35 = v33;
      if (v33)
      {
        if (mlir::DenseFPElementsAttr::classof(v33))
          v36 = v35;
        else
          v36 = 0;
      }
      else
      {
        v36 = 0;
      }
      v65 = v36;
      if (!*((_BYTE *)a2 + 47)
        || (v42 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v43))
      {
        v42 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
      }
      v44 = v42;
      if (v42 && !mlir::DenseIntElementsAttr::classof(v42))
        v44 = 0;
      v66 = v44;
      ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v59, 0);
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
      v67[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)v67))
      {
        v67[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
        if (mlir::Type::isF16((mlir::Type *)v67)
          && (v47 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0),
              v48 = mlir::detail::OpResultImpl::getNextResultAtOffset(v47, 0),
              *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8))
                           + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
        {
        }
        else
        {
          v49 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v59, 0);
          v50 = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getNextResultAtOffset(v49, 0);
          Owner = (mlir::Operation *)mlir::detail::OpResultImpl::getOwner(v50);
          {
            {
              if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                             + 8) & 0xFFFFFFFFFFFFFFF8))
                                + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
              {
LABEL_89:
                if (v36)
                {
                }
                else
                {
                  if (!v44)
                  {
                    v55 = *(void **)(v69[1] + 24);
                    v67[0] = *(void **)(*v69 + 24);
                    v67[1] = v55;
                    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v67, (mlir::MLIRContext *)2, 0);
                  }
                }
              }
              else
              {
                v52 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v59, 0);
                v53 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v52, 0);
                while (1)
                {
                  v53 = (_QWORD *)*v53;
                  if (!v53)
                    break;
                  if (*(_UNKNOWN **)(*(_QWORD *)(v53[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
                    goto LABEL_89;
                }
              }
            }
            else
            {
            }
          }
          else
          {
          }
        }
        goto LABEL_72;
      }
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
    else
    {
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
  }
  else
  {
    v37 = *((_QWORD *)a3 + 2);
    if (v37 && mlir::RewriterBase::Listener::classof(v37))
    {
      v38 = *((_QWORD *)a2 + 3);
      goto LABEL_71;
    }
  }
LABEL_94:
  v16 = 0;
LABEL_95:
  if (v69 != v71)
    free(v69);
  return v16;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::UnitAttr &,mlir::DenseFPElementsAttr &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  uint64_t *Context;
  uint64_t v21;
  char v22;
  ZinIrHalH13g *v23;
  ZinIrHalH13g *v24;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _QWORD v31[40];

  v31[38] = *MEMORY[0x24BDAC8D0];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.deconvolution", (const unsigned __int8 *)0x12, Context);
  if (!v22)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"anec.deconvolution";
    v29[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v21);
  mlir::anec::Deconvolution::build(a1, (uint64_t)v31, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12);
  v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v23 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v24 = v23;
  else
    v24 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v24;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, w_out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out, w_scale' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w_bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'");
}

void mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::~ANEC_DeconvFilterMult(mlir::anec::_anonymous_namespace_::ANEC_DeconvFilterMult *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_DeconvFilterMult *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  mlir::Operation *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  void *v9;
  uint64_t ODSOperands;
  int v11;
  uint64_t InherentAttr;
  char v13;
  uint64_t v14;
  uint64_t v15;
  mlir::Operation *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t IntegerAttr;
  char v28;
  uint64_t IntegerType;
  uint64_t v30;
  char v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(int, uint64_t);
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  mlir::detail::OpResultImpl *v49;
  mlir::Operation *Owner;
  uint64_t v51;
  _QWORD *v52;
  void *v54;
  mlir::Operation *v55;
  uint64_t v56;
  void *v57;
  mlir::Operation *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66[10];
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  _QWORD v70[7];

  v70[4] = *MEMORY[0x24BDAC8D0];
  v64 = 0;
  v65 = 0;
  v62 = 0;
  v63 = 0;
  v60 = 0;
  v61 = 0;
  v59 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
    v5 = *((_QWORD *)a2 + 9);
  else
    v5 = 0;
  v56 = 0;
  v57 = 0;
  v68 = v70;
  v70[0] = a2;
  v69 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  v58 = v6;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v55, 0);
  v66[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v55, 1u) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v66);
  if (!DefiningOp)
  {
    v15 = *((_QWORD *)a3 + 2);
    if (!v15)
      goto LABEL_94;
    v16 = v55;
    if (mlir::RewriterBase::Listener::classof(v15))
    {
LABEL_72:
      v15 = v17;
      goto LABEL_94;
    }
    goto LABEL_93;
  }
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v66[0] = v9;
  if (v9)
  {
    v57 = v9;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v66, 0);
    v5 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v66, 1u);
  }
  else
  {
    v39 = *((_QWORD *)a3 + 2);
    if (!v39)
      goto LABEL_93;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_93;
    ODSOperands = v5;
    if (!v40)
      goto LABEL_93;
  }
  v11 = v69;
  if (v69 >= HIDWORD(v69))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v70, v69 + 1, 8);
    v11 = v69;
  }
  v68[v11] = v8;
  LODWORD(v69) = v69 + 1;
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), v13))
  {
    v14 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_58;
  }
  else
  {
    v14 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
    if (!v14)
    {
LABEL_58:
      v36 = *((_QWORD *)a3 + 2);
      if (v36 && mlir::RewriterBase::Listener::classof(v36))
      {
        v37 = *((_QWORD *)a2 + 3);
LABEL_71:
        v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v36 + 64))(v36, v37, v38, v66);
        goto LABEL_72;
      }
      goto LABEL_93;
    }
  }
  if ((mlir::DenseIntElementsAttr::classof(v14) & 1) == 0)
    goto LABEL_58;
  v56 = v14;
  if (!*((_BYTE *)a2 + 47) || (v18 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v19))
    v18 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  v20 = v18;
  if (v18 && (mlir::DenseIntElementsAttr::classof(v18) & 1) != 0)
  {
    v59 = v20;
    if (!*((_BYTE *)a2 + 47) || (v21 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v22))
      v21 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
    v23 = v21;
    if (v21 && (mlir::DenseIntElementsAttr::classof(v21) & 1) != 0)
    {
      v63 = v23;
      if (!*((_BYTE *)a2 + 47)
        || (v24 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v25))
      {
        v24 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
      }
      v26 = v24;
      if (!v24 || (mlir::anec::PaddingModeAttr::classof(v24) & 1) == 0)
        v26 = mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
      v62 = v26;
      if (!*((_BYTE *)a2 + 47)
        || (IntegerAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v28))
      {
        IntegerAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
      }
      if (!IntegerAttr
        || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
        IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
      }
      v61 = IntegerAttr;
      if (!*((_BYTE *)a2 + 47)
        || (v30 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v31))
      {
        v30 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
      }
      if (!v30 || *(_UNKNOWN **)(*(_QWORD *)v30 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v30 = 0;
      v60 = v30;
      if (!*((_BYTE *)a2 + 47)
        || (v32 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v33))
      {
        v32 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
      }
      v34 = v32;
      if (v32)
      {
        if (mlir::DenseFPElementsAttr::classof(v32))
          v35 = v34;
        else
          v35 = 0;
      }
      else
      {
        v35 = 0;
      }
      v64 = v35;
      if (!*((_BYTE *)a2 + 47)
        || (v41 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v42))
      {
        v41 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
      }
      v43 = v41;
      if (v41 && !mlir::DenseIntElementsAttr::classof(v41))
        v43 = 0;
      v65 = v43;
      ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
      v66[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)v66))
      {
        v66[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
        if (mlir::Type::isF16((mlir::Type *)v66)
          && (v46 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v57, 0),
              v47 = mlir::detail::OpResultImpl::getNextResultAtOffset(v46, 0),
              *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v47 + 8) & 0xFFFFFFFFFFFFFFF8))
                           + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
        {
        }
        else
        {
          v48 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
          v49 = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getNextResultAtOffset(v48, 0);
          Owner = (mlir::Operation *)mlir::detail::OpResultImpl::getOwner(v49);
          {
            if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                           + 8) & 0xFFFFFFFFFFFFFFF8))
                              + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
            {
LABEL_88:
              if (v35)
              {
              }
              else
              {
                if (!v43)
                {
                  v54 = *(void **)(v68[1] + 24);
                  v66[0] = *(void **)(*v68 + 24);
                  v66[1] = v54;
                  mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v66, (mlir::MLIRContext *)2, 0);
                }
              }
            }
            else
            {
              v51 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
              v52 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v51, 0);
              while (1)
              {
                v52 = (_QWORD *)*v52;
                if (!v52)
                  break;
                if (*(_UNKNOWN **)(*(_QWORD *)(v52[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
                  goto LABEL_88;
              }
            }
          }
          else
          {
          }
        }
        goto LABEL_72;
      }
      v36 = *((_QWORD *)a3 + 2);
      if (v36 && mlir::RewriterBase::Listener::classof(v36))
      {
        v37 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
    else
    {
      v36 = *((_QWORD *)a3 + 2);
      if (v36 && mlir::RewriterBase::Listener::classof(v36))
      {
        v37 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
  }
  else
  {
    v36 = *((_QWORD *)a3 + 2);
    if (v36 && mlir::RewriterBase::Listener::classof(v36))
    {
      v37 = *((_QWORD *)a2 + 3);
      goto LABEL_71;
    }
  }
LABEL_93:
  v15 = 0;
LABEL_94:
  if (v68 != v70)
    free(v68);
  return v15;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, w_out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out, w_scale' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'w, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvFilterMult::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'");
}

void mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::~ANEC_DeconvInputGOC(mlir::anec::_anonymous_namespace_::ANEC_DeconvInputGOC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_DeconvInputGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  mlir::Operation *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  void *v9;
  uint64_t ODSOperands;
  uint64_t v11;
  int v12;
  uint64_t InherentAttr;
  char v14;
  uint64_t v15;
  uint64_t v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t IntegerAttr;
  char v29;
  uint64_t IntegerType;
  uint64_t v31;
  char v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(int, uint64_t);
  uint64_t v40;
  char v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  void *v52;
  mlir::Operation *v53;
  mlir::Operation *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64[10];
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD v68[6];

  v68[4] = *MEMORY[0x24BDAC8D0];
  v62 = 0;
  v63 = 0;
  v60 = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v56 = 0;
  v57 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
    v5 = *((_QWORD *)a2 + 9);
  else
    v5 = 0;
  v55 = 0;
  v66 = v68;
  v68[0] = a2;
  v67 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v53 = v6;
  v54 = v6;
  v64[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v53, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v64);
  if (!DefiningOp)
  {
    v16 = *((_QWORD *)a3 + 2);
    if (!v16)
      goto LABEL_95;
    v17 = v53;
    if (mlir::RewriterBase::Listener::classof(v16))
    {
LABEL_72:
      v16 = v18;
      goto LABEL_95;
    }
    goto LABEL_94;
  }
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v64[0] = v9;
  if (v9)
  {
    v55 = v9;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v64, 0);
    v11 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v64, 1u);
    v5 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v64, 2u);
  }
  else
  {
    v40 = *((_QWORD *)a3 + 2);
    if (!v40)
      goto LABEL_94;
    if (!mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      goto LABEL_94;
    ODSOperands = v5;
    v11 = v5;
    if (!v41)
      goto LABEL_94;
  }
  v12 = v67;
  if (v67 >= HIDWORD(v67))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
    v12 = v67;
  }
  v66[v12] = v8;
  LODWORD(v67) = v67 + 1;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v53, 1u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), v14))
  {
    v15 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_58;
  }
  else
  {
    v15 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
    if (!v15)
    {
LABEL_58:
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
LABEL_71:
        v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v37 + 64))(v37, v38, v39, v64);
        goto LABEL_72;
      }
      goto LABEL_94;
    }
  }
  if ((mlir::DenseIntElementsAttr::classof(v15) & 1) == 0)
    goto LABEL_58;
  v56 = v15;
  if (!*((_BYTE *)a2 + 47) || (v19 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v20))
    v19 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  v21 = v19;
  if (v19 && (mlir::DenseIntElementsAttr::classof(v19) & 1) != 0)
  {
    v57 = v21;
    if (!*((_BYTE *)a2 + 47) || (v22 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v23))
      v22 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
    v24 = v22;
    if (v22 && (mlir::DenseIntElementsAttr::classof(v22) & 1) != 0)
    {
      v60 = v24;
      if (!*((_BYTE *)a2 + 47)
        || (v25 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v26))
      {
        v25 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
      }
      v27 = v25;
      if (!v25 || (mlir::anec::PaddingModeAttr::classof(v25) & 1) == 0)
        v27 = mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
      v58 = v27;
      if (!*((_BYTE *)a2 + 47)
        || (IntegerAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v29))
      {
        IntegerAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
      }
      if (!IntegerAttr
        || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
        IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
      }
      v59 = IntegerAttr;
      if (!*((_BYTE *)a2 + 47)
        || (v31 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v32))
      {
        v31 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
      }
      if (!v31 || *(_UNKNOWN **)(*(_QWORD *)v31 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v31 = 0;
      v61 = v31;
      if (!*((_BYTE *)a2 + 47)
        || (v33 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v34))
      {
        v33 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
      }
      v35 = v33;
      if (v33)
      {
        if (mlir::DenseFPElementsAttr::classof(v33))
          v36 = v35;
        else
          v36 = 0;
      }
      else
      {
        v36 = 0;
      }
      v62 = v36;
      if (!*((_BYTE *)a2 + 47)
        || (v42 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v43))
      {
        v42 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
      }
      v44 = v42;
      if (v42 && !mlir::DenseIntElementsAttr::classof(v42))
        v44 = 0;
      v63 = v44;
      ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v54, 0);
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
      v64[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)v64))
      {
        v64[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
        if (mlir::Type::isF16((mlir::Type *)v64)
          && (v47 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v55, 0),
              v48 = mlir::detail::OpResultImpl::getNextResultAtOffset(v47, 0),
              *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8))
                           + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
        {
        }
        {
          {
            if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24)
                                                                                           + 8) & 0xFFFFFFFFFFFFFFF8))
                              + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
            {
LABEL_89:
              if (v36)
              {
              }
              else
              {
                if (!v44)
                {
                  v52 = *(void **)(v66[1] + 24);
                  v64[0] = *(void **)(*v66 + 24);
                  v64[1] = v52;
                  mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v64, (mlir::MLIRContext *)2, 0);
                }
              }
            }
            else
            {
              v49 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v54, 0);
              v50 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v49, 0);
              while (1)
              {
                v50 = (_QWORD *)*v50;
                if (!v50)
                  break;
                if (*(_UNKNOWN **)(*(_QWORD *)(v50[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
                  goto LABEL_89;
              }
            }
          }
          else
          {
          }
        }
        else
        {
        }
        goto LABEL_72;
      }
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
    else
    {
      v37 = *((_QWORD *)a3 + 2);
      if (v37 && mlir::RewriterBase::Listener::classof(v37))
      {
        v38 = *((_QWORD *)a2 + 3);
        goto LABEL_71;
      }
    }
  }
  else
  {
    v37 = *((_QWORD *)a3 + 2);
    if (v37 && mlir::RewriterBase::Listener::classof(v37))
    {
      v38 = *((_QWORD *)a2 + 3);
      goto LABEL_71;
    }
  }
LABEL_94:
  v16 = 0;
LABEL_95:
  if (v66 != v68)
    free(v66);
  return v16;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x, x_out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x_scale' failed to satisfy constraint: 'splat constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x_bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_scale' failed to satisfy constraint: 'is nullptr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_DeconvInputGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'kernel_zp' failed to satisfy constraint: 'is nullptr'");
}

void mlir::anec::`anonymous namespace'::ANEC_GOCDiv::~ANEC_GOCDiv(mlir::anec::_anonymous_namespace_::ANEC_GOCDiv *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCDiv *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t DefiningOp;
  uint64_t v7;
  void *v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(int, uint64_t);
  uint64_t v14;
  mlir::Operation *v15;
  uint64_t v16;
  uint64_t (*v17)(int, uint64_t);
  int v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  BOOL v22;
  void *v23;
  mlir::Operation *v24;
  uint64_t ODSOperands;
  uint64_t InherentAttr;
  char v27;
  int v28;
  uint64_t ODSResults;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  unint64_t *v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t (*v57)(int, uint64_t);
  uint64_t *Shape;
  uint64_t v59;
  uint64_t NumElements;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t IndexFromDim;
  char v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v73;
  mlir::Operation *v74;
  uint64_t v75;
  mlir::Operation *v76;
  uint64_t v77;
  void *v78[6];
  void *ElementTypeOrSelf;
  uint64_t v80;
  uint64_t v81;
  uint64_t NextResultAtOffset;
  _QWORD *v83;
  uint64_t v84;
  _QWORD v85[6];

  v85[4] = *MEMORY[0x24BDAC8D0];
  v77 = 0;
  v75 = 0;
  v83 = v85;
  v85[0] = a2;
  v84 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v74 = v5;
  v76 = v5;
  ElementTypeOrSelf = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v74, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (!DefiningOp)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_82;
    v15 = v74;
    if (!mlir::RewriterBase::Listener::classof(v11))
      goto LABEL_81;
    v16 = *((_QWORD *)v15 + 3);
LABEL_16:
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64))(v11, v16, v17, &ElementTypeOrSelf);
    goto LABEL_17;
  }
  v7 = DefiningOp;
  v8 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v9 = v8 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v10 = (void *)DefiningOp;
  else
    v10 = 0;
  ElementTypeOrSelf = v10;
  if (!v9)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_82;
    if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
    {
      v12 = *(_QWORD *)(v7 + 24);
LABEL_12:
      v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64))(v11, v12, v13, v78);
LABEL_17:
      v11 = v14;
      goto LABEL_82;
    }
    goto LABEL_81;
  }
  v75 = DefiningOp;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ElementTypeOrSelf, 0);
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ElementTypeOrSelf, 1u);
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ElementTypeOrSelf, 2u);
  v18 = v84;
  if (v84 >= HIDWORD(v84))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v85, v84 + 1, 8);
    v18 = v84;
  }
  v83[v18] = v7;
  LODWORD(v84) = v84 + 1;
  ElementTypeOrSelf = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v74, 1u) + 24);
  v19 = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (!v19)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_82;
    v24 = v74;
    if (!mlir::RewriterBase::Listener::classof(v11))
      goto LABEL_81;
    v16 = *((_QWORD *)v24 + 3);
    goto LABEL_16;
  }
  v20 = v19;
  v21 = *(void **)(*(_QWORD *)(v19 + 48) + 16);
  v22 = v21 == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id;
  if (v21 == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
    v23 = (void *)v19;
  else
    v23 = 0;
  ElementTypeOrSelf = v23;
  if (!v22)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_82;
    if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
    {
      v12 = *(_QWORD *)(v20 + 24);
      goto LABEL_12;
    }
    goto LABEL_81;
  }
  v77 = v19;
  ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ElementTypeOrSelf, 0);
  if (!*(_BYTE *)(v20 + 47) || (InherentAttr = mlir::Operation::getInherentAttr(v20, (uint64_t)"epsilon", 7), !v27))
    InherentAttr = mlir::DictionaryAttr::get(v20 + 56, "epsilon", 7uLL);
  if (!InherentAttr
    || *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_82;
    if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
    {
      v12 = *(_QWORD *)(v20 + 24);
      goto LABEL_12;
    }
    goto LABEL_81;
  }
  v73 = ODSOperands;
  v28 = v84;
  if (v84 >= HIDWORD(v84))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v85, v84 + 1, 8);
    v28 = v84;
  }
  v83[v28] = v20;
  LODWORD(v84) = v84 + 1;
  ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v76, 0);
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  v30 = mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
  v31 = (uint64_t *)(*(_QWORD *)(v30 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v31)
    goto LABEL_50;
  v32 = *v31;
  v33 = mlir::TypeID::get<mlir::ShapedType>();
  v34 = *(unsigned int *)(v32 + 16);
  if (!(_DWORD)v34)
    goto LABEL_50;
  v35 = *(_QWORD **)(v32 + 8);
  v36 = &v35[2 * v34];
  do
  {
    v37 = v34 >> 1;
    v38 = &v35[2 * (v34 >> 1)];
    v40 = *v38;
    v39 = v38 + 2;
    v34 += ~(v34 >> 1);
    if (v40 < v33)
      v35 = v39;
    else
      v34 = v37;
  }
  while (v34);
  if (v35 != v36 && *v35 == v33)
    v41 = v35[1];
  else
LABEL_50:
    v41 = 0;
  ElementTypeOrSelf = v31;
  v80 = v41;
  v42 = *(_QWORD *)(v30 + 72);
  v43 = *(_QWORD *)(*(_QWORD *)(v42 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v43)
  {
    mlir::TypeID::get<mlir::ShapedType>();
    v42 = *(_QWORD *)(v30 + 72);
  }
  v44 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v42 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v44)
    goto LABEL_62;
  v45 = *v44;
  v46 = mlir::TypeID::get<mlir::ShapedType>();
  v47 = *(unsigned int *)(v45 + 16);
  if (!(_DWORD)v47)
    goto LABEL_62;
  v48 = *(_QWORD **)(v45 + 8);
  v49 = &v48[2 * v47];
  do
  {
    v50 = v47 >> 1;
    v51 = &v48[2 * (v47 >> 1)];
    v53 = *v51;
    v52 = v51 + 2;
    v47 += ~(v47 >> 1);
    if (v53 < v46)
      v48 = v52;
    else
      v47 = v50;
  }
  while (v47);
  if (v48 != v49 && *v48 == v46)
    v54 = (void *)v48[1];
  else
LABEL_62:
    v54 = 0;
  v78[0] = v44;
  v78[1] = v54;
  if (v31 != (uint64_t *)v43
    || (Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v78),
        NumElements = mlir::ShapedType::getNumElements(Shape, v59),
        NumElements != 1)
    && ((v66 = NumElements,
         mlir::ShapedType::getShape((mlir::ShapedType *)&ElementTypeOrSelf),
         IndexFromDim = mlir::anec::getIndexFromDim(1, v67),
         !v69)
     || (v70 = IndexFromDim, mlir::ShapedType::getShape((mlir::ShapedType *)v78), v71 <= v70)
     || *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)v78) + 8 * v70) != v66))
  {
    v55 = *((_QWORD *)a3 + 2);
    if (v55 && mlir::RewriterBase::Listener::classof(v55))
    {
      v56 = *((_QWORD *)a2 + 3);
LABEL_67:
      v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v55 + 64))(v55, v56, v57, &ElementTypeOrSelf);
      goto LABEL_17;
    }
LABEL_81:
    v11 = 0;
    goto LABEL_82;
  }
  v61 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v75, 0);
  v62 = mlir::detail::OpResultImpl::getNextResultAtOffset(v61, 0);
  ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v62 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    v55 = *((_QWORD *)a3 + 2);
    if (v55 && mlir::RewriterBase::Listener::classof(v55))
    {
      v56 = *((_QWORD *)a2 + 3);
      goto LABEL_67;
    }
    goto LABEL_81;
  }
  v63 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v77, 0);
  v64 = mlir::detail::OpResultImpl::getNextResultAtOffset(v63, 0);
  ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v64 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    if ((mlir::matchPattern<mlir::detail::constant_op_matcher>(*(_QWORD *)(v73 + 24)) & 1) != 0)
    {
      ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v73 + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
      {
        v65 = *(_QWORD *)(v83[1] + 24);
        ElementTypeOrSelf = *(void **)(*v83 + 24);
        v80 = v65;
        v81 = *(_QWORD *)(v83[2] + 24);
        mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&ElementTypeOrSelf, (mlir::MLIRContext *)3, 0);
      }
    }
    else
    {
    }
  }
  else
  {
  }
LABEL_82:
  if (v83 != v85)
    free(v83);
  return v11;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

char *mlir::anec::`anonymous namespace'::fuseGOCs(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, int a8, uint64_t a9)
{
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t DefiningOp;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  void *v45;
  llvm::APFloatBase *v46;
  unint64_t v47;
  unint64_t IndexFromDim;
  uint64_t v49;
  int v50;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  _BYTE *v57;
  uint64_t v58;
  mlir::OpBuilder *v59;
  uint64_t F32Type;
  _QWORD *v61;
  uint64_t *v62;
  mlir::AffineMap *v63;
  mlir::MLIRContext *v64;
  uint64_t F16Type;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  _QWORD *v69;
  _QWORD *v70;
  unint64_t v71;
  unint64_t *v72;
  _QWORD *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  _QWORD *v81;
  _QWORD *v82;
  unint64_t v83;
  unint64_t *v84;
  _QWORD *v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  int v90;
  float *v91;
  int v92;
  float *v93;
  int v94;
  float *v95;
  int v96;
  float *v97;
  float v98;
  float v99;
  float v100;
  uint64_t v101;
  uint64_t v102;
  float v103;
  uint64_t v104;
  uint64_t v105;
  float v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  ZinIrHalH13g *v110;
  uint64_t v112;
  uint64_t v113;
  uint64_t v115;
  ZinIrHalH13g *v116;
  _QWORD *ElementsAttr;
  uint64_t v118;
  ZinIrHalH13g *v119;
  void *v120[10];
  uint64_t v121;
  uint64_t v122[2];
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  _QWORD v128[8];
  void *__b;
  unsigned int v130;
  int v131;
  _BYTE v132[48];
  void *v133;
  uint64_t v134;
  _DWORD v135[12];
  void *v136;
  uint64_t v137;
  _DWORD v138[12];
  float *v139;
  uint64_t v140;
  _DWORD v141[12];
  float *v142;
  uint64_t v143;
  _DWORD v144[12];
  uint64_t v145;

  v145 = *MEMORY[0x24BDAC8D0];
  v124 = a3;
  v125 = a2;
  v123 = a9;
  v14 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_10;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_10;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_10:
    v24 = 0;
  v122[0] = (uint64_t)v14;
  v122[1] = v24;
  v115 = *(_QWORD *)(mlir::Value::getDefiningOp((mlir::Value *)&v124) + 24);
  if (!a4
    || (v120[0] = a4, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v120)) == 0)
    || (v26 = DefiningOp,
        v27 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v26 + 48) + 32))(*(_QWORD *)(v26 + 48), v27)))
  {
    v29 = 0;
    v113 = 0;
    if (a5)
      goto LABEL_20;
LABEL_29:
    v112 = 0;
    goto LABEL_30;
  }
  v126 = v128;
  v127 = 0x100000000;
  mlir::Operation::fold(v26, 0, 0, (uint64_t)&v126);
  v29 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v126 & 0xFFFFFFFFFFFFFFF8));
  if (v29)
    v30 = v28;
  else
    v30 = 0;
  v113 = v30;
  if (v126 != v128)
    free(v126);
  if (!a5)
    goto LABEL_29;
LABEL_20:
  v120[0] = a5;
  v31 = mlir::Value::getDefiningOp((mlir::Value *)v120);
  if (!v31
    || (v32 = v31,
        v33 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v32 + 48) + 32))(*(_QWORD *)(v32 + 48), v33)))
  {
    a5 = 0;
    v112 = 0;
    if (a6)
      goto LABEL_31;
    goto LABEL_40;
  }
  v126 = v128;
  v127 = 0x100000000;
  mlir::Operation::fold(v32, 0, 0, (uint64_t)&v126);
  a5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v126 & 0xFFFFFFFFFFFFFFF8));
  if (a5)
    v35 = v34;
  else
    v35 = 0;
  v112 = v35;
  if (v126 == v128)
  {
LABEL_30:
    if (a6)
      goto LABEL_31;
LABEL_40:
    v40 = 0;
    goto LABEL_41;
  }
  free(v126);
  if (!a6)
    goto LABEL_40;
LABEL_31:
  v120[0] = a6;
  v36 = mlir::Value::getDefiningOp((mlir::Value *)v120);
  if (!v36
    || (v37 = v36,
        v38 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v37 + 48) + 32))(*(_QWORD *)(v37 + 48), v38)))
  {
    a6 = 0;
    v40 = 0;
    if (!a7)
      goto LABEL_58;
    goto LABEL_44;
  }
  v126 = v128;
  v127 = 0x100000000;
  mlir::Operation::fold(v37, 0, 0, (uint64_t)&v126);
  a6 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v126 & 0xFFFFFFFFFFFFFFF8));
  if (a6)
    v40 = v39;
  else
    v40 = 0;
  if (v126 != v128)
  {
    free(v126);
    if (!a7)
      goto LABEL_58;
    goto LABEL_44;
  }
LABEL_41:
  if (!a7)
  {
LABEL_58:
    v41 = 0;
    if (!v123)
      goto LABEL_59;
LABEL_54:
    mlir::FloatAttr::getValue((mlir::FloatAttr *)&v123, (uint64_t)&v126);
    v44 = llvm::APFloat::convertToFloat((llvm::APFloat *)&v126);
    v45 = (void *)v127;
    if (llvm::APFloatBase::PPCDoubleDouble(v46) == v45)
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v127);
    else
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v127);
    goto LABEL_60;
  }
LABEL_44:
  v120[0] = a7;
  v41 = mlir::Value::getDefiningOp((mlir::Value *)v120);
  if (v41)
  {
    v42 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v41 + 48) + 32))(*(_QWORD *)(v41 + 48), v42))
    {
      a7 = 0;
      goto LABEL_58;
    }
    v126 = v128;
    v127 = 0x100000000;
    mlir::Operation::fold(v41, 0, 0, (uint64_t)&v126);
    a7 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v126 & 0xFFFFFFFFFFFFFFF8));
    if (a7)
      v41 = v43;
    else
      v41 = 0;
    if (v126 != v128)
    {
      free(v126);
      if (!v123)
        goto LABEL_59;
      goto LABEL_54;
    }
  }
  else
  {
    a7 = 0;
  }
  if (v123)
    goto LABEL_54;
LABEL_59:
  v44 = 0.0;
LABEL_60:
  mlir::ShapedType::getShape((mlir::ShapedType *)v122);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v47);
  v49 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)v122) + 8 * IndexFromDim);
  v142 = (float *)v144;
  v143 = 0xC00000000;
  if (v29)
  {
    mlir::getIntValues<float>((uint64_t)v29, v113, (uint64_t)&v142, 0);
  }
  else
  {
    v144[0] = 1065353216;
    LODWORD(v143) = 1;
  }
  v139 = (float *)v141;
  v140 = 0xC00000000;
  if (a5)
  {
    mlir::getIntValues<float>((uint64_t)a5, v112, (uint64_t)&v139, 0);
  }
  else
  {
    v141[0] = 0;
    LODWORD(v140) = 1;
  }
  v136 = v138;
  v137 = 0xC00000000;
  if (a6)
  {
    mlir::getIntValues<float>((uint64_t)a6, v40, (uint64_t)&v136, 0);
  }
  else
  {
    v138[0] = 1065353216;
    LODWORD(v137) = 1;
  }
  v133 = v135;
  v134 = 0xC00000000;
  if (a7)
  {
    mlir::getIntValues<float>((uint64_t)a7, v41, (uint64_t)&v133, 0);
    v50 = v134;
  }
  else
  {
    v50 = 1;
    v135[0] = 0;
    LODWORD(v134) = 1;
  }
  if (v50 == 1 && (_DWORD)v137 == 1 && (_DWORD)v140 == 1 && (_DWORD)v143 == 1)
    v54 = 1;
  else
    v54 = v49;
  mlir::ShapedType::getShape((mlir::ShapedType *)v122);
  v56 = v55;
  __b = v132;
  v131 = 6;
  if (v55 < 7)
  {
    if (v55)
      memset_pattern16(v132, &unk_207A80400, 8 * v55);
    v57 = v132;
  }
  else
  {
    v130 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v132, v55, 8);
    v57 = __b;
    memset_pattern16(__b, &unk_207A80400, 8 * v56);
  }
  v130 = v56;
  *(_QWORD *)&v57[8 * IndexFromDim] = v54;
  v58 = v56;
  v59 = (mlir::OpBuilder *)(a1 + 8);
  F32Type = mlir::Builder::getF32Type((mlir::Float32Type **)(a1 + 8), (mlir::MLIRContext *)v55);
  v61 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v57, v58, F32Type, 0);
  v62 = (uint64_t *)__b;
  v63 = (mlir::AffineMap *)v130;
  F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a1 + 8), v64);
  v121 = mlir::MemRefType::get(v62, v63, F16Type, 0, 0, 0);
  if (v61)
  {
    v66 = *v61;
    v67 = mlir::TypeID::get<mlir::ShapedType>();
    v68 = *(unsigned int *)(v66 + 16);
    if ((_DWORD)v68)
    {
      v69 = *(_QWORD **)(v66 + 8);
      v70 = &v69[2 * v68];
      do
      {
        v71 = v68 >> 1;
        v72 = &v69[2 * (v68 >> 1)];
        v74 = *v72;
        v73 = v72 + 2;
        v68 += ~(v68 >> 1);
        if (v74 < v67)
          v69 = v73;
        else
          v68 = v71;
      }
      while (v68);
      if (v69 != v70 && *v69 == v67)
        v75 = v69[1];
      else
        v75 = 0;
      v77 = v61;
    }
    else
    {
      v77 = v61;
      v75 = 0;
    }
    mlir::mps::CPUNDArray::CPUNDArray(&v126, v77, v75, 0);
    v78 = *v61;
    v79 = mlir::TypeID::get<mlir::ShapedType>();
    v80 = *(unsigned int *)(v78 + 16);
    if (!(_DWORD)v80)
      goto LABEL_112;
    v81 = *(_QWORD **)(v78 + 8);
    v82 = &v81[2 * v80];
    do
    {
      v83 = v80 >> 1;
      v84 = &v81[2 * (v80 >> 1)];
      v86 = *v84;
      v85 = v84 + 2;
      v80 += ~(v80 >> 1);
      if (v86 < v79)
        v81 = v85;
      else
        v80 = v83;
    }
    while (v80);
    if (v81 != v82 && *v81 == v79)
      v76 = v81[1];
    else
LABEL_112:
      v76 = 0;
  }
  else
  {
    mlir::mps::CPUNDArray::CPUNDArray(&v126, 0, 0, 0);
    v76 = 0;
  }
  mlir::mps::CPUNDArray::CPUNDArray(v120, v61, v76, 0);
  if (v54)
  {
    v87 = 0;
    v88 = v128[3];
    v89 = (char *)v120[5];
    v90 = v143;
    v91 = v142;
    v92 = v140;
    v93 = v139;
    v94 = v137;
    v95 = (float *)v136;
    v96 = v134;
    v97 = (float *)v133;
    do
    {
      if (v90 == 1)
        v102 = 0;
      else
        v102 = v87;
      v103 = v91[v102];
      if (v92 == 1)
        v104 = 0;
      else
        v104 = v87;
      if (v94 == 1)
        v105 = 0;
      else
        v105 = v87;
      v106 = v95[v105];
      if (v96 == 1)
        v107 = 0;
      else
        v107 = v87;
      if (a8)
        v98 = v103 / (float)(v44 + v106);
      else
        v98 = v103 * v106;
      v99 = v93[v104];
      v100 = v97[v107];
      v101 = 4 * v87;
      *(float *)(v88 + v101) = v98;
      *(float *)&v89[v101] = v99 + (float)(v100 / v103);
      ++v87;
    }
    while (v54 != v87);
  }
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)&v126, 0, 1);
  v118 = v108;
  v119 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v59, v115, &v121, &ElementsAttr);
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v120, 0, 1);
  v118 = v109;
  v116 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v59, v115, &v121, &ElementsAttr);
  v110 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(v59, v115, v122, &v125, &v119, &v116);
  mlir::mps::CPUNDArray::~CPUNDArray(v120);
  mlir::mps::CPUNDArray::~CPUNDArray(&v126);
  if (__b != v132)
    free(__b);
  if (v133 != v135)
    free(v133);
  if (v136 != v138)
    free(v136);
  if (v139 != (float *)v141)
    free(v139);
  if (v142 != (float *)v144)
    free(v142);
  return (char *)v110 - 16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::GOC type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::Invert type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.invert' to have attribute 'epsilon' of type '::mlir::FloatAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'mult' failed to satisfy constraint: 'splat constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'goc' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'inv' failed to satisfy constraint: 'is FP16 value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'quotient' failed to satisfy constraint: 'constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCDiv::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'quotient' failed to satisfy constraint: 'is FP16 value'");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.gain_offset_control";
    v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4, *a5 - 16, *a6 - 16);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anec::`anonymous namespace'::ANEC_GOCGOC::~ANEC_GOCGOC(mlir::anec::_anonymous_namespace_::ANEC_GOCGOC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_GOCGOC::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCGOC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t DefiningOp;
  uint64_t v7;
  void *v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  mlir::Operation *v13;
  int v14;
  uint64_t ODSOperands;
  uint64_t v16;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Filter;
  uint64_t Bias;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  int OperandRange;
  int v48;
  uint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  unint64_t v67;
  unint64_t *v68;
  _QWORD *v69;
  unint64_t v70;
  uint64_t v71;
  float v72;
  void *v73;
  llvm::APFloatBase *v74;
  void *v75;
  float v76;
  uint64_t v77;
  mlir::Operation *v79;
  uint64_t v80;
  mlir::Operation *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  void *v91;
  uint64_t v92;
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  _QWORD *v96;
  uint64_t v97;
  _QWORD v98[6];

  v98[4] = *MEMORY[0x24BDAC8D0];
  v80 = 0;
  v96 = v98;
  v98[0] = a2;
  v97 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v79 = v5;
  v81 = v5;
  v93 = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v79, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v93);
  if (DefiningOp)
  {
    v7 = DefiningOp;
    v8 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v9 = v8 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id;
    if (v8 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
      v10 = (void *)DefiningOp;
    else
      v10 = 0;
    v93 = v10;
    if (!v9)
    {
      v11 = *((_QWORD *)a3 + 2);
      if (!v11)
        goto LABEL_92;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
LABEL_15:
        v11 = v12;
        goto LABEL_92;
      }
      goto LABEL_91;
    }
    v80 = DefiningOp;
    mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v93, 0);
    mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v93, 1u);
    mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v93, 2u);
    v14 = v97;
    if (v97 >= HIDWORD(v97))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v98, v97 + 1, 8);
      v14 = v97;
    }
    v96[v14] = v7;
    LODWORD(v97) = v97 + 1;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v79, 1u);
    v16 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v79, 2u);
    ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v80, 0);
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
    v19 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v81, 0);
    v20 = mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 0);
    v21 = *(_QWORD *)(ODSOperands + 24);
    v22 = *(_QWORD *)(v16 + 24);
    v89 = (_QWORD *)NextResultAtOffset;
    v88 = mlir::Value::getDefiningOp((mlir::Value *)&v89);
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v88);
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v88);
    v91 = 0;
    v92 = 0;
    v86 = 0;
    v87 = 0;
    v84 = 0;
    v85 = 0;
    v82 = 0;
    v83 = 0;
    v90 = Filter;
    v25 = mlir::Value::getDefiningOp((mlir::Value *)&v90);
    if (v25)
    {
      v26 = v25;
      v27 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v26 + 48) + 32))(*(_QWORD *)(v26 + 48), v27))
      {
        v93 = v95;
        v94 = 0x100000000;
        mlir::Operation::fold(v26, 0, 0, (uint64_t)&v93);
        v28 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v93 & 0xFFFFFFFFFFFFFFF8));
        if (v28)
        {
          v91 = v28;
          v92 = v29;
        }
        if (v93 != v95)
          free(v93);
      }
    }
    v90 = Bias;
    v30 = mlir::Value::getDefiningOp((mlir::Value *)&v90);
    if (v30)
    {
      v31 = v30;
      v32 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v31 + 48) + 32))(*(_QWORD *)(v31 + 48), v32))
      {
        v93 = v95;
        v94 = 0x100000000;
        mlir::Operation::fold(v31, 0, 0, (uint64_t)&v93);
        v33 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v93 & 0xFFFFFFFFFFFFFFF8));
        if (v33)
        {
          v86 = v33;
          v87 = v34;
        }
        if (v93 != v95)
          free(v93);
      }
    }
    v90 = v21;
    v35 = mlir::Value::getDefiningOp((mlir::Value *)&v90);
    if (v35)
    {
      v36 = v35;
      v37 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v36 + 48) + 32))(*(_QWORD *)(v36 + 48), v37))
      {
        v93 = v95;
        v94 = 0x100000000;
        mlir::Operation::fold(v36, 0, 0, (uint64_t)&v93);
        v38 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v93 & 0xFFFFFFFFFFFFFFF8));
        if (v38)
        {
          v84 = v38;
          v85 = v39;
        }
        if (v93 != v95)
          free(v93);
      }
    }
    v90 = v22;
    v40 = mlir::Value::getDefiningOp((mlir::Value *)&v90);
    if (v40)
    {
      v41 = v40;
      v42 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v41 + 48) + 32))(*(_QWORD *)(v41 + 48), v42))
      {
        v93 = v95;
        v94 = 0x100000000;
        mlir::Operation::fold(v41, 0, 0, (uint64_t)&v93);
        v43 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v93 & 0xFFFFFFFFFFFFFFF8));
        if (v43)
        {
          v82 = v43;
          v83 = v44;
        }
        if (v93 != v95)
          free(v93);
      }
    }
    v45 = v89;
    v46 = (_QWORD *)*v89;
    if (*v89)
    {
      while (v46[2] - 16 == v20)
      {
        v46 = (_QWORD *)*v46;
        if (!v46)
          goto LABEL_53;
      }
      if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v91))
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v86);
      else
        OperandRange = 0;
      v48 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v84);
      if (v48)
        v48 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v82);
      if (OperandRange != v48)
      {
LABEL_88:
        v77 = *((_QWORD *)a3 + 2);
        if (v77 && mlir::RewriterBase::Listener::classof(v77))
        {
          goto LABEL_15;
        }
        goto LABEL_91;
      }
      v45 = v89;
    }
LABEL_53:
    v49 = (uint64_t *)(v45[1] & 0xFFFFFFFFFFFFFFF8);
    if (!v49)
      goto LABEL_62;
    v50 = *v49;
    v51 = mlir::TypeID::get<mlir::ShapedType>();
    v52 = *(unsigned int *)(v50 + 16);
    if (!(_DWORD)v52)
      goto LABEL_62;
    v53 = *(_QWORD **)(v50 + 8);
    v54 = &v53[2 * v52];
    do
    {
      v55 = v52 >> 1;
      v56 = &v53[2 * (v52 >> 1)];
      v58 = *v56;
      v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51)
        v53 = v57;
      else
        v52 = v55;
    }
    while (v52);
    if (v53 != v54 && *v53 == v51)
      v59 = v53[1];
    else
LABEL_62:
      v59 = 0;
    v93 = v49;
    v94 = v59;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v93)
                      + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      goto LABEL_64;
    v61 = (uint64_t *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v61)
      goto LABEL_74;
    v62 = *v61;
    v63 = mlir::TypeID::get<mlir::ShapedType>();
    v64 = *(unsigned int *)(v62 + 16);
    if (!(_DWORD)v64)
      goto LABEL_74;
    v65 = *(_QWORD **)(v62 + 8);
    v66 = &v65[2 * v64];
    do
    {
      v67 = v64 >> 1;
      v68 = &v65[2 * (v64 >> 1)];
      v70 = *v68;
      v69 = v68 + 2;
      v64 += ~(v64 >> 1);
      if (v70 < v63)
        v65 = v69;
      else
        v64 = v67;
    }
    while (v64);
    if (v65 != v66 && *v65 == v63)
      v71 = v65[1];
    else
LABEL_74:
      v71 = 0;
    v93 = v61;
    v94 = v71;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v93)
                      + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
      && mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v84)
      && (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v82) & 1) != 0)
    {
      mlir::ElementsAttr::getSplatValue<llvm::APFloat>((mlir::BranchOpInterface *)&v84, (uint64_t)&v93);
      v72 = llvm::APFloat::convertToFloat((llvm::APFloat *)&v93);
      v73 = (void *)v94;
      v75 = llvm::APFloatBase::PPCDoubleDouble(v74);
      if (v75 == v73)
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v94);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v94);
      mlir::ElementsAttr::getSplatValue<llvm::APFloat>((mlir::BranchOpInterface *)&v82, (uint64_t)&v93);
      v76 = llvm::APFloat::convertToFloat((llvm::APFloat *)&v93);
      if (v75 == (void *)v94)
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v94);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v94);
      if (v72 == 1.0 && v76 == (float)(uint64_t)v76)
      {
LABEL_64:
        v60 = *(_QWORD *)(v96[1] + 24);
        v93 = *(void **)(*v96 + 24);
        v94 = v60;
        mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&v93, (mlir::MLIRContext *)2, 0);
      }
    }
    goto LABEL_88;
  }
  v11 = *((_QWORD *)a3 + 2);
  if (!v11)
    goto LABEL_92;
  v13 = v79;
  if (mlir::RewriterBase::Listener::classof(v11))
  {
    goto LABEL_15;
  }
LABEL_91:
  v11 = 0;
LABEL_92:
  if (v96 != v98)
    free(v96);
  return v11;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::GOC type");
}

llvm::APFloatBase *mlir::ElementsAttr::getSplatValue<llvm::APFloat>@<X0>(mlir::BranchOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  llvm::detail::IEEEFloat *v4;
  char *v5;
  const llvm::detail::DoubleAPFloat *v6;
  void *v7;
  llvm::APFloatBase *result;
  _BYTE v9[8];
  llvm::APFloatBase *v10;
  uint64_t v11;

  mlir::ElementsAttr::value_begin<llvm::APFloat>(a1, (uint64_t)v9);
  if (v9[1])
    v3 = 0;
  else
    v3 = v11;
  if (v9[0])
  {
    v4 = (llvm::detail::IEEEFloat *)(a2 + 8);
    v5 = (char *)v10 + 32 * v3;
    v7 = (void *)*((_QWORD *)v5 + 1);
    v6 = (const llvm::detail::DoubleAPFloat *)(v5 + 8);
    if (llvm::APFloatBase::PPCDoubleDouble(v10) == v7)
    {
      result = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v4, v6);
      if (v9[0])
        return result;
    }
    else
    {
      result = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat(v4, v6);
      if (v9[0])
        return result;
    }
  }
  else
  {
    result = (llvm::APFloatBase *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 24))();
    if (v9[0])
      return result;
  }
  result = v10;
  v10 = 0;
  if (result)
    return (llvm::APFloatBase *)(*(uint64_t (**)(llvm::APFloatBase *))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::ElementsAttr::value_begin<llvm::APFloat>@<X0>(mlir::BranchOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  char v8;
  _BYTE v9[8];
  uint64_t v10;
  char v11;

  v4 = mlir::TypeID::get<llvm::APFloat>();
  result = mlir::BranchOpInterface::getSuccessorOperands(a1, v4);
  if (!v11)
    mlir::ElementsAttr::value_begin<llvm::APFloat>((llvm *)v9, (uint64_t *)a1);
  v6 = v9[1];
  if (v9[0])
  {
    v7 = v10;
    v8 = 1;
  }
  else
  {
    v8 = 0;
    v7 = v10;
  }
  *(_BYTE *)a2 = v8;
  *(_BYTE *)(a2 + 1) = v6;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) = 0;
  return result;
}

const char *llvm::getTypeName<llvm::APFloat>()
{
  unint64_t v0;
  unint64_t v1;
  const char *v2;
  uint64_t v3;
  const char *v5;
  unint64_t v6;

  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::APFloat]";
  v6 = 63;
  v0 = llvm::StringRef::find((uint64_t *)&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
    v1 = v0;
  else
    v1 = v6;
  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
    v3 = 18;
  else
    v3 = v6 - v1;
  return &v2[v3];
}

uint64_t mlir::TypeID::get<llvm::APFloat>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &unk_25451A000;
  if ((v0 & 1) == 0)
  {
    v1 = (_QWORD *)&unk_25451A000;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::APFloat]";
      v12 = 63;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<llvm::APFloat,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = (_QWORD *)&unk_25451A000;
    }
  }
  return v1[270];
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCGOC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'goc1, goc2, scale2, bias2' failed to satisfy constraint: ''");
}

void mlir::anec::`anonymous namespace'::ANEC_GOCRelu::~ANEC_GOCRelu(mlir::anec::_anonymous_namespace_::ANEC_GOCRelu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCRelu *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t DefiningOp;
  uint64_t v7;
  void *v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(int, uint64_t);
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **);
  void **p_ArgOperands;
  uint64_t v16;
  uint64_t v17;
  uint64_t ODSOperands;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  float *v35;
  float v36;
  BOOL v37;
  BOOL v38;
  uint64_t v39;
  float *v40;
  float v41;
  BOOL v42;
  BOOL v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  float *v55;
  float v56;
  BOOL v57;
  BOOL v58;
  uint64_t v59;
  float *v60;
  float v61;
  BOOL v62;
  BOOL v63;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v66;
  _QWORD v68[2];
  uint64_t v69;
  void *ArgOperands;
  uint64_t v71;
  _BYTE v72[64];
  void *v73;
  uint64_t *v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  _QWORD v78[6];

  v78[4] = *MEMORY[0x24BDAC8D0];
  v69 = 0;
  v76 = v78;
  v78[0] = a2;
  v77 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v68[0] = v5;
  v68[1] = v5;
  ArgOperands = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v68, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (DefiningOp)
  {
    v7 = DefiningOp;
    v8 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v9 = v8 == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id;
    if (v8 == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
      v10 = (void *)DefiningOp;
    else
      v10 = 0;
    ArgOperands = v10;
    if (!v9)
    {
      v11 = *((_QWORD *)a3 + 2);
      if (!v11)
        goto LABEL_125;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
        v12 = *(_QWORD *)(v7 + 24);
        v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64);
        p_ArgOperands = (void **)&v74;
LABEL_15:
        v17 = v11;
LABEL_116:
        v11 = v14(v17, v12, v13, p_ArgOperands);
        goto LABEL_125;
      }
      goto LABEL_124;
    }
    v69 = DefiningOp;
    ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&ArgOperands, 0);
    v19 = v77;
    if (v77 >= HIDWORD(v77))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v78, v77 + 1, 8);
      v19 = v77;
    }
    v76[v19] = v7;
    LODWORD(v77) = v77 + 1;
    v20 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v68, 1u);
    v21 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v68, 2u);
    ArgOperands = *(void **)(ODSOperands + 24);
    v22 = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
    if (!v22 || *(_UNKNOWN **)(*(_QWORD *)(v22 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    {
      v23 = *((_QWORD *)a3 + 2);
      if (!v23 || !mlir::RewriterBase::Listener::classof(v23))
        goto LABEL_124;
      v12 = *((_QWORD *)a2 + 3);
LABEL_115:
      v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v23 + 64);
      p_ArgOperands = &ArgOperands;
      v17 = v23;
      goto LABEL_116;
    }
    v24 = *(void **)(v20 + 24);
    v74 = 0;
    v75 = 0;
    v73 = v24;
    v25 = mlir::Value::getDefiningOp((mlir::Value *)&v73);
    if (!v25)
      goto LABEL_112;
    v26 = v25;
    v27 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v26 + 48) + 32))(*(_QWORD *)(v26 + 48), v27))
      goto LABEL_112;
    ArgOperands = v72;
    v71 = 0x100000000;
    mlir::Operation::fold(v26, 0, 0, (uint64_t)&ArgOperands);
    v28 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
    v30 = v28;
    if (v28)
    {
      v74 = v28;
      v75 = v29;
    }
    if (ArgOperands != v72)
      free(ArgOperands);
    if (!v30)
    {
LABEL_112:
      v23 = *((_QWORD *)a3 + 2);
      if (!v23 || !mlir::RewriterBase::Listener::classof(v23))
        goto LABEL_124;
      v12 = *((_QWORD *)a2 + 3);
      goto LABEL_115;
    }
    ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v74);
    v71 = v31;
    v32 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                   + 136);
    if (v32 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      || v32 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      ArgOperands = v72;
      v71 = 0xC00000000;
      mlir::getIntValues<float>((uint64_t)v74, v75, (uint64_t)&ArgOperands, 0);
      if ((_DWORD)v71)
      {
        v39 = 4 * v71 - 4;
        v40 = (float *)ArgOperands;
        do
        {
          v41 = *v40++;
          v42 = v41 >= 0.0;
          v43 = v41 < 0.0 || v39 == 0;
          v39 -= 4;
        }
        while (!v43);
      }
      else
      {
        v42 = 1;
      }
      if (ArgOperands != v72)
        free(ArgOperands);
      if (!v42)
        goto LABEL_112;
    }
    else
    {
      ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v74);
      v71 = v33;
      if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                        + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        goto LABEL_112;
      ArgOperands = v72;
      v71 = 0xC00000000;
      mlir::getIntValues<float>((uint64_t)v74, v75, (uint64_t)&ArgOperands, 0);
      if ((_DWORD)v71)
      {
        v34 = 4 * v71 - 4;
        v35 = (float *)ArgOperands;
        do
        {
          v36 = *v35++;
          v37 = v36 >= 0.0;
          v38 = v36 < 0.0 || v34 == 0;
          v34 -= 4;
        }
        while (!v38);
      }
      else
      {
        v37 = 1;
      }
      if (ArgOperands != v72)
        free(ArgOperands);
      if (!v37)
        goto LABEL_112;
    }
    v44 = *(void **)(v21 + 24);
    v74 = 0;
    v75 = 0;
    v73 = v44;
    v45 = mlir::Value::getDefiningOp((mlir::Value *)&v73);
    if (v45)
    {
      v46 = v45;
      v47 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v46 + 48) + 32))(*(_QWORD *)(v46 + 48), v47))
      {
        ArgOperands = v72;
        v71 = 0x100000000;
        mlir::Operation::fold(v46, 0, 0, (uint64_t)&ArgOperands);
        v48 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
        v50 = v48;
        if (v48)
        {
          v74 = v48;
          v75 = v49;
        }
        if (ArgOperands != v72)
          free(ArgOperands);
        if (v50)
        {
          ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v74);
          v71 = v51;
          v52 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                         + 136);
          if (v52 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
            || v52 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
          {
            ArgOperands = v72;
            v71 = 0xC00000000;
            mlir::getIntValues<float>((uint64_t)v74, v75, (uint64_t)&ArgOperands, 0);
            if ((_DWORD)v71)
            {
              v59 = 4 * v71 - 4;
              v60 = (float *)ArgOperands;
              do
              {
                v61 = *v60++;
                v62 = v61 == 0.0;
                v63 = v61 != 0.0 || v59 == 0;
                v59 -= 4;
              }
              while (!v63);
            }
            else
            {
              v62 = 1;
            }
            if (ArgOperands != v72)
              free(ArgOperands);
            if (!v62)
              goto LABEL_121;
          }
          else
          {
            ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v74);
            v71 = v53;
            if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands)
                              + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
              goto LABEL_121;
            ArgOperands = v72;
            v71 = 0xC00000000;
            mlir::getIntValues<float>((uint64_t)v74, v75, (uint64_t)&ArgOperands, 0);
            if ((_DWORD)v71)
            {
              v54 = 4 * v71 - 4;
              v55 = (float *)ArgOperands;
              do
              {
                v56 = *v55++;
                v57 = v56 == 0.0;
                v58 = v56 != 0.0 || v54 == 0;
                v54 -= 4;
              }
              while (!v58);
            }
            else
            {
              v57 = 1;
            }
            if (ArgOperands != v72)
              free(ArgOperands);
            if (!v57)
              goto LABEL_121;
          }
          ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v69, 0);
          NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
          ArgOperands = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
          if (mlir::Type::isF16((mlir::Type *)&ArgOperands))
          {
            v66 = *(_QWORD *)(v76[1] + 24);
            ArgOperands = *(void **)(*v76 + 24);
            v71 = v66;
            mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&ArgOperands, (mlir::MLIRContext *)2, 0);
          }
          v23 = *((_QWORD *)a3 + 2);
          if (!v23 || !mlir::RewriterBase::Listener::classof(v23))
            goto LABEL_124;
          v12 = *((_QWORD *)a2 + 3);
          goto LABEL_115;
        }
      }
    }
LABEL_121:
    v23 = *((_QWORD *)a3 + 2);
    if (!v23 || !mlir::RewriterBase::Listener::classof(v23))
      goto LABEL_124;
    v12 = *((_QWORD *)a2 + 3);
    goto LABEL_115;
  }
  v11 = *((_QWORD *)a3 + 2);
  if (!v11)
    goto LABEL_125;
  v16 = v68[0];
  if (mlir::RewriterBase::Listener::classof(v11))
  {
    v12 = *(_QWORD *)(v16 + 24);
    v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v11 + 64);
    p_ArgOperands = &ArgOperands;
    goto LABEL_15;
  }
LABEL_124:
  v11 = 0;
LABEL_125:
  if (v76 != v78)
    free(v76);
  return v11;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.gain_offset_control";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GOC::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Relu,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.relu", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.relu";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::Relu type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x' failed to satisfy constraint: 'is GOC input'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'scale' failed to satisfy constraint: 'is constant >= 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'bias' failed to satisfy constraint: 'is constant 0'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCRelu::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'relu_out' failed to satisfy constraint: 'is FP16 value'");
}

void mlir::anec::`anonymous namespace'::CanonicalizeConcat::~CanonicalizeConcat(mlir::anec::_anonymous_namespace_::CanonicalizeConcat *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Concat>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Concat>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Concat>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::anec::`anonymous namespace'::CanonicalizeConcat::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t Inputs;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *Axis;
  const char *v20;
  void **v21;
  uint64_t v22;
  uint64_t DefiningOp;
  void *v24;
  BOOL v25;
  void *v26;
  uint64_t Input;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  size_t v32;
  mlir::Operation *v33;
  uint64_t v34;
  uint64_t result;
  uint64_t Shape;
  uint64_t v37;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t F32Type;
  _QWORD *v41;
  uint64_t *v42;
  mlir::AffineMap *v43;
  mlir::MLIRContext *v44;
  uint64_t F16Type;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  unint64_t v63;
  unint64_t *v64;
  _QWORD *v65;
  unint64_t v66;
  float32x4_t *v67;
  float32x4_t *v68;
  uint64_t i;
  uint64_t *v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  unint64_t v76;
  unint64_t *v77;
  _QWORD *v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t Filter;
  uint64_t Bias;
  uint64_t v86;
  __int32 *v87;
  uint64_t v88;
  float32x4_t *v89;
  uint64_t v90;
  char *v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  float32x4_t *v95;
  char *v96;
  __int128 *v97;
  _OWORD *f32;
  uint64_t v99;
  __int128 v100;
  char *v101;
  __int32 v102;
  uint64_t v103;
  __int32 *v104;
  BOOL v105;
  uint64_t v106;
  float32x4_t *v107;
  float32x4_t v108;
  float32x4_t *v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  float32x4_t *v114;
  __int32 *v115;
  __int128 *v116;
  _OWORD *v117;
  uint64_t v118;
  __int128 v119;
  uint64_t v120;
  __int32 *v121;
  __int32 v122;
  float32x4_t v123;
  float32x4_t *v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  mlir::Operation *v128;
  ZinIrHalH13g *v129;
  mlir::Builder *v130;
  ZinIrHalH13g *v131;
  ZinIrHalH13g *v132;
  void *v133[10];
  void *v134[4];
  __int16 v135;
  float32x4_t *v136;
  uint64_t v137;
  uint64_t v138[2];
  mlir::Operation *v139;
  void *v140;
  uint64_t v141;
  _BYTE v142[48];
  void *ElementsAttr;
  uint64_t v144;
  _BYTE v145[48];
  _QWORD *v146;
  uint64_t v147;
  _BYTE v148[48];
  _QWORD *ElementTypeOrSelf;
  unsigned int v150;
  int v151;
  _QWORD v152[8];

  v152[6] = *MEMORY[0x24BDAC8D0];
  v139 = a2;
  v4 = *((_QWORD *)a2 + 3);
  Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v139);
  v7 = v6;
  v8 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v139) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_10;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_10;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_10:
    v18 = 0;
  v138[0] = (uint64_t)v8;
  v138[1] = v18;
  Axis = mlir::anec::Concat::getAxis(&v139);
  if (mlir::anec::Concat::getInterleave(&v139))
  {
    v20 = "failed: interleaved concat not supported";
    goto LABEL_33;
  }
  v134[0] = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v138);
  if (!mlir::Type::isF16((mlir::Type *)v134))
  {
    v134[0] = "failed: operation output must be F16";
    v135 = 259;
    v33 = v139;
    v133[0] = v134;
    v34 = *(_QWORD *)(a3 + 16);
    if (v34)
      goto LABEL_34;
    return 0;
  }
  if (Axis != (uint64_t *)1)
  {
    v20 = "failed: only works when concat is applied on the channel axis";
    goto LABEL_33;
  }
  if (v7)
  {
    v21 = (void **)(Inputs + 24);
    v22 = v7;
    while (1)
    {
      v134[0] = *v21;
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v134);
      if (!DefiningOp)
        break;
      v24 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      v25 = v24 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id;
      v26 = v24 == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id ? (void *)DefiningOp : 0;
      v133[0] = v26;
      if (!v25)
        break;
      Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)v133);
      if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8))
                        + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        break;
      v28 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v133);
      ElementTypeOrSelf = (_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
        break;
      v21 += 4;
      if (!--v22)
        goto LABEL_26;
    }
    v20 = "failed: all inputs must be compatible";
LABEL_33:
    v134[0] = (void *)v20;
    v135 = 259;
    v33 = v139;
    v133[0] = v134;
    v34 = *(_QWORD *)(a3 + 16);
    if (v34)
    {
LABEL_34:
      result = mlir::RewriterBase::Listener::classof(v34);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v34 + 64))(v34, *((_QWORD *)v33 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::Concat &>(mlir::anec::Concat &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v133);
      return result;
    }
    return 0;
  }
LABEL_26:
  mlir::ShapedType::getShape((mlir::ShapedType *)v138);
  v30 = v29;
  ElementTypeOrSelf = v152;
  v151 = 6;
  if (v29 < 7)
  {
    if (!v29)
      goto LABEL_40;
    v32 = 8 * v29;
    v31 = v152;
  }
  else
  {
    v150 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&ElementTypeOrSelf, v152, v29, 8);
    v31 = ElementTypeOrSelf;
    v32 = 8 * v30;
  }
  memset_pattern16(v31, &unk_207A80400, v32);
LABEL_40:
  v150 = v30;
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v138);
  v37 = (uint64_t)ElementTypeOrSelf;
  ElementTypeOrSelf[1] = *(_QWORD *)(Shape + 8);
  v38 = v150;
  F32Type = mlir::Builder::getF32Type((mlir::Float32Type **)(a3 + 8), v39);
  v41 = (_QWORD *)mlir::RankedTensorType::get(v37, v38, F32Type, 0);
  v42 = ElementTypeOrSelf;
  v43 = (mlir::AffineMap *)v150;
  F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a3 + 8), v44);
  v137 = mlir::MemRefType::get(v42, v43, F16Type, 0, 0, 0);
  v130 = (mlir::Builder *)(a3 + 8);
  if (v41)
  {
    v46 = *v41;
    v47 = mlir::TypeID::get<mlir::ShapedType>();
    v48 = *(unsigned int *)(v46 + 16);
    if ((_DWORD)v48)
    {
      v49 = *(_QWORD **)(v46 + 8);
      v50 = &v49[2 * v48];
      do
      {
        v51 = v48 >> 1;
        v52 = &v49[2 * (v48 >> 1)];
        v54 = *v52;
        v53 = v52 + 2;
        v48 += ~(v48 >> 1);
        if (v54 < v47)
          v49 = v53;
        else
          v48 = v51;
      }
      while (v48);
      if (v49 != v50 && *v49 == v47)
        v55 = v49[1];
      else
        v55 = 0;
      v57 = v41;
    }
    else
    {
      v57 = v41;
      v55 = 0;
    }
    mlir::mps::CPUNDArray::CPUNDArray(v134, v57, v55, 0);
    v58 = *v41;
    v59 = mlir::TypeID::get<mlir::ShapedType>();
    v60 = *(unsigned int *)(v58 + 16);
    if (!(_DWORD)v60)
      goto LABEL_62;
    v61 = *(_QWORD **)(v58 + 8);
    v62 = &v61[2 * v60];
    do
    {
      v63 = v60 >> 1;
      v64 = &v61[2 * (v60 >> 1)];
      v66 = *v64;
      v65 = v64 + 2;
      v60 += ~(v60 >> 1);
      if (v66 < v59)
        v61 = v65;
      else
        v60 = v63;
    }
    while (v60);
    if (v61 != v62 && *v61 == v59)
      v56 = v61[1];
    else
LABEL_62:
      v56 = 0;
  }
  else
  {
    mlir::mps::CPUNDArray::CPUNDArray(v134, 0, 0, 0);
    v56 = 0;
  }
  mlir::mps::CPUNDArray::CPUNDArray(v133, v41, v56, 0);
  v67 = v136;
  v68 = (float32x4_t *)v133[5];
  v146 = v148;
  v147 = 0x600000000;
  if (v7)
  {
    for (i = 0; i != v7; ++i)
    {
      v132 = *(ZinIrHalH13g **)(Inputs + 32 * i + 24);
      v70 = (uint64_t *)(*((_QWORD *)v132 + 1) & 0xFFFFFFFFFFFFFFF8);
      if (!v70)
        goto LABEL_75;
      v71 = *v70;
      v72 = mlir::TypeID::get<mlir::ShapedType>();
      v73 = *(unsigned int *)(v71 + 16);
      if (!(_DWORD)v73)
        goto LABEL_75;
      v74 = *(_QWORD **)(v71 + 8);
      v75 = &v74[2 * v73];
      do
      {
        v76 = v73 >> 1;
        v77 = &v74[2 * (v73 >> 1)];
        v79 = *v77;
        v78 = v77 + 2;
        v73 += ~(v73 >> 1);
        if (v79 < v72)
          v74 = v78;
        else
          v73 = v76;
      }
      while (v73);
      if (v74 != v75 && *v74 == v72)
        v80 = v74[1];
      else
LABEL_75:
        v80 = 0;
      ElementsAttr = v70;
      v144 = v80;
      v81 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)&ElementsAttr) + 8);
      v131 = (ZinIrHalH13g *)mlir::Value::getDefiningOp((mlir::Value *)&v132);
      v82 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v131);
      v83 = v147;
      if (v147 >= (unint64_t)HIDWORD(v147))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v146, v148, v147 + 1, 8);
        v83 = v147;
      }
      v146[v83] = v82;
      LODWORD(v147) = v147 + 1;
      ElementsAttr = v145;
      v144 = 0xC00000000;
      v140 = v142;
      v141 = 0xC00000000;
      Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v131);
      mlir::matchConstantWithFloatVector<float>(Filter, (uint64_t)&ElementsAttr);
      Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v131);
      mlir::matchConstantWithFloatVector<float>(Bias, (uint64_t)&v140);
      v86 = v144;
      if ((_DWORD)v144 == 1)
      {
        if (v81 < 1)
          goto LABEL_97;
        v87 = (__int32 *)ElementsAttr;
        if ((unint64_t)v81 < 8
          || v67 < (float32x4_t *)((char *)ElementsAttr + 4) && ElementsAttr < &v67->f32[v81])
        {
          v88 = 0;
          v89 = v67;
LABEL_84:
          v90 = v81 - v88;
          v67 = v89;
          do
          {
            v67->i32[0] = *v87;
            v67 = (float32x4_t *)((char *)v67 + 4);
            --v90;
          }
          while (v90);
          goto LABEL_97;
        }
        v88 = v81 & 0x7FFFFFFFFFFFFFF8;
        v89 = (float32x4_t *)((char *)v67 + 4 * (v81 & 0xFFFFFFFFFFFFFFF8));
        v123 = vld1q_dup_f32((const float *)ElementsAttr);
        v124 = v67 + 1;
        v125 = v81 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v124[-1] = v123;
          *v124 = v123;
          v124 += 2;
          v125 -= 8;
        }
        while (v125);
        v67 = (float32x4_t *)((char *)v67 + 4 * (v81 & 0xFFFFFFFFFFFFFFF8));
        if (v81 != v88)
          goto LABEL_84;
      }
      else
      {
        if (!(_DWORD)v144)
          goto LABEL_97;
        v91 = (char *)ElementsAttr;
        v92 = (v144 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v92 < 7 || (unint64_t)((char *)v67 - (_BYTE *)ElementsAttr) < 0x20)
        {
          v95 = v67;
          v96 = (char *)ElementsAttr;
LABEL_95:
          v101 = &v91[4 * v86];
          v67 = v95;
          do
          {
            v102 = *(_DWORD *)v96;
            v96 += 4;
            v67->i32[0] = v102;
            v67 = (float32x4_t *)((char *)v67 + 4);
          }
          while (v96 != v101);
          goto LABEL_97;
        }
        v93 = v92 + 1;
        v94 = (v92 + 1) & 0x7FFFFFFFFFFFFFF8;
        v95 = (float32x4_t *)((char *)v67 + 4 * v94);
        v96 = (char *)ElementsAttr + 4 * v94;
        v97 = (__int128 *)((char *)ElementsAttr + 16);
        f32 = (_OWORD *)v67[1].f32;
        v99 = v94;
        do
        {
          v100 = *v97;
          *(f32 - 1) = *(v97 - 1);
          *f32 = v100;
          v97 += 2;
          f32 += 2;
          v99 -= 8;
        }
        while (v99);
        v67 = (float32x4_t *)((char *)v67 + 4 * v94);
        if (v93 != v94)
          goto LABEL_95;
      }
LABEL_97:
      v103 = v141;
      v104 = (__int32 *)v140;
      if ((_DWORD)v141 == 1)
      {
        if (v81 >= 1)
        {
          if ((unint64_t)v81 >= 8
            && (v68 < (float32x4_t *)((char *)v140 + 4) ? (v105 = v140 >= &v68->f32[v81]) : (v105 = 1), v105))
          {
            v106 = v81 & 0x7FFFFFFFFFFFFFF8;
            v107 = (float32x4_t *)((char *)v68 + 4 * (v81 & 0xFFFFFFFFFFFFFFF8));
            v108 = vld1q_dup_f32((const float *)v140);
            v109 = v68 + 1;
            v110 = v81 & 0xFFFFFFFFFFFFFFF8;
            do
            {
              v109[-1] = v108;
              *v109 = v108;
              v109 += 2;
              v110 -= 8;
            }
            while (v110);
            v68 = (float32x4_t *)((char *)v68 + 4 * (v81 & 0xFFFFFFFFFFFFFFF8));
            if (v81 == v106)
              goto LABEL_123;
          }
          else
          {
            v106 = 0;
            v107 = v68;
          }
          v120 = v81 - v106;
          v68 = v107;
          do
          {
            v68->i32[0] = *v104;
            v68 = (float32x4_t *)((char *)v68 + 4);
            --v120;
          }
          while (v120);
        }
      }
      else if ((_DWORD)v141)
      {
        v111 = (v141 - 1) & 0x3FFFFFFFFFFFFFFFLL;
        if (v111 < 7 || (unint64_t)((char *)v68 - (_BYTE *)v140) < 0x20)
        {
          v114 = v68;
          v115 = (__int32 *)v140;
        }
        else
        {
          v112 = v111 + 1;
          v113 = (v111 + 1) & 0x7FFFFFFFFFFFFFF8;
          v114 = (float32x4_t *)((char *)v68 + 4 * v113);
          v115 = (__int32 *)((char *)v140 + 4 * v113);
          v116 = (__int128 *)((char *)v140 + 16);
          v117 = (_OWORD *)v68[1].f32;
          v118 = v113;
          do
          {
            v119 = *v116;
            *(v117 - 1) = *(v116 - 1);
            *v117 = v119;
            v116 += 2;
            v117 += 2;
            v118 -= 8;
          }
          while (v118);
          v68 = (float32x4_t *)((char *)v68 + 4 * v113);
          if (v112 == v113)
            goto LABEL_123;
        }
        v121 = &v104[v103];
        v68 = v114;
        do
        {
          v122 = *v115++;
          v68->i32[0] = v122;
          v68 = (float32x4_t *)((char *)v68 + 4);
        }
        while (v115 != v121);
      }
LABEL_123:
      if (v104 != (__int32 *)v142)
        free(v104);
      if (ElementsAttr != v145)
        free(ElementsAttr);
    }
  }
  ElementsAttr = mlir::anec::Concat::getAxis(&v139);
  LOBYTE(v132) = mlir::anec::Concat::getInterleave(&v139);
  v140 = mlir::OpBuilder::create<mlir::anec::Concat,llvm::SmallVector<mlir::Value,6u> &,unsigned long long,BOOL>(v130, v4, (uint64_t)&v146, (uint64_t *)&ElementsAttr, (unsigned __int8 *)&v132);
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v134, 0, 1);
  v144 = v126;
  v132 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v130, v4, &v137, (_QWORD **)&ElementsAttr);
  ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v133, 0, 1);
  v144 = v127;
  v131 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v130, v4, &v137, (_QWORD **)&ElementsAttr);
  v128 = v139;
  v129 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::anec::Concat &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(v130, *((_QWORD *)v139 + 3), v138, &v140, &v132, &v131);
  (*(void (**)(uint64_t, mlir::Operation *, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v128, v129);
  if (v146 != (_QWORD *)v148)
    free(v146);
  mlir::mps::CPUNDArray::~CPUNDArray(v133);
  mlir::mps::CPUNDArray::~CPUNDArray(v134);
  if (ElementTypeOrSelf != v152)
    free(ElementTypeOrSelf);
  return 1;
}

uint64_t mlir::matchConstantWithFloatVector<float>(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _QWORD v13[2];
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17[2];
  _QWORD v18[2];

  v18[1] = *MEMORY[0x24BDAC8D0];
  v14 = 0;
  v15 = 0;
  if (!a1)
    return 0;
  v16 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  if (!DefiningOp)
    return 0;
  v4 = DefiningOp;
  v5 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 32))(*(_QWORD *)(v4 + 48), v5))
    return 0;
  v17[0] = v18;
  v17[1] = (void *)0x100000000;
  mlir::Operation::fold(v4, 0, 0, (uint64_t)v17);
  v6 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8));
  v8 = v6;
  if (v6)
  {
    v14 = v6;
    v15 = v7;
  }
  if (v17[0] != v18)
    free(v17[0]);
  if (!v8)
    return 0;
  v13[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v14);
  v13[1] = v9;
  v10 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v13) + 136);
  if (v10 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    && v10 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    return 0;
  }
  v11 = 1;
  mlir::getIntValues<float>((uint64_t)v14, v15, a2, 1);
  return v11;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Concat,llvm::SmallVector<mlir::Value,6u> &,unsigned long long,BOOL>(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.concat", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.concat";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v11);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Concat::build(a1, (uint64_t)v22, v21[0], v21[1], *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::Concat &>(mlir::anec::Concat &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::anec::Concat &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.gain_offset_control";
    v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4 - 16, *a5 - 16, *a6 - 16);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

BOOL mlir::OperationPass<mlir::ModuleOp>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

void mlir::PDLPatternModule::~PDLPatternModule(mlir::PDLPatternModule *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v15;

  if (*((_DWORD *)this + 33))
  {
    v2 = *((unsigned int *)this + 32);
    if ((_DWORD)v2)
    {
      v3 = 0;
      while (1)
      {
        v6 = *(_QWORD **)(*((_QWORD *)this + 15) + v3);
        if (v6 != (_QWORD *)-8 && v6 != 0)
          break;
        v3 += 8;
        if (8 * v2 == v3)
          goto LABEL_15;
      }
      v8 = *v6;
      v4 = (_QWORD *)v6[4];
      if (v4 == v6 + 1)
      {
        v4 = v6 + 1;
        v5 = 4;
      }
      else
      {
        if (!v4)
LABEL_6:
          llvm::deallocate_buffer((llvm *)v6, (void *)(v8 + 41));
        v5 = 5;
      }
      (*(void (**)(void))(*v4 + 8 * v5))();
      goto LABEL_6;
    }
  }
LABEL_15:
  free(*((void **)this + 15));
  if (!*((_DWORD *)this + 27) || (v9 = *((unsigned int *)this + 26), !(_DWORD)v9))
  {
LABEL_29:
    free(*((void **)this + 12));
    llvm::deallocate_buffer(*((llvm **)this + 9), (void *)(16 * *((unsigned int *)this + 22)));
  }
  v10 = 0;
  while (1)
  {
    v13 = *(_QWORD **)(*((_QWORD *)this + 12) + v10);
    if (v13 != (_QWORD *)-8 && v13 != 0)
      break;
    v10 += 8;
    if (8 * v9 == v10)
      goto LABEL_29;
  }
  v15 = *v13;
  v11 = (_QWORD *)v13[4];
  if (v11 == v13 + 1)
  {
    v11 = v13 + 1;
    v12 = 4;
  }
  else
  {
    if (!v11)
LABEL_20:
      llvm::deallocate_buffer((llvm *)v13, (void *)(v15 + 41));
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
  goto LABEL_20;
}

uint64_t sub_2071367E0()
{
  uint64_t v0;

  llvm::SmallVector<std::unique_ptr<mlir::PDLPatternConfigSet>,6u>::~SmallVector((char **)(v0 + 8));
  if (*(_QWORD *)v0)
    mlir::Operation::erase(*(mlir::Operation **)v0);
  return v0;
}

char **llvm::SmallVector<std::unique_ptr<mlir::PDLPatternConfigSet>,6u>::~SmallVector(char **a1)
{
  char *v2;
  uint64_t v3;
  char *v4;
  char **v5;
  char **v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = &v2[8 * v3];
    do
    {
      v6 = (char **)*((_QWORD *)v4 - 1);
      v4 -= 8;
      v5 = v6;
      *(_QWORD *)v4 = 0;
      if (v6)
      {
        v7 = *v5;
        v8 = *((unsigned int *)v5 + 2);
        if ((_DWORD)v8)
        {
          v9 = 8 * v8;
          v10 = v7 - 8;
          do
          {
            v11 = *(_QWORD *)&v10[v9];
            *(_QWORD *)&v10[v9] = 0;
            if (v11)
              (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
            v9 -= 8;
          }
          while (v9);
          v7 = *v5;
        }
        if (v7 != (char *)(v5 + 2))
          free(v7);
        MEMORY[0x20BD002F8](v5, 0x1080C407559D7D1);
      }
    }
    while (v4 != v2);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

llvm::raw_ostream *OUTLINED_FUNCTION_0_8(const char *a1, size_t a2)
{
  llvm::raw_ostream *v2;

  return llvm::raw_ostream::operator<<(v2, a1, a2);
}

void mlir::anec::getANECConvCanonicalizationPatterns(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  const char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  const char *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  _QWORD *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  const char *v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  _QWORD *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  uint64_t *v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  unint64_t v105;

  v2 = *a1;
  v3 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v104, 3);
  mlir::Pattern::Pattern(v3 + 8, (uint64_t)"anec.input_view", 15, (__int16)v104, v2, 0, 0);
  *(_QWORD *)v3 = &off_24C0514C0;
  if (!*(_QWORD *)(v3 + 72))
  {
    v104 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_PadDeconvCrop1Folding]";
    v105 = 111;
    v4 = llvm::StringRef::find((uint64_t *)&v104, "DesiredTypeName = ", 0x12uLL, 0);
    if (v105 >= v4)
      v5 = v4;
    else
      v5 = v105;
    v6 = &v104[v5];
    v7 = v105 - v5;
    if (v105 - v5 >= 0x12)
      v8 = 18;
    else
      v8 = v105 - v5;
    v9 = &v6[v8];
    v10 = v7 - v8;
    if (v10 >= v10 - 1)
      --v10;
    *(_QWORD *)(v3 + 64) = v9;
    *(_QWORD *)(v3 + 72) = v10;
  }
  v11 = *(unsigned int *)(v3 + 88);
  if (v11 > *(_DWORD *)(v3 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 80, (void *)(v3 + 96), v11, 16);
    LODWORD(v11) = *(_DWORD *)(v3 + 88);
  }
  *(_DWORD *)(v3 + 88) = v11;
  v13 = (char *)a1[2];
  v12 = a1[3];
  if ((unint64_t)v13 >= v12)
  {
    v15 = (char *)a1[1];
    v16 = (v13 - v15) >> 3;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      goto LABEL_119;
    v18 = v12 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        goto LABEL_120;
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = (uint64_t *)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v3;
    v14 = v21 + 1;
    if (v13 == v15)
    {
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
    }
    else
    {
      v23 = v13 - v15 - 8;
      if (v23 < 0x78
        || &v13[-(v23 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v21
        && &v20[v13 - v15 - (v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v13)
      {
        goto LABEL_123;
      }
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v26 = &v13[-v25];
      v21 = (uint64_t *)((char *)v21 - v25);
      v27 = &v20[8 * v16 - 16];
      v28 = v13 - 16;
      v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v31 = *((_OWORD *)v28 - 1);
        v30 = *(_OWORD *)v28;
        *((_OWORD *)v28 - 1) = 0uLL;
        *(_OWORD *)v28 = 0uLL;
        *((_OWORD *)v27 - 1) = v31;
        *(_OWORD *)v27 = v30;
        v27 -= 32;
        v28 -= 32;
        v29 -= 4;
      }
      while (v29);
      v13 = v26;
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_123:
        do
        {
          v32 = *((_QWORD *)v13 - 1);
          v13 -= 8;
          *(_QWORD *)v13 = 0;
          *--v21 = v32;
        }
        while (v13 != v15);
      }
      v13 = (char *)a1[1];
      v33 = (char *)a1[2];
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
      while (v33 != v13)
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        v34 = v35;
        *(_QWORD *)v33 = 0;
        if (v35)
          (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
      }
    }
    if (v13)
      operator delete(v13);
  }
  else
  {
    *(_QWORD *)v13 = v3;
    v14 = v13 + 8;
  }
  a1[2] = (uint64_t)v14;
  v36 = *a1;
  v37 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v104, 4);
  mlir::Pattern::Pattern(v37 + 8, (uint64_t)"anec.input_view", 15, (__int16)v104, v36, 0, 0);
  *(_QWORD *)v37 = &off_24C051500;
  if (!*(_QWORD *)(v37 + 72))
  {
    v104 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_PadDeconvCrop2Folding]";
    v105 = 111;
    v38 = llvm::StringRef::find((uint64_t *)&v104, "DesiredTypeName = ", 0x12uLL, 0);
    if (v105 >= v38)
      v39 = v38;
    else
      v39 = v105;
    v40 = &v104[v39];
    v41 = v105 - v39;
    if (v105 - v39 >= 0x12)
      v42 = 18;
    else
      v42 = v105 - v39;
    v43 = &v40[v42];
    v44 = v41 - v42;
    if (v44 >= v44 - 1)
      --v44;
    *(_QWORD *)(v37 + 64) = v43;
    *(_QWORD *)(v37 + 72) = v44;
  }
  v45 = *(unsigned int *)(v37 + 88);
  if (v45 > *(_DWORD *)(v37 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v37 + 80, (void *)(v37 + 96), v45, 16);
    LODWORD(v45) = *(_DWORD *)(v37 + 88);
  }
  *(_DWORD *)(v37 + 88) = v45;
  v47 = (char *)a1[2];
  v46 = a1[3];
  if ((unint64_t)v47 >= v46)
  {
    v49 = (char *)a1[1];
    v50 = (v47 - v49) >> 3;
    v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61)
      goto LABEL_119;
    v52 = v46 - (_QWORD)v49;
    if (v52 >> 2 > v51)
      v51 = v52 >> 2;
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8)
      v53 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v53 = v51;
    if (v53)
    {
      if (v53 >> 61)
        goto LABEL_120;
      v54 = (char *)operator new(8 * v53);
    }
    else
    {
      v54 = 0;
    }
    v55 = (uint64_t *)&v54[8 * v50];
    v56 = &v54[8 * v53];
    *v55 = v37;
    v48 = v55 + 1;
    if (v47 == v49)
    {
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
    }
    else
    {
      v57 = v47 - v49 - 8;
      if (v57 < 0x78
        || &v47[-(v57 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v55
        && &v54[v47 - v49 - (v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v47)
      {
        goto LABEL_124;
      }
      v58 = (v57 >> 3) + 1;
      v59 = 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      v60 = &v47[-v59];
      v55 = (uint64_t *)((char *)v55 - v59);
      v61 = &v54[8 * v50 - 16];
      v62 = v47 - 16;
      v63 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v65 = *((_OWORD *)v62 - 1);
        v64 = *(_OWORD *)v62;
        *((_OWORD *)v62 - 1) = 0uLL;
        *(_OWORD *)v62 = 0uLL;
        *((_OWORD *)v61 - 1) = v65;
        *(_OWORD *)v61 = v64;
        v61 -= 32;
        v62 -= 32;
        v63 -= 4;
      }
      while (v63);
      v47 = v60;
      if (v58 != (v58 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_124:
        do
        {
          v66 = *((_QWORD *)v47 - 1);
          v47 -= 8;
          *(_QWORD *)v47 = 0;
          *--v55 = v66;
        }
        while (v47 != v49);
      }
      v47 = (char *)a1[1];
      v67 = (char *)a1[2];
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
      while (v67 != v47)
      {
        v69 = *((_QWORD *)v67 - 1);
        v67 -= 8;
        v68 = v69;
        *(_QWORD *)v67 = 0;
        if (v69)
          (*(void (**)(uint64_t))(*(_QWORD *)v68 + 8))(v68);
      }
    }
    if (v47)
      operator delete(v47);
  }
  else
  {
    *(_QWORD *)v47 = v37;
    v48 = v47 + 8;
  }
  a1[2] = (uint64_t)v48;
  v70 = *a1;
  v71 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v104, 2);
  mlir::Pattern::Pattern(v71 + 8, (uint64_t)"anec.deconvolution", 18, (__int16)v104, v70, 0, 0);
  *(_QWORD *)v71 = &off_24C051410;
  if (!*(_QWORD *)(v71 + 72))
  {
    v104 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_PadDeconvFolding]";
    v105 = 106;
    v72 = llvm::StringRef::find((uint64_t *)&v104, "DesiredTypeName = ", 0x12uLL, 0);
    if (v105 >= v72)
      v73 = v72;
    else
      v73 = v105;
    v74 = &v104[v73];
    v75 = v105 - v73;
    if (v105 - v73 >= 0x12)
      v76 = 18;
    else
      v76 = v105 - v73;
    v77 = &v74[v76];
    v78 = v75 - v76;
    if (v78 >= v78 - 1)
      --v78;
    *(_QWORD *)(v71 + 64) = v77;
    *(_QWORD *)(v71 + 72) = v78;
  }
  v79 = *(unsigned int *)(v71 + 88);
  if (v79 > *(_DWORD *)(v71 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v71 + 80, (void *)(v71 + 96), v79, 16);
    LODWORD(v79) = *(_DWORD *)(v71 + 88);
  }
  *(_DWORD *)(v71 + 88) = v79;
  v81 = (char *)a1[2];
  v80 = a1[3];
  if ((unint64_t)v81 < v80)
  {
    *(_QWORD *)v81 = v71;
    v82 = v81 + 8;
    goto LABEL_118;
  }
  v83 = (char *)a1[1];
  v84 = (v81 - v83) >> 3;
  v85 = v84 + 1;
  if ((unint64_t)(v84 + 1) >> 61)
LABEL_119:
    abort();
  v86 = v80 - (_QWORD)v83;
  if (v86 >> 2 > v85)
    v85 = v86 >> 2;
  if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8)
    v87 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v87 = v85;
  if (!v87)
  {
    v88 = 0;
    goto LABEL_103;
  }
  if (v87 >> 61)
LABEL_120:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v88 = (char *)operator new(8 * v87);
LABEL_103:
  v89 = (uint64_t *)&v88[8 * v84];
  v90 = &v88[8 * v87];
  *v89 = v71;
  v82 = v89 + 1;
  if (v81 == v83)
  {
    a1[1] = (uint64_t)v89;
    a1[2] = (uint64_t)v82;
    a1[3] = (uint64_t)v90;
  }
  else
  {
    v91 = v81 - v83 - 8;
    if (v91 < 0x78
      || &v81[-(v91 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v89
      && &v88[v81 - v83 - (v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v81)
    {
      goto LABEL_125;
    }
    v92 = (v91 >> 3) + 1;
    v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
    v94 = &v81[-v93];
    v89 = (uint64_t *)((char *)v89 - v93);
    v95 = &v88[8 * v84 - 16];
    v96 = v81 - 16;
    v97 = v92 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v99 = *((_OWORD *)v96 - 1);
      v98 = *(_OWORD *)v96;
      *((_OWORD *)v96 - 1) = 0uLL;
      *(_OWORD *)v96 = 0uLL;
      *((_OWORD *)v95 - 1) = v99;
      *(_OWORD *)v95 = v98;
      v95 -= 32;
      v96 -= 32;
      v97 -= 4;
    }
    while (v97);
    v81 = v94;
    if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_125:
      do
      {
        v100 = *((_QWORD *)v81 - 1);
        v81 -= 8;
        *(_QWORD *)v81 = 0;
        *--v89 = v100;
      }
      while (v81 != v83);
    }
    v81 = (char *)a1[1];
    v101 = (char *)a1[2];
    a1[1] = (uint64_t)v89;
    a1[2] = (uint64_t)v82;
    a1[3] = (uint64_t)v90;
    while (v101 != v81)
    {
      v103 = *((_QWORD *)v101 - 1);
      v101 -= 8;
      v102 = v103;
      *(_QWORD *)v101 = 0;
      if (v103)
        (*(void (**)(uint64_t))(*(_QWORD *)v102 + 8))(v102);
    }
  }
  if (v81)
    operator delete(v81);
LABEL_118:
  a1[2] = (uint64_t)v82;
}

void mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::~ANEC_PadDeconvCrop1Folding(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop1Folding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop1Folding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mlir::Operation *v8;
  uint64_t DefiningOp;
  uint64_t v10;
  int v11;
  uint64_t InherentAttr;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(int, uint64_t);
  uint64_t v17;
  uint64_t v18;
  mlir::Operation *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  char v25;
  uint64_t ODSResults;
  mlir::Operation *v28;
  uint64_t v29;
  mlir::Operation *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::Operation *v38;
  mlir::Operation *v39;
  uint64_t v40;
  _QWORD v41[2];
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *NextResultAtOffset;
  uint64_t v59;
  uint64_t v60;
  mlir::Operation *v61;
  _QWORD *v62;
  uint64_t v63;
  _QWORD v64[5];

  v64[4] = *MEMORY[0x24BDAC8D0];
  v55 = 0;
  v56 = 0;
  v53 = 0;
  v54 = 0;
  v51 = 0;
  v52 = 0;
  v49 = 0;
  v50 = 0;
  v48 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
  {
    v5 = *((unsigned int *)a2 + 17);
    v46 = *((_QWORD *)a2 + 9);
    v47 = v5;
    v44 = 0;
    v45 = 0;
    v42 = 0;
    v43 = 0;
    v6 = *((_QWORD *)a2 + 9);
    v7 = *((unsigned int *)a2 + 17);
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v46 = 0;
    v47 = 0;
    v44 = 0;
    v45 = 0;
    v42 = 0;
    v43 = 0;
  }
  v41[0] = v6;
  v41[1] = v7;
  v40 = 0;
  v62 = v64;
  v64[0] = a2;
  v63 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v8 = a2;
  else
    v8 = 0;
  v38 = v8;
  v39 = v8;
  NextResultAtOffset = *(uint64_t **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v38, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
  if (!DefiningOp)
  {
    v18 = *((_QWORD *)a3 + 2);
    if (!v18)
      goto LABEL_48;
    v19 = v38;
    if (mlir::RewriterBase::Listener::classof(v18))
    {
      goto LABEL_22;
    }
    goto LABEL_47;
  }
  v10 = DefiningOp;
  v11 = v63;
  if (v63 >= HIDWORD(v63))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v64, v63 + 1, 8);
    v11 = v63;
  }
  v62[v11] = v10;
  LODWORD(v63) = v63 + 1;
  if (!*((_BYTE *)a2 + 47)
    || (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dimension", 9), !v13))
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dimension", 9uLL);
  }
  if (!InherentAttr
    || *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v14 = *((_QWORD *)a3 + 2);
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
LABEL_18:
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t **))(*(_QWORD *)v14 + 64))(v14, v15, v16, &NextResultAtOffset);
LABEL_22:
      v18 = v17;
      goto LABEL_48;
    }
    goto LABEL_47;
  }
  if (!*((_BYTE *)a2 + 47) || (v20 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"offset", 6), !v21))
    v20 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "offset", 6uLL);
  if (v20 && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    if (!*((_BYTE *)a2 + 47) || (v22 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"size", 4), !v23))
      v22 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "size", 4uLL);
    if (!v22 || *(_UNKNOWN **)(*(_QWORD *)v22 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v14 = *((_QWORD *)a3 + 2);
      if (v14 && mlir::RewriterBase::Listener::classof(v14))
      {
        v15 = *((_QWORD *)a2 + 3);
        goto LABEL_18;
      }
      goto LABEL_47;
    }
    if (!*((_BYTE *)a2 + 47) || (v24 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"step", 4), !v25))
      v24 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "step", 4uLL);
    if (!v24 || *(_UNKNOWN **)(*(_QWORD *)v24 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v14 = *((_QWORD *)a3 + 2);
      if (v14 && mlir::RewriterBase::Listener::classof(v14))
      {
        v15 = *((_QWORD *)a2 + 3);
        goto LABEL_18;
      }
      goto LABEL_47;
    }
    v53 = v24;
    ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v45, 0);
    NextResultAtOffset = (uint64_t *)mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
    v28 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
    v29 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v40, 0);
    v57 = mlir::detail::OpResultImpl::getNextResultAtOffset(v29, 0);
    v30 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v57);
    v31 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v39, 0);
    v37 = mlir::detail::OpResultImpl::getNextResultAtOffset(v31, 0);
    v61 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v37);
    v32 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v39, 0);
    v33 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v32, 0);
    {
      goto LABEL_22;
    }
    mlir::IntegerAttr::getValue(&v53, (llvm::APInt *)&NextResultAtOffset);
    v34 = v59;
    if (v59 >= 0x41)
    {
      if (v34 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&NextResultAtOffset) >= 0x41)
      {
        if (NextResultAtOffset)
          MEMORY[0x20BD002D4](NextResultAtOffset, 0x1000C8000313F17);
        goto LABEL_62;
      }
      v35 = *NextResultAtOffset;
      MEMORY[0x20BD002D4]();
      if (v35 != 1)
      {
LABEL_62:
        goto LABEL_22;
      }
    }
    else if (NextResultAtOffset != (uint64_t *)1)
    {
      goto LABEL_62;
    }
    v36 = *(_QWORD *)(v62[1] + 24);
    NextResultAtOffset = *(uint64_t **)(*v62 + 24);
    v59 = v36;
    v60 = *(_QWORD *)(v62[2] + 24);
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, &NextResultAtOffset, (mlir::MLIRContext *)3, 0);
  }
  v14 = *((_QWORD *)a3 + 2);
  if (v14 && mlir::RewriterBase::Listener::classof(v14))
  {
    v15 = *((_QWORD *)a2 + 3);
    goto LABEL_18;
  }
LABEL_47:
  v18 = 0;
LABEL_48:
  if (v62 != v64)
    free(v62);
  return v18;
}

uint64_t mlir::anec::`anonymous namespace'::static_dag_matcher_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, uint64_t *a15, _QWORD *a16, _QWORD *a17, uint64_t *a18)
{
  uint64_t v20;
  uint64_t DefiningOp;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t InherentAttr;
  char v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t IntegerAttr;
  char v43;
  mlir::Builder *v44;
  uint64_t IntegerType;
  uint64_t v46;
  char v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t result;
  uint64_t v54;
  uint64_t (*v55)(int, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;

  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v20 = a2;
  else
    v20 = 0;
  v63 = v20;
  if (!v20)
  {
    v52 = *(_QWORD *)(a1 + 16);
    if (v52)
    {
      result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
      if (!(_DWORD)result)
        return result;
      v54 = *(_QWORD *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v52 + 64))(v52, v54, v55, &v62);
    }
    return 0;
  }
  *a6 = v20;
  v62 = *(_QWORD *)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v63, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v62);
  if (DefiningOp)
  {
    v27 = DefiningOp;
    {
      v28 = *(unsigned int *)(a3 + 8);
      if (v28 >= *(_DWORD *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v28 + 1, 8);
        LODWORD(v28) = *(_DWORD *)(a3 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a3 + 8 * v28) = v27;
      ++*(_DWORD *)(a3 + 8);
      *a17 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v63, 1u);
      a17[1] = v29;
      if (!*(_BYTE *)(a2 + 47) || (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"stride", 6), !v31))
        InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "stride", 6uLL);
      v32 = InherentAttr;
      if (InherentAttr && (mlir::DenseIntElementsAttr::classof(InherentAttr) & 1) != 0)
      {
        *a11 = v32;
        if (!*(_BYTE *)(a2 + 47) || (v33 = mlir::Operation::getInherentAttr(a2, (uint64_t)"dilation", 8), !v34))
          v33 = mlir::DictionaryAttr::get(a2 + 56, "dilation", 8uLL);
        v35 = v33;
        if (v33 && (mlir::DenseIntElementsAttr::classof(v33) & 1) != 0)
        {
          *a10 = v35;
          if (!*(_BYTE *)(a2 + 47) || (v36 = mlir::Operation::getInherentAttr(a2, (uint64_t)"padding", 7), !v37))
            v36 = mlir::DictionaryAttr::get(a2 + 56, "padding", 7uLL);
          v38 = v36;
          if (v36 && (mlir::DenseIntElementsAttr::classof(v36) & 1) != 0)
          {
            *a12 = v38;
            if (!*(_BYTE *)(a2 + 47)
              || (v39 = mlir::Operation::getInherentAttr(a2, (uint64_t)"padding_mode", 12), !v40))
            {
              v39 = mlir::DictionaryAttr::get(a2 + 56, "padding_mode", 0xCuLL);
            }
            v41 = v39;
            if (!v39 || (mlir::anec::PaddingModeAttr::classof(v39) & 1) == 0)
              v41 = mlir::anec::BoxCoordinateModeAttr::get(*(_QWORD *)(a1 + 8), 0);
            *a8 = v41;
            if (!*(_BYTE *)(a2 + 47)
              || (IntegerAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"groups", 6), !v43))
            {
              IntegerAttr = mlir::DictionaryAttr::get(a2 + 56, "groups", 6uLL);
            }
            if (!IntegerAttr
              || *(_UNKNOWN **)(*(_QWORD *)IntegerAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            {
              v44 = (mlir::Builder *)(a1 + 8);
              IntegerType = mlir::Builder::getIntegerType(v44, 0x40u, 0);
              IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)v44, IntegerType, 1);
            }
            *a9 = IntegerAttr;
            if (!*(_BYTE *)(a2 + 47)
              || (v46 = mlir::Operation::getInherentAttr(a2, (uint64_t)"channel_wise", 12), !v47))
            {
              v46 = mlir::DictionaryAttr::get(a2 + 56, "channel_wise", 0xCuLL);
            }
            if (!v46
              || *(_UNKNOWN **)(*(_QWORD *)v46 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            {
              v46 = 0;
            }
            *a5 = v46;
            if (!*(_BYTE *)(a2 + 47)
              || (v48 = mlir::Operation::getInherentAttr(a2, (uint64_t)"kernel_scale", 12), !v49))
            {
              v48 = mlir::DictionaryAttr::get(a2 + 56, "kernel_scale", 0xCuLL);
            }
            v50 = v48;
            if (v48)
            {
              if (mlir::DenseFPElementsAttr::classof(v48))
                v51 = v50;
              else
                v51 = 0;
            }
            else
            {
              v51 = 0;
            }
            *a4 = v51;
            if (!*(_BYTE *)(a2 + 47)
              || (v58 = mlir::Operation::getInherentAttr(a2, (uint64_t)"kernel_zero_point", 17), !v59))
            {
              v58 = mlir::DictionaryAttr::get(a2 + 56, "kernel_zero_point", 0x11uLL);
            }
            v60 = v58;
            if (v58)
            {
              if (mlir::DenseIntElementsAttr::classof(v58))
                v61 = v60;
              else
                v61 = 0;
            }
            else
            {
              v61 = 0;
            }
            *a15 = v61;
            return 1;
          }
          v52 = *(_QWORD *)(a1 + 16);
          if (v52)
          {
            result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
            if (!(_DWORD)result)
              return result;
            v54 = *(_QWORD *)(a2 + 24);
            return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v52 + 64))(v52, v54, v55, &v62);
          }
        }
        else
        {
          v52 = *(_QWORD *)(a1 + 16);
          if (v52)
          {
            result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
            if (!(_DWORD)result)
              return result;
            v54 = *(_QWORD *)(a2 + 24);
            return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v52 + 64))(v52, v54, v55, &v62);
          }
        }
      }
      else
      {
        v52 = *(_QWORD *)(a1 + 16);
        if (v52)
        {
          result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
          if (!(_DWORD)result)
            return result;
          v54 = *(_QWORD *)(a2 + 24);
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v52 + 64))(v52, v54, v55, &v62);
        }
      }
    }
    return 0;
  }
  v56 = *(_QWORD *)(a1 + 16);
  if (!v56)
    return 0;
  v57 = v63;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
  return result;
}

uint64_t mlir::Operation::getAttrOfType<mlir::IntegerAttr>(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result;
  char v7;

  if (!*(_BYTE *)(a1 + 47) || (result = mlir::Operation::getInherentAttr(a1, (uint64_t)a2, a3), !v7))
    result = mlir::DictionaryAttr::get(a1 + 56, a2, a3);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)result + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      return 0;
  }
  return result;
}

uint64_t mlir::anec::`anonymous namespace'::tryCanonDeconvPaddings(mlir::Operation *a1, mlir::Operation *a2, mlir::Operation **a3, uint64_t a4, _QWORD *a5, uint64_t *a6, uint64_t *a7)
{
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t *v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t PaddingSizes;
  char *v25;
  uint64_t v26;
  _QWORD *v27;
  char *v29;
  __int128 v30;
  __int128 v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t Padding;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  _BOOL4 v41;
  BOOL v42;
  uint64_t PaddingModes;
  char *v45;
  char *v46;
  __int128 v47;
  _WORD *v48;
  char *v49;
  int v50;
  uint64_t PaddingMode;
  uint64_t v53;
  uint64_t *v54;
  char *v55;
  uint64_t Stride;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  mlir::Operation **v63;
  uint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t *v74;
  uint64_t *Dimension;
  unint64_t v76;
  uint64_t DimFromIndex;
  uint64_t *Offset;
  unsigned int v79;
  uint64_t v80;
  uint64_t *Size;
  uint64_t v82;
  uint64_t *v83;
  char *v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  const void *Shape;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  double v96;
  void *v97;
  llvm::APFloatBase *v98;
  uint64_t v99;
  __int128 v100;
  uint64_t v101;
  uint64_t *v102[4];
  __int16 v103;
  mlir::Operation *v104;
  unint64_t v105;
  unint64_t v106;
  __int128 v107;
  __int128 v108;
  mlir::Operation *v109;
  mlir::Operation *v110;
  void *v111;
  unsigned int v112;
  uint64_t v113;
  __int16 v114;
  void *v115[2];
  _BYTE v116[24];
  void *v117;
  uint64_t v118;
  _WORD v119[24];
  void *v120;
  uint64_t v121;
  _WORD v122[40];
  uint64_t v123;
  _QWORD v124[25];

  v124[23] = *MEMORY[0x24BDAC8D0];
  v109 = a2;
  v110 = a1;
  while (1)
  {
    a5 = (_QWORD *)*a5;
    if (!a5)
      break;
    if (*(_UNKNOWN **)(*(_QWORD *)(a5[2] + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    {
      v11 = "Pattern can be further extended";
LABEL_34:
      v120 = v11;
      v122[8] = 259;
      mlir::Operation::emitOpError((uint64_t *)a1, (const void ***)&v120, (uint64_t)&v123);
      v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
      if (v123)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v123);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v124);
      return v12;
    }
  }
  v12 = *(_QWORD *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v110) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v12)
    goto LABEL_14;
  v13 = *(_QWORD *)v12;
  v14 = mlir::TypeID::get<mlir::ShapedType>();
  v15 = *(unsigned int *)(v13 + 16);
  if (!(_DWORD)v15)
    goto LABEL_14;
  v16 = *(_QWORD **)(v13 + 8);
  v17 = &v16[2 * v15];
  do
  {
    v18 = v15 >> 1;
    v19 = &v16[2 * (v15 >> 1)];
    v21 = *v19;
    v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14)
      v16 = v20;
    else
      v15 = v18;
  }
  while (v15);
  if (v16 != v17 && *v16 == v14)
    v22 = v16[1];
  else
LABEL_14:
    v22 = 0;
  v123 = v12;
  v124[0] = v22;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v123);
  if (v23 != 4)
  {
    a1 = v110;
    v11 = "Conv2D input must be 4D";
    goto LABEL_34;
  }
  v120 = v122;
  v121 = 0xA00000000;
  PaddingSizes = mlir::anec::Padding::getPaddingSizes((mlir::anec::Padding *)&v109);
  mlir::getValues<unsigned long long>(PaddingSizes, (uint64_t)&v120);
  v25 = (char *)v120;
  v26 = v121 - 4;
  if (v121 != 4)
  {
    v27 = v120;
    while (!*v27++)
    {
      if (!--v26)
        goto LABEL_20;
    }
    v117 = "Padding on Batch / Depth / Channel dimension not supported";
    v119[8] = 259;
    mlir::Operation::emitOpError((uint64_t *)v110, (const void ***)&v117, (uint64_t)&v123);
    v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
    if (v123)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v123);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v124);
    goto LABEL_124;
  }
LABEL_20:
  v29 = (char *)v120 + 8 * v121;
  v30 = *((_OWORD *)v29 - 3);
  v31 = *((_OWORD *)v29 - 1);
  *((_OWORD *)v120 + 1) = *((_OWORD *)v29 - 2);
  *((_OWORD *)v25 + 2) = v31;
  *(_OWORD *)v25 = v30;
  v32 = v120;
  v33 = v25 - (_BYTE *)v120 + 48;
  LODWORD(v121) = v33 >> 3;
  if (!(_DWORD)v121)
  {
LABEL_24:
    v35 = 0;
    v36 = 0;
    goto LABEL_25;
  }
  v34 = 8 * (v33 >> 3);
  while (!*v32)
  {
    ++v32;
    v34 -= 8;
    if (!v34)
      goto LABEL_24;
  }
  v117 = v119;
  v118 = 0x500000000;
  PaddingModes = mlir::anec::Padding::getPaddingModes((mlir::anec::Padding *)&v109);
  mlir::getValues<unsigned long long>(PaddingModes, (uint64_t)&v117);
  v45 = (char *)v117;
  v46 = (char *)v117 + 8 * v118;
  v47 = *(_OWORD *)(v46 - 24);
  *((_QWORD *)v117 + 2) = *((_QWORD *)v46 - 1);
  *(_OWORD *)v45 = v47;
  v48 = v117;
  LODWORD(v118) = (unint64_t)(v45 - (_BYTE *)v117 + 24) >> 3;
  if (*((_QWORD *)v120 + 2) || *((_QWORD *)v120 + 3))
  {
    if (*((_QWORD *)v120 + 4) || *((_QWORD *)v120 + 5))
    {
      v49 = (char *)v117 + 8;
      if (*((_QWORD *)v117 + 1) != *((_QWORD *)v117 + 2))
      {
        v111 = "Padding mode must be the same on all axes";
        v114 = 259;
        mlir::Operation::emitOpError((uint64_t *)v110, (const void ***)&v111, (uint64_t)&v123);
        v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
        if (v123)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v123);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v124);
        v36 = 0;
        v50 = 0;
        v48 = v117;
        goto LABEL_118;
      }
    }
    else
    {
      v49 = (char *)v117 + 8;
    }
  }
  else
  {
    v49 = (char *)v117 + 16;
  }
  v36 = *(_QWORD *)v49;
  v50 = 1;
LABEL_118:
  if (v48 != v119)
    free(v48);
  if (!v50)
    goto LABEL_124;
  if (v36 == 6)
  {
    mlir::anec::Padding::getBackgroundValue(&v109, (uint64_t)&v123);
    v96 = llvm::APFloat::convertToDouble((llvm::APFloat *)&v123);
    v97 = (void *)v124[0];
    if (llvm::APFloatBase::PPCDoubleDouble(v98) == v97)
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v124);
    else
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v124);
    if (v96 == 0.0)
      v36 = 0;
    else
      v36 = 6;
  }
  v35 = 1;
LABEL_25:
  v117 = v119;
  v118 = 0x600000000;
  Padding = mlir::anec::Deconvolution::getPadding((mlir::anec::Deconvolution *)&v110);
  mlir::getValues<unsigned long long>(Padding, (uint64_t)&v117);
  if ((_DWORD)v118)
  {
    v38 = (uint64_t *)v117;
    v39 = 8 * v118 - 8;
    do
    {
      v40 = *v38++;
      v41 = v40 != 0;
      if (v40)
        v42 = 1;
      else
        v42 = v39 == 0;
      v39 -= 8;
    }
    while (!v42);
  }
  else
  {
    v41 = 0;
  }
  PaddingMode = mlir::anec::Deconvolution::getPaddingMode(&v110);
  if ((v35 & v41) != 1 || v36 == PaddingMode)
  {
    if (v41)
      v53 = PaddingMode;
    else
      v53 = 0;
    if (v35)
      v53 = v36;
    if ((v53 & 0xFFFFFFFFFFFFFFFDLL) == 0)
    {
      v101 = v53;
      v115[0] = v116;
      v115[1] = (void *)0x300000000;
      Stride = mlir::anec::Deconvolution::getStride((mlir::anec::Deconvolution *)&v110);
      mlir::getValues<long long>(Stride, (uint64_t)v115);
      v57 = *((_QWORD *)v120 + 3);
      v58 = *((_QWORD *)v117 + 3);
      v60 = *((_QWORD *)v115[0] + 1);
      v59 = *((_QWORD *)v115[0] + 2);
      v61 = *((_QWORD *)v117 + 2) + v60 * *((_QWORD *)v120 + 2);
      v105 = 0;
      v106 = 0;
      *(_QWORD *)&v107 = v61;
      *((_QWORD *)&v107 + 1) = v58 + v60 * v57;
      v62 = *((_QWORD *)v117 + 5) + v59 * *((_QWORD *)v120 + 5);
      *(_QWORD *)&v108 = *((_QWORD *)v117 + 4) + v59 * *((_QWORD *)v120 + 4);
      *((_QWORD *)&v108 + 1) = v62;
      if (a4)
      {
        v63 = &a3[a4];
        while (1)
        {
          v104 = *a3;
          v64 = (uint64_t *)(*(_QWORD *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v104) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v64)
            goto LABEL_79;
          v65 = *v64;
          v66 = mlir::TypeID::get<mlir::ShapedType>();
          v67 = *(unsigned int *)(v65 + 16);
          if (!(_DWORD)v67)
            goto LABEL_79;
          v68 = *(_QWORD **)(v65 + 8);
          v69 = &v68[2 * v67];
          do
          {
            v70 = v67 >> 1;
            v71 = &v68[2 * (v67 >> 1)];
            v73 = *v71;
            v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66)
              v68 = v72;
            else
              v67 = v70;
          }
          while (v67);
          if (v68 != v69 && *v68 == v66)
            v74 = (uint64_t *)v68[1];
          else
LABEL_79:
            v74 = 0;
          v102[0] = v64;
          v102[1] = v74;
          Dimension = mlir::anec::InputView::getDimension(&v104);
          mlir::ShapedType::getShape((mlir::ShapedType *)v102);
          DimFromIndex = mlir::anec::getDimFromIndex((mlir::anec *)Dimension, v76);
          if ((DimFromIndex & 0xFF00000000) == 0 || (DimFromIndex - 3) >= 2)
            break;
          Offset = mlir::anec::InputView::getOffset(&v104);
          v79 = mlir::anec::InputView::getDimension(&v104);
          v80 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)v102) + 8 * v79);
          Size = mlir::anec::InputView::getSize(&v104);
          mlir::ShapedType::getShape((mlir::ShapedType *)v102);
          v83 = (uint64_t *)(&v105 + 2 * ((_QWORD)mlir::anec::InputView::getDimension(&v104) - v82));
          v84 = (char *)Size + (_QWORD)Offset - v80 + v83[7];
          v83[6] -= (uint64_t)Offset;
          v83[7] = (uint64_t)v84;
          if (++a3 == v63)
            goto LABEL_85;
        }
        v111 = "Cropping on batch / depth / channel dimension not supported";
        v114 = 259;
        mlir::Operation::emitOpError((uint64_t *)v110, (const void ***)&v111, (uint64_t)&v123);
        v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
        if (v123)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v123);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v124);
      }
      else
      {
LABEL_85:
        if ((v105 & 0x8000000000000000) != 0)
        {
          v86 = v105 >> 63;
        }
        else
        {
          v85 = v106;
          if ((v106 & 0x8000000000000000) == 0)
          {
            v85 = v107;
            if ((v107 & 0x8000000000000000) == 0)
            {
              v85 = *((_QWORD *)&v107 + 1);
              if ((*((_QWORD *)&v107 + 1) & 0x8000000000000000) == 0)
              {
                v85 = v108;
                if ((v108 & 0x8000000000000000) == 0)
                  v85 = *((_QWORD *)&v108 + 1);
              }
            }
          }
          v86 = v85 >> 63;
        }
        if ((_DWORD)v86)
        {
          v111 = "Cropping output required";
          v114 = 259;
          mlir::Operation::emitOpError((uint64_t *)v110, (const void ***)&v111, (uint64_t)&v123);
          v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v123);
        }
        else
        {
          v102[0] = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v110) + 8) & 0xFFFFFFFFFFFFFFF8);
          v123 = (uint64_t)mlir::Type::cast<mlir::ShapedType>(v102);
          v124[0] = v87;
          Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v123);
          llvm::SmallVector<long long,5u>::SmallVector<long long,void>(&v111, Shape, v89);
          if (v112 <= 4)
          {
            v123 = 1;
            llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v111, (uint64_t)v111 + 16, &v123);
          }
          v90 = *((_QWORD *)v111 + 3);
          if ((uint64_t)v107 >= v90)
            goto LABEL_111;
          if (*((uint64_t *)&v107 + 1) >= v90)
            goto LABEL_111;
          v91 = *((_QWORD *)v111 + 4);
          if ((uint64_t)v108 >= v91 || *((uint64_t *)&v108 + 1) >= v91)
            goto LABEL_111;
          v92 = 2 * v90;
          v93 = v90 < -1;
          v94 = ((_BYTE)v90 + 1) & 1;
          if (v93)
            v94 = -v94;
          if (*((_QWORD *)&v107 + 1) + (_QWORD)v107 > v92 - *((_QWORD *)v115[0] + 1) - v94)
            goto LABEL_111;
          v95 = (v91 + 1) & 1;
          if (v91 < -1)
            v95 = -v95;
          if (*((_QWORD *)&v108 + 1) + (_QWORD)v108 <= 2 * v91 - *((_QWORD *)v115[0] + 2) - v95)
          {
            if (a6)
              *a6 = v101;
            if (a7)
            {
              llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)a7, 6uLL);
              v99 = *a7;
              *(_QWORD *)v99 = 0;
              *(_QWORD *)(v99 + 8) = 0;
              v100 = v108;
              *(_OWORD *)(v99 + 16) = v107;
              *(_OWORD *)(v99 + 32) = v100;
            }
            v12 = 1;
          }
          else
          {
LABEL_111:
            v102[0] = (uint64_t *)"Padding value not supported by ANEC";
            v103 = 259;
            mlir::Operation::emitOpError((uint64_t *)v110, (const void ***)v102, (uint64_t)&v123);
            v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v123);
          }
          if (v111 != &v113)
            free(v111);
        }
      }
      if (v115[0] != v116)
        free(v115[0]);
      goto LABEL_65;
    }
    v54 = (uint64_t *)v110;
    v55 = "Unsupported padding mode";
  }
  else
  {
    v54 = (uint64_t *)v110;
    v55 = "Padding mode of Deconv and Pad ops must be the same";
  }
  v111 = v55;
  v114 = 259;
  mlir::Operation::emitOpError(v54, (const void ***)&v111, (uint64_t)&v123);
  v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v123);
  if (v123)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v123);
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v124);
LABEL_65:
  if (v117 != v119)
    free(v117);
LABEL_124:
  if (v120 != v122)
    free(v120);
  return v12;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

char *mlir::anec::`anonymous namespace'::canonDeconvPaddings(uint64_t a1, uint64_t a2, mlir::Operation *a3, mlir::Operation *a4, mlir::Operation **a5, uint64_t a6, _QWORD *a7)
{
  mlir::Builder *v9;
  uint64_t IntegerType;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t *v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  ZinIrHalH13g *v23;
  uint64_t KernelZeroPointAttr;
  uint64_t KernelScaleAttr;
  BOOL ChannelWise;
  uint64_t *Groups;
  uint64_t Dilation;
  uint64_t Stride;
  uint64_t Filter;
  uint64_t Input;
  uint64_t v33;
  mlir::Operation *v34;
  mlir::Operation *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[11];

  v39[10] = *MEMORY[0x24BDAC8D0];
  v34 = a4;
  v35 = a3;
  v33 = 0;
  v37 = v39;
  v38 = 0xA00000000;
  v36 = 6;
  v9 = (mlir::Builder *)(a1 + 8);
  IntegerType = mlir::Builder::getIntegerType(v9, 0x40u, 0);
  v11 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v36, 1, IntegerType, 0);
  v12 = v11;
  if (!v11)
    goto LABEL_10;
  v13 = *v11;
  v14 = mlir::TypeID::get<mlir::ShapedType>();
  v15 = *(unsigned int *)(v13 + 16);
  if (!(_DWORD)v15)
    goto LABEL_10;
  v16 = *(_QWORD **)(v13 + 8);
  v17 = &v16[2 * v15];
  do
  {
    v18 = v15 >> 1;
    v19 = &v16[2 * (v15 >> 1)];
    v21 = *v19;
    v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14)
      v16 = v20;
    else
      v15 = v18;
  }
  while (v15);
  if (v16 != v17 && *v16 == v14)
    v22 = v16[1];
  else
LABEL_10:
    v22 = 0;
  v36 = mlir::DenseElementsAttr::getFromRawBuffer(v12, v22, v37, 8 * v38, 8, 1, 0);
  Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v34);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v35);
  Stride = mlir::anec::Deconvolution::getStride((mlir::anec::Deconvolution *)&v35);
  Dilation = mlir::anec::Deconvolution::getDilation((mlir::anec::Deconvolution *)&v35);
  Groups = mlir::anec::Convolution::getGroups(&v35);
  ChannelWise = mlir::anec::Deconvolution::getChannelWise(&v35);
  KernelScaleAttr = mlir::anec::Convolution::getKernelScaleAttr(&v35);
  KernelZeroPointAttr = mlir::anec::Convolution::getKernelZeroPointAttr(&v35);
  v23 = mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::MemRefType>,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::anec::PaddingMode &,unsigned long long,BOOL,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>((uint64_t *)v9, a2, &Input, &Filter, &Stride, &Dilation, &v36, &v33, (uint64_t *)&Groups, (char *)&ChannelWise, &KernelScaleAttr, &KernelZeroPointAttr);
  if (v37 != v39)
    free(v37);
  return (char *)v23 - 16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t mlir::anec::`anonymous namespace'::static_dag_matcher_0(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v9;
  uint64_t v14;
  uint64_t InherentAttr;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  char v30;
  char v31;
  uint64_t v32;

  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id)
    v9 = a2;
  else
    v9 = 0;
  v32 = v9;
  if (v9)
  {
    *a6 = v9;
    *a3 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v32, 0);
    a3[1] = v14;
    if (*(_BYTE *)(a2 + 47)
      && (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"padding_modes", 13), v16))
    {
      v17 = InherentAttr;
      if (!InherentAttr)
      {
LABEL_24:
        v25 = *(_QWORD *)(a1 + 16);
        if (v25)
        {
          result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
          if ((_DWORD)result)
          return result;
        }
        return 0;
      }
    }
    else
    {
      v17 = mlir::DictionaryAttr::get(a2 + 56, "padding_modes", 0xDuLL);
      if (!v17)
        goto LABEL_24;
    }
    if ((mlir::DenseIntElementsAttr::classof(v17) & 1) == 0)
      goto LABEL_24;
    *a7 = v17;
    if (!*(_BYTE *)(a2 + 47) || (v18 = mlir::Operation::getInherentAttr(a2, (uint64_t)"padding_sizes", 13), !v19))
      v18 = mlir::DictionaryAttr::get(a2 + 56, "padding_sizes", 0xDuLL);
    v20 = v18;
    if (v18 && (mlir::DenseIntElementsAttr::classof(v18) & 1) != 0)
    {
      *a4 = v20;
      if (!*(_BYTE *)(a2 + 47) || (v21 = mlir::Operation::getInherentAttr(a2, (uint64_t)"background_value", 16), !v22))
        v21 = mlir::DictionaryAttr::get(a2 + 56, "background_value", 0x10uLL);
      if (v21 && *(_UNKNOWN **)(*(_QWORD *)v21 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        *a5 = v21;
        return 1;
      }
      v23 = *(_QWORD *)(a1 + 16);
      if (!v23)
        return 0;
      result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
      if ((_DWORD)result)
    }
    else
    {
      v27 = *(_QWORD *)(a1 + 16);
      if (!v27)
        return 0;
      result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
      if ((_DWORD)result)
    }
  }
  else
  {
    v26 = *(_QWORD *)(a1 + 16);
    if (!v26)
      return 0;
    result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
    if ((_DWORD)result)
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::Deconvolution type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_1>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp1");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::Padding type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_1>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.padding' to have attribute 'padding_modes' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_2>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.padding' to have attribute 'padding_sizes' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::anec::Padding &,mlir::DenseIntElementsAttr &)::$_3>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.padding' to have attribute 'background_value' of type '::mlir::FloatAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_2>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_3>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::static_dag_matcher_1(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseFPElementsAttr &,mlir::UnitAttr &,mlir::anec::Deconvolution &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingModeAttr &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::anec::Padding &)::$_4>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'dimension' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'offset' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'size' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'step' of type '::mlir::IntegerAttr'");
}

_QWORD *llvm::SmallVector<long long,5u>::SmallVector<long long,void>(_QWORD *a1, const void *a2, uint64_t a3)
{
  size_t v6;
  unsigned int v7;

  *a1 = a1 + 2;
  a1[1] = 0x500000000;
  v6 = 8 * a3;
  if ((unint64_t)(8 * a3) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, (8 * a3) >> 3, 8);
    v7 = *((_DWORD *)a1 + 2);
    if (!a3)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = 0;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + (v6 >> 3);
  return a1;
}

void llvm::SmallVectorImpl<unsigned long long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), a2, 8);
        v2 = *(unsigned int *)(a1 + 8);
      }
      if (a2 != v2)
        bzero((void *)(*(_QWORD *)a1 + 8 * v2), 8 * (a2 - v2));
    }
    *(_DWORD *)(a1 + 8) = a2;
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'conv_op, pad_op, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop1Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'iv1_step' failed to satisfy constraint: ''");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Deconvolution,mlir::detail::TypedValue<mlir::MemRefType>,mlir::detail::TypedValue<mlir::MemRefType>,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr&,mlir::anec::PaddingMode &,unsigned long long,BOOL,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, char *a10, uint64_t *a11, uint64_t *a12)
{
  uint64_t *Context;
  uint64_t v21;
  char v22;
  ZinIrHalH13g *v23;
  ZinIrHalH13g *v24;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _QWORD v31[40];

  v31[38] = *MEMORY[0x24BDAC8D0];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.deconvolution", (const unsigned __int8 *)0x12, Context);
  if (!v22)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"anec.deconvolution";
    v29[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v21);
  mlir::anec::Deconvolution::build(a1, (uint64_t)v31, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12);
  v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v23 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v24 = v23;
  else
    v24 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v24;
}

void mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::~ANEC_PadDeconvCrop2Folding(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop2Folding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvCrop2Folding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  uint64_t v6;
  mlir::Operation *v7;
  uint64_t DefiningOp;
  uint64_t v9;
  void *v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(int, uint64_t);
  uint64_t v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t InherentAttr;
  char v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t (*v33)(int, uint64_t);
  uint64_t v34;
  char v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  char v39;
  uint64_t ODSResults;
  mlir::Operation *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  mlir::Operation *v57;
  mlir::Operation *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[2];
  uint64_t v63;
  uint64_t v64;
  _QWORD v65[2];
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t NextResultAtOffset;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  _QWORD v85[5];

  v85[4] = *MEMORY[0x24BDAC8D0];
  v75 = 0;
  v76 = 0;
  v73 = 0;
  v74 = 0;
  v71 = 0;
  v72 = 0;
  v69 = 0;
  v70 = 0;
  v67 = 0;
  v68 = 0;
  v66 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
  {
    v5 = *((_QWORD *)a2 + 9);
    v6 = *((unsigned int *)a2 + 17);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v65[0] = v5;
  v65[1] = v6;
  v63 = 0;
  v64 = 0;
  v62[0] = v5;
  v62[1] = v6;
  v60 = 0;
  v61 = 0;
  v59 = 0;
  v83 = v85;
  v85[0] = a2;
  v84 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v7 = a2;
  else
    v7 = 0;
  v57 = v7;
  v58 = v7;
  v78 = *(uint64_t **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v57, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v78);
  if (!DefiningOp)
  {
    v13 = *((_QWORD *)a3 + 2);
    if (!v13)
      goto LABEL_85;
    v17 = v57;
    if (mlir::RewriterBase::Listener::classof(v13))
    {
      goto LABEL_18;
    }
    goto LABEL_84;
  }
  v9 = DefiningOp;
  v10 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v12 = (uint64_t *)DefiningOp;
  else
    v12 = 0;
  v78 = v12;
  if (!v11)
  {
    v13 = *((_QWORD *)a3 + 2);
    if (!v13)
      goto LABEL_85;
    if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
    {
      v14 = *(_QWORD *)(v9 + 24);
LABEL_14:
      v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v13 + 64))(v13, v14, v15, &NextResultAtOffset);
LABEL_18:
      v13 = v16;
      goto LABEL_85;
    }
    goto LABEL_84;
  }
  v60 = DefiningOp;
  NextResultAtOffset = *(_QWORD *)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v78, 0) + 24);
  v18 = mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
  if (!v18)
  {
    v13 = *((_QWORD *)a3 + 2);
    if (!v13)
      goto LABEL_85;
    v23 = v78;
    if (mlir::RewriterBase::Listener::classof(v13))
    {
      v14 = v23[3];
      goto LABEL_14;
    }
    goto LABEL_84;
  }
  v19 = v18;
  {
    v20 = v84;
    if (v84 >= HIDWORD(v84))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v85, v84 + 1, 8);
      v20 = v84;
    }
    v83[v20] = v19;
    LODWORD(v84) = v84 + 1;
    if (!*(_BYTE *)(v9 + 47) || (InherentAttr = mlir::Operation::getInherentAttr(v9, (uint64_t)"dimension", 9), !v22))
      InherentAttr = mlir::DictionaryAttr::get(v9 + 56, "dimension", 9uLL);
    if (!InherentAttr
      || *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v13 = *((_QWORD *)a3 + 2);
      if (!v13)
        goto LABEL_85;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
        v14 = *(_QWORD *)(v9 + 24);
        goto LABEL_14;
      }
      goto LABEL_84;
    }
    if (!*(_BYTE *)(v9 + 47) || (v24 = mlir::Operation::getInherentAttr(v9, (uint64_t)"offset", 6), !v25))
      v24 = mlir::DictionaryAttr::get(v9 + 56, "offset", 6uLL);
    if (!v24 || *(_UNKNOWN **)(*(_QWORD *)v24 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v13 = *((_QWORD *)a3 + 2);
      if (!v13)
        goto LABEL_85;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
        v14 = *(_QWORD *)(v9 + 24);
        goto LABEL_14;
      }
      goto LABEL_84;
    }
    if (!*(_BYTE *)(v9 + 47) || (v26 = mlir::Operation::getInherentAttr(v9, (uint64_t)"size", 4), !v27))
      v26 = mlir::DictionaryAttr::get(v9 + 56, "size", 4uLL);
    if (!v26 || *(_UNKNOWN **)(*(_QWORD *)v26 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      goto LABEL_18;
    }
    v28 = mlir::Operation::getAttrOfType<mlir::IntegerAttr>(v9, "step", 4uLL);
    if (!v28)
    {
      goto LABEL_18;
    }
    v68 = v28;
    llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back((uint64_t)&v83, v9);
    if (!*((_BYTE *)a2 + 47) || (v29 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dimension", 9), !v30))
      v29 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dimension", 9uLL);
    if (!v29 || *(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v31 = *((_QWORD *)a3 + 2);
      if (!v31 || !mlir::RewriterBase::Listener::classof(v31))
        goto LABEL_84;
      v32 = *((_QWORD *)a2 + 3);
LABEL_57:
      v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t **))(*(_QWORD *)v31 + 64))(v31, v32, v33, &v78);
      goto LABEL_18;
    }
    if (!*((_BYTE *)a2 + 47) || (v34 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"offset", 6), !v35))
      v34 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "offset", 6uLL);
    if (!v34 || *(_UNKNOWN **)(*(_QWORD *)v34 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v31 = *((_QWORD *)a3 + 2);
      if (!v31 || !mlir::RewriterBase::Listener::classof(v31))
        goto LABEL_84;
      v32 = *((_QWORD *)a2 + 3);
      goto LABEL_57;
    }
    if (!*((_BYTE *)a2 + 47) || (v36 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"size", 4), !v37))
      v36 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "size", 4uLL);
    if (!v36 || *(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v31 = *((_QWORD *)a3 + 2);
      if (!v31 || !mlir::RewriterBase::Listener::classof(v31))
        goto LABEL_84;
      v32 = *((_QWORD *)a2 + 3);
      goto LABEL_57;
    }
    if (!*((_BYTE *)a2 + 47) || (v38 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"step", 4), !v39))
      v38 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "step", 4uLL);
    if (!v38 || *(_UNKNOWN **)(*(_QWORD *)v38 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v31 = *((_QWORD *)a3 + 2);
      if (!v31 || !mlir::RewriterBase::Listener::classof(v31))
        goto LABEL_84;
      v32 = *((_QWORD *)a2 + 3);
      goto LABEL_57;
    }
    v74 = v38;
    ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v63, 0);
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
    v42 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
    v43 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v61, 0);
    v82 = mlir::detail::OpResultImpl::getNextResultAtOffset(v43, 0);
    v44 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v82);
    v45 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v60, 0);
    v56 = mlir::detail::OpResultImpl::getNextResultAtOffset(v45, 0);
    v78 = (uint64_t *)mlir::Value::getDefiningOp((mlir::Value *)&v56);
    v46 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
    v55 = mlir::detail::OpResultImpl::getNextResultAtOffset(v46, 0);
    v79 = mlir::Value::getDefiningOp((mlir::Value *)&v55);
    v47 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v58, 0);
    v48 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v47, 0);
    {
      goto LABEL_18;
    }
    mlir::IntegerAttr::getValue(&v68, (llvm::APInt *)&v78);
    v49 = v79;
    if (v79 >= 0x41)
    {
      if (v49 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78) >= 0x41)
      {
        if (v78)
          MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
        goto LABEL_100;
      }
      v50 = *v78;
      MEMORY[0x20BD002D4]();
      if (v50 != 1)
      {
LABEL_100:
        goto LABEL_18;
      }
    }
    else if (v78 != (uint64_t *)1)
    {
      goto LABEL_100;
    }
    mlir::IntegerAttr::getValue(&v74, (llvm::APInt *)&v78);
    v51 = v79;
    if (v79 >= 0x41)
    {
      if (v51 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78) >= 0x41)
      {
        if (v78)
          MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
        goto LABEL_106;
      }
      v52 = *v78;
      MEMORY[0x20BD002D4]();
      if (v52 != 1)
      {
LABEL_106:
        goto LABEL_18;
      }
    }
    else if (v78 != (uint64_t *)1)
    {
      goto LABEL_106;
    }
    v53 = *(_QWORD *)(v83[1] + 24);
    v78 = *(uint64_t **)(*v83 + 24);
    v79 = v53;
    v54 = *(_QWORD *)(v83[3] + 24);
    v80 = *(_QWORD *)(v83[2] + 24);
    v81 = v54;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, &v78, (mlir::MLIRContext *)4, 0);
  }
LABEL_84:
  v13 = 0;
LABEL_85:
  if (v83 != v85)
    free(v83);
  return v13;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#13}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#14}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::anec::InputView type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp1");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'dimension' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'offset' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'size' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#7}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'step' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#8}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'dimension' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#9}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'offset' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#10}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'size' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#11}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.input_view' to have attribute 'step' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#12}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'conv_op, pad_op, crop_op, out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#13}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'iv1_step' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvCrop2Folding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#14}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'iv2_step' failed to satisfy constraint: ''");
}

void mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::~ANEC_PadDeconvFolding(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvFolding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_PadDeconvFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  uint64_t v6;
  mlir::Operation *v7;
  uint64_t DefiningOp;
  uint64_t v9;
  int v10;
  uint64_t InherentAttr;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  char v20;
  uint64_t IntegerType;
  char v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  char v26;
  uint64_t ODSResults;
  mlir::Operation *v28;
  uint64_t v29;
  mlir::Operation *v30;
  uint64_t v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  mlir::Operation *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(int, uint64_t);
  mlir::Operation *v41;
  uint64_t v42;
  mlir::Operation *v43;
  _QWORD v44[2];
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *NextResultAtOffset;
  void *v49[6];
  _QWORD *v50;
  uint64_t v51;
  _QWORD v52[5];

  v52[4] = *MEMORY[0x24BDAC8D0];
  v46 = 0;
  v47 = 0;
  v45 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
  {
    v5 = *((_QWORD *)a2 + 9);
    v6 = *((unsigned int *)a2 + 17);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v44[0] = v5;
  v44[1] = v6;
  v42 = 0;
  v50 = v52;
  v52[0] = a2;
  v51 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    v7 = a2;
  else
    v7 = 0;
  v41 = v7;
  v43 = v7;
  v49[0] = *(void **)(mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v41, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v49);
  if (!DefiningOp)
  {
    v34 = *((_QWORD *)a3 + 2);
    if (!v34)
      goto LABEL_70;
    v35 = v41;
    if (mlir::RewriterBase::Listener::classof(v34))
    {
LABEL_65:
      v34 = v36;
      goto LABEL_70;
    }
    goto LABEL_69;
  }
  v9 = DefiningOp;
  v10 = v51;
  if (v51 >= HIDWORD(v51))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v51 + 1, 8);
    v10 = v51;
  }
  v50[v10] = v9;
  LODWORD(v51) = v51 + 1;
  mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v41, 1u);
  if (!*((_BYTE *)a2 + 47)
    || (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"stride", 6), !v12))
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "stride", 6uLL);
  }
  if (!InherentAttr || (mlir::DenseIntElementsAttr::classof(InherentAttr) & 1) == 0)
  {
    v37 = *((_QWORD *)a3 + 2);
    if (!v37 || !mlir::RewriterBase::Listener::classof(v37))
      goto LABEL_69;
    v38 = *((_QWORD *)a2 + 3);
    goto LABEL_64;
  }
  if (!*((_BYTE *)a2 + 47) || (v13 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dilation", 8), !v14))
    v13 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dilation", 8uLL);
  if (!v13 || (mlir::DenseIntElementsAttr::classof(v13) & 1) == 0)
  {
    v37 = *((_QWORD *)a3 + 2);
    if (!v37 || !mlir::RewriterBase::Listener::classof(v37))
      goto LABEL_69;
    v38 = *((_QWORD *)a2 + 3);
    goto LABEL_64;
  }
  if (!*((_BYTE *)a2 + 47) || (v15 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding", 7), !v16))
    v15 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding", 7uLL);
  if (!v15 || (mlir::DenseIntElementsAttr::classof(v15) & 1) == 0)
  {
    v37 = *((_QWORD *)a3 + 2);
    if (!v37 || !mlir::RewriterBase::Listener::classof(v37))
      goto LABEL_69;
    v38 = *((_QWORD *)a2 + 3);
LABEL_64:
    v36 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v37 + 64))(v37, v38, v39, v49);
    goto LABEL_65;
  }
  if (!*((_BYTE *)a2 + 47)
    || (v17 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"padding_mode", 12), !v18))
  {
    v17 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "padding_mode", 0xCuLL);
  }
  if (!v17 || (mlir::anec::PaddingModeAttr::classof(v17) & 1) == 0)
    mlir::anec::BoxCoordinateModeAttr::get(*((_QWORD *)a3 + 1), 0);
  if (!*((_BYTE *)a2 + 47) || (v19 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"groups", 6), !v20))
    v19 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "groups", 6uLL);
  if (!v19 || *(_UNKNOWN **)(*(_QWORD *)v19 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::PatternRewriter *)((char *)a3 + 8), 0x40u, 0);
    mlir::Builder::getIntegerAttr((uint64_t)a3 + 8, IntegerType, 1);
  }
  if (!*((_BYTE *)a2 + 47) || (mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"channel_wise", 12), !v22))
    mlir::DictionaryAttr::get((uint64_t)a2 + 56, "channel_wise", 0xCuLL);
  if (!*((_BYTE *)a2 + 47)
    || (v23 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_scale", 12), !v24))
  {
    v23 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_scale", 0xCuLL);
  }
  if (v23)
    mlir::DenseFPElementsAttr::classof(v23);
  if (!*((_BYTE *)a2 + 47)
    || (v25 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"kernel_zero_point", 17), !v26))
  {
    v25 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "kernel_zero_point", 0x11uLL);
  }
  if (v25)
    mlir::DenseIntElementsAttr::classof(v25);
  ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v43, 0);
  v49[0] = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  v28 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v49);
  v29 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v42, 0);
  NextResultAtOffset = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v29, 0);
  v30 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
  v31 = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v43, 0);
  v32 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v31, 0);
  {
    v33 = *(void **)(v50[1] + 24);
    v49[0] = *(void **)(*v50 + 24);
    v49[1] = v33;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v49, (mlir::MLIRContext *)2, 0);
  }
  v37 = *((_QWORD *)a3 + 2);
  if (v37 && mlir::RewriterBase::Listener::classof(v37))
  {
    v38 = *((_QWORD *)a2 + 3);
    goto LABEL_64;
  }
LABEL_69:
  v34 = 0;
LABEL_70:
  if (v50 != v52)
    free(v50);
  return v34;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'stride' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'dilation' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.deconvolution' to have attribute 'padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_PadDeconvFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out, pad_op' failed to satisfy constraint: ''");
}

void mlir::anec::getANECLateCanonicalizationPatterns(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  const char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  const char *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  _QWORD *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  const char *v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  _QWORD *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  uint64_t *v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  const char *v108;
  unint64_t v109;
  uint64_t v110;
  const char *v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  char *v115;
  _QWORD *v116;
  char *v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  uint64_t *v123;
  char *v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  char *v129;
  char *v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  uint64_t v134;
  char *v135;
  uint64_t v136;
  uint64_t v137;
  const char *v138;
  unint64_t v139;

  v2 = *a1;
  v3 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v138, 1);
  mlir::Pattern::Pattern(v3 + 8, (uint64_t)"anec.gain_offset_control", 24, (__int16)v138, v2, 0, 0);
  *(_QWORD *)v3 = &off_24C050EF0;
  if (!*(_QWORD *)(v3 + 72))
  {
    v138 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_GOCFolding]";
    v139 = 100;
    v4 = llvm::StringRef::find((uint64_t *)&v138, "DesiredTypeName = ", 0x12uLL, 0);
    if (v139 >= v4)
      v5 = v4;
    else
      v5 = v139;
    v6 = &v138[v5];
    v7 = v139 - v5;
    if (v139 - v5 >= 0x12)
      v8 = 18;
    else
      v8 = v139 - v5;
    v9 = &v6[v8];
    v10 = v7 - v8;
    if (v10 >= v10 - 1)
      --v10;
    *(_QWORD *)(v3 + 64) = v9;
    *(_QWORD *)(v3 + 72) = v10;
  }
  v11 = *(unsigned int *)(v3 + 88);
  if (v11 > *(_DWORD *)(v3 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 80, (void *)(v3 + 96), v11, 16);
    LODWORD(v11) = *(_DWORD *)(v3 + 88);
  }
  *(_DWORD *)(v3 + 88) = v11;
  v13 = (char *)a1[2];
  v12 = a1[3];
  if ((unint64_t)v13 >= v12)
  {
    v15 = (char *)a1[1];
    v16 = (v13 - v15) >> 3;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      goto LABEL_158;
    v18 = v12 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        goto LABEL_159;
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = (uint64_t *)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v3;
    v14 = v21 + 1;
    if (v13 == v15)
    {
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
    }
    else
    {
      v23 = v13 - v15 - 8;
      if (v23 < 0x78
        || &v13[-(v23 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v21
        && &v20[v13 - v15 - (v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v13)
      {
        goto LABEL_162;
      }
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v26 = &v13[-v25];
      v21 = (uint64_t *)((char *)v21 - v25);
      v27 = &v20[8 * v16 - 16];
      v28 = v13 - 16;
      v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v31 = *((_OWORD *)v28 - 1);
        v30 = *(_OWORD *)v28;
        *((_OWORD *)v28 - 1) = 0uLL;
        *(_OWORD *)v28 = 0uLL;
        *((_OWORD *)v27 - 1) = v31;
        *(_OWORD *)v27 = v30;
        v27 -= 32;
        v28 -= 32;
        v29 -= 4;
      }
      while (v29);
      v13 = v26;
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_162:
        do
        {
          v32 = *((_QWORD *)v13 - 1);
          v13 -= 8;
          *(_QWORD *)v13 = 0;
          *--v21 = v32;
        }
        while (v13 != v15);
      }
      v13 = (char *)a1[1];
      v33 = (char *)a1[2];
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
      while (v33 != v13)
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        v34 = v35;
        *(_QWORD *)v33 = 0;
        if (v35)
          (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
      }
    }
    if (v13)
      operator delete(v13);
  }
  else
  {
    *(_QWORD *)v13 = v3;
    v14 = v13 + 8;
  }
  a1[2] = (uint64_t)v14;
  v36 = *a1;
  v37 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v138, 1);
  mlir::Pattern::Pattern(v37 + 8, (uint64_t)"anec.invert", 11, (__int16)v138, v36, 0, 0);
  *(_QWORD *)v37 = &off_24C051278;
  if (!*(_QWORD *)(v37 + 72))
  {
    v138 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_InvertFolding]";
    v139 = 103;
    v38 = llvm::StringRef::find((uint64_t *)&v138, "DesiredTypeName = ", 0x12uLL, 0);
    if (v139 >= v38)
      v39 = v38;
    else
      v39 = v139;
    v40 = &v138[v39];
    v41 = v139 - v39;
    if (v139 - v39 >= 0x12)
      v42 = 18;
    else
      v42 = v139 - v39;
    v43 = &v40[v42];
    v44 = v41 - v42;
    if (v44 >= v44 - 1)
      --v44;
    *(_QWORD *)(v37 + 64) = v43;
    *(_QWORD *)(v37 + 72) = v44;
  }
  v45 = *(unsigned int *)(v37 + 88);
  if (v45 > *(_DWORD *)(v37 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v37 + 80, (void *)(v37 + 96), v45, 16);
    LODWORD(v45) = *(_DWORD *)(v37 + 88);
  }
  *(_DWORD *)(v37 + 88) = v45;
  v47 = (char *)a1[2];
  v46 = a1[3];
  if ((unint64_t)v47 >= v46)
  {
    v49 = (char *)a1[1];
    v50 = (v47 - v49) >> 3;
    v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61)
      goto LABEL_158;
    v52 = v46 - (_QWORD)v49;
    if (v52 >> 2 > v51)
      v51 = v52 >> 2;
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8)
      v53 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v53 = v51;
    if (v53)
    {
      if (v53 >> 61)
        goto LABEL_159;
      v54 = (char *)operator new(8 * v53);
    }
    else
    {
      v54 = 0;
    }
    v55 = (uint64_t *)&v54[8 * v50];
    v56 = &v54[8 * v53];
    *v55 = v37;
    v48 = v55 + 1;
    if (v47 == v49)
    {
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
    }
    else
    {
      v57 = v47 - v49 - 8;
      if (v57 < 0x78
        || &v47[-(v57 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v55
        && &v54[v47 - v49 - (v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v47)
      {
        goto LABEL_163;
      }
      v58 = (v57 >> 3) + 1;
      v59 = 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      v60 = &v47[-v59];
      v55 = (uint64_t *)((char *)v55 - v59);
      v61 = &v54[8 * v50 - 16];
      v62 = v47 - 16;
      v63 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v65 = *((_OWORD *)v62 - 1);
        v64 = *(_OWORD *)v62;
        *((_OWORD *)v62 - 1) = 0uLL;
        *(_OWORD *)v62 = 0uLL;
        *((_OWORD *)v61 - 1) = v65;
        *(_OWORD *)v61 = v64;
        v61 -= 32;
        v62 -= 32;
        v63 -= 4;
      }
      while (v63);
      v47 = v60;
      if (v58 != (v58 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_163:
        do
        {
          v66 = *((_QWORD *)v47 - 1);
          v47 -= 8;
          *(_QWORD *)v47 = 0;
          *--v55 = v66;
        }
        while (v47 != v49);
      }
      v47 = (char *)a1[1];
      v67 = (char *)a1[2];
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
      while (v67 != v47)
      {
        v69 = *((_QWORD *)v67 - 1);
        v67 -= 8;
        v68 = v69;
        *(_QWORD *)v67 = 0;
        if (v69)
          (*(void (**)(uint64_t))(*(_QWORD *)v68 + 8))(v68);
      }
    }
    if (v47)
      operator delete(v47);
  }
  else
  {
    *(_QWORD *)v47 = v37;
    v48 = v47 + 8;
  }
  a1[2] = (uint64_t)v48;
  v70 = *a1;
  v71 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v138, 1);
  mlir::Pattern::Pattern(v71 + 8, (uint64_t)"anec.mult", 9, (__int16)v138, v70, 0, 0);
  *(_QWORD *)v71 = &off_24C050F30;
  if (!*(_QWORD *)(v71 + 72))
  {
    v138 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::ANEC_MulFolding]";
    v139 = 100;
    v72 = llvm::StringRef::find((uint64_t *)&v138, "DesiredTypeName = ", 0x12uLL, 0);
    if (v139 >= v72)
      v73 = v72;
    else
      v73 = v139;
    v74 = &v138[v73];
    v75 = v139 - v73;
    if (v139 - v73 >= 0x12)
      v76 = 18;
    else
      v76 = v139 - v73;
    v77 = &v74[v76];
    v78 = v75 - v76;
    if (v78 >= v78 - 1)
      --v78;
    *(_QWORD *)(v71 + 64) = v77;
    *(_QWORD *)(v71 + 72) = v78;
  }
  v79 = *(unsigned int *)(v71 + 88);
  if (v79 > *(_DWORD *)(v71 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v71 + 80, (void *)(v71 + 96), v79, 16);
    LODWORD(v79) = *(_DWORD *)(v71 + 88);
  }
  *(_DWORD *)(v71 + 88) = v79;
  v81 = (char *)a1[2];
  v80 = a1[3];
  if ((unint64_t)v81 >= v80)
  {
    v83 = (char *)a1[1];
    v84 = (v81 - v83) >> 3;
    v85 = v84 + 1;
    if ((unint64_t)(v84 + 1) >> 61)
      goto LABEL_158;
    v86 = v80 - (_QWORD)v83;
    if (v86 >> 2 > v85)
      v85 = v86 >> 2;
    if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8)
      v87 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v87 = v85;
    if (v87)
    {
      if (v87 >> 61)
        goto LABEL_159;
      v88 = (char *)operator new(8 * v87);
    }
    else
    {
      v88 = 0;
    }
    v89 = (uint64_t *)&v88[8 * v84];
    v90 = &v88[8 * v87];
    *v89 = v71;
    v82 = v89 + 1;
    if (v81 == v83)
    {
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
    }
    else
    {
      v91 = v81 - v83 - 8;
      if (v91 < 0x78
        || &v81[-(v91 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v89
        && &v88[v81 - v83 - (v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v81)
      {
        goto LABEL_164;
      }
      v92 = (v91 >> 3) + 1;
      v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
      v94 = &v81[-v93];
      v89 = (uint64_t *)((char *)v89 - v93);
      v95 = &v88[8 * v84 - 16];
      v96 = v81 - 16;
      v97 = v92 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v99 = *((_OWORD *)v96 - 1);
        v98 = *(_OWORD *)v96;
        *((_OWORD *)v96 - 1) = 0uLL;
        *(_OWORD *)v96 = 0uLL;
        *((_OWORD *)v95 - 1) = v99;
        *(_OWORD *)v95 = v98;
        v95 -= 32;
        v96 -= 32;
        v97 -= 4;
      }
      while (v97);
      v81 = v94;
      if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_164:
        do
        {
          v100 = *((_QWORD *)v81 - 1);
          v81 -= 8;
          *(_QWORD *)v81 = 0;
          *--v89 = v100;
        }
        while (v81 != v83);
      }
      v81 = (char *)a1[1];
      v101 = (char *)a1[2];
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
      while (v101 != v81)
      {
        v103 = *((_QWORD *)v101 - 1);
        v101 -= 8;
        v102 = v103;
        *(_QWORD *)v101 = 0;
        if (v103)
          (*(void (**)(uint64_t))(*(_QWORD *)v102 + 8))(v102);
      }
    }
    if (v81)
      operator delete(v81);
  }
  else
  {
    *(_QWORD *)v81 = v71;
    v82 = v81 + 8;
  }
  a1[2] = (uint64_t)v82;
  v104 = *a1;
  v105 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v138, 1);
  mlir::Pattern::Pattern(v105 + 8, (uint64_t)"anec.cast", 9, (__int16)v138, v104, 0, 0);
  *(_QWORD *)v105 = &off_24C050F70;
  if (!*(_QWORD *)(v105 + 72))
  {
    v138 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::CanonicalizeCast]";
    v139 = 101;
    v106 = llvm::StringRef::find((uint64_t *)&v138, "DesiredTypeName = ", 0x12uLL, 0);
    if (v139 >= v106)
      v107 = v106;
    else
      v107 = v139;
    v108 = &v138[v107];
    v109 = v139 - v107;
    if (v139 - v107 >= 0x12)
      v110 = 18;
    else
      v110 = v139 - v107;
    v111 = &v108[v110];
    v112 = v109 - v110;
    if (v112 >= v112 - 1)
      --v112;
    *(_QWORD *)(v105 + 64) = v111;
    *(_QWORD *)(v105 + 72) = v112;
  }
  v113 = *(unsigned int *)(v105 + 88);
  if (v113 > *(_DWORD *)(v105 + 92))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v105 + 80, (void *)(v105 + 96), v113, 16);
    LODWORD(v113) = *(_DWORD *)(v105 + 88);
  }
  *(_DWORD *)(v105 + 88) = v113;
  v115 = (char *)a1[2];
  v114 = a1[3];
  if ((unint64_t)v115 < v114)
  {
    *(_QWORD *)v115 = v105;
    v116 = v115 + 8;
    goto LABEL_157;
  }
  v117 = (char *)a1[1];
  v118 = (v115 - v117) >> 3;
  v119 = v118 + 1;
  if ((unint64_t)(v118 + 1) >> 61)
LABEL_158:
    abort();
  v120 = v114 - (_QWORD)v117;
  if (v120 >> 2 > v119)
    v119 = v120 >> 2;
  if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF8)
    v121 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v121 = v119;
  if (!v121)
  {
    v122 = 0;
    goto LABEL_142;
  }
  if (v121 >> 61)
LABEL_159:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v122 = (char *)operator new(8 * v121);
LABEL_142:
  v123 = (uint64_t *)&v122[8 * v118];
  v124 = &v122[8 * v121];
  *v123 = v105;
  v116 = v123 + 1;
  if (v115 == v117)
  {
    a1[1] = (uint64_t)v123;
    a1[2] = (uint64_t)v116;
    a1[3] = (uint64_t)v124;
  }
  else
  {
    v125 = v115 - v117 - 8;
    if (v125 < 0x78
      || &v115[-(v125 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v123
      && &v122[v115 - v117 - (v125 & 0xFFFFFFFFFFFFFFF8) - 8] < v115)
    {
      goto LABEL_165;
    }
    v126 = (v125 >> 3) + 1;
    v127 = 8 * (v126 & 0x3FFFFFFFFFFFFFFCLL);
    v128 = &v115[-v127];
    v123 = (uint64_t *)((char *)v123 - v127);
    v129 = &v122[8 * v118 - 16];
    v130 = v115 - 16;
    v131 = v126 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v133 = *((_OWORD *)v130 - 1);
      v132 = *(_OWORD *)v130;
      *((_OWORD *)v130 - 1) = 0uLL;
      *(_OWORD *)v130 = 0uLL;
      *((_OWORD *)v129 - 1) = v133;
      *(_OWORD *)v129 = v132;
      v129 -= 32;
      v130 -= 32;
      v131 -= 4;
    }
    while (v131);
    v115 = v128;
    if (v126 != (v126 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_165:
      do
      {
        v134 = *((_QWORD *)v115 - 1);
        v115 -= 8;
        *(_QWORD *)v115 = 0;
        *--v123 = v134;
      }
      while (v115 != v117);
    }
    v115 = (char *)a1[1];
    v135 = (char *)a1[2];
    a1[1] = (uint64_t)v123;
    a1[2] = (uint64_t)v116;
    a1[3] = (uint64_t)v124;
    while (v135 != v115)
    {
      v137 = *((_QWORD *)v135 - 1);
      v135 -= 8;
      v136 = v137;
      *(_QWORD *)v135 = 0;
      if (v137)
        (*(void (**)(uint64_t))(*(_QWORD *)v136 + 8))(v136);
    }
  }
  if (v115)
    operator delete(v115);
LABEL_157:
  a1[2] = (uint64_t)v116;
}

void mlir::anec::`anonymous namespace'::ANEC_GOCFolding::~ANEC_GOCFolding(mlir::anec::_anonymous_namespace_::ANEC_GOCFolding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_GOCFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_GOCFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t v7;
  uint64_t v8;
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(int, uint64_t);
  uint64_t v21;
  _QWORD v23[2];
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD v27[6];

  v27[4] = *MEMORY[0x24BDAC8D0];
  v25 = v27;
  v27[0] = a2;
  v26 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v23[0] = v5;
  v23[1] = v5;
  ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v23, 0);
  v7 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v23, 1u);
  v8 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v23, 2u);
  v24 = *(void **)(ODSOperands + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp
    || (v10 = DefiningOp,
        v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        ((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11) & 1) == 0))
  {
    v18 = *((_QWORD *)a3 + 2);
    if (!v18 || !mlir::RewriterBase::Listener::classof(v18))
      goto LABEL_21;
    v19 = *((_QWORD *)a2 + 3);
    goto LABEL_20;
  }
  v24 = *(void **)(v7 + 24);
  v12 = mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!v12
    || (v13 = v12,
        v14 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        ((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v13 + 48) + 32))(*(_QWORD *)(v13 + 48), v14) & 1) == 0))
  {
    v18 = *((_QWORD *)a3 + 2);
    if (!v18 || !mlir::RewriterBase::Listener::classof(v18))
      goto LABEL_21;
    v19 = *((_QWORD *)a2 + 3);
LABEL_20:
    v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v18 + 64))(v18, v19, v20, &v24);
    goto LABEL_22;
  }
  v24 = *(void **)(v8 + 24);
  v15 = mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (v15)
  {
    v16 = v15;
    v17 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v16 + 48) + 32))(*(_QWORD *)(v16 + 48), v17) & 1) != 0)
    {
      v24 = *(void **)(*v25 + 24);
      mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&v24, (mlir::MLIRContext *)1, 0);
    }
  }
  v18 = *((_QWORD *)a3 + 2);
  if (v18 && mlir::RewriterBase::Listener::classof(v18))
  {
    v19 = *((_QWORD *)a2 + 3);
    goto LABEL_20;
  }
LABEL_21:
  v21 = 0;
LABEL_22:
  if (v25 != v27)
    free(v25);
  return v21;
}

char *mlir::anec::`anonymous namespace'::foldGOCLike(uint64_t a1, uint64_t a2, uint64_t *a3, mlir::AffineMap *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v12;
  void *v24;
  void *v36;
  uint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t i;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  float v67;
  uint64_t v68;
  uint64_t v69;
  float v70;
  mlir::MLIRContext *v71;
  uint64_t F32Type;
  _QWORD *v73;
  void *v74;
  ZinIrHalH13g *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  _QWORD *v81;
  _QWORD *v82;
  unint64_t v83;
  unint64_t *v84;
  _QWORD *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *ElementsAttr;
  uint64_t v95;
  uint64_t v101;
  void *v102[5];
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _BYTE v109[48];
  void *v110;
  uint64_t v111;
  _BYTE v112[48];
  float *v113;
  uint64_t v114;
  _BYTE v115[48];
  float *v116;
  uint64_t v117;
  _QWORD v118[8];

  v118[6] = *MEMORY[0x24BDAC8D0];
  v106 = a5;
  v116 = (float *)v118;
  v117 = 0xC00000000;
  v113 = (float *)v115;
  v114 = 0xC00000000;
  v110 = v112;
  v111 = 0xC00000000;
  v12 = *(void **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(a7 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136);
  if (v12 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v12 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::matchConstantWithFloatVector<float>(a7, (uint64_t)&v116);
  }
  else
  {
    mlir::matchConstantWithIntVector<float>(a7, (uint64_t)&v116);
  }
  v24 = *(void **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(a8 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136);
  if (v24 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v24 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::matchConstantWithFloatVector<float>(a8, (uint64_t)&v113);
    if (!a9)
      goto LABEL_87;
  }
  else
  {
    mlir::matchConstantWithIntVector<float>(a8, (uint64_t)&v113);
    if (!a9)
      goto LABEL_87;
  }
  v36 = *(void **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(a9 + 8) & 0xFFFFFFFFFFFFFFF8)) + 136);
  if (v36 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v36 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::matchConstantWithFloatVector<float>(a9, (uint64_t)&v110);
  }
  else
  {
    mlir::matchConstantWithIntVector<float>(a9, (uint64_t)&v110);
  }
LABEL_87:
  if (a6 < 1)
  {
    v40 = 1;
    v37 = a3;
    v38 = (unint64_t)a4;
    goto LABEL_96;
  }
  v37 = a3;
  v38 = (unint64_t)a4;
  if (a6 == 1)
  {
    v39 = 0;
    v40 = 1;
LABEL_94:
    v45 = a6 - v39;
    v46 = &a3[v39];
    do
    {
      v47 = *v46++;
      v40 *= v47;
      --v45;
    }
    while (v45);
    goto LABEL_96;
  }
  v39 = a6 & 0xFFFFFFFFFFFFFFFELL;
  v41 = a3 + 1;
  v42 = 1;
  v43 = a6 & 0xFFFFFFFFFFFFFFFELL;
  v44 = 1;
  do
  {
    v42 *= *(v41 - 1);
    v44 *= *v41;
    v41 += 2;
    v43 -= 2;
  }
  while (v43);
  v40 = v44 * v42;
  if (v39 != a6)
    goto LABEL_94;
LABEL_96:
  v48 = a6 + 1;
  if (a6 + 1 >= v38)
  {
    v50 = 1;
    goto LABEL_105;
  }
  v49 = v38 + ~a6;
  if (v49 < 2)
  {
    v50 = 1;
LABEL_103:
    v55 = v38 - v48;
    v56 = &v37[v48];
    do
    {
      v57 = *v56++;
      v50 *= v57;
      --v55;
    }
    while (v55);
    goto LABEL_105;
  }
  v48 += v49 & 0xFFFFFFFFFFFFFFFELL;
  v51 = &v37[a6 + 2];
  v52 = 1;
  v53 = v49 & 0xFFFFFFFFFFFFFFFELL;
  v54 = 1;
  do
  {
    v52 *= *(v51 - 1);
    v54 *= *v51;
    v51 += 2;
    v53 -= 2;
  }
  while (v53);
  v50 = v54 * v52;
  if (v49 != (v49 & 0xFFFFFFFFFFFFFFFELL))
    goto LABEL_103;
LABEL_105:
  v58 = v37[a6];
  v107 = v109;
  v108 = 0xC00000000;
  if (v40 >= 1)
  {
    v59 = 0;
    v60 = 0;
    for (i = 0; i != v40; ++i)
    {
      if (v58 >= 1)
      {
        v62 = 0;
        v63 = v59;
        do
        {
          v64 = v50;
          v65 = v63;
          if (v50 >= 1)
          {
            do
            {
              if ((_DWORD)v117 == 1)
                v66 = 0;
              else
                v66 = v65;
              v67 = v116[v66];
              if ((_DWORD)v111)
              {
                if ((_DWORD)v111 == 1)
                  v68 = 0;
                else
                  v68 = v62;
                v67 = v67 + *((float *)v110 + v68);
              }
              if ((_DWORD)v114 == 1)
                v69 = 0;
              else
                v69 = v62;
              v70 = v113[v69];
              if (v60 >= HIDWORD(v108))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v107, v109, v60 + 1, 4);
                v60 = v108;
              }
              *((float *)v107 + v60) = v67 * v70;
              v60 = v108 + 1;
              LODWORD(v108) = v108 + 1;
              ++v65;
              --v64;
            }
            while (v64);
          }
          ++v62;
          v63 += v50;
        }
        while (v62 != v58);
      }
      v59 += v50 * v58;
    }
  }
  if (mlir::Type::isF16((mlir::Type *)&v106))
  {
    v104 = (_QWORD *)mlir::MemRefType::get(a3, a4, v106, 0, 0, 0);
    F32Type = mlir::Builder::getF32Type((mlir::Float32Type **)(a1 + 8), v71);
    v73 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)a3, (uint64_t)a4, F32Type, 0);
    v102[0] = mlir::createRawElementsAttr(v73, v107, (const void *)(4 * v108));
    v102[1] = v74;
    v75 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a1 + 8), a2, (uint64_t *)&v104, (_QWORD **)v102);
  }
  else
  {
    v104 = 0;
    v105 = 0;
    v76 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)a3, (uint64_t)a4, v106, 0);
    v77 = (uint64_t)v76;
    if (!v76)
      goto LABEL_138;
    v78 = *v76;
    v79 = mlir::TypeID::get<mlir::ShapedType>();
    v80 = *(unsigned int *)(v78 + 16);
    if (!(_DWORD)v80)
      goto LABEL_138;
    v81 = *(_QWORD **)(v78 + 8);
    v82 = &v81[2 * v80];
    do
    {
      v83 = v80 >> 1;
      v84 = &v81[2 * (v80 >> 1)];
      v86 = *v84;
      v85 = v84 + 2;
      v80 += ~(v80 >> 1);
      if (v86 < v79)
        v81 = v85;
      else
        v80 = v83;
    }
    while (v80);
    if (v81 != v82 && *v81 == v79)
      v87 = v81[1];
    else
LABEL_138:
      v87 = 0;
    mlir::mps::CPUNDArray::tryMakeAliasedArray(v77, v87, (uint64_t)&v104, (uint64_t)v102);
    if (mlir::Type::isSignedInteger((mlir::Type *)&v106, 8))
    {
      if ((_DWORD)v108)
      {
        v88 = 0;
        v89 = v103;
        do
        {
          v90 = llroundf(*((float *)v107 + v88));
          if (v90 >= 127)
            v90 = 127;
          if (v90 <= -128)
            LOBYTE(v90) = 0x80;
          *(_BYTE *)(v89 + v88++) = v90;
        }
        while (v88 < v108);
      }
    }
    else
    {
      mlir::Type::isUnsignedInteger((mlir::Type *)&v106, 8);
      if ((_DWORD)v108)
      {
        v91 = 0;
        v92 = v103;
        do
        {
          v93 = llroundf(*((float *)v107 + v91));
          if (v93 >= 255)
            v93 = 255;
          *(_BYTE *)(v92 + v91++) = v93 & ~(v93 >> 63);
        }
        while (v91 < v108);
      }
    }
    ElementsAttr = v104;
    if (v104)
      v95 = v105;
    else
      ElementsAttr = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v102, 0, 0);
    v104 = ElementsAttr;
    v105 = v95;
    v101 = mlir::MemRefType::get(a3, a4, v106, 0, 0, 0);
    v75 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a1 + 8), a2, &v101, &v104);
    mlir::mps::CPUNDArray::~CPUNDArray(v102);
  }
  if (v107 != v109)
    free(v107);
  if (v110 != v112)
    free(v110);
  if (v113 != (float *)v115)
    free(v113);
  if (v116 != (float *)v118)
    free(v116);
  return (char *)v75 - 16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x' failed to satisfy constraint: 'constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'scale' failed to satisfy constraint: 'constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_GOCFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'bias' failed to satisfy constraint: 'constant value'");
}

uint64_t mlir::matchConstantWithIntVector<float>(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16[2];
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v13 = 0;
  v14 = 0;
  if (!a1)
    return 0;
  v15 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (!DefiningOp)
    return 0;
  v4 = DefiningOp;
  v5 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 32))(*(_QWORD *)(v4 + 48), v5))
    return 0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  mlir::Operation::fold(v4, 0, 0, (uint64_t)v16);
  v6 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v16[0] & 0xFFFFFFFFFFFFFFF8));
  v8 = v6;
  if (v6)
  {
    v13 = v6;
    v14 = v7;
  }
  if (v16[0] != v17)
    free(v16[0]);
  if (!v8)
    return 0;
  v12[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v13);
  v12[1] = v9;
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v12) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    return 0;
  v10 = 1;
  mlir::getIntValues<float>((uint64_t)v13, v14, a2, 1);
  return v10;
}

void mlir::anec::`anonymous namespace'::ANEC_InvertFolding::~ANEC_InvertFolding(mlir::anec::_anonymous_namespace_::ANEC_InvertFolding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_InvertFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_InvertFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t InherentAttr;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(int, uint64_t);
  uint64_t v12;
  llvm::APFloatBase *Value;
  void *v14;
  int v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _QWORD v21[2];
  uint64_t v22;
  void *v23;
  uint64_t v24;
  _QWORD v25[4];
  void *ElementTypeOrSelf;
  _QWORD v27[2];
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v22 = 0;
  v23 = v25;
  v25[0] = a2;
  v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v21[0] = v5;
  v21[1] = v5;
  ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)v21, 0);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"epsilon", 7), v8))
  {
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "epsilon", 7uLL);
    if (!InherentAttr)
    {
LABEL_10:
      v9 = *((_QWORD *)a3 + 2);
      if (v9 && mlir::RewriterBase::Listener::classof(v9))
      {
        v10 = *((_QWORD *)a2 + 3);
LABEL_13:
        v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v9 + 64))(v9, v10, v11, &ElementTypeOrSelf);
        goto LABEL_31;
      }
      goto LABEL_30;
    }
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    goto LABEL_10;
  v22 = InherentAttr;
  Value = (llvm::APFloatBase *)mlir::FloatAttr::getValue((mlir::FloatAttr *)&v22, (uint64_t)&ElementTypeOrSelf);
  v14 = (void *)v27[0];
  if (llvm::APFloatBase::PPCDoubleDouble(Value) == v14)
  {
    v19 = *(_BYTE *)(v27[1] + 28) & 7;
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v27);
    if (v19 == 3)
    {
LABEL_16:
      ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
      if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
      {
        ElementTypeOrSelf = *(void **)(ODSOperands + 24);
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
        if (DefiningOp)
        {
          v17 = DefiningOp;
          v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
          if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18) & 1) != 0)
          {
            ElementTypeOrSelf = *(void **)(*(_QWORD *)v23 + 24);
            mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&ElementTypeOrSelf, (mlir::MLIRContext *)1, 0);
          }
        }
        v9 = *((_QWORD *)a3 + 2);
        if (v9 && mlir::RewriterBase::Listener::classof(v9))
        {
          v10 = *((_QWORD *)a2 + 3);
          goto LABEL_13;
        }
      }
      else
      {
        v9 = *((_QWORD *)a3 + 2);
        if (v9 && mlir::RewriterBase::Listener::classof(v9))
        {
          v10 = *((_QWORD *)a2 + 3);
          goto LABEL_13;
        }
      }
      goto LABEL_30;
    }
  }
  else
  {
    v15 = v28 & 7;
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v27);
    if (v15 == 3)
      goto LABEL_16;
  }
  v9 = *((_QWORD *)a3 + 2);
  if (v9 && mlir::RewriterBase::Listener::classof(v9))
  {
    v10 = *((_QWORD *)a2 + 3);
    goto LABEL_13;
  }
LABEL_30:
  v12 = 0;
LABEL_31:
  if (v23 != v25)
    free(v23);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'anec.invert' to have attribute 'epsilon' of type '::mlir::FloatAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'attr' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_InvertFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x' failed to satisfy constraint: 'constant value'");
}

void mlir::anec::`anonymous namespace'::ANEC_MulFolding::~ANEC_MulFolding(mlir::anec::_anonymous_namespace_::ANEC_MulFolding *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::anec::`anonymous namespace'::ANEC_MulFolding::matchAndRewrite(mlir::anec::_anonymous_namespace_::ANEC_MulFolding *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t v7;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  char v10;
  uint64_t DefiningOp;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)(int, uint64_t);
  uint64_t v20;
  mlir::Operation *v22;
  mlir::Operation *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD v27[6];

  v27[4] = *MEMORY[0x24BDAC8D0];
  v25 = v27;
  v27[0] = a2;
  v26 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v22 = v5;
  v23 = v5;
  ODSOperands = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v22, 0);
  v7 = mlir::anec::Convolution::getODSOperands((mlir::anec::Convolution *)&v22, 1u);
  ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v23, 0);
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  if (!v10)
  {
    v17 = *((_QWORD *)a3 + 2);
    if (!v17 || !mlir::RewriterBase::Listener::classof(v17))
      goto LABEL_20;
    v18 = *((_QWORD *)a2 + 3);
    goto LABEL_19;
  }
  v24 = *(void **)(ODSOperands + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp
    || (v12 = DefiningOp,
        v13 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        ((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v12 + 48) + 32))(*(_QWORD *)(v12 + 48), v13) & 1) == 0))
  {
    v17 = *((_QWORD *)a3 + 2);
    if (!v17 || !mlir::RewriterBase::Listener::classof(v17))
      goto LABEL_20;
    v18 = *((_QWORD *)a2 + 3);
LABEL_19:
    v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v17 + 64))(v17, v18, v19, &v24);
    goto LABEL_21;
  }
  v24 = *(void **)(v7 + 24);
  v14 = mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (v14)
  {
    v15 = v14;
    v16 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v15 + 48) + 32))(*(_QWORD *)(v15 + 48), v16) & 1) != 0)
    {
      v24 = *(void **)(*v25 + 24);
      mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&v24, (mlir::MLIRContext *)1, 0);
    }
  }
  v17 = *((_QWORD *)a3 + 2);
  if (v17 && mlir::RewriterBase::Listener::classof(v17))
  {
    v18 = *((_QWORD *)a2 + 3);
    goto LABEL_19;
  }
LABEL_20:
  v20 = 0;
LABEL_21:
  if (v25 != v27)
    free(v25);
  return v20;
}

uint64_t mlir::anec::`anonymous namespace'::getMultBroadcastAxis(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t Shape;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  _QWORD v19[2];
  uint64_t DefiningOp;
  uint64_t v21;

  v21 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  v1 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&DefiningOp) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v1)
    goto LABEL_10;
  v2 = *v1;
  v3 = mlir::TypeID::get<mlir::ShapedType>();
  v4 = *(unsigned int *)(v2 + 16);
  if (!(_DWORD)v4)
    goto LABEL_10;
  v5 = *(_QWORD **)(v2 + 8);
  v6 = &v5[2 * v4];
  do
  {
    v7 = v4 >> 1;
    v8 = &v5[2 * (v4 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v4 += ~(v4 >> 1);
    if (v10 < v3)
      v5 = v9;
    else
      v4 = v7;
  }
  while (v4);
  if (v5 != v6 && *v5 == v3)
    v11 = v5[1];
  else
LABEL_10:
    v11 = 0;
  v19[0] = v1;
  v19[1] = v11;
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v19);
  if (v13)
  {
    v14 = 0;
    v15 = 8 * v13;
    v16 = -1;
    while (1)
    {
      if (*(_QWORD *)(Shape + 8 * v14) != 1)
      {
        v17 = v16 == -1;
        v16 = v14;
        if (!v17)
          break;
      }
      ++v14;
      v15 -= 8;
      if (!v15)
        return v16 & ~(v16 >> 63);
    }
    return 0;
  }
  else
  {
    v16 = -1;
    return v16 & ~(v16 >> 63);
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_MulFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'out' failed to satisfy constraint: ''");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_MulFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'x' failed to satisfy constraint: 'constant value'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anec::`anonymous namespace'::ANEC_MulFolding::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'scale' failed to satisfy constraint: 'constant value'");
}

void mlir::anec::`anonymous namespace'::CanonicalizeCast::~CanonicalizeCast(mlir::anec::_anonymous_namespace_::CanonicalizeCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Cast>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Cast>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::anec::Cast>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::anec::`anonymous namespace'::CanonicalizeCast::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float16Type **a3)
{
  mlir::MLIRContext *v4;
  uint64_t F16Type;
  _QWORD *v6;
  mlir::MLIRContext *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v16;
  ZinIrHalH13g *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t Input;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v21 = a2;
  Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v21);
  v19 = *(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v21) + 8) & 0xFFFFFFFFFFFFFFF8;
  v22 = xmmword_207AB5520;
  v23 = unk_207AB5530;
  F16Type = mlir::Builder::getF16Type(a3 + 1, v4);
  v6 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v22, 4, F16Type, 0);
  v22 = xmmword_207AB5520;
  v23 = unk_207AB5530;
  v8 = mlir::Builder::getF16Type(a3 + 1, v7);
  v18 = mlir::MemRefType::get((uint64_t *)&v22, (mlir::AffineMap *)4, v8, 0, 0, 0);
  v9 = *(_QWORD *)(v21 + 24);
  *(_QWORD *)&v22 = mlir::createSplatF16ElementsAttr(v6, 1.0);
  *((_QWORD *)&v22 + 1) = v10;
  v17 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 1), v9, &v18, (_QWORD **)&v22);
  v11 = *(_QWORD *)(v21 + 24);
  *(_QWORD *)&v22 = mlir::createSplatF16ElementsAttr(v6, 0.0);
  *((_QWORD *)&v22 + 1) = v12;
  v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 1), v11, &v18, (_QWORD **)&v22);
  v13 = v21;
  v14 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(v21 + 24), (uint64_t *)&v19, &Input, &v17, &v16);
  (*((void (**)(mlir::Float16Type **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, v13, v14);
  return 1;
}

uint64_t mlir::anec::writeSingleRegionPlist(uint64_t a1, _QWORD *a2, void **a3)
{
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *i;
  mlir::ForwardIterator *v12;
  mlir::Block *v13;
  uint64_t ParentOp;
  uint64_t v15;
  mlir::anec::ANECIRProcedure *v16;
  unint64_t *v17;
  unint64_t v18;
  unsigned __int8 v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t InherentAttr;
  char v24;
  uint64_t v25;
  uint64_t v26;
  mlir::anec::ANECIRProcedure *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int8x16_t *v36;
  const unsigned __int8 *v37;
  int Key;
  uint64_t DefiningOp;
  uint64_t *v40;
  void *v41;
  BOOL v42;
  mlir::Operation *v43;
  uint64_t Input;
  uint64_t v45;
  uint64_t v46;
  uint64_t *UInt;
  unsigned int ANENextSupportedInterleaveValue;
  unint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  int v53;
  int8x16_t *v54;
  const unsigned __int8 *v55;
  int v56;
  uint64_t v57;
  mlir::Operation *v58;
  mlir::Operation *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  unsigned int v64;
  uint64_t v65;
  llvm *v66;
  uint64_t v68;
  _QWORD *v69;
  _QWORD *v70;
  mlir::anec::ANECIRProcedure *v72[2];
  mlir::Operation *v73;
  _QWORD v74[4];
  __int16 v75;
  uint64_t v76;
  void *v77;
  void **v78;
  uint64_t *v79;
  uint64_t v80;
  _QWORD v81[3];

  v81[1] = *MEMORY[0x24BDAC8D0];
  if (a1)
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v6 = *(unsigned int *)(a1 + 44);
  if ((v6 & 0x7FFFFF) != 0)
    v7 = (_QWORD *)(((a1 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a1 + 40));
  else
    v7 = 0;
  if ((_QWORD *)*v7 != v7)
  {
    v8 = v7[1];
    v9 = v8 ? v8 - 8 : 0;
    v10 = *(uint64_t **)(v9 + 48);
    for (i = *(uint64_t **)(v9 + 56); v10 != i; ++v10)
    {
      v15 = *v10;
      v16 = (mlir::anec::ANECIRProcedure *)a2[1];
      v72[0] = *(mlir::anec::ANECIRProcedure **)a2;
      v72[1] = v16;
      if (v16)
      {
        v17 = (unint64_t *)((char *)v16 + 8);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
        do
          v20 = __ldaxr(v17);
        while (__stlxr(v20 - 1, v17));
        if (v20)
        {
          if (!v19)
            return 0;
        }
        else
        {
          v21 = v19;
          (*(void (**)(mlir::anec::ANECIRProcedure *))(*(_QWORD *)v16 + 16))(v16);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v16);
          if (!v21)
            return 0;
        }
      }
      {
        return 0;
      }
    }
  }
  v77 = a2;
  v78 = a3;
  if (!mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a1, (mlir::Operation *)llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::anec::writeSingleRegionPlist(mlir::Operation *,std::shared_ptr<mlir::anec::ANECIRNetwork> const&,mlir::anec::ANECIRWeights &)::$_0>, (uint64_t)&v77, 1))return 0;
  v12 = (mlir::ForwardIterator *)a1;
  do
  {
    v13 = (mlir::Block *)*((_QWORD *)v12 + 2);
    if (!v13)
    {
      v12 = 0;
      if (!*(_BYTE *)(a1 + 47))
        goto LABEL_36;
      goto LABEL_31;
    }
    ParentOp = mlir::Block::getParentOp(v13);
    v12 = (mlir::ForwardIterator *)ParentOp;
  }
  while (ParentOp
       && *(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id);
  if (!*(_BYTE *)(a1 + 47))
  {
LABEL_36:
    InherentAttr = mlir::DictionaryAttr::get(a1 + 56, "sym_name", 8uLL);
    if (!InherentAttr)
      goto LABEL_37;
    goto LABEL_33;
  }
LABEL_31:
  InherentAttr = mlir::Operation::getInherentAttr(a1, (uint64_t)"sym_name", 8);
  if (!v24)
    goto LABEL_36;
  if (!InherentAttr)
  {
LABEL_37:
    v25 = 0;
    goto LABEL_38;
  }
LABEL_33:
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v25 = InherentAttr;
  else
    v25 = 0;
LABEL_38:
  v76 = v25;
  v79 = v81;
  v80 = 0x100000000;
  v77 = &v76;
  v78 = (void **)&v79;
  v74[0] = &v77;
  v22 = 1;
  mlir::detail::walk<mlir::ForwardIterator>(v12, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec12_GLOBAL__N_120updateNetworkIOTypesES3_RKNSt3__110shared_ptrINSB_13ANECIRNetworkEEEE3__0NS1_9placement10RegionCallEvEENSD_9enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESS_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v74, 1);
  if ((_DWORD)v80)
  {
    if ((_DWORD)v80 == 1)
    {
      v26 = *v79;
      v27 = (mlir::anec::ANECIRProcedure *)*a2;
      v28 = *(uint64_t **)(*a2 + 8);
      v29 = *(unsigned int *)(*a2 + 16);
      v30 = (uint64_t *)*((_QWORD *)v27 + 13);
      v31 = *((unsigned int *)v27 + 28);
      if ((_DWORD)v29)
      {
        v32 = 0;
        v33 = 32 * v29;
        do
        {
          v34 = *v28;
          v35 = *(char *)(*v28 + 31);
          if (v35 >= 0)
            v36 = (int8x16_t *)(*v28 + 8);
          else
            v36 = *(int8x16_t **)(*v28 + 8);
          if (v35 >= 0)
            v37 = (const unsigned __int8 *)*(unsigned __int8 *)(*v28 + 31);
          else
            v37 = *(const unsigned __int8 **)(v34 + 16);
          Key = llvm::StringMapImpl::FindKey((uint64_t *)&v77, v36, v37);
          if (Key == -1 || Key == (unint64_t)v78)
          {
            v74[0] = *(_QWORD *)(*(_QWORD *)(v26 + 72) + v32 + 24);
            DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v74);
            if (DefiningOp)
            {
              v40 = (uint64_t *)DefiningOp;
              v41 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
              v42 = v41 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id;
              v43 = v41 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id
                  ? (mlir::Operation *)DefiningOp
                  : 0;
              v73 = v43;
              if (v42)
              {
                Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v73);
                v45 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v73);
                if ((v46 & 0xFF00000000) == 0)
                {
LABEL_92:
                  v22 = 0;
                  goto LABEL_93;
                }
                *(_DWORD *)(v34 + 104) = v46;
                v74[0] = mlir::placement::MemrefToTensor::getInterleaveAttr(&v73);
                if (v74[0])
                {
                  UInt = mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)v74);
                  ANENextSupportedInterleaveValue = mlir::getANENextSupportedInterleaveValue((uint64_t)UInt);
                }
                else
                {
                  ANENextSupportedInterleaveValue = 1;
                }
                *(_QWORD *)(v34 + 96) = ANENextSupportedInterleaveValue;
              }
            }
          }
          else
          {
          }
          v32 += 32;
          v28 += 2;
        }
        while (v33 != v32);
      }
      if ((_DWORD)v31)
      {
        v49 = 0;
        v50 = v26 - 96;
        v51 = (uint64_t *)(v26 - 16);
        do
        {
          v52 = *v30;
          v53 = *(char *)(*v30 + 31);
          if (v53 >= 0)
            v54 = (int8x16_t *)(*v30 + 8);
          else
            v54 = *(int8x16_t **)(*v30 + 8);
          if (v53 >= 0)
            v55 = (const unsigned __int8 *)*(unsigned __int8 *)(*v30 + 31);
          else
            v55 = *(const unsigned __int8 **)(v52 + 16);
          v56 = llvm::StringMapImpl::FindKey((uint64_t *)&v77, v54, v55);
          if (v56 == -1 || v56 == (unint64_t)v78)
          {
            if (v49 > 5)
            {
              v57 = *(_QWORD *)(v50 - 24 * (v49 - 5));
              if (!v57)
                goto LABEL_69;
            }
            else
            {
              v57 = *v51;
              if (!*v51)
                goto LABEL_69;
            }
            v58 = *(mlir::Operation **)(v57 + 16);
            if (*(_UNKNOWN **)(*((_QWORD *)v58 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
              v59 = v58;
            else
              v59 = 0;
            v73 = v59;
            if (v59)
            {
              v60 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v73);
              v61 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v73);
              if ((v62 & 0xFF00000000) == 0)
                goto LABEL_92;
              *(_DWORD *)(v52 + 128) = v62;
              v74[0] = mlir::placement::MemrefToTensor::getInterleaveAttr(&v73);
              if (v74[0])
              {
                v63 = mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)v74);
                v64 = mlir::getANENextSupportedInterleaveValue((uint64_t)v63);
              }
              else
              {
                v64 = 1;
              }
              *(_QWORD *)(v52 + 96) = v64;
            }
          }
          else
          {
          }
LABEL_69:
          ++v49;
          v51 -= 2;
          v30 += 2;
        }
        while (v31 != v49);
      }
      v22 = 1;
LABEL_93:
      if (HIDWORD(v78) && (_DWORD)v78)
      {
        v65 = 0;
        do
        {
          v66 = *(llvm **)((char *)v77 + v65);
          if (v66 != (llvm *)-8 && v66 != 0)
          {
            v68 = *(_QWORD *)v66;
            v69 = (_QWORD *)*((_QWORD *)v66 + 7);
            if (v69 != (_QWORD *)((char *)v66 + 72))
              free(v69);
            v70 = (_QWORD *)*((_QWORD *)v66 + 1);
            if (v70 != (_QWORD *)((char *)v66 + 24))
              free(v70);
            llvm::deallocate_buffer(v66, (void *)(v68 + 121));
          }
          v65 += 8;
        }
        while (8 * v78 != v65);
      }
      free(v77);
    }
    else
    {
      v74[0] = "Found more than one call to the same region";
      v75 = 259;
      mlir::Operation::emitError((uint64_t *)a1, (uint64_t)v74, (uint64_t)&v77);
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v77);
      if (v77)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v77);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v78);
    }
  }
  if (v79 != v81)
    free(v79);
  return v22;
}

uint64_t mlir::anec::`anonymous namespace'::addInputToNetwork(mlir::anec::ANECIRProcedure **a1, uint64_t a2, int a3)
{
  uint64_t v6;
  int ANECIRDataType;
  std::string *v8;
  std::string::size_type v9;
  uint64_t **v10;
  mlir::anec::ANECIRProcedure *v11;
  int v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  int v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  int8x16_t *v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  uint64_t v27;
  mlir::anec::ANECIRProcedure *v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  __int128 v37;
  unint64_t *v38;
  unint64_t v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  BOOL v44;
  uint64_t v45;
  uint64_t *v46;
  std::__shared_weak_count *v47;
  unint64_t *v48;
  unint64_t v49;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  std::string __p;
  __int128 v58;
  void *v59[2];
  std::string::size_type v60;
  std::string v61;
  void *v62;
  int v63;
  _QWORD v64[5];
  char v65;
  uint64_t *v66;
  uint64_t v67;
  _QWORD v68[8];

  v68[6] = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 8);
  ANECIRDataType = mlir::anec::getANECIRDataType(a2);
  std::to_string(&v61, *(_DWORD *)(a2 + 24));
  v8 = std::string::insert(&v61, 0, "__arg");
  v9 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)v59 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v60 = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  v66 = v68;
  v67 = 0x300000000;
  if (a3)
  {
    v10 = *(uint64_t ***)a2;
    if (!*(_QWORD *)a2)
      goto LABEL_23;
    while (1)
    {
      v11 = *a1;
      mlir::anec::computeOpKeyString((mlir::anec *)v10[2], &v61);
      mlir::anec::ANECIRProcedure::OperationName(v11, &__p);
      mlir::anec::ANECIRInput::Create((uint64_t)v59, ANECIRDataType, (uint64_t)&__p, (uint64_t)&v61, (uint64_t *)&v58);
      v12 = v67;
      if (v67 >= HIDWORD(v67))
      {
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIRInput>,false>::growAndEmplaceBack<std::shared_ptr<mlir::anec::ANECIRInput>>((uint64_t)&v66, (uint64_t)&v58);
        v13 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
        if (*((_QWORD *)&v58 + 1))
        {
          v14 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
          do
            v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
      }
      else
      {
        *(_OWORD *)&v66[2 * v67] = v58;
        v58 = 0uLL;
        LODWORD(v67) = v12 + 1;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v61.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_7;
LABEL_12:
        operator delete(v61.__r_.__value_.__l.__data_);
        v10 = (uint64_t **)*v10;
        if (!v10)
          goto LABEL_23;
      }
      else
      {
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_12;
LABEL_7:
        v10 = (uint64_t **)*v10;
        if (!v10)
          goto LABEL_23;
      }
    }
  }
  *((_BYTE *)&v61.__r_.__value_.__s + 23) = 0;
  v61.__r_.__value_.__s.__data_[0] = 0;
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
  __p.__r_.__value_.__s.__data_[0] = 0;
  mlir::anec::ANECIRInput::Create((uint64_t)v59, ANECIRDataType, (uint64_t)&v61, (uint64_t)&__p, (uint64_t *)&v58);
  v16 = v67;
  if (v67 >= HIDWORD(v67))
  {
    llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIRInput>,false>::growAndEmplaceBack<std::shared_ptr<mlir::anec::ANECIRInput>>((uint64_t)&v66, (uint64_t)&v58);
    v51 = (std::__shared_weak_count *)*((_QWORD *)&v58 + 1);
    if (*((_QWORD *)&v58 + 1))
    {
      v52 = (unint64_t *)(*((_QWORD *)&v58 + 1) + 8);
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
    }
  }
  else
  {
    *(_OWORD *)&v66[2 * v67] = v58;
    v58 = 0uLL;
    LODWORD(v67) = v16 + 1;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v61.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_23;
LABEL_74:
    operator delete(v61.__r_.__value_.__l.__data_);
    goto LABEL_23;
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_74;
LABEL_23:
  v17 = v66;
  if (!(_DWORD)v67)
  {
    v45 = 1;
    goto LABEL_68;
  }
  v18 = v6 & 0xFFFFFFFFFFFFFFF8;
  v19 = &v66[2 * v67];
  do
  {
    mlir::anec::calcANEIOInfo(v18, 0, 0, (uint64_t)&v61);
    if (!v65)
    {
      v45 = 0;
      goto LABEL_59;
    }
    v20 = *v17;
    v21 = (uint64_t *)v61.__r_.__value_.__r.__words[0];
    v22 = LODWORD(v61.__r_.__value_.__r.__words[1]);
    if (LODWORD(v61.__r_.__value_.__r.__words[1]) == 5)
      *(_QWORD *)(v20 + 144) = *(_QWORD *)(v61.__r_.__value_.__r.__words[0] + 8);
    v23 = (int8x16_t *)&v21[v22];
    v24 = v23[-2].i64[1];
    v25 = *v21;
    *(int8x16_t *)(v20 + 112) = vextq_s8(v23[-1], v23[-1], 8uLL);
    *(_QWORD *)(v20 + 128) = v24;
    *(_QWORD *)(v20 + 136) = v25;
    if (v63 == 5)
    {
      v26 = *((int8x16_t *)v62 + 1);
      *(int8x16_t *)(v20 + 168) = vextq_s8(*(int8x16_t *)v62, *(int8x16_t *)v62, 8uLL);
    }
    else
    {
      v26 = *(int8x16_t *)((char *)v62 + 8);
    }
    *(int8x16_t *)(v20 + 152) = vextq_s8(v26, v26, 8uLL);
    v27 = *v17;
    *(_QWORD *)(v27 + 96) = v64[4];
    v28 = *a1;
    v29 = (std::__shared_weak_count *)v17[1];
    v55 = v27;
    v56 = v29;
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        v31 = __ldxr(p_shared_owners);
      while (__stxr(v31 + 1, p_shared_owners));
    }
    v33 = (unint64_t *)((char *)v28 + 8);
    v32 = *((_QWORD *)v28 + 1);
    v34 = *((unsigned int *)v28 + 4);
    if (v34 < *((_DWORD *)v28 + 5))
      goto LABEL_36;
    v43 = v34 + 1;
    v44 = v32 + 16 * v34 > (unint64_t)&v55;
    if (v32 > (unint64_t)&v55 || !v44)
    {
      llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow((uint64_t)v28 + 8, v43);
      v32 = *v33;
LABEL_36:
      v35 = (char *)&v55;
      goto LABEL_37;
    }
    v54 = (char *)&v55 - v32;
    llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow((uint64_t)v28 + 8, v43);
    v32 = *v33;
    v35 = &v54[*v33];
LABEL_37:
    v36 = *((unsigned int *)v28 + 4);
    v37 = *(_OWORD *)v35;
    *(_OWORD *)(v32 + 16 * v36) = *(_OWORD *)v35;
    if (*((_QWORD *)&v37 + 1))
    {
      v38 = (unint64_t *)(*((_QWORD *)&v37 + 1) + 8);
      do
        v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
      LODWORD(v36) = *((_DWORD *)v28 + 4);
    }
    *((_DWORD *)v28 + 4) = v36 + 1;
    v40 = v56;
    if (!v56)
      goto LABEL_45;
    v41 = (unint64_t *)&v56->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
      if (!v65)
        goto LABEL_25;
    }
    else
    {
LABEL_45:
      if (!v65)
        goto LABEL_25;
    }
    if (v62 != v64)
      free(v62);
    if ((std::string::size_type *)v61.__r_.__value_.__l.__data_ != &v61.__r_.__value_.__r.__words[2])
      free(v61.__r_.__value_.__l.__data_);
LABEL_25:
    v17 += 2;
  }
  while (v17 != v19);
  v45 = 1;
LABEL_59:
  v17 = v66;
  if ((_DWORD)v67)
  {
    v46 = &v66[2 * v67];
    do
    {
      v47 = (std::__shared_weak_count *)*(v46 - 1);
      if (v47)
      {
        v48 = (unint64_t *)&v47->__shared_owners_;
        do
          v49 = __ldaxr(v48);
        while (__stlxr(v49 - 1, v48));
        if (!v49)
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
      }
      v46 -= 2;
    }
    while (v46 != v17);
    v17 = v66;
  }
LABEL_68:
  if (v17 != v68)
    free(v17);
  if (SHIBYTE(v60) < 0)
    operator delete(v59[0]);
  return v45;
}

BOOL mlir::anec::writeMultiProcedurePlist(unsigned int *a1, void *a2, mlir::anec::ANECIRProcedure **a3, uint64_t a4)
{
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *i;
  int v14;
  mlir::anec::ANECIRProcedure *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL8 v24;
  uint64_t v25;
  llvm *v26;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  mlir::anec::ANECIRProcedure *v32;
  unint64_t *v33;
  unint64_t v34;
  unsigned __int8 v35;
  unint64_t v36;
  int v37;
  void *v39;
  uint64_t v40;
  mlir::anec::ANECIRProcedure **v41;
  mlir::anec::ANECIRProcedure *v42[2];

  if (a1)
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  v8 = a1[11];
  if ((v8 & 0x7FFFFF) != 0)
    v9 = (_QWORD *)((((unint64_t)&a1[4 * ((v8 >> 23) & 1) + 17] + ((v8 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * a1[10]);
  else
    v9 = 0;
  if ((_QWORD *)*v9 != v9)
  {
    v10 = v9[1];
    v11 = v10 ? v10 - 8 : 0;
    v12 = *(uint64_t **)(v11 + 48);
    for (i = *(uint64_t **)(v11 + 56); v12 != i; ++v12)
    {
      v31 = *v12;
      v32 = a3[1];
      v42[0] = *a3;
      v42[1] = v32;
      if (v32)
      {
        v33 = (unint64_t *)((char *)v32 + 8);
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
        do
          v36 = __ldaxr(v33);
        while (__stlxr(v36 - 1, v33));
        if (v36)
        {
          if (!v35)
            return 0;
        }
        else
        {
          v37 = v35;
          (*(void (**)(mlir::anec::ANECIRProcedure *))(*(_QWORD *)v32 + 16))(v32);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v32);
          if (!v37)
            return 0;
        }
      }
      {
        return 0;
      }
    }
  }
  v39 = a2;
  v40 = a4;
  v41 = a3;
  v14 = mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a1, (mlir::Operation *)llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::anec::writeMultiProcedurePlist(mlir::Operation *,std::shared_ptr<mlir::anec::ANECIRNetwork> const&,std::shared_ptr<mlir::anec::ANECIRProcedure> const&,mlir::anec::ANECIRWeights &)::$_0>, (uint64_t)&v39, 1);
  v15 = *a3;
  v16 = *((unsigned int *)v15 + 4);
  if ((_DWORD)v16)
  {
    v17 = (uint64_t *)*((_QWORD *)v15 + 1);
    v18 = 16 * v16;
    do
    {
      v19 = *v17;
      v17 += 2;
      v18 -= 16;
    }
    while (v18);
  }
  v20 = *((unsigned int *)v15 + 28);
  if ((_DWORD)v20)
  {
    v21 = (uint64_t *)*((_QWORD *)v15 + 13);
    v22 = 16 * v20;
    do
    {
      v23 = *v21;
      v21 += 2;
      v22 -= 16;
    }
    while (v22);
  }
  v24 = v14 != 0;
  if (HIDWORD(v40) && (_DWORD)v40)
  {
    v25 = 0;
    do
    {
      v26 = *(llvm **)((char *)v39 + v25);
      if (v26 != (llvm *)-8 && v26 != 0)
      {
        v28 = *(_QWORD *)v26;
        v29 = (_QWORD *)*((_QWORD *)v26 + 7);
        if (v29 != (_QWORD *)((char *)v26 + 72))
          free(v29);
        v30 = (_QWORD *)*((_QWORD *)v26 + 1);
        if (v30 != (_QWORD *)((char *)v26 + 24))
          free(v30);
        llvm::deallocate_buffer(v26, (void *)(v28 + 121));
      }
      v25 += 8;
    }
    while (8 * v40 != v25);
  }
  free(v39);
  return v24;
}

uint64_t mlir::anec::`anonymous namespace'::ParseCustomIOInfoFromAttribute@<X0>(mlir::anec::_anonymous_namespace_ *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  char v6;
  uint64_t InherentAttr;
  char v8;
  uint64_t v9[2];
  uint64_t *v10;
  uint64_t v11;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0x7800000000;
  if (!*((_BYTE *)this + 47)
    || (result = mlir::Operation::getInherentAttr((uint64_t)this, (uint64_t)"io_info", 7), !v6))
  {
    result = mlir::DictionaryAttr::contains((uint64_t)this + 56, "io_info", 7uLL);
    if (!(_DWORD)result)
      return result;
LABEL_6:
    if (!*((_BYTE *)this + 47)
      || (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)this, (uint64_t)"io_info", 7), !v8))
    {
      InherentAttr = mlir::DictionaryAttr::get((uint64_t)this + 56, "io_info", 7uLL);
    }
    v11 = InherentAttr;
    v10 = (uint64_t *)mlir::DictionaryAttr::get((uint64_t)&v11, "input", 5uLL);
    v9[0] = (uint64_t)a2;
    v9[1] = mlir::DictionaryAttr::get((uint64_t)&v11, "output", 6uLL);
  }
  if (result)
    goto LABEL_6;
  return result;
}

void mlir::anec::createWriteProcedureListPlistPass(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, int a4@<W3>, char a5@<W4>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  std::string __p;
  std::string __str;

  v12 = operator new();
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    if ((*(char *)(a2 + 23) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else
  {
    __str = *(std::string *)a1;
    if ((*(char *)(a2 + 23) & 0x80000000) == 0)
    {
LABEL_3:
      __p = *(std::string *)a2;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_6:
  *(_QWORD *)(v12 + 16) = "builtin.module";
  *(_QWORD *)(v12 + 24) = 14;
  *(_BYTE *)(v12 + 32) = 1;
  *(_BYTE *)(v12 + 40) = 0;
  *(_BYTE *)(v12 + 120) = 0;
  *(_OWORD *)(v12 + 128) = 0u;
  *(_OWORD *)(v12 + 144) = 0u;
  *(_OWORD *)(v12 + 160) = 0u;
  *(_QWORD *)(v12 + 176) = 0;
  *(_QWORD *)(v12 + 184) = v12 + 200;
  *(_QWORD *)(v12 + 192) = 0x400000000;
  *(_QWORD *)(v12 + 232) = v12 + 248;
  *(_QWORD *)(v12 + 240) = 0x400000000;
  *(_QWORD *)(v12 + 280) = 0;
  *(_QWORD *)(v12 + 288) = 0;
  *(_QWORD *)(v12 + 296) = 0x1000000000;
  *(_QWORD *)(v12 + 336) = 0;
  *(_OWORD *)(v12 + 304) = 0u;
  *(_OWORD *)(v12 + 320) = 0u;
  *(_QWORD *)v12 = off_24BFF4778;
  *(_OWORD *)(v12 + 352) = 0u;
  *(_OWORD *)(v12 + 368) = 0u;
  *(_OWORD *)(v12 + 384) = 0u;
  *(_DWORD *)(v12 + 344) = a4;
  std::string::operator=((std::string *)(v12 + 352), &__str);
  std::string::operator=((std::string *)(v12 + 376), &__p);
  *(_BYTE *)(v12 + 400) = a3;
  *(_BYTE *)(v12 + 401) = a5;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_8;
LABEL_10:
    operator delete(__str.__r_.__value_.__l.__data_);
    goto LABEL_8;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_10;
LABEL_8:
  *a6 = v12;
}

void mlir::anec::createWritePlistPass(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, int a4@<W3>, char a5@<W4>, uint64_t *a6@<X8>)
{
  uint64_t v11;
  void (**v12)(mlir::anec::_anonymous_namespace_::WriteA13PlistPass *__hidden);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t *v21;
  char v22;
  char v23;
  std::string v24;
  std::string __str;
  char v26;
  char v27;

  v23 = a3;
  v22 = a5;
  switch(a4)
  {
    case 1:
      v11 = operator new();
      if (*(char *)(a1 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
          goto LABEL_5;
      }
      else
      {
        __str = *(std::string *)a1;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_5:
          v24 = *(std::string *)a2;
LABEL_23:
          v27 = a3;
          v26 = a5;
          v12 = &off_24C051078;
          goto LABEL_39;
        }
      }
      std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
      goto LABEL_23;
    case 2:
      v11 = operator new();
      if (*(char *)(a1 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
          goto LABEL_8;
      }
      else
      {
        __str = *(std::string *)a1;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_8:
          v24 = *(std::string *)a2;
          goto LABEL_26;
        }
      }
      std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_26:
      v27 = a3;
      v26 = a5;
      v12 = &off_24C0510E8;
      goto LABEL_39;
    case 3:
      v11 = operator new();
      if (*(char *)(a1 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
          goto LABEL_11;
      }
      else
      {
        __str = *(std::string *)a1;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_11:
          v24 = *(std::string *)a2;
          goto LABEL_29;
        }
      }
      std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_29:
      v27 = a3;
      v26 = a5;
      v12 = &off_24C051158;
      goto LABEL_39;
    case 4:
      v11 = operator new();
      if (*(char *)(a1 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
          goto LABEL_14;
      }
      else
      {
        __str = *(std::string *)a1;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_14:
          v24 = *(std::string *)a2;
          goto LABEL_32;
        }
      }
      std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_32:
      v27 = a3;
      v26 = a5;
      v12 = &off_24C0511C8;
      goto LABEL_39;
    case 5:
      v11 = operator new();
      if (*(char *)(a1 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
          goto LABEL_17;
      }
      else
      {
        __str = *(std::string *)a1;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_17:
          v24 = *(std::string *)a2;
          goto LABEL_35;
        }
      }
      std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_35:
      v27 = a3;
      v26 = a5;
      v12 = &off_24BFF4708;
      goto LABEL_39;
    case 6:
      v11 = operator new();
      if (*(char *)(a1 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
          goto LABEL_20;
      }
      else
      {
        __str = *(std::string *)a1;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_20:
          v24 = *(std::string *)a2;
          goto LABEL_38;
        }
      }
      std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_38:
      v27 = a3;
      v26 = a5;
      v12 = &off_24C051450;
LABEL_39:
      *(_QWORD *)v11 = v12;
      std::string::operator=((std::string *)(v11 + 472), &__str);
      v13 = *(_QWORD *)(v11 + 568);
      if (v13)
      {
        (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v13 + 48))(v13, &__str);
        std::string::operator=((std::string *)(v11 + 720), &v24);
        v14 = *(_QWORD *)(v11 + 816);
        if (v14)
        {
          (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v14 + 48))(v14, &v24);
          *(_BYTE *)(v11 + 968) = a3;
          v15 = *(_QWORD *)(v11 + 1024);
          if (v15)
          {
            (*(void (**)(uint64_t, char *))(*(_QWORD *)v15 + 48))(v15, &v27);
            *(_BYTE *)(v11 + 1424) = a5;
            v16 = *(_QWORD *)(v11 + 1480);
            if (v16)
            {
              (*(void (**)(uint64_t, char *))(*(_QWORD *)v16 + 48))(v16, &v26);
              if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v24.__r_.__value_.__l.__data_);
                if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_45;
              }
              else if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_45:
                *a6 = v11;
                return;
              }
              operator delete(__str.__r_.__value_.__l.__data_);
              goto LABEL_45;
            }
          }
        }
      }
      v17 = std::__throw_bad_function_call[abi:nn180100]();
      return;
    default:
      *a6 = __str.__r_.__value_.__r.__words[0];
      return;
  }
}

void std::make_unique[abi:nn180100]<mlir::anec::`anonymous namespace'::WriteA12PlistPass,std::string &,std::string &,BOOL &,BOOL &>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, char *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  char v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::string __p;
  std::string __str;
  char v20;
  char v21;

  v10 = operator new();
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    if ((*(char *)(a2 + 23) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_5:
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    goto LABEL_6;
  }
  __str = *(std::string *)a1;
  if (*(char *)(a2 + 23) < 0)
    goto LABEL_5;
LABEL_3:
  __p = *(std::string *)a2;
LABEL_6:
  v11 = *a3;
  v12 = *a4;
  v21 = v11;
  v20 = v12;
  *(_QWORD *)v10 = &off_24C051008;
  std::string::operator=((std::string *)(v10 + 472), &__str);
  v13 = *(_QWORD *)(v10 + 568);
  if (!v13)
    goto LABEL_15;
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v13 + 48))(v13, &__str);
  std::string::operator=((std::string *)(v10 + 720), &__p);
  v14 = *(_QWORD *)(v10 + 816);
  if (!v14
    || ((*(void (**)(uint64_t, std::string *))(*(_QWORD *)v14 + 48))(v14, &__p),
        *(_BYTE *)(v10 + 968) = v11,
        (v15 = *(_QWORD *)(v10 + 1024)) == 0)
    || ((*(void (**)(uint64_t, char *))(*(_QWORD *)v15 + 48))(v15, &v21),
        *(_BYTE *)(v10 + 1424) = v12,
        (v16 = *(_QWORD *)(v10 + 1480)) == 0))
  {
LABEL_15:
    v17 = std::__throw_bad_function_call[abi:nn180100]();
    mlir::anec::populateWritePlistPass(v17);
    return;
  }
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v16 + 48))(v16, &v20);
  *a5 = v10;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_14:
    operator delete(__str.__r_.__value_.__l.__data_);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_14;
}

void mlir::anec::populateWritePlistPass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __asm { BR              X10 }
}

void sub_20713E380(uint64_t *__p, uint64_t a2, uint64_t a3, uint64_t a4, std::string *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__pa, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  char v14;
  int v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE **v19;
  uint64_t v20;
  std::string v21;
  std::string v22;
  uint64_t v23[9];

  v19 = (_BYTE **)mlir::OpPassManager::nest(__p, "anec.A13", 8uLL);
  if (*(char *)(v18 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)v18, *(_QWORD *)(v18 + 8));
    if ((*(char *)(v17 + 23) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else
  {
    v22 = *(std::string *)v18;
    if ((*(char *)(v17 + 23) & 0x80000000) == 0)
    {
LABEL_3:
      v21 = *(std::string *)v17;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)v17, *(_QWORD *)(v17 + 8));
LABEL_6:
  mlir::anec::createWritePlistPass((uint64_t)&v22, (uint64_t)&v21, v16, v15, v14, v23);
  mlir::OpPassManager::addPass(v19, v23);
  v20 = v23[0];
  v23[0] = 0;
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
  if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_10;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
LABEL_10:
    operator delete(v22.__r_.__value_.__l.__data_);
}

void mlir::anec::getRegionConversionInfo(unsigned int *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  mlir::anec::ANECIRProcedure *v8;
  mlir::anec::ANECIRProcedure *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  _QWORD v26[4];
  mlir::anec::ANECIRProcedure *v27[2];
  mlir::anec::ANECIRProcedure *v28;
  mlir::anec::ANECIRProcedure *v29;

  v8 = (mlir::anec::ANECIRProcedure *)operator new();
  *(_QWORD *)v8 = &off_24C051568;
  *((_QWORD *)v8 + 1) = (char *)v8 + 24;
  *((_QWORD *)v8 + 2) = 0x500000000;
  *((_QWORD *)v8 + 13) = (char *)v8 + 120;
  *((_QWORD *)v8 + 14) = 0x500000000;
  *((_QWORD *)v8 + 25) = 0x6765725F63656E61;
  *((_QWORD *)v8 + 26) = 7237481;
  *((_BYTE *)v8 + 223) = 11;
  *((_OWORD *)v8 + 14) = 0u;
  *((_OWORD *)v8 + 15) = 0u;
  *((_OWORD *)v8 + 16) = 0u;
  v28 = v8;
  v9 = (mlir::anec::ANECIRProcedure *)operator new();
  *(_QWORD *)v9 = &off_24C05DA60;
  *((_QWORD *)v9 + 1) = 0;
  *((_QWORD *)v9 + 2) = 0;
  *((_QWORD *)v9 + 3) = v8;
  v29 = v9;
  if (a1)
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  v10 = a1[11];
  if ((v10 & 0x7FFFFF) != 0)
    v11 = (_QWORD *)((((unint64_t)&a1[4 * ((v10 >> 23) & 1) + 17] + ((v10 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * a1[10]);
  else
    v11 = 0;
  if ((_QWORD *)*v11 != v11)
  {
    v12 = v11[1];
    v13 = v12 ? v12 - 8 : 0;
    v14 = *(uint64_t **)(v13 + 48);
    v15 = *(uint64_t **)(v13 + 56);
    if (v15 != v14)
    {
      while (1)
      {
        v20 = *v14;
        v21 = (std::__shared_weak_count *)v29;
        v27[0] = v28;
        v27[1] = v29;
        if (!v29)
          break;
        v22 = (unint64_t *)((char *)v29 + 8);
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
        do
          v24 = __ldaxr(v22);
        while (__stlxr(v24 - 1, v22));
        if (v24)
          goto LABEL_19;
        v25 = v19;
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
        if (!v25)
          goto LABEL_12;
LABEL_20:
        if (++v14 == v15)
          goto LABEL_11;
      }
LABEL_19:
      if (!v19)
        goto LABEL_12;
      goto LABEL_20;
    }
  }
LABEL_11:
  v26[0] = a2;
  v26[1] = a4;
  v26[2] = a3;
  v26[3] = &v28;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a1, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anec::getRegionConversionInfo(mlir::Operation *,mlir::anec::ANECIRWeights &,std::shared_ptr<mlir::anec::RegionConversionInfo> &,llvm::DenseMap<long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>> &)::$_0>, (uint64_t)v26, 1);
  mlir::anec::ANECIRNetwork::getUnits((uint64_t)v28, *a3 + 192);
  mlir::anec::ANECIRNetwork::getConstants((uint64_t)v28, *a3 + 64);
  mlir::anec::ANECIRNetwork::getInputs((uint64_t)v28, *a3);
LABEL_12:
  v16 = (std::__shared_weak_count *)v29;
  if (v29)
  {
    v17 = (unint64_t *)((char *)v29 + 8);
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

_QWORD *mlir::anec::ANECIRInput::Create@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  std::string *v11;
  std::string *v12;
  std::string *v13;
  _QWORD *result;

  v10 = operator new();
  *(_QWORD *)v10 = off_24C050D68;
  v11 = (std::string *)(v10 + 8);
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    *(_QWORD *)(v10 + 24) = *(_QWORD *)(a1 + 16);
  }
  *(_DWORD *)(v10 + 32) = 0;
  *(_QWORD *)(v10 + 40) = off_24C051800;
  v12 = (std::string *)(v10 + 48);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *(_QWORD *)(v10 + 64) = *(_QWORD *)(a3 + 16);
  }
  v13 = (std::string *)(v10 + 72);
  if (*(char *)(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)a4;
    *(_QWORD *)(v10 + 88) = *(_QWORD *)(a4 + 16);
  }
  *(_QWORD *)v10 = off_24C050D28;
  *(_QWORD *)(v10 + 40) = &unk_24C050D48;
  *(_QWORD *)(v10 + 96) = 1;
  *(_DWORD *)(v10 + 104) = a2;
  *(_QWORD *)(v10 + 144) = 0;
  *(_QWORD *)(v10 + 168) = 0;
  *(_QWORD *)(v10 + 176) = 0;
  *a5 = v10;
  result = (_QWORD *)operator new();
  *result = &off_24C05D980;
  result[1] = 0;
  result[2] = 0;
  result[3] = v10;
  a5[1] = (uint64_t)result;
  return result;
}

uint64_t llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIRInput>,false>::growAndEmplaceBack<std::shared_ptr<mlir::anec::ANECIRInput>>(uint64_t a1, uint64_t a2)
{
  char *v4;
  _OWORD *v5;
  _OWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  char *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  int v16;
  unsigned int v17;
  unint64_t v19;

  v19 = 0;
  v4 = (char *)(a1 + 16);
  v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 16, &v19);
  v6 = v5;
  v5[*(unsigned int *)(a1 + 8)] = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v7 = *(char **)a1;
  v8 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v8)
  {
    v9 = 16 * v8;
    v10 = v5;
    do
    {
      *v10++ = *(_OWORD *)v7;
      *(_QWORD *)v7 = 0;
      *((_QWORD *)v7 + 1) = 0;
      v7 += 16;
      v9 -= 16;
    }
    while (v9);
    v7 = *(char **)a1;
    v11 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v11)
    {
      v12 = &v7[16 * v11];
      do
      {
        v13 = (std::__shared_weak_count *)*((_QWORD *)v12 - 1);
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            v15 = __ldaxr(p_shared_owners);
          while (__stlxr(v15 - 1, p_shared_owners));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        v12 -= 16;
      }
      while (v12 != v7);
      v7 = *(char **)a1;
    }
  }
  v16 = v19;
  if (v7 != v4)
    free(v7);
  *(_QWORD *)a1 = v6;
  v17 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v17;
  *(_DWORD *)(a1 + 12) = v16;
  return (uint64_t)&v6[v17 - 1];
}

void mlir::anec::ANECIRInput::~ANECIRInput(mlir::anec::ANECIRInput *this)
{
  *((_QWORD *)this + 5) = off_24C051800;
  if (*((char *)this + 95) < 0)
  {
    operator delete(*((void **)this + 9));
    if ((*((char *)this + 71) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 6));
LABEL_3:
  *(_QWORD *)this = off_24C050D68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

{
  *((_QWORD *)this + 5) = off_24C051800;
  if (*((char *)this + 95) < 0)
  {
    operator delete(*((void **)this + 9));
    if ((*((char *)this + 71) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 6));
LABEL_3:
  *(_QWORD *)this = off_24C050D68;
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
  JUMPOUT(0x20BD002F8);
}

void `non-virtual thunk to'mlir::anec::ANECIRInput::~ANECIRInput(void **this)
{
  *this = off_24C051800;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    if ((*((char *)this + 31) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((*((char *)this + 31) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[1]);
LABEL_3:
  *(this - 5) = off_24C050D68;
  if (*((char *)this - 9) < 0)
    operator delete(*(this - 4));
}

{
  *this = off_24C051800;
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  *(this - 5) = off_24C050D68;
  if (*((char *)this - 9) < 0)
    operator delete(*(this - 4));
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_pointer<mlir::anec::ANECIRInput *,std::shared_ptr<mlir::anec::ANECIRInput>::__shared_ptr_default_delete<mlir::anec::ANECIRInput,mlir::anec::ANECIRInput>,std::allocator<mlir::anec::ANECIRInput>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<mlir::anec::ANECIRInput *,std::shared_ptr<mlir::anec::ANECIRInput>::__shared_ptr_default_delete<mlir::anec::ANECIRInput,mlir::anec::ANECIRInput>,std::allocator<mlir::anec::ANECIRInput>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    *(_QWORD *)(v1 + 40) = off_24C051800;
    if (*(char *)(v1 + 95) < 0)
    {
      operator delete(*(void **)(v1 + 72));
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
        goto LABEL_4;
    }
    else if ((*(char *)(v1 + 71) & 0x80000000) == 0)
    {
      goto LABEL_4;
    }
    operator delete(*(void **)(v1 + 48));
LABEL_4:
    *(_QWORD *)v1 = off_24C050D68;
    if (*(char *)(v1 + 31) < 0)
      operator delete(*(void **)(v1 + 8));
    JUMPOUT(0x20BD002F8);
  }
  return result;
}

int8x16_t mlir::anec::`anonymous namespace'::updateIOWithCustomInfo<mlir::anec::ANECIRInput,true>(uint64_t a1, uint64_t a2)
{
  int8x16_t *v4;
  int v5;
  int8x16_t *v6;
  const unsigned __int8 *v7;
  int Key;
  int8x16_t result;
  int v10;
  int8x16_t *v11;
  const unsigned __int8 *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x16_t v17;
  uint64_t *v18;
  uint64_t v19;
  int8x16_t *v20;
  uint64_t v21;
  uint64_t v22;

  v4 = (int8x16_t *)(a1 + 8);
  v5 = *(char *)(a1 + 31);
  if (v5 >= 0)
    v6 = (int8x16_t *)(a1 + 8);
  else
    v6 = *(int8x16_t **)(a1 + 8);
  if (v5 >= 0)
    v7 = (const unsigned __int8 *)*(unsigned __int8 *)(a1 + 31);
  else
    v7 = *(const unsigned __int8 **)(a1 + 16);
  Key = llvm::StringMapImpl::FindKey((uint64_t *)a2, v6, v7);
  if (Key != -1 && Key != (unint64_t)*(unsigned int *)(a2 + 8))
  {
    v10 = *(char *)(a1 + 31);
    if (v10 >= 0)
      v11 = v4;
    else
      v11 = *(int8x16_t **)(a1 + 8);
    if (v10 >= 0)
      v12 = (const unsigned __int8 *)*(unsigned __int8 *)(a1 + 31);
    else
      v12 = *(const unsigned __int8 **)(a1 + 16);
    v13 = llvm::StringMapImpl::FindKey((uint64_t *)a2, v11, v12);
    if (v13 == -1)
      v14 = *(unsigned int *)(a2 + 8);
    else
      v14 = v13;
    v15 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v14);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(v15 + 104);
    v16 = *(_QWORD *)(v15 + 56);
    if (*(_DWORD *)(v15 + 64) == 5)
    {
      v17 = *(int8x16_t *)(v16 + 16);
      *(int8x16_t *)(a1 + 168) = vextq_s8(*(int8x16_t *)v16, *(int8x16_t *)v16, 8uLL);
    }
    else
    {
      v17 = *(int8x16_t *)(v16 + 8);
    }
    *(int8x16_t *)(a1 + 152) = vextq_s8(v17, v17, 8uLL);
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(v15 + 112);
    v18 = *(uint64_t **)(v15 + 8);
    v19 = *(unsigned int *)(v15 + 16);
    if ((_DWORD)v19 == 5)
      *(_QWORD *)(a1 + 144) = v18[1];
    v20 = (int8x16_t *)&v18[v19];
    v21 = v20[-2].i64[1];
    v22 = *v18;
    result = vextq_s8(v20[-1], v20[-1], 8uLL);
    *(int8x16_t *)(a1 + 112) = result;
    *(_QWORD *)(a1 + 128) = v21;
    *(_QWORD *)(a1 + 136) = v22;
  }
  return result;
}

uint64_t mlir::anec::`anonymous namespace'::updateNetworkIOTypes(mlir::Operation *,std::shared_ptr<mlir::anec::ANECIRNetwork> const&)::$_1::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, int64_t a4)
{
  uint64_t ElementTypeOrSelf;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t Shape;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unsigned int ANECIRDataType;
  uint64_t v24;
  uint64_t v25;
  const char *v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD v32[24];

  v32[23] = *MEMORY[0x24BDAC8D0];
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a2);
  v30 = ElementTypeOrSelf;
  v29 = mlir::getElementTypeOrSelf(a3);
  if (ElementTypeOrSelf == v29)
  {
    v25 = ElementTypeOrSelf;
LABEL_21:
    ANECIRDataType = mlir::anec::getANECIRDataType(v25);
    v24 = 0x100000000;
    return v24 | ANECIRDataType;
  }
  if (!mlir::Type::isF32((mlir::Type *)&v30) || !mlir::Type::isF16((mlir::Type *)&v29))
  {
    v22 = "Only F16 <-> F32 ANE / host type conversion is supported";
    goto LABEL_17;
  }
  v8 = (_QWORD *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_13;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_13;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_13:
    v18 = 0;
  v31 = v8;
  v32[0] = v18;
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v31);
  v21 = *(_QWORD *)(Shape + 8 * v20 - 8);
  if (v21 * (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v30) >> 3) <= a4)
  {
    v25 = v30;
    goto LABEL_21;
  }
  v22 = "Invalid input strides: row stride must be large enough to represent the whole F32 row";
LABEL_17:
  v27 = v22;
  v28 = 259;
  mlir::Operation::emitError(a1, (uint64_t)&v27, (uint64_t)&v31);
  if (v31)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v31);
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v32);
  ANECIRDataType = 0;
  v24 = 0;
  return v24 | ANECIRDataType;
}

uint64_t mlir::anec::`anonymous namespace'::updateIOWithCustomInfo<mlir::anec::ANECIROutput,true>(uint64_t a1, uint64_t a2)
{
  int8x16_t *v4;
  int v5;
  int8x16_t *v6;
  const unsigned __int8 *v7;
  uint64_t result;
  int v9;
  int8x16_t *v10;
  const unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  int8x16_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v4 = (int8x16_t *)(a1 + 8);
  v5 = *(char *)(a1 + 31);
  if (v5 >= 0)
    v6 = (int8x16_t *)(a1 + 8);
  else
    v6 = *(int8x16_t **)(a1 + 8);
  if (v5 >= 0)
    v7 = (const unsigned __int8 *)*(unsigned __int8 *)(a1 + 31);
  else
    v7 = *(const unsigned __int8 **)(a1 + 16);
  result = llvm::StringMapImpl::FindKey((uint64_t *)a2, v6, v7);
  if ((_DWORD)result != -1 && (int)result != (unint64_t)*(unsigned int *)(a2 + 8))
  {
    v9 = *(char *)(a1 + 31);
    if (v9 >= 0)
      v10 = v4;
    else
      v10 = *(int8x16_t **)(a1 + 8);
    if (v9 >= 0)
      v11 = (const unsigned __int8 *)*(unsigned __int8 *)(a1 + 31);
    else
      v11 = *(const unsigned __int8 **)(a1 + 16);
    result = llvm::StringMapImpl::FindKey((uint64_t *)a2, v10, v11);
    if ((_DWORD)result == -1)
      v12 = *(unsigned int *)(a2 + 8);
    else
      v12 = (int)result;
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v12);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(v13 + 104);
    v14 = *(int8x16_t **)(v13 + 56);
    v15 = *(unsigned int *)(v13 + 64);
    if ((_DWORD)v15 == 5)
    {
      v17 = v14[1].i64[0];
      v16 = v14[1].i64[1];
      *(int8x16_t *)(a1 + 152) = vextq_s8(*v14, *v14, 8uLL);
    }
    else
    {
      v16 = v14[-1].i64[v15];
      if (v15 <= 2)
        v18 = v15 - 2;
      else
        v18 = v15 - 3;
      v17 = v14->i64[v18];
    }
    *(_QWORD *)(a1 + 136) = v16;
    *(_QWORD *)(a1 + 144) = v17;
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(v13 + 112);
  }
  return result;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec12_GLOBAL__N_120updateNetworkIOTypesES3_RKNSt3__110shared_ptrINSB_13ANECIRNetworkEEEE3__0NS1_9placement10RegionCallEvEENSD_9enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESS_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *a1, mlir::Operation *a2)
{
  uint64_t v2;
  const void *AttrData;
  size_t v4;
  size_t v5;
  const void *Callee;
  uint64_t v7;
  uint64_t v8;
  mlir::Operation *v9;
  uint64_t v10;
  mlir::Operation *v11;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
    {
      v2 = *a1;
      v11 = a2;
      AttrData = (const void *)mlir::OpaqueAttr::getAttrData(*(mlir::OpaqueAttr **)v2);
      v5 = v4;
      Callee = (const void *)mlir::placement::RegionCall::getCallee(&v11);
      if (v5 == v7 && (!v5 || !memcmp(AttrData, Callee, v5)))
      {
        v8 = *(_QWORD *)(v2 + 8);
        v9 = v11;
        v10 = *(unsigned int *)(v8 + 8);
        if (v10 >= *(_DWORD *)(v8 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(*(_QWORD *)(v2 + 8), (void *)(v8 + 16), v10 + 1, 8);
          LODWORD(v10) = *(_DWORD *)(v8 + 8);
        }
        *(_QWORD *)(*(_QWORD *)v8 + 8 * v10) = v9;
        ++*(_DWORD *)(v8 + 8);
      }
    }
  }
}

void mlir::Attribute::walk<(mlir::WalkOrder)1,mlir::anec::`anonymous namespace'::ParseCustomIOInfoFromAttribute(mlir::Operation *)::$_0 &>(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3;
  char *v4;
  _QWORD *v5;
  uint64_t v6;
  void *v7[2];
  void *__p[2];
  __int128 v9;
  llvm *v10[2];
  unsigned int v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v11 = 0;
  v9 = 0u;
  *(_OWORD *)v10 = 0u;
  *(_OWORD *)v7 = 0u;
  *(_OWORD *)__p = 0u;
  v3 = *a2;
  v12[0] = &off_24BFF5090;
  v12[1] = v3;
  v13 = v12;
  v4 = std::vector<std::function<mlir::WalkResult ()(mlir::Attribute)>>::__emplace_back_slow_path<std::function<mlir::WalkResult ()(mlir::Attribute)>>(v7, v12);
  v5 = v13;
  v7[1] = v4;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  mlir::AttrTypeWalker::walkImpl(v7, *a1, 1u);
  llvm::deallocate_buffer(v10[0], (void *)(24 * v11));
}

char *std::vector<std::function<mlir::WalkResult ()(mlir::Attribute)>>::__emplace_back_slow_path<std::function<mlir::WalkResult ()(mlir::Attribute)>>(_QWORD *a1, _QWORD *a2)
{
  char *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v20;
  uint64_t v21;
  char *v22;

  v2 = (char *)a1[1];
  v3 = (uint64_t)&v2[-*a1] >> 5;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59)
    abort();
  v7 = a1[2] - *a1;
  if (v7 >> 4 > v4)
    v4 = v7 >> 4;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0)
    v8 = 0x7FFFFFFFFFFFFFFLL;
  else
    v8 = v4;
  if (v8)
  {
    if (v8 >> 59)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v9 = (char *)operator new(32 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = &v9[32 * v3];
  v11 = (_QWORD *)a2[3];
  if (v11)
  {
    if (v11 == a2)
    {
      *((_QWORD *)v10 + 3) = v10;
      (*(void (**)(_QWORD *, char *))(*a2 + 24))(a2, v10);
      v2 = (char *)a1[1];
    }
    else
    {
      *((_QWORD *)v10 + 3) = v11;
      a2[3] = 0;
    }
  }
  else
  {
    *((_QWORD *)v10 + 3) = 0;
  }
  v12 = &v9[32 * v8];
  v13 = v10 + 32;
  v14 = (char *)*a1;
  if (v2 != (char *)*a1)
  {
    do
    {
      v15 = v10;
      v10 -= 32;
      v16 = v2 - 32;
      v17 = (char *)*((_QWORD *)v2 - 1);
      if (v17)
      {
        if (v16 == v17)
        {
          *((_QWORD *)v15 - 1) = v10;
          (*(void (**)(_QWORD, char *))(**((_QWORD **)v2 - 1) + 24))(*((_QWORD *)v2 - 1), v10);
        }
        else
        {
          *((_QWORD *)v15 - 1) = v17;
          *((_QWORD *)v2 - 1) = 0;
        }
      }
      else
      {
        *((_QWORD *)v15 - 1) = 0;
      }
      v2 -= 32;
    }
    while (v16 != v14);
    v2 = (char *)*a1;
  }
  v18 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v13;
  a1[2] = v12;
  if (v18 != v2)
  {
    do
    {
      v22 = v18 - 32;
      v20 = (char *)*((_QWORD *)v18 - 1);
      if (v18 - 32 == v20)
      {
        v20 = v18 - 32;
        v21 = 4;
      }
      else
      {
        if (!v20)
          goto LABEL_31;
        v21 = 5;
      }
      (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_31:
      v18 = v22;
    }
    while (v22 != v2);
  }
  if (v2)
    operator delete(v2);
  return v13;
}

void _ZNSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIRZNS2_4anec12_GLOBAL__N_130ParseCustomIOInfoFromAttributeEPNS2_9OperationEE3__0NS2_14DictionaryAttrENS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSC_E_NS_9allocatorISL_EEFNS2_10WalkResultESC_EED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIRZNS2_4anec12_GLOBAL__N_130ParseCustomIOInfoFromAttributeEPNS2_9OperationEE3__0NS2_14DictionaryAttrENS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSC_E_NS_9allocatorISL_EEFNS2_10WalkResultESC_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24BFF5090;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIRZNS2_4anec12_GLOBAL__N_130ParseCustomIOInfoFromAttributeEPNS2_9OperationEE3__0NS2_14DictionaryAttrENS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSC_E_NS_9allocatorISL_EEFNS2_10WalkResultESC_EE7__cloneEPNS0_6__baseISP_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24BFF5090;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir14AttrTypeWalker7addWalkIRZNS2_4anec12_GLOBAL__N_130ParseCustomIOInfoFromAttributeEPNS2_9OperationEE3__0NS2_14DictionaryAttrENS2_9AttributeEvEENS_9enable_ifIXoontsr3stdE9is_same_vIT0_T1_Esr3stdE9is_same_vIT2_vEEvE4typeEOT_EUlSC_E_NS_9allocatorISL_EEFNS2_10WalkResultESC_EEclEOSC_(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  int8x16_t *AttrData;
  const unsigned __int8 *v6;
  const unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t Value;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void **v22;
  unint64_t v23;
  uint64_t v24;
  char *buffer;
  char *v26;
  char *v27;
  uint64_t *i;
  void **v30;
  unint64_t v31;
  uint64_t v32;
  _BYTE *v33;
  uint64_t v35;
  uint64_t v36;
  void *__src;
  uint64_t v38;
  _BYTE v39[32];
  void *v40;
  uint64_t v41;
  _BYTE v42[32];
  uint64_t UInt;
  int ANECIRDataType;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    return 1;
  v36 = *a2;
  __src = v39;
  v38 = 0x400000000;
  v40 = v42;
  v41 = 0x400000000;
  UInt = 1;
  v3 = mlir::DictionaryAttr::get((uint64_t)&v36, "name", 4uLL);
  if (v3)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v3 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      v4 = v3;
    else
      v4 = 0;
  }
  else
  {
    v4 = 0;
  }
  v35 = v4;
  AttrData = (int8x16_t *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v35);
  v7 = v6;
  v8 = mlir::DictionaryAttr::get((uint64_t)&v36, "interleave", 0xAuLL);
  if (v8)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v9 = v8;
    else
      v9 = 0;
  }
  else
  {
    v9 = 0;
  }
  v35 = v9;
  UInt = (uint64_t)mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&v35);
  v10 = mlir::DictionaryAttr::get((uint64_t)&v36, "shape", 5uLL);
  if (v10)
  {
    v11 = v10;
    if (mlir::DenseIntElementsAttr::classof(v10))
      v10 = v11;
    else
      v10 = 0;
  }
  mlir::getValues<long long>(v10, (uint64_t)&__src);
  v12 = mlir::DictionaryAttr::get((uint64_t)&v36, "strides", 7uLL);
  if (v12)
  {
    v13 = v12;
    if (mlir::DenseIntElementsAttr::classof(v12))
      v12 = v13;
    else
      v12 = 0;
  }
  mlir::getValues<long long>(v12, (uint64_t)&v40);
  v14 = mlir::DictionaryAttr::get((uint64_t)&v36, "elementType", 0xBuLL);
  if (v14)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
      v15 = v14;
    else
      v15 = 0;
  }
  else
  {
    v15 = 0;
  }
  v35 = v15;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v35);
  ANECIRDataType = mlir::anec::getANECIRDataType(Value);
  v17 = *(_QWORD *)(a1 + 8);
  v18 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)v17, AttrData, v7);
  v19 = *(_QWORD *)v17;
  v20 = v18;
  v21 = *(_QWORD *)(*(_QWORD *)v17 + 8 * v18);
  if (v21 == -8)
  {
    --*(_DWORD *)(v17 + 16);
  }
  else if (v21)
  {
    goto LABEL_27;
  }
  buffer = (char *)llvm::allocate_buffer((size_t)(v7 + 121), (std::align_val_t)8uLL);
  v26 = buffer;
  v27 = buffer + 120;
  if (v7)
    memcpy(buffer + 120, AttrData, (size_t)v7);
  v7[(_QWORD)v27] = 0;
  *(_OWORD *)(v26 + 56) = 0u;
  *(_OWORD *)(v26 + 104) = 0u;
  *(_OWORD *)(v26 + 40) = 0u;
  *(_OWORD *)(v26 + 88) = 0u;
  *(_OWORD *)(v26 + 72) = 0u;
  *(_OWORD *)(v26 + 24) = 0u;
  *(_QWORD *)v26 = v7;
  *((_QWORD *)v26 + 1) = v26 + 24;
  *((_QWORD *)v26 + 2) = 0x400000000;
  *((_QWORD *)v26 + 7) = v26 + 72;
  *((_DWORD *)v26 + 17) = 4;
  *((_QWORD *)v26 + 13) = 1;
  *(_QWORD *)(v19 + 8 * v20) = v26;
  ++*(_DWORD *)(v17 + 12);
  for (i = (uint64_t *)(*(_QWORD *)v17
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)v17, v20)); ; ++i)
  {
    v21 = *i;
    if (*i && v21 != -8)
      break;
  }
LABEL_27:
  v22 = (void **)(v21 + 8);
  if ((void **)(v21 + 8) != &__src)
  {
    v23 = v38;
    v24 = *(unsigned int *)(v21 + 16);
    if (v24 >= v38)
    {
      if ((_DWORD)v38)
        memmove(*v22, __src, 8 * v38);
LABEL_48:
      *(_DWORD *)(v21 + 16) = v23;
      v30 = (void **)(v21 + 56);
      v31 = v41;
      v32 = *(unsigned int *)(v21 + 64);
      if (v32 >= v41)
      {
        if ((_DWORD)v41)
          memmove(*v30, v40, 8 * v41);
        goto LABEL_58;
      }
      if (*(_DWORD *)(v21 + 68) >= v41)
      {
        if ((_DWORD)v32)
        {
          memmove(*v30, v40, 8 * v32);
          goto LABEL_56;
        }
      }
      else
      {
        *(_DWORD *)(v21 + 64) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21 + 56, (void *)(v21 + 72), v31, 8);
      }
      v32 = 0;
LABEL_56:
      if (v32 != v41)
        memcpy((char *)*v30 + 8 * v32, (char *)v40 + 8 * v32, 8 * v41 - 8 * v32);
LABEL_58:
      *(_DWORD *)(v21 + 64) = v31;
      goto LABEL_59;
    }
    if (*(_DWORD *)(v21 + 20) >= v38)
    {
      if ((_DWORD)v24)
      {
        memmove(*v22, __src, 8 * v24);
        goto LABEL_46;
      }
    }
    else
    {
      *(_DWORD *)(v21 + 16) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v21 + 8, (void *)(v21 + 24), v23, 8);
    }
    v24 = 0;
LABEL_46:
    if (v24 != v38)
      memcpy((char *)*v22 + 8 * v24, (char *)__src + 8 * v24, 8 * v38 - 8 * v24);
    goto LABEL_48;
  }
LABEL_59:
  v33 = v40;
  *(_QWORD *)(v21 + 104) = UInt;
  *(_DWORD *)(v21 + 112) = ANECIRDataType;
  if (v33 != v42)
    free(v33);
  if (__src != v39)
    free(__src);
  return 1;
}

void mlir::anec::ANECIRNetwork::~ANECIRNetwork(mlir::anec::ANECIRNetwork *this)
{
  mlir::anec::ANECIRNetwork::~ANECIRNetwork(this);
  JUMPOUT(0x20BD002F8);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;

  *(_QWORD *)this = &off_24C051568;
  v2 = *((_QWORD *)this + 31);
  if (v2)
  {
    v3 = *((_QWORD *)this + 32);
    v4 = (void *)*((_QWORD *)this + 31);
    if (v3 != v2)
    {
      do
      {
        v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 31);
    }
    *((_QWORD *)this + 32) = v2;
    operator delete(v4);
  }
  v8 = *((_QWORD *)this + 28);
  if (v8)
  {
    v9 = *((_QWORD *)this + 29);
    v10 = (void *)*((_QWORD *)this + 28);
    if (v9 != v8)
    {
      do
      {
        v11 = *(std::__shared_weak_count **)(v9 - 8);
        if (v11)
        {
          v12 = (unint64_t *)&v11->__shared_owners_;
          do
            v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
        v9 -= 16;
      }
      while (v9 != v8);
      v10 = (void *)*((_QWORD *)this + 28);
    }
    *((_QWORD *)this + 29) = v8;
    operator delete(v10);
  }
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  v14 = (char *)*((_QWORD *)this + 13);
  v15 = *((unsigned int *)this + 28);
  if ((_DWORD)v15)
  {
    v16 = &v14[16 * v15];
    do
    {
      v17 = (std::__shared_weak_count *)*((_QWORD *)v16 - 1);
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      v16 -= 16;
    }
    while (v16 != v14);
    v14 = (char *)*((_QWORD *)this + 13);
  }
  if (v14 != (char *)this + 120)
    free(v14);
  v20 = (char *)*((_QWORD *)this + 1);
  v21 = *((unsigned int *)this + 4);
  if ((_DWORD)v21)
  {
    v22 = &v20[16 * v21];
    do
    {
      v23 = (std::__shared_weak_count *)*((_QWORD *)v22 - 1);
      if (v23)
      {
        v24 = (unint64_t *)&v23->__shared_owners_;
        do
          v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      v22 -= 16;
    }
    while (v22 != v20);
    v20 = (char *)*((_QWORD *)this + 1);
  }
  if (v20 != (char *)this + 24)
    free(v20);
}

void std::__shared_ptr_pointer<mlir::anec::ANECIRNetwork *,std::shared_ptr<mlir::anec::ANECIRNetwork>::__shared_ptr_default_delete<mlir::anec::ANECIRNetwork,mlir::anec::ANECIRNetwork>,std::allocator<mlir::anec::ANECIRNetwork>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<mlir::anec::ANECIRNetwork *,std::shared_ptr<mlir::anec::ANECIRNetwork>::__shared_ptr_default_delete<mlir::anec::ANECIRNetwork,mlir::anec::ANECIRNetwork>,std::allocator<mlir::anec::ANECIRNetwork>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::anec::writeSingleRegionPlist(mlir::Operation *,std::shared_ptr<mlir::anec::ANECIRNetwork> const&,mlir::anec::ANECIRWeights &)::$_0>(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2)
{
  uint64_t v4;
  mlir::anec::ANECIRWeights *v5;
  mlir::anec::_anonymous_namespace_ *v7;
  uint64_t InterfaceFor;

  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD *, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD **)a2 + 6), v4)
  {
    if (!mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2))
    {
      v7 = 0;
      InterfaceFor = 0;
      return 1;
    }
    v7 = a2;
    InterfaceFor = mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
    if (!a2
      || mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v7, **(_QWORD **)a1, *(_QWORD *)(a1 + 8)))
    {
      return 1;
    }
  }
  return 0;
}

uint64_t mlir::anec::`anonymous namespace'::addConstToNetwork(mlir::anec::_anonymous_namespace_ *this, mlir::Operation *a2, mlir::anec::ANECIRNetwork *a3, mlir::anec::ANECIRWeights *a4)
{
  mlir::Operation *v7;
  uint64_t v8;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::string *v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unsigned int IndexFromDim;
  char v29;
  uint64_t v30;
  unsigned int v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  char v38;
  uint64_t v39;
  unsigned int v40;
  char v41;
  uint64_t v42;
  uint64_t RHS;
  int ANECIRDataType;
  unint64_t v45;
  uint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  _OWORD *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  __int128 v54;
  const void **v55;
  __int16 v56;
  std::string __p;
  unint64_t v58;
  void *v59;
  uint64_t v60;
  _QWORD v61[24];

  v61[22] = *MEMORY[0x24BDAC8D0];
  if (mlir::anec::ANECIRWeights::hasConstant(a3, this) || (mlir::isOpTriviallyDead((void ***)this, v7) & 1) != 0)
    return 1;
  v58 = *((_QWORD *)this - 1) & 0xFFFFFFFFFFFFFFF8;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58);
  v11 = v10;
  mlir::anec::computeOpKeyString(this, &__p);
  v12 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)this + 6) + 32))(*((_QWORD *)this + 6), v12))
    goto LABEL_15;
  v59 = v61;
  v60 = 0x100000000;
  mlir::Operation::fold((uint64_t)this, 0, 0, (uint64_t)&v59);
  v14 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v59 & 0xFFFFFFFFFFFFFFF8));
  if (v14)
    v15 = v13;
  else
    v15 = 0;
  if (v59 != v61)
    free(v59);
  if (!v14)
  {
LABEL_15:
    v16 = "Unable to get Elements from the constant op";
    goto LABEL_16;
  }
  if (!mlir::ElementsAttr::getNumElements((uint64_t)v14, v15))
  {
    v16 = "Weights should have 1 or more elements";
    goto LABEL_16;
  }
  if (v11 >= 6)
  {
    v16 = "Weights should have a rank less than or equal to 5";
LABEL_16:
    v55 = (const void **)v16;
    v56 = 259;
    mlir::Operation::emitOpError((uint64_t *)this, &v55, (uint64_t)&v59);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v59);
    if (v59)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v59);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v60);
    goto LABEL_19;
  }
  v17 = mlir::anec::ANECIRWeights::addConstant(a3, this);
  v19 = (_QWORD *)*((_QWORD *)this - 2);
  if (v19)
  {
    v20 = v17;
    v21 = v18;
    while (1)
    {
      v22 = v19[2];
      v23 = mlir::TypeID::get<mlir::OpTrait::anec::HasWeights<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::HasWeights>(void)::Empty>>();
      if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v22 + 48) + 32))(*(_QWORD *)(v22 + 48), v23))break;
      v19 = (_QWORD *)*v19;
      v8 = 1;
      if (!v19)
        goto LABEL_19;
    }
    v24 = operator new();
    *(_QWORD *)v24 = off_24C050D68;
    v25 = (std::string *)(v24 + 8);
    v53 = v21;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v25, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)&v25->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v24 + 24) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
    }
    *(_DWORD *)(v24 + 32) = 16;
    *(_QWORD *)v24 = off_24C051588;
    v26 = (std::__shared_weak_count *)operator new();
    v26->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    v26->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05DAD0;
    v26->__shared_weak_owners_ = 0;
    v26[1].__vftable = (std::__shared_weak_count_vtbl *)v24;
    IndexFromDim = mlir::anec::getIndexFromDim(0, v11);
    if (v29)
      v30 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58) + 8 * IndexFromDim);
    else
      v30 = 1;
    v31 = mlir::anec::getIndexFromDim(2, v11);
    if (v32)
      v33 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58) + 8 * v31);
    else
      v33 = 1;
    v34 = 1;
    v35 = mlir::anec::getIndexFromDim(1, v11);
    if (v36)
      v34 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58) + 8 * v35);
    v37 = mlir::anec::getIndexFromDim(3, v11);
    if (v38)
      v39 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58) + 8 * v37);
    else
      v39 = 1;
    v40 = mlir::anec::getIndexFromDim(4, v11);
    if (v41)
      v42 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58) + 8 * v40);
    else
      v42 = 1;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v58);
    ANECIRDataType = mlir::anec::getANECIRDataType(RHS);
    mlir::anec::ANECIRConstant::SetWeight(v24, v20, ANECIRDataType, v53, v30, v33, v34, v39, v42);
    *(_QWORD *)&v54 = v24;
    *((_QWORD *)&v54 + 1) = v26;
    do
      v45 = __ldxr(p_shared_owners);
    while (__stxr(v45 + 1, p_shared_owners));
    v46 = (uint64_t *)*((_QWORD *)a2 + 32);
    if ((unint64_t)v46 >= *((_QWORD *)a2 + 33))
    {
      v49 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>((uint64_t)a2 + 248, &v54);
      v48 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
      *((_QWORD *)a2 + 32) = v49;
      if (!v48)
      {
        do
LABEL_55:
          v52 = __ldaxr(p_shared_owners);
        while (__stlxr(v52 - 1, p_shared_owners));
        if (!v52)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
        goto LABEL_58;
      }
    }
    else
    {
      *v46 = v24;
      v46[1] = (uint64_t)v26;
      do
        v47 = __ldxr(p_shared_owners);
      while (__stxr(v47 + 1, p_shared_owners));
      *((_QWORD *)a2 + 32) = v46 + 2;
      v48 = v26;
    }
    v50 = (unint64_t *)&v48->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
    goto LABEL_55;
  }
LABEL_58:
  v8 = 1;
LABEL_19:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v8;
}

void mlir::anec::ANECIRConstant::~ANECIRConstant(void **this)
{
  *this = off_24C050D68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24C050D68;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_pointer<mlir::anec::ANECIRConstant *,std::shared_ptr<mlir::anec::ANECIRConstant>::__shared_ptr_default_delete<mlir::anec::ANECIRConstant,mlir::anec::ANECIRConstant>,std::allocator<mlir::anec::ANECIRConstant>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<mlir::anec::ANECIRConstant *,std::shared_ptr<mlir::anec::ANECIRConstant>::__shared_ptr_default_delete<mlir::anec::ANECIRConstant,mlir::anec::ANECIRConstant>,std::allocator<mlir::anec::ANECIRConstant>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    *(_QWORD *)v1 = off_24C050D68;
    if (*(char *)(v1 + 31) < 0)
      operator delete(*(void **)(v1 + 8));
    JUMPOUT(0x20BD002F8);
  }
  return result;
}

uint64_t mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v21 = *(_QWORD *)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v21);
    if (result)
    {
      v19 = result;
      v20 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19 + 104))(v19, v20, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    v7 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
    v8 = *(unsigned int *)(v6 + 40);
    if (!(_DWORD)v8)
      goto LABEL_14;
    v9 = *(_QWORD **)(v6 + 32);
    v10 = &v9[2 * v8];
    do
    {
      v11 = v8 >> 1;
      v12 = &v9[2 * (v8 >> 1)];
      v14 = *v12;
      v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7)
        v9 = v13;
      else
        v8 = v11;
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (result = v9[1]) == 0)
    {
LABEL_14:
      v16 = *(_QWORD *)(v6 + 24);
      v17 = *(_QWORD *)(a1 + 48);
      v18 = mlir::TypeID::get<mlir::anec::PlistGeneratorInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16 + 104))(v16, v18, v17);
    }
  }
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::anec::writeMultiProcedurePlist(mlir::Operation *,std::shared_ptr<mlir::anec::ANECIRNetwork> const&,std::shared_ptr<mlir::anec::ANECIRProcedure> const&,mlir::anec::ANECIRWeights &)::$_0>(uint64_t a1, mlir::anec::_anonymous_namespace_ *a2)
{
  uint64_t v4;
  mlir::anec::ANECIRWeights *v5;
  uint64_t *v6;
  mlir::anec::_anonymous_namespace_ *v8;
  uint64_t InterfaceFor;

  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v4)
  {
    if (!mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2))
    {
      v8 = 0;
      InterfaceFor = 0;
      return 1;
    }
    v8 = a2;
    InterfaceFor = mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
    if (!a2)
      return 1;
    v6 = *(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::RegionReturn,void>::id
       ? *(uint64_t **)(a1 + 16)
       : *(uint64_t **)a1;
    if (mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v8, *v6, *(_QWORD *)(a1 + 8)))
      return 1;
  }
  return 0;
}

void mlir::anec::`anonymous namespace'::WriteProcedureListPlistPass::~WriteProcedureListPlistPass(void **this)
{
  *this = off_24BFF4778;
  if (*((char *)this + 399) < 0)
  {
    operator delete(this[47]);
    if ((*((char *)this + 375) & 0x80000000) == 0)
      goto LABEL_3;
LABEL_5:
    operator delete(this[44]);
    goto LABEL_3;
  }
  if (*((char *)this + 375) < 0)
    goto LABEL_5;
LABEL_3:
  mlir::Pass::~Pass((mlir::Pass *)this);
}

{
  *this = off_24BFF4778;
  if (*((char *)this + 399) < 0)
  {
    operator delete(this[47]);
    if ((*((char *)this + 375) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((*((char *)this + 375) & 0x80000000) == 0)
  {
LABEL_3:
    mlir::Pass::~Pass((mlir::Pass *)this);
    JUMPOUT(0x20BD002F8);
  }
  operator delete(this[44]);
  goto LABEL_3;
}

const char *mlir::PassWrapper<mlir::anec::`anonymous namespace'::WriteProcedureListPlistPass,mlir::OperationPass<mlir::ModuleOp>>::getName()
{
  unint64_t v0;
  unint64_t v1;
  const char *v2;
  uint64_t v3;
  const char *v5;
  unint64_t v6;

  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::anec::(anonymous namespace)::WriteProcedureListPlistPass]";
  v6 = 112;
  v0 = llvm::StringRef::find((uint64_t *)&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
    v1 = v0;
  else
    v1 = v6;
  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
    v3 = 18;
  else
    v3 = v6 - v1;
  return &v2[v3];
}

char *mlir::Pass::getArgument(mlir::Pass *this)
{
  return &byte_207AF6795;
}

char *mlir::Pass::getDescription(mlir::Pass *this)
{
  return &byte_207AF6795;
}

uint64_t mlir::anec::`anonymous namespace'::WriteProcedureListPlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteProcedureListPlistPass *this)
{
  unint64_t v2;
  uint64_t v3;
  char v4;
  char *v5;
  uint64_t v6;
  char v7;
  char *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t Context;
  char v12;
  char *v13;
  uint64_t v14;
  char v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char *v20;
  uint64_t v21;
  char v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char *v27;
  uint64_t v28;
  char v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char *v34;
  uint64_t v35;
  char v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  char *v41;
  uint64_t v42;
  char v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  uint64_t v49;
  char v50;
  char *v51;
  uint64_t v52;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  switch(*((_DWORD *)this + 86))
  {
    case 1:
      Context = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v12 = *((_BYTE *)this + 375);
      if (v12 >= 0)
        v13 = (char *)this + 352;
      else
        v13 = (char *)*((_QWORD *)this + 44);
      if (v12 >= 0)
        v14 = *((unsigned __int8 *)this + 375);
      else
        v14 = *((_QWORD *)this + 45);
      v15 = *((_BYTE *)this + 399);
      if (v15 >= 0)
        v16 = (char *)this + 376;
      else
        v16 = (char *)*((_QWORD *)this + 47);
      if (v15 >= 0)
        v17 = *((unsigned __int8 *)this + 399);
      else
        v17 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A13>(v2, Context, (uint64_t)v13, v14, (uint64_t)v16, v17, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
        goto LABEL_99;
      break;
    case 2:
      v18 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v19 = *((_BYTE *)this + 375);
      if (v19 >= 0)
        v20 = (char *)this + 352;
      else
        v20 = (char *)*((_QWORD *)this + 44);
      if (v19 >= 0)
        v21 = *((unsigned __int8 *)this + 375);
      else
        v21 = *((_QWORD *)this + 45);
      v22 = *((_BYTE *)this + 399);
      if (v22 >= 0)
        v23 = (char *)this + 376;
      else
        v23 = (char *)*((_QWORD *)this + 47);
      if (v22 >= 0)
        v24 = *((unsigned __int8 *)this + 399);
      else
        v24 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A14>(v2, v18, (uint64_t)v20, v21, (uint64_t)v23, v24, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
        goto LABEL_99;
      break;
    case 3:
      v25 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v26 = *((_BYTE *)this + 375);
      if (v26 >= 0)
        v27 = (char *)this + 352;
      else
        v27 = (char *)*((_QWORD *)this + 44);
      if (v26 >= 0)
        v28 = *((unsigned __int8 *)this + 375);
      else
        v28 = *((_QWORD *)this + 45);
      v29 = *((_BYTE *)this + 399);
      if (v29 >= 0)
        v30 = (char *)this + 376;
      else
        v30 = (char *)*((_QWORD *)this + 47);
      if (v29 >= 0)
        v31 = *((unsigned __int8 *)this + 399);
      else
        v31 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A15>(v2, v25, (uint64_t)v27, v28, (uint64_t)v30, v31, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
        goto LABEL_99;
      break;
    case 4:
      v32 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v33 = *((_BYTE *)this + 375);
      if (v33 >= 0)
        v34 = (char *)this + 352;
      else
        v34 = (char *)*((_QWORD *)this + 44);
      if (v33 >= 0)
        v35 = *((unsigned __int8 *)this + 375);
      else
        v35 = *((_QWORD *)this + 45);
      v36 = *((_BYTE *)this + 399);
      if (v36 >= 0)
        v37 = (char *)this + 376;
      else
        v37 = (char *)*((_QWORD *)this + 47);
      if (v36 >= 0)
        v38 = *((unsigned __int8 *)this + 399);
      else
        v38 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A16>(v2, v32, (uint64_t)v34, v35, (uint64_t)v37, v38, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
        goto LABEL_99;
      break;
    case 5:
      v39 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v40 = *((_BYTE *)this + 375);
      if (v40 >= 0)
        v41 = (char *)this + 352;
      else
        v41 = (char *)*((_QWORD *)this + 44);
      if (v40 >= 0)
        v42 = *((unsigned __int8 *)this + 375);
      else
        v42 = *((_QWORD *)this + 45);
      v43 = *((_BYTE *)this + 399);
      if (v43 >= 0)
        v44 = (char *)this + 376;
      else
        v44 = (char *)*((_QWORD *)this + 47);
      if (v43 >= 0)
        v45 = *((unsigned __int8 *)this + 399);
      else
        v45 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A17>(v2, v39, (uint64_t)v41, v42, (uint64_t)v44, v45, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
        goto LABEL_99;
      break;
    case 6:
      v46 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v47 = *((_BYTE *)this + 375);
      if (v47 >= 0)
        v48 = (char *)this + 352;
      else
        v48 = (char *)*((_QWORD *)this + 44);
      if (v47 >= 0)
        v49 = *((unsigned __int8 *)this + 375);
      else
        v49 = *((_QWORD *)this + 45);
      v50 = *((_BYTE *)this + 399);
      if (v50 >= 0)
        v51 = (char *)this + 376;
      else
        v51 = (char *)*((_QWORD *)this + 47);
      if (v50 >= 0)
        v52 = *((unsigned __int8 *)this + 399);
      else
        v52 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A11Legacy>(v2, v46, (uint64_t)v48, v49, (uint64_t)v51, v52, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
        goto LABEL_99;
      break;
    default:
      v3 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 24));
      v4 = *((_BYTE *)this + 375);
      if (v4 >= 0)
        v5 = (char *)this + 352;
      else
        v5 = (char *)*((_QWORD *)this + 44);
      if (v4 >= 0)
        v6 = *((unsigned __int8 *)this + 375);
      else
        v6 = *((_QWORD *)this + 45);
      v7 = *((_BYTE *)this + 399);
      if (v7 >= 0)
        v8 = (char *)this + 376;
      else
        v8 = (char *)*((_QWORD *)this + 47);
      if (v7 >= 0)
        v9 = *((unsigned __int8 *)this + 399);
      else
        v9 = *((_QWORD *)this + 48);
      result = mlir::anec::genProcedureListANECIR<mlir::anec::A12>(v2, v3, (uint64_t)v5, v6, (uint64_t)v8, v9, *((_BYTE *)this + 400));
      if (!(_BYTE)result)
LABEL_99:
        *((_QWORD *)this + 5) |= 4uLL;
      break;
  }
  return result;
}

void mlir::PassWrapper<mlir::anec::`anonymous namespace'::WriteProcedureListPlistPass,mlir::OperationPass<mlir::ModuleOp>>::clonePass(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  std::string *v6;
  std::string *v7;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24BFF4778;
  *(_QWORD *)(v4 + 8) = v5;
  *(_DWORD *)(v4 + 344) = *(_DWORD *)(a1 + 344);
  v6 = (std::string *)(v4 + 352);
  if (*(char *)(a1 + 375) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a1 + 352), *(_QWORD *)(a1 + 360));
  }
  else
  {
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 352);
    *(_QWORD *)(v4 + 368) = *(_QWORD *)(a1 + 368);
  }
  v7 = (std::string *)(v4 + 376);
  if (*(char *)(a1 + 399) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a1 + 376), *(_QWORD *)(a1 + 384));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 376);
    *(_QWORD *)(v4 + 392) = *(_QWORD *)(a1 + 392);
  }
  *(_WORD *)(v4 + 400) = *(_WORD *)(a1 + 400);
  *a2 = v4;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A12>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A12>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A12EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A12EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A13>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A13>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A13EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A13EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A14>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A14>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A14EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A14EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A15>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A15>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A15EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A15EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A16>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A16>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A16EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A16EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A17>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A17>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A17EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A17EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A11Legacy>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  std::ios_base *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  std::string *data;
  std::string::size_type size;
  std::string *v25;
  std::string::size_type v26;
  llvm *v27;
  uint64_t v28;
  uint64_t v29;
  mlir::StringAttr *Context;
  mlir::StringAttr *v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  void *v34;
  std::string *v35;
  std::string::size_type v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  const char *v39;
  size_t v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::ToolOutputFile::CleanupInstaller *v43;
  llvm::ToolOutputFile::CleanupInstaller *v44;
  std::__shared_weak_count *v45;
  unint64_t *p_shared_owners;
  unint64_t v47;
  uint64_t v49;
  llvm::ToolOutputFile::CleanupInstaller *v50;
  llvm::ToolOutputFile::CleanupInstaller *v51;
  void *v52;
  size_t v53;
  uint64_t v54;
  std::string *v55;
  std::__shared_weak_count *v56;
  std::string __p;
  uint64_t v58;
  uint64_t v59;
  _BYTE v60[16];
  ZinIrHalH13g *v61;
  uint64_t (*v62)(void);
  ZinIrHalH13g *v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t *v66;
  const void **v67[4];
  __int16 v68;
  const void ***v69;
  _BYTE v70[192];
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *p_p;
  llvm *v76;
  _QWORD *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  _QWORD v81[5];
  __int128 v82;
  __int128 v83;
  int v84;
  _QWORD v85[20];

  v85[19] = *MEMORY[0x24BDAC8D0];
  v65[1] = a4;
  v66 = (uint64_t *)a1;
  v64[1] = a6;
  v65[0] = a3;
  v64[0] = a5;
  mlir::Region::getOps<mlir::anec::A11Legacy>((mlir::Region *)(((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40)), (uint64_t)v60);
  if (v61 == v63)
    return 1;
  v8 = v62;
  ZinIrHalH13g::~ZinIrHalH13g(v61);
  v9 = v8();
  mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v9);
  v58 = 0;
  v59 = 0;
  p_p = &v59;
  v76 = (llvm *)&v58;
  v67[0] = (const void **)&p_p;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_9A11LegacyEEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v67, 1);
  if ((unint64_t)(v58 + v59) < 0x100)
  {
    p_p = v64;
    v76 = (llvm *)&v66;
    v77 = v65;
    mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()((uint64_t)&p_p, &__p);
    LOWORD(v79) = 260;
    p_p = &__p;
    if (llvm::sys::fs::access((unsigned __int8 *)&p_p, 0) || (a7 & 1) != 0)
    {
      HIBYTE(v77) = 5;
      strcpy((char *)&p_p, "1.0.3");
      mlir::anec::ANECIRTop::Create((uint64_t)&__p, (uint64_t)&p_p, &v55);
      if (SHIBYTE(v77) < 0)
        operator delete(p_p);
      v52 = 0;
      v53 = 0;
      v54 = 0;
      if (SHIBYTE(v55[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v55[1].__r_.__value_.__l.__data_;
        size = v55[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v55 + 1;
        size = HIBYTE(v55[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v52, &v51);
      if (v51)
      {
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v25 = &__p;
        else
          v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v26 = __p.__r_.__value_.__l.__size_;
        v27 = (llvm *)mlir::openOutputFile(v25, v26, (uint64_t)&v52, &v50);
        if (v50)
        {
          v28 = *((_QWORD *)v51 + 17);
          v77 = 0;
          p_p = 0;
          v76 = 0;
          LODWORD(v78) = 0;
          v79 = v81;
          v80 = 0;
          v81[0] = v28;
          v49 = 0;
          v67[0] = (const void **)&v49;
          v67[1] = (const void **)&v55;
          v67[2] = (const void **)&p_p;
          v69 = v67;
          if (mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v66, (mlir::Operation *)_ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_9A11LegacyEEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_, (uint64_t)&v69, 1))
          {
            v29 = v66[3];
            if (*(_UNKNOWN **)(*(_QWORD *)v29 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v29 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v55, *((llvm::raw_ostream **)v50 + 17), (_DWORD)v80 == 0, v29, 0, 0))
            {
              v31 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v66 + 3));
              v32 = mlir::FileLineColLoc::get(v31, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x26Fu, 0);
              v67[0] = (const void **)"ANEC IR Write failed";
              v68 = 259;
              mlir::emitError(v32, (uint64_t)v67, (uint64_t)v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v70);
            }
            else
            {
              *((_BYTE *)v51 + 24) = 1;
              *((_BYTE *)v50 + 24) = 1;
            }
          }
          if (v79 != v81)
            free(v79);
          llvm::deallocate_buffer(v76, (void *)(16 * v78));
        }
        v33 = (llvm::raw_ostream *)llvm::errs(v27);
        v34 = (void *)*((_QWORD *)v33 + 4);
        if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0x1AuLL)
        {
          *((_QWORD *)v33 + 4) += 27;
        }
        else
        {
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = &__p;
        else
          v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          v36 = __p.__r_.__value_.__l.__size_;
        v37 = llvm::raw_ostream::write(v33, (const char *)v35, v36);
        v38 = *((_QWORD *)v37 + 4);
        if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 8)
        {
          *(_BYTE *)(v38 + 8) = 32;
          *((_QWORD *)v37 + 4) += 9;
        }
        else
        {
        }
        if (v54 >= 0)
          v39 = (const char *)&v52;
        else
          v39 = (const char *)v52;
        if (v54 >= 0)
          v40 = HIBYTE(v54);
        else
          v40 = v53;
        v41 = llvm::raw_ostream::write(v37, v39, v40);
        v42 = (_BYTE *)*((_QWORD *)v41 + 4);
        if (*((_BYTE **)v41 + 3) == v42)
        {
          llvm::raw_ostream::write(v41, "\n", 1uLL);
          v22 = 0;
        }
        else
        {
          v22 = 0;
          *v42 = 10;
          ++*((_QWORD *)v41 + 4);
        }
        v43 = v50;
        v50 = 0;
        if (v43)
        {
          if (*((_BYTE *)v43 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v43 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v43);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        LOWORD(v79) = 260;
        p_p = &v52;
        mlir::OpState::emitError(&v66, (uint64_t)&p_p, (uint64_t)&v71);
        if (v71)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
        v22 = 0;
      }
      v44 = v51;
      v51 = 0;
      if (v44)
      {
        if (*((_BYTE *)v44 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v44 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v44);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v54) < 0)
        operator delete(v52);
      v45 = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v47 = __ldaxr(p_shared_owners);
        while (__stlxr(v47 - 1, p_shared_owners));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
    }
    else
    {
      mlir::emitError(v66[3], (uint64_t)&p_p);
      if (p_p)
      {
        mlir::Diagnostic::operator<<((uint64_t)&v76, "File ");
        if (p_p)
        {
          v68 = 260;
          v67[0] = (const void **)&__p;
          mlir::Diagnostic::operator<<((uint64_t)&v76, v67);
          if (p_p)
            mlir::Diagnostic::operator<<((uint64_t)&v76, " exists already.");
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&p_p);
      if (p_p)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&p_p);
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v76);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    v10 = MEMORY[0x24BEDB858];
    v11 = MEMORY[0x24BEDB858] + 104;
    v85[0] = MEMORY[0x24BEDB858] + 104;
    v12 = MEMORY[0x24BEDB858] + 64;
    v13 = MEMORY[0x24BEDB7F0];
    v14 = *(void **)(MEMORY[0x24BEDB7F0] + 16);
    v15 = *(void **)(MEMORY[0x24BEDB7F0] + 24);
    v77 = (_QWORD *)(MEMORY[0x24BEDB858] + 64);
    p_p = v14;
    *(void **)((char *)&p_p + *((_QWORD *)v14 - 3)) = v15;
    v76 = 0;
    v16 = (std::ios_base *)((char *)&p_p + *((_QWORD *)p_p - 3));
    std::ios_base::init(v16, &v78);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v17 = *(_QWORD **)(v13 + 40);
    v77 = *(_QWORD **)(v13 + 32);
    *(_QWORD **)((char *)&v77 + *(v77 - 3)) = v17;
    p_p = *(void **)(v13 + 8);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 48);
    v85[0] = v11;
    p_p = (void *)(v10 + 24);
    v77 = (_QWORD *)v12;
    std::streambuf::basic_streambuf();
    v18 = MEMORY[0x24BEDB848];
    v78 = MEMORY[0x24BEDB848] + 16;
    v82 = 0u;
    v83 = 0u;
    v84 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v77, (uint64_t)"The number of ANE I/O exceededs fvmlib limit of 255 total (", 59);
    v19 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)" inputs, ", 9);
    v20 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)" outputs)", 9);
    std::stringbuf::str();
    v68 = 260;
    v67[0] = (const void **)&__p;
    mlir::OpState::emitError(&v66, (uint64_t)v67, (uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v74);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    p_p = *(void **)v13;
    v21 = *(_QWORD **)(v13 + 72);
    *(void **)((char *)&p_p + *((_QWORD *)p_p - 3)) = *(void **)(v13 + 64);
    v77 = v21;
    v78 = v18 + 16;
    if (SBYTE7(v83) < 0)
      operator delete((void *)v82);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x20BD0022C](v85);
    return 0;
  }
  return v22;
}

void mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(void)#1}::operator()(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  const void **v3;
  size_t v4;
  const void *v5;
  uint64_t (*v7)(void);
  mlir::SymbolRefAttr *v8;
  mlir::Operation *v9;
  uint64_t AttrData;
  unint64_t v11;
  size_t v12;
  const void *v13;
  void **p_dst;
  uint64_t v15;
  uint64_t v16;
  std::string *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[4];
  __int16 v24;
  _QWORD v25[4];
  __int16 v26;
  _QWORD v27[2];
  ZinIrHalH13g *v28;
  __int16 v29;
  uint64_t (*v30)(void);
  void **__dst;
  size_t v32;
  unint64_t v33;

  v3 = *(const void ***)a1;
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v4)
  {
    v5 = *v3;
    if (!*v3)
    {
      a2->__r_.__value_.__r.__words[0] = 0;
      a2->__r_.__value_.__l.__size_ = 0;
      a2->__r_.__value_.__r.__words[2] = 0;
      return;
    }
    if (v4 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v4 >= 0x17)
      {
        v15 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v4 | 7) != 0x17)
          v15 = v4 | 7;
        v16 = v15 + 1;
        v17 = (std::string *)operator new(v15 + 1);
        a2->__r_.__value_.__l.__size_ = v4;
        a2->__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
        a2->__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
        a2 = v17;
      }
      else
      {
        *((_BYTE *)&a2->__r_.__value_.__s + 23) = v4;
      }
      memmove(a2, v5, v4);
      a2->__r_.__value_.__s.__data_[v4] = 0;
      return;
    }
LABEL_25:
    abort();
  }
  mlir::Region::getOps<mlir::func::FuncOp>((mlir::Region *)(((**(_QWORD **)(a1 + 8)+ 16 * (((unint64_t)*(unsigned int *)(**(_QWORD **)(a1 + 8) + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(**(_QWORD **)(a1 + 8) + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(**(_QWORD **)(a1 + 8) + 40)), (uint64_t)v27);
  v7 = v30;
  ZinIrHalH13g::~ZinIrHalH13g(v28);
  v8 = (mlir::SymbolRefAttr *)v7();
  v23[0] = mlir::SymbolRefAttr::get(v8, v9);
  v25[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v23);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v25);
  if (!AttrData)
  {
    __dst = 0;
    v32 = 0;
    v33 = 0;
    goto LABEL_22;
  }
  v12 = v11;
  if (v11 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_25;
  v13 = (const void *)AttrData;
  if (v11 >= 0x17)
  {
    v18 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v18 = v11 | 7;
    v19 = v18 + 1;
    p_dst = (void **)operator new(v18 + 1);
    v32 = v12;
    v33 = v19 | 0x8000000000000000;
    __dst = p_dst;
  }
  else
  {
    HIBYTE(v33) = v11;
    p_dst = (void **)&__dst;
    if (!v11)
      goto LABEL_21;
  }
  memmove(p_dst, v13, v12);
LABEL_21:
  *((_BYTE *)p_dst + v12) = 0;
LABEL_22:
  v20 = *(uint64_t **)(a1 + 16);
  v24 = 773;
  v22 = *v20;
  v21 = v20[1];
  v23[0] = v22;
  v23[1] = v21;
  v23[2] = "/";
  v25[0] = v23;
  v25[2] = &__dst;
  v26 = 1026;
  v27[0] = v25;
  v28 = (ZinIrHalH13g *)".plist";
  v29 = 770;
  llvm::Twine::str((llvm::Twine *)v27, a2);
  if (SHIBYTE(v33) < 0)
    operator delete(__dst);
}

std::string *mlir::anec::ANECIRTop::Create@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string **a3@<X8>)
{
  std::string *v6;
  std::string *v7;
  std::string *v8;
  std::string *result;

  v6 = (std::string *)operator new();
  v7 = v6;
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    v6->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
  }
  mlir::anec::ANECIRTop::deriveWeightsFileName((std::string *)a1, (char *)&v7[1]);
  v8 = v7 + 2;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v7[2].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
  v7[3].__r_.__value_.__r.__words[0] = (std::string::size_type)&v7[3].__r_.__value_.__r.__words[2];
  v7[3].__r_.__value_.__l.__size_ = 0x100000000;
  v7[4].__r_.__value_.__l.__size_ = (std::string::size_type)&v7[5];
  v7[4].__r_.__value_.__r.__words[2] = 0x300000000;
  *a3 = v7;
  result = (std::string *)operator new();
  result->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C05DB40;
  result->__r_.__value_.__l.__size_ = 0;
  result->__r_.__value_.__r.__words[2] = 0;
  result[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
  a3[1] = result;
  return result;
}

double mlir::Region::getOps<mlir::anec::A12>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A12,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A12,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A12,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A12,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A12,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A12EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

double mlir::Region::getOps<mlir::func::FuncOp>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::func::FuncOp,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::func::FuncOp,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::func::FuncOp,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::func::FuncOp,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::func::FuncOp,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id;
}

void std::__shared_ptr_pointer<mlir::anec::ANECIRTop *,std::shared_ptr<mlir::anec::ANECIRTop>::__shared_ptr_default_delete<mlir::anec::ANECIRTop,mlir::anec::ANECIRTop>,std::allocator<mlir::anec::ANECIRTop>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

mlir::anec::ANECIRTop *std::__shared_ptr_pointer<mlir::anec::ANECIRTop *,std::shared_ptr<mlir::anec::ANECIRTop>::__shared_ptr_default_delete<mlir::anec::ANECIRTop,mlir::anec::ANECIRTop>,std::allocator<mlir::anec::ANECIRTop>>::__on_zero_shared(uint64_t a1)
{
  mlir::anec::ANECIRTop *result;

  result = *(mlir::anec::ANECIRTop **)(a1 + 24);
  if (result)
  {
    mlir::anec::ANECIRTop::~ANECIRTop(result);
    JUMPOUT(0x20BD002F8);
  }
  return result;
}

void mlir::anec::ANECIRTop::~ANECIRTop(mlir::anec::ANECIRTop *this)
{
  char *v2;
  uint64_t v3;
  char *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;

  v2 = (char *)*((_QWORD *)this + 13);
  v3 = *((unsigned int *)this + 28);
  if ((_DWORD)v3)
  {
    v4 = &v2[16 * v3];
    do
    {
      v5 = (std::__shared_weak_count *)*((_QWORD *)v4 - 1);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
      v4 -= 16;
    }
    while (v4 != v2);
    v2 = (char *)*((_QWORD *)this + 13);
  }
  if (v2 != (char *)this + 120)
    free(v2);
  v8 = (char *)*((_QWORD *)this + 9);
  v9 = *((unsigned int *)this + 20);
  if ((_DWORD)v9)
  {
    v10 = &v8[16 * v9];
    do
    {
      v11 = (std::__shared_weak_count *)*((_QWORD *)v10 - 1);
      if (v11)
      {
        v12 = (unint64_t *)&v11->__shared_owners_;
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }
      v10 -= 16;
    }
    while (v10 != v8);
    v8 = (char *)*((_QWORD *)this + 9);
  }
  if (v8 != (char *)this + 88)
    free(v8);
  if (*((char *)this + 71) < 0)
  {
    operator delete(*((void **)this + 6));
    if ((*((char *)this + 47) & 0x80000000) == 0)
    {
LABEL_25:
      if ((*((char *)this + 23) & 0x80000000) == 0)
        return;
LABEL_29:
      operator delete(*(void **)this);
      return;
    }
  }
  else if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    goto LABEL_25;
  }
  operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0)
    goto LABEL_29;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A12EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id)
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  else
    return 1;
}

uint64_t mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(uint64_t **a1, uint64_t a2)
{
  mlir::Operation *v4;
  uint64_t AttrData;
  unint64_t v6;
  const void *v7;
  std::string::size_type v8;
  std::string *p_dst;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::string *v13;
  int v14;
  std::__shared_weak_count *v15;
  std::string *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::string *v21;
  int v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::string *v25;
  std::string *v26;
  std::string *v27;
  __int128 v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  std::string **v32;
  unint64_t v33;
  _OWORD *v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  uint64_t v43;
  mlir::anec::ANECIRProcedure **v44;
  uint64_t v45;
  __int128 v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  __int128 v60;
  unint64_t *v61;
  unint64_t v62;
  std::__shared_weak_count *v63;
  unint64_t *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  char *v79;
  char *v80;
  uint64_t v81;
  std::__shared_weak_count *v82;
  mlir::anec::ANECIRProcedure *v83;
  std::__shared_weak_count *v84;
  __int128 v85;
  mlir::anec::ANECIRProcedure *v86;
  std::__shared_weak_count *v87;
  std::string __dst;
  uint64_t v89;
  std::__shared_weak_count *v90;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)a2);
  v89 = mlir::SymbolRefAttr::get((mlir::SymbolRefAttr *)a2, v4);
  __dst.__r_.__value_.__r.__words[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v89);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = (const void *)AttrData;
  v8 = v6;
  if (v6 >= 0x17)
  {
    v10 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v10 = v6 | 7;
    v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v6;
  p_dst = &__dst;
  if (v6)
LABEL_8:
    memmove(p_dst, v7, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  v12 = operator new();
  *(_QWORD *)v12 = &off_24C051568;
  *(_QWORD *)(v12 + 8) = v12 + 24;
  *(_QWORD *)(v12 + 16) = 0x500000000;
  *(_QWORD *)(v12 + 104) = v12 + 120;
  *(_QWORD *)(v12 + 112) = 0x500000000;
  v13 = (std::string *)(v12 + 200);
  v14 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v13, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
    *(_QWORD *)(v12 + 216) = *((_QWORD *)&__dst.__r_.__value_.__l + 2);
  }
  *(_OWORD *)(v12 + 240) = 0u;
  *(_OWORD *)(v12 + 256) = 0u;
  *(_OWORD *)(v12 + 224) = 0u;
  v89 = v12;
  v15 = (std::__shared_weak_count *)operator new();
  v15->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05DA60;
  v15->__shared_owners_ = 0;
  v15->__shared_weak_owners_ = 0;
  v15[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
  v90 = v15;
  if ((v14 & 0x80000000) == 0)
  {
    if (v8 < 0x17)
      goto LABEL_14;
LABEL_17:
    v17 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v17 = v8 | 7;
    v18 = v17 + 1;
    v16 = (std::string *)operator new(v17 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
    goto LABEL_20;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (v8 >= 0x17)
    goto LABEL_17;
LABEL_14:
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v8;
  v16 = &__dst;
  if (v8)
LABEL_20:
    memmove(v16, v7, v8);
  v16->__r_.__value_.__s.__data_[v8] = 0;
  v19 = **a1;
  **a1 = v19 + 1;
  v20 = operator new();
  *(_QWORD *)v20 = &off_24C051568;
  *(_QWORD *)(v20 + 8) = v20 + 24;
  *(_QWORD *)(v20 + 16) = 0x500000000;
  *(_QWORD *)(v20 + 104) = v20 + 120;
  *(_QWORD *)(v20 + 112) = 0x500000000;
  v21 = (std::string *)(v20 + 200);
  v22 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v21, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v21->__r_.__value_.__l.__data_ = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
    *(_QWORD *)(v20 + 216) = *((_QWORD *)&__dst.__r_.__value_.__l + 2);
  }
  *(_OWORD *)(v20 + 240) = 0u;
  *(_OWORD *)(v20 + 256) = 0u;
  *(_OWORD *)(v20 + 224) = 0u;
  *(_QWORD *)v20 = &off_24BFF47E8;
  *(_QWORD *)(v20 + 272) = 0;
  *(_QWORD *)(v20 + 280) = 0;
  *(_QWORD *)(v20 + 288) = 0;
  *(_QWORD *)(v20 + 296) = v19;
  v86 = (mlir::anec::ANECIRProcedure *)v20;
  v23 = (std::__shared_weak_count *)operator new();
  v23->__vftable = (std::__shared_weak_count_vtbl *)&off_24BFF59C8;
  v23->__shared_owners_ = 0;
  v23->__shared_weak_owners_ = 0;
  v23[1].__vftable = (std::__shared_weak_count_vtbl *)v20;
  v87 = v23;
  if (v22 < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  mlir::anec::ANECIRProcedure::OperationName((mlir::anec::ANECIRProcedure *)v20, &__dst);
  v24 = v89;
  v25 = (std::string *)operator new();
  v26 = v25;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(v25, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  else
    *v25 = __dst;
  v27 = v26 + 1;
  if (*(char *)(v24 + 223) < 0)
  {
    std::string::__init_copy_ctor_external(v27, *(const std::string::value_type **)(v24 + 200), *(_QWORD *)(v24 + 208));
  }
  else
  {
    v28 = *(_OWORD *)(v24 + 200);
    v26[1].__r_.__value_.__r.__words[2] = *(_QWORD *)(v24 + 216);
    *(_OWORD *)&v27->__r_.__value_.__l.__data_ = v28;
  }
  v29 = (std::__shared_weak_count *)operator new();
  v29->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v29->__shared_owners_;
  v29->__vftable = (std::__shared_weak_count_vtbl *)&off_24BFF5990;
  v29->__shared_weak_owners_ = 0;
  v29[1].__vftable = (std::__shared_weak_count_vtbl *)v26;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  *(_QWORD *)&v85 = v26;
  *((_QWORD *)&v85 + 1) = v29;
  do
    v31 = __ldxr(p_shared_owners);
  while (__stxr(v31 + 1, p_shared_owners));
  v32 = *(std::string ***)(v20 + 280);
  if ((unint64_t)v32 >= *(_QWORD *)(v20 + 288))
  {
    v34 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v20 + 272, &v85);
  }
  else
  {
    *v32 = v26;
    v32[1] = (std::string *)v29;
    do
      v33 = __ldxr(p_shared_owners);
    while (__stxr(v33 + 1, p_shared_owners));
    v34 = v32 + 2;
  }
  *(_QWORD *)(v20 + 280) = v34;
  v35 = (std::__shared_weak_count *)*((_QWORD *)&v85 + 1);
  if (*((_QWORD *)&v85 + 1))
  {
    v36 = (unint64_t *)(*((_QWORD *)&v85 + 1) + 8);
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = *a1[1];
  v83 = v86;
  v84 = v87;
  if (v87)
  {
    v39 = (unint64_t *)&v87->__shared_owners_;
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }
  v42 = (unint64_t *)(v38 + 104);
  v41 = *(_QWORD *)(v38 + 104);
  v43 = *(unsigned int *)(v38 + 112);
  v44 = &v83;
  if (v43 >= *(_DWORD *)(v38 + 116))
  {
    v75 = v43 + 1;
    v76 = v41 + 16 * v43 > (unint64_t)&v83;
    if (v41 <= (unint64_t)&v83 && v76)
    {
      v79 = (char *)&v83 - v41;
      llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(v38 + 104, v75);
      v41 = *v42;
      v44 = (mlir::anec::ANECIRProcedure **)&v79[*v42];
    }
    else
    {
      llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(v38 + 104, v75);
      v41 = *v42;
      v44 = &v83;
    }
  }
  v45 = *(unsigned int *)(v38 + 112);
  v46 = *(_OWORD *)v44;
  *(_OWORD *)(v41 + 16 * v45) = *(_OWORD *)v44;
  if (*((_QWORD *)&v46 + 1))
  {
    v47 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
    do
      v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
    LODWORD(v45) = *(_DWORD *)(v38 + 112);
  }
  *(_DWORD *)(v38 + 112) = v45 + 1;
  v49 = v84;
  if (v84)
  {
    v50 = (unint64_t *)&v84->__shared_owners_;
    do
      v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
  if (mlir::anec::writeMultiProcedurePlist((unsigned int *)a2, &v89, &v86, (uint64_t)a1[2]))
  {
    v52 = *a1[1];
    v81 = v89;
    v82 = v90;
    if (v90)
    {
      v53 = (unint64_t *)&v90->__shared_owners_;
      do
        v54 = __ldxr(v53);
      while (__stxr(v54 + 1, v53));
    }
    v56 = (unint64_t *)(v52 + 72);
    v55 = *(_QWORD *)(v52 + 72);
    v57 = *(unsigned int *)(v52 + 80);
    v58 = (char *)&v81;
    if (v57 >= *(_DWORD *)(v52 + 84))
    {
      v77 = v57 + 1;
      v78 = v55 + 16 * v57 > (unint64_t)&v81;
      if (v55 <= (unint64_t)&v81 && v78)
      {
        v80 = (char *)&v81 - v55;
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(v52 + 72, v77);
        v55 = *v56;
        v58 = &v80[*v56];
      }
      else
      {
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(v52 + 72, v77);
        v55 = *v56;
        v58 = (char *)&v81;
      }
    }
    v59 = *(unsigned int *)(v52 + 80);
    v60 = *(_OWORD *)v58;
    *(_OWORD *)(v55 + 16 * v59) = *(_OWORD *)v58;
    if (*((_QWORD *)&v60 + 1))
    {
      v61 = (unint64_t *)(*((_QWORD *)&v60 + 1) + 8);
      do
        v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
      LODWORD(v59) = *(_DWORD *)(v52 + 80);
    }
    *(_DWORD *)(v52 + 80) = v59 + 1;
    v63 = v82;
    if (v82)
    {
      v64 = (unint64_t *)&v82->__shared_owners_;
      do
        v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }
    v66 = 1;
  }
  else
  {
    v66 = 0;
  }
  do
    v67 = __ldaxr(p_shared_owners);
  while (__stlxr(v67 - 1, p_shared_owners));
  if (!v67)
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  v68 = v87;
  if (v87)
  {
    v69 = (unint64_t *)&v87->__shared_owners_;
    do
      v70 = __ldaxr(v69);
    while (__stlxr(v70 - 1, v69));
    if (!v70)
    {
      ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
      std::__shared_weak_count::__release_weak(v68);
    }
  }
  v71 = v90;
  if (v90)
  {
    v72 = (unint64_t *)&v90->__shared_owners_;
    do
      v73 = __ldaxr(v72);
    while (__stlxr(v73 - 1, v72));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  return v66;
}

void mlir::anec::ANECIRProcedure::~ANECIRProcedure(mlir::anec::ANECIRProcedure *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  *(_QWORD *)this = &off_24BFF47E8;
  v2 = *((_QWORD *)this + 34);
  if (v2)
  {
    v3 = *((_QWORD *)this + 35);
    v4 = (void *)*((_QWORD *)this + 34);
    if (v3 != v2)
    {
      do
      {
        v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 34);
    }
    *((_QWORD *)this + 35) = v2;
    operator delete(v4);
  }
  mlir::anec::ANECIRNetwork::~ANECIRNetwork(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  *(_QWORD *)this = &off_24BFF47E8;
  v2 = *((_QWORD *)this + 34);
  if (v2)
  {
    v3 = *((_QWORD *)this + 35);
    v4 = (void *)*((_QWORD *)this + 34);
    if (v3 != v2)
    {
      do
      {
        v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 34);
    }
    *((_QWORD *)this + 35) = v2;
    operator delete(v4);
  }
  mlir::anec::ANECIRNetwork::~ANECIRNetwork(this);
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_pointer<mlir::anec::ANECIRProcedure *,std::shared_ptr<mlir::anec::ANECIRProcedure>::__shared_ptr_default_delete<mlir::anec::ANECIRProcedure,mlir::anec::ANECIRProcedure>,std::allocator<mlir::anec::ANECIRProcedure>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<mlir::anec::ANECIRProcedure *,std::shared_ptr<mlir::anec::ANECIRProcedure>::__shared_ptr_default_delete<mlir::anec::ANECIRProcedure,mlir::anec::ANECIRProcedure>,std::allocator<mlir::anec::ANECIRProcedure>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<mlir::anec::ANECIROperation *,std::shared_ptr<mlir::anec::ANECIROperation>::__shared_ptr_default_delete<mlir::anec::ANECIROperation,mlir::anec::ANECIROperation>,std::allocator<mlir::anec::ANECIROperation>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t std::__shared_ptr_pointer<mlir::anec::ANECIROperation *,std::shared_ptr<mlir::anec::ANECIROperation>::__shared_ptr_default_delete<mlir::anec::ANECIROperation,mlir::anec::ANECIROperation>,std::allocator<mlir::anec::ANECIROperation>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    if (*(char *)(v1 + 47) < 0)
    {
      operator delete(*(void **)(v1 + 24));
      if ((*(char *)(v1 + 23) & 0x80000000) == 0)
LABEL_8:
        JUMPOUT(0x20BD002F8);
    }
    else if ((*(char *)(v1 + 23) & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(*(void **)v1);
    goto LABEL_8;
  }
  return result;
}

double mlir::Region::getOps<mlir::anec::A13>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A13,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A13,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A13,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A13,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A13,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A13EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A13EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id)
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  else
    return 1;
}

double mlir::Region::getOps<mlir::anec::A14>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A14,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A14,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A14,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A14,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A14,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A14EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A14EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id)
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  else
    return 1;
}

double mlir::Region::getOps<mlir::anec::A15>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A15,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A15,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A15,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A15,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A15,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A15EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A15EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id)
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  else
    return 1;
}

double mlir::Region::getOps<mlir::anec::A16>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A16,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A16,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A16,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A16,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A16,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A16EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A16EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id)
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  else
    return 1;
}

double mlir::Region::getOps<mlir::anec::A17>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A17,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A17,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A17,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A17,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A17,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_3A17EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_3A17EEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id)
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  else
    return 1;
}

double mlir::Region::getOps<mlir::anec::A11Legacy>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::anec::A11Legacy,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::anec::A11Legacy,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::anec::A11Legacy,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::anec::A11Legacy,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::anec::A11Legacy,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id;
}

_QWORD ***_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSB_9A11LegacyEEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESI_bbEUlSD_E_SD_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESR_E4typeES3_OT1_EUlS3_E_EEvlS3_(_QWORD ***result, mlir::Operation *a2)
{
  _QWORD **v2;
  unsigned int v3;
  unsigned int v4;
  mlir::Operation *v5;
  uint64_t FunctionType;

  if (a2)
  {
    if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id)
    {
      v2 = *result;
      v5 = a2;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
      **v2 += v3;
      FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
      result = (_QWORD ***)mlir::FunctionType::getResults((mlir::FunctionType *)&FunctionType);
      *v2[1] += v4;
    }
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_4anec22genProcedureListANECIRINSC_9A11LegacyEEENS1_13LogicalResultENS1_8ModuleOpEPNS1_11MLIRContextENS_9StringRefESJ_bbEUlSE_E0_SE_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESS_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t ***a1, uint64_t a2)
{
  if (a2
    && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id)
  {
    return mlir::anec::genProcedureListANECIR<mlir::anec::A12>(mlir::ModuleOp,mlir::MLIRContext *,llvm::StringRef,llvm::StringRef,BOOL,BOOL)::{lambda(mlir::anec::A12)#2}::operator()(*a1, a2);
  }
  else
  {
    return 1;
  }
}

uint64_t mlir::anec::WriteA12PlistPassBase<mlir::anec::`anonymous namespace'::WriteA12PlistPass>::WriteA12PlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A12";
  *(_QWORD *)(a1 + 24) = 8;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24C0515D0;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA12PlistPass::~WriteA12PlistPass(mlir::anec::_anonymous_namespace_::WriteA12PlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA12PlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24C0515D0;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA12PlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA12PlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA12PlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA12PlistPassBase<mlir::anec::`anonymous namespace'::WriteA12PlistPass>::getName()
{
  return "WriteA12PlistPass";
}

const char *mlir::anec::WriteA12PlistPassBase<mlir::anec::`anonymous namespace'::WriteA12PlistPass>::getArgument()
{
  return "write-A12-plist";
}

const char *mlir::anec::WriteA12PlistPassBase<mlir::anec::`anonymous namespace'::WriteA12PlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA12PlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA12PlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A12>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA12PlistPassBase<mlir::anec::`anonymous namespace'::WriteA12PlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C0515D0;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24C051008;
  *a2 = v4;
  return result;
}

_QWORD *mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  const void **v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD v34[2];
  _QWORD v35[3];
  _QWORD *v36;
  const void *v37[3];
  const void **v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v34[0] = a3;
  v34[1] = a4;
  v37[0] = a2;
  v7 = llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc>((uint64_t)a1, (uint64_t)v34, v37, a5);
  *(_QWORD *)(v7 + 232) = &unk_24C051DF0;
  v8 = v7 + 232;
  *(_BYTE *)(v7 + 240) = 0;
  *(_QWORD *)v7 = &off_24C051D70;
  v10 = (uint64_t *)a2[21];
  v9 = a2[22];
  v11 = v10;
  if ((unint64_t)v10 >= v9)
  {
    v13 = (uint64_t *)a2[20];
    v14 = v10 - v13;
    v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 61)
      abort();
    v16 = v9 - (_QWORD)v13;
    if (v16 >> 2 > v15)
      v15 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v18 = (char *)operator new(8 * v17);
    }
    else
    {
      v18 = 0;
    }
    v19 = (uint64_t *)&v18[8 * v14];
    v20 = &v18[8 * v17];
    *v19 = v8;
    v12 = v19 + 1;
    if (v10 != v13)
    {
      v21 = (char *)v10 - (char *)v13 - 8;
      if (v21 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v13 - v18) < 0x20)
        goto LABEL_38;
      v22 = (v21 >> 3) + 1;
      v23 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
      v11 = &v10[v23 / 0xFFFFFFFFFFFFFFF8];
      v19 = (uint64_t *)((char *)v19 - v23);
      v24 = &v18[8 * v14 - 16];
      v25 = v10 - 2;
      v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v27 = *(_OWORD *)v25;
        *((_OWORD *)v24 - 1) = *((_OWORD *)v25 - 1);
        *(_OWORD *)v24 = v27;
        v24 -= 32;
        v25 -= 4;
        v26 -= 4;
      }
      while (v26);
      if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v28 = *--v11;
          *--v19 = v28;
        }
        while (v11 != v13);
      }
      v11 = (uint64_t *)a2[20];
    }
    a2[20] = v19;
    a2[21] = v12;
    a2[22] = v20;
    if (v11)
      operator delete(v11);
  }
  else
  {
    *v10 = v8;
    v12 = v10 + 1;
  }
  a2[21] = v12;
  v35[0] = &off_24C05A3F8;
  v35[1] = a1;
  v36 = v35;
  v37[0] = &off_24C05A3F8;
  v38 = v37;
  v37[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v37, a1 + 25);
  v29 = v38;
  if (v38 == v37)
  {
    v30 = 4;
    v29 = v37;
  }
  else
  {
    if (!v38)
      goto LABEL_28;
    v30 = 5;
  }
  (*((void (**)(void))*v29 + v30))();
LABEL_28:
  v31 = v36;
  if (v36 == v35)
  {
    v32 = 4;
    v31 = v35;
    goto LABEL_32;
  }
  if (v36)
  {
    v32 = 5;
LABEL_32:
    (*(void (**)(void))(*v31 + 8 * v32))();
  }
  return a1;
}

void mlir::Pass::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(a1);
  JUMPOUT(0x20BD002F8);
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::print(_QWORD *a1, llvm::raw_ostream *this)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  llvm::raw_ostream *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  int v11;
  const char *v12;
  size_t v13;

  v4 = (const void *)a1[2];
  v5 = a1[3];
  v6 = (_BYTE *)*((_QWORD *)this + 4);
  if (v5 <= *((_QWORD *)this + 3) - (_QWORD)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      v6 = (_BYTE *)(*((_QWORD *)this + 4) + v5);
      *((_QWORD *)this + 4) = v6;
    }
    v7 = this;
  }
  else
  {
    v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    v6 = (_BYTE *)*((_QWORD *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v6 + 1;
    *v6 = 61;
  }
  v10 = (const char *)a1[16];
  v9 = (const char *)(a1 + 16);
  v8 = v10;
  v11 = v9[23];
  if (v11 >= 0)
    v12 = v9;
  else
    v12 = v8;
  if (v11 >= 0)
    v13 = *((unsigned __int8 *)v9 + 23);
  else
    v13 = *((_QWORD *)v9 + 1);
  return llvm::raw_ostream::write(this, v12, v13);
}

std::string *mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  std::string *result;

  result = std::string::operator=((std::string *)(a1 + 128), (const std::string *)(a2 - 104));
  *(_BYTE *)(a1 + 240) = *(_BYTE *)(a2 + 8);
  return result;
}

uint64_t `non-virtual thunk to'mlir::Pass::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  return mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(a1 - 232);
}

void `non-virtual thunk to'mlir::Pass::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(a1 - 232);
  JUMPOUT(0x20BD002F8);
}

llvm::raw_ostream *`non-virtual thunk to'mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  llvm::raw_ostream *v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  int v11;
  const char *v12;
  size_t v13;

  v4 = *(const void **)(a1 - 216);
  v5 = *(_QWORD *)(a1 - 208);
  v6 = (_BYTE *)*((_QWORD *)this + 4);
  if (v5 <= *((_QWORD *)this + 3) - (_QWORD)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      v6 = (_BYTE *)(*((_QWORD *)this + 4) + v5);
      *((_QWORD *)this + 4) = v6;
    }
    v7 = this;
  }
  else
  {
    v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    v6 = (_BYTE *)*((_QWORD *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v6 + 1;
    *v6 = 61;
  }
  v10 = *(const char **)(a1 - 104);
  v9 = a1 - 104;
  v8 = v10;
  v11 = *(char *)(v9 + 23);
  if (v11 >= 0)
    v12 = (const char *)v9;
  else
    v12 = v8;
  if (v11 >= 0)
    v13 = *(unsigned __int8 *)(v9 + 23);
  else
    v13 = *(_QWORD *)(v9 + 8);
  return llvm::raw_ostream::write(this, v12, v13);
}

uint64_t `non-virtual thunk to'mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::getOption(uint64_t a1)
{
  return a1 - 232;
}

std::string *`non-virtual thunk to'mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  std::string *result;

  result = std::string::operator=((std::string *)(a1 - 104), (const std::string *)(a2 - 104));
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc>(uint64_t a1, uint64_t a2, const void **a3, _OWORD *a4)
{
  __int16 v8;
  void *v9;
  uint64_t v10;
  llvm::SmallPtrSetImplBase *v11;
  _QWORD *GeneralCategory;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;

  *(_QWORD *)a1 = &unk_24C02E140;
  *(_WORD *)(a1 + 8) = 0;
  v8 = *(_WORD *)(a1 + 10);
  v9 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v10 = a1 + 64;
  *(_WORD *)(a1 + 10) = v8 & 0x8000;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  v11 = (llvm::SmallPtrSetImplBase *)(a1 + 88);
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v9, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = &unk_24C02DDA8;
  *(_QWORD *)a1 = &unk_24C02DED0;
  *(_QWORD *)(a1 + 192) = &unk_24C02E1F8;
  *(_QWORD *)(a1 + 200) = &off_24C053588;
  *(_QWORD *)(a1 + 224) = a1 + 200;
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v14 = *a3;
  v15 = *(_QWORD *)(a1 + 96);
  if (v15 != *(_QWORD *)(a1 + 88))
  {
LABEL_4:
    llvm::SmallPtrSetImplBase::insert_imp_big(v11, v14);
    goto LABEL_5;
  }
  v17 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v17)
  {
LABEL_14:
    if (v17 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v17 + 1;
      *(_QWORD *)(v15 + 8 * v17) = v14;
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  v18 = 0;
  v19 = 8 * v17;
  v20 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v20 != v14)
  {
    if (*v20 == -2)
      v18 = v20;
    ++v20;
    v19 -= 8;
    if (!v19)
    {
      if (!v18)
        goto LABEL_14;
      *v18 = v14;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_5:
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(a1);
  JUMPOUT(0x20BD002F8);
}

uint64_t `non-virtual thunk to'mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  return mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(a1 - 232);
}

void `non-virtual thunk to'mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(a1 - 232);
  JUMPOUT(0x20BD002F8);
}

void std::__function::__func<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::~__func()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *std::__function::__func<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24C053588;
  return result;
}

void std::__function::__func<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24C053588;
}

void _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISR_EEFvRKSB_EED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISR_EEFvRKSB_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C05A3F8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISR_EEFvRKSB_EE7__cloneEPNS0_6__baseISV_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C05A3F8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISR_EEFvRKSB_EEclESU_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 240) = 1;
  return result;
}

uint64_t mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)a1 = &unk_24C02DED0;
  v2 = (_QWORD *)(a1 + 200);
  v3 = *(_QWORD **)(a1 + 224);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)(a1 + 152) = &off_24C02DE48;
  if (*(char *)(a1 + 183) < 0)
  {
    operator delete(*(void **)(a1 + 160));
    if ((*(char *)(a1 + 151) & 0x80000000) == 0)
      goto LABEL_8;
  }
  else if ((*(char *)(a1 + 151) & 0x80000000) == 0)
  {
    goto LABEL_8;
  }
  operator delete(*(void **)(a1 + 128));
LABEL_8:
  *(_QWORD *)a1 = &unk_24C02E140;
  v5 = *(void **)(a1 + 96);
  if (v5 != *(void **)(a1 + 88))
    free(v5);
  v6 = *(void **)(a1 + 64);
  if (v6 != (void *)(a1 + 80))
    free(v6);
  return a1;
}

_QWORD *mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, __n128 *a5, _BYTE **a6, _WORD *a7)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  const void **v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD v36[2];
  _QWORD v37[3];
  _QWORD *v38;
  const void *v39[3];
  const void **v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v36[0] = a3;
  v36[1] = a4;
  v39[0] = a2;
  v9 = llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((uint64_t)a1, (uint64_t)v36, v39, a5, a6, a7);
  *(_QWORD *)(v9 + 192) = &unk_24C051EB0;
  v10 = v9 + 192;
  *(_BYTE *)(v9 + 200) = 0;
  *(_QWORD *)v9 = &off_24C051E30;
  v12 = (uint64_t *)a2[21];
  v11 = a2[22];
  v13 = v12;
  if ((unint64_t)v12 >= v11)
  {
    v15 = (uint64_t *)a2[20];
    v16 = v12 - v15;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      abort();
    v18 = v11 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = (uint64_t *)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v10;
    v14 = v21 + 1;
    if (v12 != v15)
    {
      v23 = (char *)v12 - (char *)v15 - 8;
      if (v23 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v15 - v20) < 0x20)
        goto LABEL_38;
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v13 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
      v21 = (uint64_t *)((char *)v21 - v25);
      v26 = &v20[8 * v16 - 16];
      v27 = v12 - 2;
      v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v29 = *(_OWORD *)v27;
        *((_OWORD *)v26 - 1) = *((_OWORD *)v27 - 1);
        *(_OWORD *)v26 = v29;
        v26 -= 32;
        v27 -= 4;
        v28 -= 4;
      }
      while (v28);
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v30 = *--v13;
          *--v21 = v30;
        }
        while (v13 != v15);
      }
      v13 = (uint64_t *)a2[20];
    }
    a2[20] = v21;
    a2[21] = v14;
    a2[22] = v22;
    if (v13)
      operator delete(v13);
  }
  else
  {
    *v12 = v10;
    v14 = v12 + 1;
  }
  a2[21] = v14;
  v37[0] = &off_24C05A488;
  v37[1] = a1;
  v38 = v37;
  v39[0] = &off_24C05A488;
  v40 = v39;
  v39[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v39, a1 + 20);
  v31 = v40;
  if (v40 == v39)
  {
    v32 = 4;
    v31 = v39;
  }
  else
  {
    if (!v40)
      goto LABEL_28;
    v32 = 5;
  }
  (*((void (**)(void))*v31 + v32))();
LABEL_28:
  v33 = v38;
  if (v38 == v37)
  {
    v34 = 4;
    v33 = v37;
    goto LABEL_32;
  }
  if (v38)
  {
    v34 = 5;
LABEL_32:
    (*(void (**)(void))(*v33 + 8 * v34))();
  }
  return a1;
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _BYTE **a5, _WORD *a6)
{
  void *v12;
  uint64_t v13;
  _QWORD *GeneralCategory;
  uint64_t v15;

  *(_QWORD *)a1 = &unk_24C02E140;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  v12 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_BYTE *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = &off_24C02DDC8;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)a1 = &unk_24C02DF38;
  *(_QWORD *)(a1 + 152) = &unk_24C02E228;
  *(_QWORD *)(a1 + 160) = &off_24C0535D0;
  *(_QWORD *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _BYTE **a5, _WORD *a6)
{
  const void *v11;
  uint64_t v12;
  __n128 result;
  _BYTE *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;

  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v11 = *a3;
  v12 = *(_QWORD *)(a1 + 96);
  if (v12 != *(_QWORD *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v11);
    goto LABEL_3;
  }
  v15 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v15)
  {
LABEL_12:
    if (v15 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v15 + 1;
      *(_QWORD *)(v12 + 8 * v15) = v11;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  v16 = 0;
  v17 = 8 * v15;
  v18 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v18 != v11)
  {
    if (*v18 == -2)
      v16 = v18;
    ++v18;
    v17 -= 8;
    if (!v17)
    {
      if (!v16)
        goto LABEL_12;
      *v16 = v11;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  v14 = *a5;
  *(_BYTE *)(a1 + 128) = **a5;
  *(_BYTE *)(a1 + 145) = 1;
  *(_BYTE *)(a1 + 144) = *v14;
  *(_WORD *)(a1 + 10) = (32 * (*a6 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

void _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKbEED0Ev()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKbEE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C05A488;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKbEE7__cloneEPNS0_6__baseIST_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C05A488;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEENS7_12OptionHiddenEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKbEEclESS_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 200) = 1;
  return result;
}

uint64_t mlir::anec::`anonymous namespace'::writePlist(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, std::string::size_type a5, char a6, const void *a7, std::string::size_type a8, char a9)
{
  uint64_t v10;
  uint64_t InherentAttr;
  char v19;
  uint64_t v20;
  uint64_t AttrData;
  size_t v22;
  const void *v23;
  size_t v24;
  std::string *p_dst;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  std::string *v32;
  int v33;
  std::__shared_weak_count *v34;
  std::string *data;
  std::string::size_type size;
  std::string *v37;
  std::string::size_type v38;
  llvm *v39;
  uint64_t v40;
  uint64_t ParentOp;
  uint64_t v42;
  mlir::StringAttr *Context;
  std::string *v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  __int128 v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  mlir::StringAttr *v58;
  uint64_t v59;
  llvm::raw_ostream *v60;
  void *v61;
  std::string *v62;
  std::string::size_type v63;
  llvm::raw_ostream *v64;
  uint64_t v65;
  const char *v66;
  size_t v67;
  llvm::raw_ostream *v68;
  _BYTE *v69;
  llvm::ToolOutputFile::CleanupInstaller *v70;
  llvm::ToolOutputFile::CleanupInstaller *v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  unint64_t v79;
  BOOL v80;
  char *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  std::string *v84;
  llvm *v85;
  uint64_t v86;
  size_t v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  llvm::ToolOutputFile::CleanupInstaller *v91;
  llvm::ToolOutputFile::CleanupInstaller *v92;
  void *v93;
  size_t v94;
  uint64_t v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  std::string *v98;
  std::__shared_weak_count *v99;
  _QWORD v100[4];
  __int16 v101;
  std::string __dst;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void *__p[2];
  const char *v107;
  __int16 v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  if (!(a3 | a5))
  {
    mlir::emitError(*(_QWORD *)(a1 + 24), (uint64_t)__p);
    if (__p[0])
      mlir::Diagnostic::operator<<((uint64_t)&__p[1], "Missing filename and directory, one or the other must be specified.");
    v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)__p);
    if (__p[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)__p);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&__p[1]);
    return v10;
  }
  if (*(_BYTE *)(a1 + 47))
  {
    InherentAttr = mlir::Operation::getInherentAttr(a1, (uint64_t)"sym_name", 8);
    if (v19)
    {
      if (InherentAttr)
        goto LABEL_10;
LABEL_14:
      v20 = 0;
      goto LABEL_15;
    }
  }
  InherentAttr = mlir::DictionaryAttr::get(a1 + 56, "sym_name", 8uLL);
  if (!InherentAttr)
    goto LABEL_14;
LABEL_10:
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v20 = InherentAttr;
  else
    v20 = 0;
LABEL_15:
  v103 = v20;
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v103);
  v23 = (const void *)AttrData;
  v24 = v22;
  if (a5)
  {
    if (a4)
    {
      if (a5 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_139;
      if (a5 >= 0x17)
      {
        v26 = (a5 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((a5 | 7) != 0x17)
          v26 = a5 | 7;
        v27 = v26 + 1;
        p_dst = (std::string *)operator new(v26 + 1);
        __dst.__r_.__value_.__l.__size_ = a5;
        __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = a5;
        p_dst = &__dst;
      }
      memmove(p_dst, a4, a5);
      p_dst->__r_.__value_.__s.__data_[a5] = 0;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
    }
  }
  else
  {
    v101 = 773;
    v100[0] = a2;
    v100[1] = a3;
    v100[2] = "/";
    v84 = (std::string *)v100;
    v86 = AttrData;
    v87 = v22;
    LOWORD(v88) = 1282;
    __p[0] = &v84;
    v107 = ".plist";
    v108 = 770;
    llvm::Twine::str((llvm::Twine *)__p, &__dst);
  }
  v108 = 260;
  __p[0] = &__dst;
  if (llvm::sys::fs::access((unsigned __int8 *)__p, 0) || (a6 & 1) != 0)
  {
    HIBYTE(v107) = 5;
    strcpy((char *)__p, "1.0.3");
    mlir::anec::ANECIRTop::Create((uint64_t)&__dst, (uint64_t)__p, &v98);
    if (SHIBYTE(v107) < 0)
      operator delete(__p[0]);
    if (v24 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v24 >= 0x17)
      {
        v29 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v24 | 7) != 0x17)
          v29 = v24 | 7;
        v30 = v29 + 1;
        v28 = operator new(v29 + 1);
        __p[1] = (void *)v24;
        v107 = (const char *)(v30 | 0x8000000000000000);
        __p[0] = v28;
      }
      else
      {
        HIBYTE(v107) = v24;
        v28 = __p;
        if (!v24)
          goto LABEL_45;
      }
      memmove(v28, v23, v24);
LABEL_45:
      *((_BYTE *)v28 + v24) = 0;
      v31 = operator new();
      *(_QWORD *)v31 = &off_24C051568;
      *(_QWORD *)(v31 + 8) = v31 + 24;
      *(_QWORD *)(v31 + 16) = 0x500000000;
      *(_QWORD *)(v31 + 104) = v31 + 120;
      *(_QWORD *)(v31 + 112) = 0x500000000;
      v32 = (std::string *)(v31 + 200);
      v33 = SHIBYTE(v107);
      if (SHIBYTE(v107) < 0)
      {
        std::string::__init_copy_ctor_external(v32, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      }
      else
      {
        *(_OWORD *)&v32->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
        *(_QWORD *)(v31 + 216) = v107;
      }
      *(_OWORD *)(v31 + 240) = 0u;
      *(_OWORD *)(v31 + 256) = 0u;
      *(_OWORD *)(v31 + 224) = 0u;
      v96 = v31;
      v34 = (std::__shared_weak_count *)operator new();
      v34->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05DA60;
      v34->__shared_owners_ = 0;
      v34->__shared_weak_owners_ = 0;
      v34[1].__vftable = (std::__shared_weak_count_vtbl *)v31;
      v97 = v34;
      if (v33 < 0)
        operator delete(__p[0]);
      v93 = 0;
      v94 = 0;
      v95 = 0;
      if (SHIBYTE(v98[1].__r_.__value_.__r.__words[2]) < 0)
      {
        data = (std::string *)v98[1].__r_.__value_.__l.__data_;
        size = v98[1].__r_.__value_.__l.__size_;
      }
      else
      {
        data = v98 + 1;
        size = HIBYTE(v98[1].__r_.__value_.__r.__words[2]);
      }
      mlir::openOutputFile(data, size, (uint64_t)&v93, &v92);
      if (v92)
      {
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v37 = &__dst;
        else
          v37 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v38 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          v38 = __dst.__r_.__value_.__l.__size_;
        v39 = (llvm *)mlir::openOutputFile(v37, v38, (uint64_t)&v93, &v91);
        if (v91)
        {
          v40 = *((_QWORD *)v92 + 17);
          v85 = 0;
          v86 = 0;
          v84 = 0;
          LODWORD(v87) = 0;
          v88 = &v90;
          v89 = 0;
          v90 = v40;
          if (mlir::anec::writeSingleRegionPlist(a1, &v96, (void **)&v84))
          {
            ParentOp = a1;
            do
              ParentOp = mlir::Block::getParentOp(*(mlir::Block **)(ParentOp + 16));
            while (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id);
            v42 = *(_QWORD *)(ParentOp + 24);
            if (*(_UNKNOWN **)(*(_QWORD *)v42 + 136) != &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
            {
              Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
              v42 = mlir::FileLineColLoc::get(Context, "unknown", 7uLL, 0, 0);
            }
            v44 = v98;
            v82 = v96;
            v83 = v97;
            if (v97)
            {
              p_shared_owners = (unint64_t *)&v97->__shared_owners_;
              do
                v46 = __ldxr(p_shared_owners);
              while (__stxr(v46 + 1, p_shared_owners));
            }
            v48 = (unint64_t *)&v44[3];
            v47 = v44[3].__r_.__value_.__r.__words[0];
            v49 = LODWORD(v44[3].__r_.__value_.__r.__words[1]);
            v50 = (char *)&v82;
            if (v49 >= HIDWORD(v44[3].__r_.__value_.__r.__words[1]))
            {
              v79 = v49 + 1;
              v80 = v47 + 16 * v49 > (unint64_t)&v82;
              if (v47 <= (unint64_t)&v82 && v80)
              {
                v81 = (char *)&v82 - v47;
                llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow((uint64_t)&v44[3], v79);
                v47 = *v48;
                v50 = &v81[*v48];
              }
              else
              {
                llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow((uint64_t)&v44[3], v79);
                v47 = *v48;
                v50 = (char *)&v82;
              }
            }
            v51 = LODWORD(v44[3].__r_.__value_.__r.__words[1]);
            v52 = *(_OWORD *)v50;
            *(_OWORD *)(v47 + 16 * v51) = *(_OWORD *)v50;
            if (*((_QWORD *)&v52 + 1))
            {
              v53 = (unint64_t *)(*((_QWORD *)&v52 + 1) + 8);
              do
                v54 = __ldxr(v53);
              while (__stxr(v54 + 1, v53));
              LODWORD(v51) = v44[3].__r_.__value_.__r.__words[1];
            }
            LODWORD(v44[3].__r_.__value_.__r.__words[1]) = v51 + 1;
            v55 = v83;
            if (v83)
            {
              v56 = (unint64_t *)&v83->__shared_owners_;
              do
                v57 = __ldaxr(v56);
              while (__stlxr(v57 - 1, v56));
              if (!v57)
              {
                ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
                std::__shared_weak_count::__release_weak(v55);
              }
            }
            if (mlir::anec::ANECIRTop::Write((uint64_t)v98, *((llvm::raw_ostream **)v91 + 17), (_DWORD)v89 == 0, v42, a7, a8))
            {
              v58 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
              v59 = mlir::FileLineColLoc::get(v58, "/Library/Caches/com.apple.xbs/Sources/ANECompiler/ext/mlir/mlir-mps/src/Dialect/ANEC/Transforms/Passes.cpp", 0x6AuLL, 0x1CAu, 0);
              v100[0] = "ANEC IR Write failed";
              v101 = 259;
              mlir::emitError(v59, (uint64_t)v100, (uint64_t)__p);
              mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)__p);
              if (__p[0])
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)__p);
              std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&__p[1]);
            }
            else
            {
              *((_BYTE *)v92 + 24) = 1;
              *((_BYTE *)v91 + 24) = 1;
              if ((a9 & 1) == 0)
            }
          }
          if (v88 != &v90)
            free(v88);
          llvm::deallocate_buffer(v85, (void *)(16 * v87));
        }
        v60 = (llvm::raw_ostream *)llvm::errs(v39);
        v61 = (void *)*((_QWORD *)v60 + 4);
        if (*((_QWORD *)v60 + 3) - (_QWORD)v61 > 0x1AuLL)
        {
          *((_QWORD *)v60 + 4) += 27;
        }
        else
        {
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v62 = &__dst;
        else
          v62 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v63 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          v63 = __dst.__r_.__value_.__l.__size_;
        v64 = llvm::raw_ostream::write(v60, (const char *)v62, v63);
        v65 = *((_QWORD *)v64 + 4);
        if ((unint64_t)(*((_QWORD *)v64 + 3) - v65) > 8)
        {
          *(_BYTE *)(v65 + 8) = 32;
          *((_QWORD *)v64 + 4) += 9;
        }
        else
        {
        }
        if (v95 >= 0)
          v66 = (const char *)&v93;
        else
          v66 = (const char *)v93;
        if (v95 >= 0)
          v67 = HIBYTE(v95);
        else
          v67 = v94;
        v68 = llvm::raw_ostream::write(v64, v66, v67);
        v69 = (_BYTE *)*((_QWORD *)v68 + 4);
        if (*((_BYTE **)v68 + 3) == v69)
        {
          llvm::raw_ostream::write(v68, "\n", 1uLL);
          v10 = 0;
        }
        else
        {
          v10 = 0;
          *v69 = 10;
          ++*((_QWORD *)v68 + 4);
        }
        v70 = v91;
        v91 = 0;
        if (v70)
        {
          if (*((_BYTE *)v70 + 128))
            llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v70 + 32));
          llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v70);
          MEMORY[0x20BD002F8]();
        }
      }
      else
      {
        v108 = 260;
        __p[0] = &v93;
        mlir::Operation::emitError((uint64_t *)a1, (uint64_t)__p, (uint64_t)&v104);
        if (v104)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v104);
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v105);
        v10 = 0;
      }
      v71 = v92;
      v92 = 0;
      if (v71)
      {
        if (*((_BYTE *)v71 + 128))
          llvm::raw_fd_ostream::~raw_fd_ostream((llvm::ToolOutputFile::CleanupInstaller *)((char *)v71 + 32));
        llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller(v71);
        MEMORY[0x20BD002F8]();
      }
      if (SHIBYTE(v95) < 0)
        operator delete(v93);
      v72 = v97;
      if (v97)
      {
        v73 = (unint64_t *)&v97->__shared_owners_;
        do
          v74 = __ldaxr(v73);
        while (__stlxr(v74 - 1, v73));
        if (!v74)
        {
          ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
          std::__shared_weak_count::__release_weak(v72);
        }
      }
      v75 = v99;
      if (v99)
      {
        v76 = (unint64_t *)&v99->__shared_owners_;
        do
          v77 = __ldaxr(v76);
        while (__stlxr(v77 - 1, v76));
        if (!v77)
        {
          ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
          std::__shared_weak_count::__release_weak(v75);
        }
      }
      goto LABEL_132;
    }
LABEL_139:
    abort();
  }
  mlir::emitError(*(_QWORD *)(a1 + 24), (uint64_t)__p);
  if (__p[0])
  {
    mlir::Diagnostic::operator<<((uint64_t)&__p[1], "File ");
    if (__p[0])
    {
      LOWORD(v88) = 260;
      v84 = &__dst;
      mlir::Diagnostic::operator<<((uint64_t)&__p[1], (const void ***)&v84);
      if (__p[0])
        mlir::Diagnostic::operator<<((uint64_t)&__p[1], " exists already.");
    }
  }
  v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)__p);
  if (__p[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)__p);
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&__p[1]);
LABEL_132:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anec::`anonymous namespace'::writePlist(mlir::Operation *,llvm::StringRef,llvm::StringRef,BOOL,llvm::StringRef,BOOL)::$_0>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v4;
  mlir::StringAttr *Context;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;

  if (!*(_BYTE *)(a2 + 47) || (result = mlir::Operation::getInherentAttr(a2, (uint64_t)"name", 4), !v4))
  {
    result = mlir::DictionaryAttr::contains(a2 + 56, "name", 4uLL);
    if (!(_DWORD)result)
      return result;
    goto LABEL_6;
  }
  if (result)
  {
LABEL_6:
    Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    v8 = 261;
    v7[0] = "name";
    v7[1] = 4;
    v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
    return mlir::Operation::removeAttr(a2, v6);
  }
  return result;
}

uint64_t mlir::anec::WriteA13PlistPassBase<mlir::anec::`anonymous namespace'::WriteA13PlistPass>::WriteA13PlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A13";
  *(_QWORD *)(a1 + 24) = 8;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24C051640;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA13PlistPass::~WriteA13PlistPass(mlir::anec::_anonymous_namespace_::WriteA13PlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA13PlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24C051640;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA13PlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA13PlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA13PlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA13PlistPassBase<mlir::anec::`anonymous namespace'::WriteA13PlistPass>::getName()
{
  return "WriteA13PlistPass";
}

const char *mlir::anec::WriteA13PlistPassBase<mlir::anec::`anonymous namespace'::WriteA13PlistPass>::getArgument()
{
  return "write-A13-plist";
}

const char *mlir::anec::WriteA13PlistPassBase<mlir::anec::`anonymous namespace'::WriteA13PlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA13PlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA13PlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A13>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA13PlistPassBase<mlir::anec::`anonymous namespace'::WriteA13PlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C051640;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24C051078;
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::WriteA14PlistPassBase<mlir::anec::`anonymous namespace'::WriteA14PlistPass>::WriteA14PlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A14";
  *(_QWORD *)(a1 + 24) = 8;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24C0516B0;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA14PlistPass::~WriteA14PlistPass(mlir::anec::_anonymous_namespace_::WriteA14PlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA14PlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24C0516B0;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA14PlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA14PlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA14PlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA14PlistPassBase<mlir::anec::`anonymous namespace'::WriteA14PlistPass>::getName()
{
  return "WriteA14PlistPass";
}

const char *mlir::anec::WriteA14PlistPassBase<mlir::anec::`anonymous namespace'::WriteA14PlistPass>::getArgument()
{
  return "write-A14-plist";
}

const char *mlir::anec::WriteA14PlistPassBase<mlir::anec::`anonymous namespace'::WriteA14PlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA14PlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA14PlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A14>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA14PlistPassBase<mlir::anec::`anonymous namespace'::WriteA14PlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C0516B0;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24C0510E8;
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::WriteA15PlistPassBase<mlir::anec::`anonymous namespace'::WriteA15PlistPass>::WriteA15PlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A15";
  *(_QWORD *)(a1 + 24) = 8;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24C051720;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA15PlistPass::~WriteA15PlistPass(mlir::anec::_anonymous_namespace_::WriteA15PlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA15PlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24C051720;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA15PlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA15PlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA15PlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA15PlistPassBase<mlir::anec::`anonymous namespace'::WriteA15PlistPass>::getName()
{
  return "WriteA15PlistPass";
}

const char *mlir::anec::WriteA15PlistPassBase<mlir::anec::`anonymous namespace'::WriteA15PlistPass>::getArgument()
{
  return "write-A15-plist";
}

const char *mlir::anec::WriteA15PlistPassBase<mlir::anec::`anonymous namespace'::WriteA15PlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA15PlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA15PlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A15>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA15PlistPassBase<mlir::anec::`anonymous namespace'::WriteA15PlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C051720;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24C051158;
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::WriteA16PlistPassBase<mlir::anec::`anonymous namespace'::WriteA16PlistPass>::WriteA16PlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A16";
  *(_QWORD *)(a1 + 24) = 8;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24C051790;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA16PlistPass::~WriteA16PlistPass(mlir::anec::_anonymous_namespace_::WriteA16PlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA16PlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24C051790;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA16PlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA16PlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA16PlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA16PlistPassBase<mlir::anec::`anonymous namespace'::WriteA16PlistPass>::getName()
{
  return "WriteA16PlistPass";
}

const char *mlir::anec::WriteA16PlistPassBase<mlir::anec::`anonymous namespace'::WriteA16PlistPass>::getArgument()
{
  return "write-A16-plist";
}

const char *mlir::anec::WriteA16PlistPassBase<mlir::anec::`anonymous namespace'::WriteA16PlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA16PlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA16PlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A16>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA16PlistPassBase<mlir::anec::`anonymous namespace'::WriteA16PlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C051790;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24C0511C8;
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::WriteA17PlistPassBase<mlir::anec::`anonymous namespace'::WriteA17PlistPass>::WriteA17PlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A17";
  *(_QWORD *)(a1 + 24) = 8;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24BFF4888;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA17PlistPass::~WriteA17PlistPass(mlir::anec::_anonymous_namespace_::WriteA17PlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA17PlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24BFF4888;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA17PlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA17PlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA17PlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA17PlistPassBase<mlir::anec::`anonymous namespace'::WriteA17PlistPass>::getName()
{
  return "WriteA17PlistPass";
}

const char *mlir::anec::WriteA17PlistPassBase<mlir::anec::`anonymous namespace'::WriteA17PlistPass>::getArgument()
{
  return "write-A17-plist";
}

const char *mlir::anec::WriteA17PlistPassBase<mlir::anec::`anonymous namespace'::WriteA17PlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA17PlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA17PlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A17>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA17PlistPassBase<mlir::anec::`anonymous namespace'::WriteA17PlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24BFF4888;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24BFF4708;
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::WriteA11LegacyPlistPassBase<mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass>::WriteA11LegacyPlistPassBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  char v5;
  int *v6;
  __n128 v7;

  *(_QWORD *)(a1 + 16) = "anec.A11Legacy";
  *(_QWORD *)(a1 + 24) = 14;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_24C051820;
  v7.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v7.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"plist-directory", 15, &v7);
  *(_QWORD *)(a1 + 344) = &off_24C050910;
  *(_QWORD *)(a1 + 576) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v7.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 592), v2, (uint64_t)"plist-filename", 14, &v7);
  *(_QWORD *)(a1 + 592) = &off_24C050910;
  *(_QWORD *)(a1 + 824) = &unk_24C050990;
  v7.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v7.n128_u64[1] = 64;
  v5 = 0;
  v6 = (int *)&v5;
  v4 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(a1 + 840), v2, (uint64_t)"force-overwrite", 15, &v7, (_BYTE **)&v6, &v4);
  *(_QWORD *)(a1 + 840) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1032) = &unk_24C050A50;
  v7.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not "
                                     "provided, no debug info will be added to the plist.";
  v7.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(a1 + 1048), v2, (uint64_t)"bundle-name", 11, &v7);
  *(_QWORD *)(a1 + 1048) = &off_24C050910;
  *(_QWORD *)(a1 + 1280) = &unk_24C050990;
                                     "It's only usefull for debugging. If false, all those attributes are erased.";
  v7.n128_u64[1] = 158;
  LOBYTE(v4) = 1;
  v6 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1296), v2, (uint64_t)"keep-unit-name-attrs", 20, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1296) = &off_24C0509D0;
  *(_QWORD *)(a1 + 1488) = &unk_24C050A50;
  return a1;
}

void mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass::~WriteA11LegacyPlistPass(mlir::anec::_anonymous_namespace_::WriteA11LegacyPlistPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::anec::_anonymous_namespace_::WriteA11LegacyPlistPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;

  *(_QWORD *)this = off_24C051820;
  *((_QWORD *)this + 162) = &unk_24C02DF38;
  v2 = (char *)this + 1456;
  v3 = (char *)*((_QWORD *)this + 185);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 162) = &unk_24C02E140;
  v5 = (void *)*((_QWORD *)this + 174);
  if (v5 != *((void **)this + 173))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 170);
  if (v6 != (char *)this + 1376)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 1048);
  *((_QWORD *)this + 105) = &unk_24C02DF38;
  v7 = (mlir::anec::_anonymous_namespace_::WriteA11LegacyPlistPass *)*((_QWORD *)this + 128);
  if (v7 == (mlir::anec::_anonymous_namespace_::WriteA11LegacyPlistPass *)((char *)this + 1000))
  {
    v8 = 4;
    v7 = (mlir::anec::_anonymous_namespace_::WriteA11LegacyPlistPass *)((char *)this + 1000);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 105) = &unk_24C02E140;
  v9 = (void *)*((_QWORD *)this + 117);
  if (v9 != *((void **)this + 116))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 113);
  if (v10 != (char *)this + 920)
    free(v10);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::anec::WriteA11LegacyPlistPassBase<mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass>::getName()
{
  return "WriteA11LegacyPlistPass";
}

const char *mlir::anec::WriteA11LegacyPlistPassBase<mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass>::getArgument()
{
  return "write-A11Legacy-plist";
}

const char *mlir::anec::WriteA11LegacyPlistPassBase<mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass>::getDescription()
{
  return "Write the ANEC dialect to a plist";
}

uint64_t mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass::runOnOperation(mlir::anec::_anonymous_namespace_::WriteA11LegacyPlistPass *this)
{
  unint64_t v2;
  int v3;
  char *v4;
  uint64_t v5;
  int v6;
  char *v7;
  std::string::size_type v8;
  int v9;
  char *v10;
  std::string::size_type v11;
  uint64_t result;

  v2 = *((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8;
  v3 = *((char *)this + 495);
  if (v3 >= 0)
    v4 = (char *)this + 472;
  else
    v4 = (char *)*((_QWORD *)this + 59);
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)this + 495);
  else
    v5 = *((_QWORD *)this + 60);
  v6 = *((char *)this + 743);
  if (v6 >= 0)
    v7 = (char *)this + 720;
  else
    v7 = (char *)*((_QWORD *)this + 90);
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)this + 743);
  else
    v8 = *((_QWORD *)this + 91);
  v9 = *((char *)this + 1199);
  if (v9 >= 0)
    v10 = (char *)this + 1176;
  else
    v10 = (char *)*((_QWORD *)this + 147);
  if (v9 >= 0)
    v11 = *((unsigned __int8 *)this + 1199);
  else
    v11 = *((_QWORD *)this + 148);
  if (!(_BYTE)result)
    *((_QWORD *)this + 5) |= 4uLL;
  return result;
}

BOOL mlir::OperationPass<mlir::anec::A11Legacy>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  const void *AttrData;
  size_t v4;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(_BYTE *)(a1 + 32) || v4 != *(_QWORD *)(a1 + 24))
    return 0;
  if (v4)
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  return 1;
}

_QWORD *mlir::anec::WriteA11LegacyPlistPassBase<mlir::anec::`anonymous namespace'::WriteA11LegacyPlistPass>::clonePass@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  char v8;
  int *v9;
  __n128 v10;

  v4 = operator new();
  v5 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = v4 + 200;
  *(_QWORD *)(v4 + 192) = 0x400000000;
  *(_QWORD *)(v4 + 232) = v4 + 248;
  *(_QWORD *)(v4 + 240) = 0x400000000;
  *(_QWORD *)(v4 + 280) = 0;
  *(_QWORD *)(v4 + 288) = 0;
  *(_DWORD *)(v4 + 296) = 0;
  *(_DWORD *)(v4 + 300) = 16;
  *(_OWORD *)(v4 + 304) = 0u;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_QWORD *)(v4 + 336) = 0;
  *(_QWORD *)v4 = off_24C051820;
  *(_QWORD *)(v4 + 8) = v5;
  v10.n128_u64[0] = (unint64_t)"The directory in which to place generated plists.";
  v10.n128_u64[1] = 49;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 344), (_QWORD *)(v4 + 152), (uint64_t)"plist-directory", 15, &v10);
  *(_QWORD *)(v4 + 344) = &off_24C050910;
  *(_QWORD *)(v4 + 576) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"The filename for the plist to be produced.";
  v10.n128_u64[1] = 42;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 592), (_QWORD *)(v4 + 152), (uint64_t)"plist-filename", 14, &v10);
  *(_QWORD *)(v4 + 592) = &off_24C050910;
  *(_QWORD *)(v4 + 824) = &unk_24C050990;
  v10.n128_u64[0] = (unint64_t)"Force the pass to overwrite any files that already exist. DANGER";
  v10.n128_u64[1] = 64;
  v8 = 0;
  v9 = (int *)&v8;
  v7 = 1;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>,llvm::cl::OptionHidden>((_QWORD *)(v4 + 840), (_QWORD *)(v4 + 152), (uint64_t)"force-overwrite", 15, &v10, (_BYTE **)&v9, &v7);
  *(_QWORD *)(v4 + 840) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1032) = &unk_24C050A50;
  v10.n128_u64[0] = (unint64_t)"Bundle name of the framework or application owning the model being compiled.If not"
                                      " provided, no debug info will be added to the plist.";
  v10.n128_u64[1] = 134;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((_QWORD *)(v4 + 1048), (_QWORD *)(v4 + 152), (uint64_t)"bundle-name", 11, &v10);
  *(_QWORD *)(v4 + 1048) = &off_24C050910;
  *(_QWORD *)(v4 + 1280) = &unk_24C050990;
                                      " It's only usefull for debugging. If false, all those attributes are erased.";
  v10.n128_u64[1] = 158;
  LOBYTE(v7) = 1;
  v9 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(v4 + 1296), (_QWORD *)(v4 + 152), (uint64_t)"keep-unit-name-attrs", 20, &v10, (_BYTE **)&v9);
  *(_QWORD *)(v4 + 1296) = &off_24C0509D0;
  *(_QWORD *)(v4 + 1488) = &unk_24C050A50;
  *(_QWORD *)v4 = &off_24C051450;
  *a2 = v4;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anec::getRegionConversionInfo(mlir::Operation *,mlir::anec::ANECIRWeights &,std::shared_ptr<mlir::anec::RegionConversionInfo> &,llvm::DenseMap<long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>> &)::$_0>(uint64_t a1, _QWORD **a2)
{
  uint64_t v4;
  mlir::anec::ANECIRWeights *v5;
  uint64_t v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t *v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t result;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *p_shared_owners;
  unint64_t v39;
  uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  int v43;
  int v44;
  unsigned int v45;
  _QWORD *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  _QWORD *v49;
  BOOL v50;
  int v51;
  uint64_t v52;
  __int128 v53;
  mlir::StringAttr *Context;
  std::string::size_type size;
  std::string *v56;
  uint64_t v57;
  mlir::StringAttr *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  uint64_t InterfaceFor;
  int v66;
  uint64_t v67;
  unsigned int v68;
  unsigned int v69;
  int v70;
  unsigned int v71;
  unint64_t v72;
  char *v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD v78[4];
  __int16 v79;
  std::string v80;
  const char *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  __int16 v84;

  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD *, uint64_t))(*a2[6] + 32))(a2[6], v4))
    goto LABEL_58;
  if (!mlir::anec::ANECIRWeights::hasConstant(*(mlir::anec::ANECIRWeights **)a1, (mlir::Operation *)a2))
  {
    if (!(_BYTE)result)
      return result;
    v33 = mlir::anec::ANECIRWeights::lookupConstant(*(mlir::anec::ANECIRWeights **)a1, (mlir::Operation *)a2);
    v35 = *(_QWORD *)(**(_QWORD **)(a1 + 24) + 256);
    if (v35 == *(_QWORD *)(**(_QWORD **)(a1 + 24) + 248))
      goto LABEL_58;
    v36 = *(_QWORD *)(v35 - 16);
    v37 = *(std::__shared_weak_count **)(v35 - 8);
    if (v37)
    {
      p_shared_owners = (unint64_t *)&v37->__shared_owners_;
      do
        v39 = __ldxr(p_shared_owners);
      while (__stxr(v39 + 1, p_shared_owners));
    }
    if (!v36 || *(_QWORD *)(v36 + 40) != v33)
    {
LABEL_53:
      if (v37)
      {
        v63 = (unint64_t *)&v37->__shared_owners_;
        do
          v64 = __ldaxr(v63);
        while (__stlxr(v64 - 1, v63));
        if (!v64)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }
      goto LABEL_58;
    }
    v40 = *(_QWORD *)(a1 + 8);
    v81 = (const char *)v33;
    v82 = v36;
    v83 = v37;
    if (v37)
    {
      v41 = (unint64_t *)&v37->__shared_owners_;
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
    }
    v43 = *(_DWORD *)(v40 + 16);
    if (v43)
    {
      v44 = v43 - 1;
      v45 = v44 & (37 * v33);
      v46 = (_QWORD *)(*(_QWORD *)v40 + 24 * v45);
      v47 = *v46;
      v48 = v37;
      if (v33 == *v46)
      {
LABEL_48:
        if (v48)
        {
          v61 = (unint64_t *)&v48->__shared_owners_;
          do
            v62 = __ldaxr(v61);
          while (__stlxr(v62 - 1, v61));
          if (!v62)
          {
            ((void (*)(std::__shared_weak_count *, uint64_t))v48->__on_zero_shared)(v48, v34);
            std::__shared_weak_count::__release_weak(v48);
          }
        }
        goto LABEL_53;
      }
      v49 = 0;
      LODWORD(v34) = 1;
      while (v47 != 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v49)
          v50 = 0;
        else
          v50 = v47 == 0x8000000000000000;
        if (v50)
          v49 = v46;
        v51 = v45 + v34;
        v34 = (v34 + 1);
        v45 = v51 & v44;
        v46 = (_QWORD *)(*(_QWORD *)v40 + 24 * v45);
        v47 = *v46;
        if (v33 == *v46)
        {
          v48 = v37;
          goto LABEL_48;
        }
      }
      if (v49)
        v60 = (uint64_t)v49;
      else
        v60 = (uint64_t)v46;
    }
    else
    {
      v60 = 0;
    }
    llvm::DenseMapBase<llvm::DenseMap<long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>>,long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>>::InsertIntoBucket<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>(v40, v60, (uint64_t *)&v81, (uint64_t)&v82);
    v48 = v83;
    goto LABEL_48;
  }
  v6 = mlir::anec::ANECIRWeights::lookupConstant(*(mlir::anec::ANECIRWeights **)a1, (mlir::Operation *)a2);
  v7 = *(uint64_t **)(a1 + 8);
  v8 = *((_DWORD *)v7 + 4);
  if (v8)
  {
    v9 = *v7;
    v10 = 37 * v6;
    v11 = v8 - 1;
    v12 = (v8 - 1) & (37 * v6);
    v13 = (_QWORD *)(v9 + 24 * v12);
    v14 = *v13;
    if (v6 != *v13)
    {
      v66 = 1;
      v67 = *v13;
      v68 = v11 & v10;
      while (v67 != 0x7FFFFFFFFFFFFFFFLL)
      {
        v69 = v68 + v66++;
        v68 = v69 & v11;
        v67 = *(_QWORD *)(v9 + 24 * v68);
        if (v6 == v67)
        {
          v70 = 1;
          while (v14 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v71 = v12 + v70++;
            v12 = v71 & v11;
            v13 = (_QWORD *)(v9 + 24 * v12);
            v14 = *v13;
            if (v6 == *v13)
              goto LABEL_81;
          }
          v13 = (_QWORD *)(v9 + 24 * v8);
LABEL_81:
          v15 = **(_QWORD **)(a1 + 16);
          goto LABEL_6;
        }
      }
      goto LABEL_58;
    }
    v15 = **(_QWORD **)(a1 + 16);
LABEL_6:
    v17 = (unint64_t *)(v15 + 64);
    v16 = *(_QWORD *)(v15 + 64);
    v18 = (char *)(v13 + 1);
    v19 = *(unsigned int *)(v15 + 72);
    if (v19 >= *(_DWORD *)(v15 + 76))
    {
      v76 = v6;
      v77 = v15;
      v72 = v19 + 1;
      v75 = (char *)(v13 + 1);
      if (v16 <= (unint64_t)v18 && v16 + 16 * v19 > (unint64_t)v18)
      {
        v74 = &v75[-v16];
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow((uint64_t)v17, v72);
        v16 = *v17;
        v18 = &v74[*v17];
        v6 = v76;
        v15 = v77;
      }
      else
      {
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow((uint64_t)v17, v72);
        v16 = *v17;
        v6 = v76;
        v15 = v77;
        v18 = v75;
      }
    }
    v20 = *(unsigned int *)(v15 + 72);
    v21 = *(_OWORD *)v18;
    *(_OWORD *)(v16 + 16 * v20) = *(_OWORD *)v18;
    if (*((_QWORD *)&v21 + 1))
    {
      v22 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
      do
        v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
      LODWORD(v20) = *(_DWORD *)(v15 + 72);
    }
    *(_DWORD *)(v15 + 72) = v20 + 1;
    v24 = *(uint64_t **)(a1 + 8);
    v25 = *v24;
    v26 = *((_DWORD *)v24 + 4);
    if (v26)
    {
      v27 = (v26 - 1) & v10;
      v28 = (uint64_t *)(v25 + 24 * v27);
      v29 = *v28;
      if (v6 == *v28)
      {
LABEL_39:
        v52 = v28[1];
        if (*(char *)(v52 + 31) < 0)
        {
          std::string::__init_copy_ctor_external(&v80, *(const std::string::value_type **)(v52 + 8), *(_QWORD *)(v52 + 16));
        }
        else
        {
          v53 = *(_OWORD *)(v52 + 8);
          v80.__r_.__value_.__r.__words[2] = *(_QWORD *)(v52 + 24);
          *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v53;
        }
        Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 3));
        size = HIBYTE(v80.__r_.__value_.__r.__words[2]);
        v56 = &v80;
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          size = v80.__r_.__value_.__l.__size_;
          v56 = (std::string *)v80.__r_.__value_.__r.__words[0];
        }
        v79 = 261;
        v78[0] = v56;
        v78[1] = size;
        v57 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v78);
        v58 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 3));
        v84 = 261;
        v81 = "name";
        v82 = 4;
        v59 = mlir::StringAttr::get(v58, (mlir::MLIRContext *)&v81);
        mlir::Operation::setAttr((uint64_t)a2, v59, v57);
        if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v80.__r_.__value_.__l.__data_);
        goto LABEL_58;
      }
      v30 = 1;
      while (v29 != 0x7FFFFFFFFFFFFFFFLL)
      {
        v31 = v27 + v30++;
        v27 = v31 & (v26 - 1);
        v28 = (uint64_t *)(v25 + 24 * v27);
        v29 = *v28;
        if (v6 == *v28)
          goto LABEL_39;
      }
    }
    v28 = (uint64_t *)(v25 + 24 * v26);
    goto LABEL_39;
  }
LABEL_58:
  result = mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
  if (result)
  {
    if (a2)
    {
      InterfaceFor = mlir::OpInterface<mlir::anec::PlistGeneratorInterface,mlir::anec::detail::PlistGeneratorInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
      v81 = (const char *)a2;
      v82 = InterfaceFor;
      return mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v81, **(_QWORD **)(a1 + 24), *(_QWORD *)a1);
    }
    else
    {
      result = 0;
      v81 = 0;
      v82 = 0;
    }
  }
  else
  {
    v81 = 0;
    v82 = 0;
  }
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>>,long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>>::InsertIntoBucket<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  unsigned int v18;

  v8 = *(_DWORD *)(a1 + 8);
  v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
LABEL_3:
    v10 = *(_QWORD *)a2;
    goto LABEL_4;
  }
  llvm::DenseMap<long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>>::grow(a1, v9);
  v10 = *a3;
  v12 = *(_DWORD *)(a1 + 16) - 1;
  v13 = (37 * *a3) & v12;
  a2 = *(_QWORD *)a1 + 24 * v13;
  v14 = *(_QWORD *)a2;
  if (*a3 != *(_QWORD *)a2)
  {
    v15 = 0;
    v16 = 1;
    while (v14 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v15)
        v17 = 0;
      else
        v17 = v14 == 0x8000000000000000;
      if (v17)
        v15 = a2;
      v18 = v13 + v16++;
      v13 = v18 & v12;
      a2 = *(_QWORD *)a1 + 24 * (v18 & v12);
      v14 = *(_QWORD *)a2;
      if (v10 == *(_QWORD *)a2)
        goto LABEL_4;
    }
    if (v15)
      a2 = v15;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v10 != 0x7FFFFFFFFFFFFFFFLL)
    --*(_DWORD *)(a1 + 12);
  *(_QWORD *)a2 = *a3;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)a4;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  return a2;
}

_QWORD *llvm::DenseMap<long long,std::shared_ptr<mlir::anec::ANECIRConstant>,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseMapPair<long long,std::shared_ptr<mlir::anec::ANECIRConstant>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  unsigned int v10;
  unint64_t v11;
  _QWORD *v12;
  unsigned int v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  llvm *v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  unsigned int v33;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(_DWORD *)(a1 + 16);
    if (!v10)
      goto LABEL_16;
    v11 = 24 * v10 - 24;
    if (v11 >= 0x18)
    {
      v16 = v11 / 0x18 + 1;
      v12 = &result[3 * (v16 & 0x1FFFFFFFFFFFFFFELL)];
      v17 = v16 & 0x1FFFFFFFFFFFFFFELL;
      v18 = result;
      do
      {
        *v18 = 0x7FFFFFFFFFFFFFFFLL;
        v18[3] = 0x7FFFFFFFFFFFFFFFLL;
        v18 += 6;
        v17 -= 2;
      }
      while (v17);
      if (v16 == (v16 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_16:
        if ((_DWORD)v3)
        {
          v20 = v4;
          do
          {
            v26 = *(_QWORD *)v20;
            if ((unint64_t)(*(_QWORD *)v20 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
            {
              v27 = *(_DWORD *)(a1 + 16) - 1;
              v28 = v27 & (37 * v26);
              v25 = *(_QWORD *)a1 + 24 * v28;
              v29 = *(_QWORD *)v25;
              if (v26 != *(_QWORD *)v25)
              {
                v30 = 0;
                v31 = 1;
                while (v29 != 0x7FFFFFFFFFFFFFFFLL)
                {
                  if (v30)
                    v32 = 0;
                  else
                    v32 = v29 == 0x8000000000000000;
                  if (v32)
                    v30 = v25;
                  v33 = v28 + v31++;
                  v28 = v33 & v27;
                  v25 = *(_QWORD *)a1 + 24 * (v33 & v27);
                  v29 = *(_QWORD *)v25;
                  if (v26 == *(_QWORD *)v25)
                    goto LABEL_26;
                }
                if (v30)
                  v25 = v30;
              }
LABEL_26:
              *(_QWORD *)v25 = v26;
              *(_OWORD *)(v25 + 8) = *(_OWORD *)((char *)v20 + 8);
              *((_QWORD *)v20 + 1) = 0;
              *((_QWORD *)v20 + 2) = 0;
              ++*(_DWORD *)(a1 + 8);
            }
            v20 = (llvm *)((char *)v20 + 24);
          }
          while (v20 != (llvm *)((char *)v4 + 24 * v3));
        }
        llvm::deallocate_buffer(v4, (void *)(24 * v3));
      }
    }
    else
    {
      v12 = result;
    }
    v19 = &result[3 * v10];
    do
    {
      *v12 = 0x7FFFFFFFFFFFFFFFLL;
      v12 += 3;
    }
    while (v12 != v19);
    goto LABEL_16;
  }
  *(_QWORD *)(a1 + 8) = 0;
  v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    v14 = 24 * v13 - 24;
    if (v14 < 0x18)
    {
      v15 = result;
LABEL_21:
      v24 = &result[3 * v13];
      do
      {
        *v15 = 0x7FFFFFFFFFFFFFFFLL;
        v15 += 3;
      }
      while (v15 != v24);
      return result;
    }
    v21 = v14 / 0x18 + 1;
    v15 = &result[3 * (v21 & 0x1FFFFFFFFFFFFFFELL)];
    v22 = v21 & 0x1FFFFFFFFFFFFFFELL;
    v23 = result;
    do
    {
      *v23 = 0x7FFFFFFFFFFFFFFFLL;
      v23[3] = 0x7FFFFFFFFFFFFFFFLL;
      v23 += 6;
      v22 -= 2;
    }
    while (v22);
    if (v21 != (v21 & 0x1FFFFFFFFFFFFFFELL))
      goto LABEL_21;
  }
  return result;
}

uint64_t mlir::arith::invertPredicate(uint64_t a1)
{
  return qword_207AB5E00[a1];
}

void mlir::arith::ConstantOp::getAsmResultNames(uint64_t a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t NextResultAtOffset;
  uint64_t Int;
  uint64_t v17;
  const char *v18;
  _BYTE *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unsigned int v27;
  void (**v28)(llvm::raw_svector_ostream *__hidden);
  int v29;
  uint64_t v30;
  unint64_t v31;
  _BYTE *v32;
  char v33;
  uint64_t v34;
  int v35;
  void **v36;
  unint64_t v37;
  uint64_t v38;
  void *v39;
  __int128 v40;
  _QWORD v41[5];

  v41[4] = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(*(_QWORD *)a1 - 8);
  v6 = *(_QWORD *)(*(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64);
  if (v6)
    mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v6 + 8);
  v7 = *(void **)(*(_QWORD *)v6 + 136);
  v8 = v7 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v9 = v6;
  else
    v9 = 0;
  v38 = v9;
  if (v8)
  {
    v12 = v5 & 0xFFFFFFFFFFFFFFF8;
    if (*(_UNKNOWN **)(*(_QWORD *)(v5 & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      v13 = v5 & 0xFFFFFFFFFFFFFFF8;
    else
      v13 = 0;
    v37 = v13;
    if (v13 && mlir::IntegerType::getWidth((mlir::IntegerType *)&v37) == 1)
    {
      if (*(_DWORD *)(*(_QWORD *)a1 + 36))
        v14 = *(_QWORD *)a1 - 16;
      else
        v14 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, 0);
      Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v38);
      if (Int)
        v17 = 4;
      else
        v17 = 5;
      if (Int)
        v18 = "true";
      else
        v18 = "false";
      a2(a3, NextResultAtOffset, v18, v17);
    }
    else
    {
      v39 = v41;
      v40 = xmmword_207AB5560;
      v29 = 0;
      v33 = 0;
      v34 = 0;
      v35 = 1;
      v31 = 0;
      v32 = 0;
      v30 = 0;
      v28 = &off_24C02DCB8;
      v36 = &v39;
      llvm::raw_ostream::SetBufferAndMode((uint64_t)&v28, 0, 0, 0);
      v19 = v32;
      if ((unint64_t)v32 >= v31)
      {
        v20 = llvm::raw_ostream::write((llvm::raw_ostream *)&v28, 99);
      }
      else
      {
        ++v32;
        *v19 = 99;
        v20 = (llvm::raw_ostream *)&v28;
      }
      mlir::IntegerAttr::getValue(&v38, (llvm::APInt *)&v26);
      llvm::APInt::print((llvm::APInt *)&v26, v20, 1);
      if (v27 >= 0x41 && v26)
        MEMORY[0x20BD002D4](v26, 0x1000C8000313F17);
      if (v37)
      {
        v21 = v32;
        if ((unint64_t)v32 >= v31)
        {
          v22 = llvm::raw_ostream::write((llvm::raw_ostream *)&v28, 95);
        }
        else
        {
          ++v32;
          *v21 = 95;
          v22 = (llvm::raw_ostream *)&v28;
        }
        v26 = v12;
        mlir::Type::print((llvm::raw_ostream *)&v26, v22);
      }
      if (*(_DWORD *)(*(_QWORD *)a1 + 36))
        v23 = *(_QWORD *)a1 - 16;
      else
        v23 = 0;
      v24 = mlir::detail::OpResultImpl::getNextResultAtOffset(v23, 0);
      a2(a3, v24, (const char *)*v36, (uint64_t)v36[1]);
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v28);
      if (v39 != v41)
        free(v39);
    }
  }
  else
  {
    if (*(_DWORD *)(*(_QWORD *)a1 + 36))
      v10 = *(_QWORD *)a1 - 16;
    else
      v10 = 0;
    v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
    a2(a3, v11, "cst", 3);
  }
}

_QWORD *mlir::arith::ConstantOp::getValue(mlir::arith::ConstantOp *this)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  if (!v1)
    return 0;
  mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v1 + 8);
  return v1;
}

uint64_t mlir::arith::ConstantOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  int *v5;
  char *v6;
  char *v7;
  __int128 v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t canMapOperands;
  uint64_t v12;
  void *v13;
  BOOL v14;
  uint64_t v15;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  char *v22;
  char *v23;
  __int128 v24;
  int *v25;
  char *v26;
  char *v27;
  __int128 v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  _QWORD *v59;
  uint64_t v60;
  const void **v61[4];
  __int16 v62;
  int v63;
  const char *v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  void *v68;
  unsigned int v69;
  unsigned int v70;
  _BYTE v71[96];
  void *v72;
  _QWORD *v73;
  void *__p;
  _QWORD *v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  v2 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  v3 = (_QWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v4 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v3 + 8);
    v66 = v3;
    v67 = v4;
    if (mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v66) != v2)
      goto LABEL_3;
  }
  else
  {
    v66 = 0;
    v67 = 0;
    if (mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v66) != v2)
    {
LABEL_3:
      v62 = 257;
      mlir::OpState::emitOpError(this, v61, (uint64_t)&v66);
      if (v66)
      {
        v63 = 3;
        v64 = "value type ";
        v65 = 11;
        v5 = &v63;
        v6 = (char *)v68;
        if (v69 >= v70)
        {
          v50 = v69 + 1;
          if (v68 <= &v63 && (char *)v68 + 24 * v69 > (char *)&v63)
          {
            v55 = (char *)&v63 - (_BYTE *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
            v6 = (char *)v68;
            v5 = (int *)((char *)v68 + v55);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
            v5 = &v63;
            v6 = (char *)v68;
          }
        }
        v7 = &v6[24 * v69];
        v8 = *(_OWORD *)v5;
        *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
        *(_OWORD *)v7 = v8;
        ++v69;
      }
      v9 = (_QWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
      if (v9)
      {
        v10 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v9 + 8);
        v59 = v9;
        v60 = v10;
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v59);
        if (!v66)
          goto LABEL_26;
      }
      else
      {
        v59 = 0;
        v60 = 0;
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v59);
        if (!v66)
          goto LABEL_26;
      }
      v16 = &v63;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v63, canMapOperands);
      v17 = (char *)v68;
      if (v69 >= v70)
      {
        v51 = v69 + 1;
        if (v68 <= &v63 && (char *)v68 + 24 * v69 > (char *)&v63)
        {
          v56 = (char *)&v63 - (_BYTE *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v51, 24);
          v17 = (char *)v68;
          v16 = (int *)((char *)v68 + v56);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v51, 24);
          v16 = &v63;
          v17 = (char *)v68;
        }
      }
      v18 = &v17[24 * v69];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v18 = v19;
      v20 = ++v69;
      if (v66)
      {
        v63 = 3;
        v64 = " must match return type: ";
        v65 = 25;
        v21 = &v63;
        v22 = (char *)v68;
        if (v20 >= v70)
        {
          v52 = v20 + 1;
          v53 = (char *)v68 + 24 * v20 > (char *)&v63;
          if (v68 <= &v63 && v53)
          {
            v57 = (char *)&v63 - (_BYTE *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
            v22 = (char *)v68;
            v21 = (int *)((char *)v68 + v57);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
            v21 = &v63;
            v22 = (char *)v68;
          }
        }
        v23 = &v22[24 * v69];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
        *(_OWORD *)v23 = v24;
        ++v69;
        if (v66)
        {
          v25 = &v63;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v63, v2);
          v26 = (char *)v68;
          if (v69 >= v70)
          {
            v54 = v69 + 1;
            if (v68 <= &v63 && (char *)v68 + 24 * v69 > (char *)&v63)
            {
              v58 = (char *)&v63 - (_BYTE *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
              v26 = (char *)v68;
              v25 = (int *)((char *)v68 + v58);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
              v25 = &v63;
              v26 = (char *)v68;
            }
          }
          v27 = &v26[24 * v69];
          v28 = *(_OWORD *)v25;
          *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
          *(_OWORD *)v27 = v28;
          ++v69;
        }
      }
LABEL_26:
      v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v66);
      if (v66)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v66);
      if (v76)
      {
        v29 = __p;
        if (__p)
        {
          v30 = v75;
          v31 = __p;
          if (v75 != __p)
          {
            do
              v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
            while (v30 != v29);
            v31 = __p;
          }
          v75 = v29;
          operator delete(v31);
        }
        v32 = v72;
        if (!v72)
          goto LABEL_71;
        v33 = v73;
        v34 = v72;
        if (v73 == v72)
        {
LABEL_70:
          v73 = v32;
          operator delete(v34);
LABEL_71:
          if (v68 != v71)
            free(v68);
          return v15;
        }
        do
        {
          v36 = *--v33;
          v35 = v36;
          *v33 = 0;
          if (v36)
            MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
        }
        while (v33 != v32);
LABEL_69:
        v34 = v72;
        goto LABEL_70;
      }
      return v15;
    }
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v2 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && (v66 = (_QWORD *)v2, mlir::IntegerType::getSignedness((mlir::IntegerType *)&v66)))
  {
    v61[0] = (const void **)"integer return type must be signless";
    v62 = 259;
    mlir::OpState::emitOpError(this, v61, (uint64_t)&v66);
    v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v66);
    if (v66)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v66);
    if (v76)
    {
      v37 = __p;
      if (__p)
      {
        v38 = v75;
        v39 = __p;
        if (v75 != __p)
        {
          do
            v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
          while (v38 != v37);
          v39 = __p;
        }
        v75 = v37;
        operator delete(v39);
      }
      v32 = v72;
      if (!v72)
        goto LABEL_71;
      v40 = v73;
      v34 = v72;
      if (v73 == v72)
        goto LABEL_70;
      do
      {
        v42 = *--v40;
        v41 = v42;
        *v40 = 0;
        if (v42)
          MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
      }
      while (v40 != v32);
      goto LABEL_69;
    }
  }
  else
  {
    v12 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
    if (v12)
      mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v12 + 8);
    v13 = *(void **)(*(_QWORD *)v12 + 136);
    v14 = v13 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
       || v13 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id;
    if (v14 || mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v12 + 8))
      return 1;
    v61[0] = (const void **)"value must be an integer, float, or elements attribute";
    v62 = 259;
    mlir::OpState::emitOpError(this, v61, (uint64_t)&v66);
    v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v66);
    if (v66)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v66);
    if (v76)
    {
      v43 = __p;
      if (__p)
      {
        v44 = v75;
        v45 = __p;
        if (v75 != __p)
        {
          do
            v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
          while (v44 != v43);
          v45 = __p;
        }
        v75 = v43;
        operator delete(v45);
      }
      v32 = v72;
      if (!v72)
        goto LABEL_71;
      v46 = v73;
      v34 = v72;
      if (v73 == v72)
        goto LABEL_70;
      do
      {
        v48 = *--v46;
        v47 = v48;
        *v46 = 0;
        if (v48)
          MEMORY[0x20BD002D4](v47, 0x1000C8077774924);
      }
      while (v46 != v32);
      goto LABEL_69;
    }
  }
  return v15;
}

BOOL mlir::arith::ConstantOp::isBuildableWith(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)a1 + 8))
  {
    v9 = 0;
    v10 = 0;
    return 0;
  }
  v4 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)a1 + 8);
  v9 = a1;
  v10 = v4;
  if (!a1)
    return 0;
  if (mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v9) != a2)
    return 0;
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    v8 = a2;
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v8))
      return 0;
  }
  v6 = *(void **)(*(_QWORD *)a1 + 136);
  return v6 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
      || v6 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id
      || mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)a1 + 8) != 0;
}

ZinIrHalH13g *mlir::arith::ConstantOp::materialize(mlir::OpBuilder *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v9[2];

  if (!mlir::arith::ConstantOp::isBuildableWith((uint64_t)a2, a3))
    return 0;
  if (a2)
    v7 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*a2 + 8);
  else
    v7 = 0;
  v9[0] = (uint64_t)a2;
  v9[1] = v7;
  return mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::TypedAttr>(a1, a4, v9);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::TypedAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  ZinIrHalH13g *v9;
  ZinIrHalH13g *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x24BDAC8D0];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"arith.constant";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::arith::ConstantOp::build((uint64_t)a1, (uint64_t)v17, *a3, a3[1]);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

unint64_t mlir::arith::ConstantOp::fold(uint64_t a1)
{
  unint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64);
  if (v1)
    mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v1 + 8);
  return v1 & 0xFFFFFFFFFFFFFFFBLL;
}

void mlir::arith::ConstantIntOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t IntegerType;
  _QWORD *IntegerAttr;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;

  IntegerType = mlir::Builder::getIntegerType(a1, a4);
  IntegerAttr = (_QWORD *)mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a3);
  v9 = IntegerAttr;
  if (!IntegerAttr)
  {
    v13 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v13 = 0;
    v13[1] = 0;
    v12 = *(unsigned int *)(a2 + 72);
    if (v12 < *(_DWORD *)(a2 + 76))
      goto LABEL_4;
    goto LABEL_3;
  }
  v10 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*IntegerAttr + 8);
  v11 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *v11 = v9;
  v11[1] = v10;
  v12 = *(unsigned int *)(a2 + 72);
  if (v12 >= *(_DWORD *)(a2 + 76))
  {
LABEL_3:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
LABEL_4:
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v12) = IntegerType;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::arith::ConstantOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  uint64_t v10;

  v9 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *v9 = a4;
  v9[1] = a5;
  v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

BOOL mlir::arith::ConstantIntOp::classof(_BOOL8 this, mlir::Operation *a2)
{
  unint64_t v2;

  if (this)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(this + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id)
    {
      v2 = *(_QWORD *)(this - 8) & 0xFFFFFFFFFFFFFFF8;
      return mlir::Type::isSignlessInteger((mlir::Type *)&v2);
    }
    else
    {
      return 0;
    }
  }
  return this;
}

void mlir::arith::ConstantIndexOp::build(mlir::IndexType **a1, uint64_t a2, mlir::MLIRContext *a3)
{
  uint64_t IndexType;
  _QWORD *IndexAttr;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;

  IndexType = mlir::Builder::getIndexType(a1, (mlir::MLIRContext *)a2);
  IndexAttr = (_QWORD *)mlir::Builder::getIndexAttr(a1, a3);
  v8 = IndexAttr;
  if (!IndexAttr)
  {
    v12 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v12 = 0;
    v12[1] = 0;
    v11 = *(unsigned int *)(a2 + 72);
    if (v11 < *(_DWORD *)(a2 + 76))
      goto LABEL_4;
    goto LABEL_3;
  }
  v9 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*IndexAttr + 8);
  v10 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *v10 = v8;
  v10[1] = v9;
  v11 = *(unsigned int *)(a2 + 72);
  if (v11 >= *(_DWORD *)(a2 + 76))
  {
LABEL_3:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a2 + 72);
  }
LABEL_4:
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v11) = IndexType;
  ++*(_DWORD *)(a2 + 72);
}

BOOL mlir::arith::ConstantIndexOp::classof(_BOOL8 this, mlir::Operation *a2)
{
  unint64_t v2;

  if (this)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(this + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id)
    {
      v2 = *(_QWORD *)(this - 8) & 0xFFFFFFFFFFFFFFF8;
      return mlir::Type::isIndex((mlir::Type *)&v2);
    }
    else
    {
      return 0;
    }
  }
  return this;
}

uint64_t mlir::arith::AddIOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t DefiningOp;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t canMapOperands;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t Value;
  int v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  const void *v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t Type;
  int v38;
  unint64_t NumElements;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  char *Address;
  llvm::APInt *v50;
  unsigned int v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  unsigned int v62;
  const void *v63;
  unsigned int v64;
  uint64_t v65;
  unsigned int v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  const void *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned __int8 v77;
  _QWORD v78[2];
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  unsigned int v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _OWORD v88[4];
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  if (!v4)
    goto LABEL_16;
  DWORD2(v87) = 1;
  *(_QWORD *)&v87 = 0;
  *(_QWORD *)&v85 = &v87;
  v5 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v85, v4);
  v6 = DWORD2(v87);
  if (v5)
  {
    if (DWORD2(v87) < 0x41)
    {
      v7 = (_QWORD)v87 == 0;
      goto LABEL_11;
    }
    if (v6 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v87) > 0x40)
    {
      if ((_QWORD)v87)
        MEMORY[0x20BD002D4](v87, 0x1000C8000313F17);
      goto LABEL_16;
    }
    v7 = *(_QWORD *)v87 == 0;
  }
  else
  {
    v7 = 0;
    if (DWORD2(v87) < 0x41)
      goto LABEL_11;
  }
  if (!(_QWORD)v87)
  {
LABEL_11:
    if (v7)
      goto LABEL_12;
    goto LABEL_16;
  }
  MEMORY[0x20BD002D4](v87, 0x1000C8000313F17);
  if (v7)
  {
LABEL_12:
    v8 = *(_QWORD *)(*a1 + 72);
    return *(_QWORD *)(v8 + 24) | 4;
  }
LABEL_16:
  *(_QWORD *)&v87 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v87);
  if (DefiningOp)
  {
    v11 = *a1;
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::SubIOp,void>::id)
    {
      v12 = *(_QWORD *)(DefiningOp + 72);
      if (*(_QWORD *)(*(_QWORD *)(v11 + 72) + 56) == *(_QWORD *)(v12 + 56))
        return *(_QWORD *)(v12 + 24) | 4;
    }
  }
  else
  {
    v11 = *a1;
  }
  *(_QWORD *)&v87 = *(_QWORD *)(*(_QWORD *)(v11 + 72) + 56);
  v13 = mlir::Value::getDefiningOp((mlir::Value *)&v87);
  if (v13)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v13 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::SubIOp,void>::id)
    {
      v8 = *(_QWORD *)(v13 + 72);
      if (*(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) == *(_QWORD *)(v8 + 56))
        return *(_QWORD *)(v8 + 24) | 4;
    }
  }
  v14 = *(uint64_t **)(a2 + 40);
  canMapOperands = *v14;
  if (*v14
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v16 = *v14;
  }
  else
  {
    v16 = v14[1];
    if (!v16 || *(_UNKNOWN **)(*(_QWORD *)v16 + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      if (canMapOperands)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
        {
          v17 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
          *(_QWORD *)&v87 = canMapOperands;
          *((_QWORD *)&v87 + 1) = v17;
          canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v87);
        }
        else
        {
          canMapOperands = 0;
          v87 = 0uLL;
        }
      }
      else
      {
        v87 = 0uLL;
      }
      v16 = v14[1];
      if (v16)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v16 + 8))
        {
          v18 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v16 + 8);
          *(_QWORD *)&v87 = v16;
          *((_QWORD *)&v87 + 1) = v18;
          v19 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v87);
          v16 = 0;
          if (canMapOperands && v19 && canMapOperands == v19)
          {
            v20 = *v14;
            if (*v14
              && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            {
              v16 = *v14;
            }
            else
            {
              v21 = v14[1];
              if (v21)
              {
                v22 = *(void **)(*(_QWORD *)v21 + 136);
                if (v22 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
                  v16 = v14[1];
                else
                  v16 = 0;
                if (!v20 || v22 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
                  return v16 & 0xFFFFFFFFFFFFFFFBLL;
                if (v22 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
                  && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
                {
                  v68 = *v14;
                  v65 = v21;
                  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v68);
                  if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65))
                  {
                    mlir::IntegerAttr::getValue(&v68, (llvm::APInt *)&v74);
                    mlir::IntegerAttr::getValue(&v65, (llvm::APInt *)&v71);
                    v24 = v75;
                    DWORD2(v85) = v75;
                    if (v75 > 0x40)
                    {
                      llvm::APInt::initSlowCase((llvm::APInt *)&v85, &v74);
                      v24 = DWORD2(v85);
                      v25 = (const void *)v85;
                    }
                    else
                    {
                      v25 = v74;
                      *(_QWORD *)&v85 = v74;
                    }
                    DWORD2(v87) = v24;
                    *(_QWORD *)&v87 = v25;
                    DWORD2(v85) = 0;
                    llvm::APInt::operator+=((uint64_t)&v87, &v71);
                    LOBYTE(v88[0]) = 1;
                    if (DWORD2(v85) >= 0x41 && (_QWORD)v85)
                      MEMORY[0x20BD002D4](v85, 0x1000C8000313F17);
                    if (v72 >= 0x41 && v71)
                      MEMORY[0x20BD002D4](v71, 0x1000C8000313F17);
                    if (v75 >= 0x41 && v74)
                      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
                    v16 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v87);
                    if (!LOBYTE(v88[0]))
                      return v16 & 0xFFFFFFFFFFFFFFFBLL;
                    goto LABEL_84;
                  }
                }
                else
                {
                  if (mlir::DenseElementsAttr::classof(*v14))
                    v26 = v20;
                  else
                    v26 = 0;
                  *(_QWORD *)&v87 = v26;
                  if (v26
                    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v87)
                    && ((v27 = v14[1], !mlir::DenseElementsAttr::classof(v27)) ? (v28 = 0) : (v28 = v27),
                        (*(_QWORD *)&v87 = v28) != 0
                     && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v87)))
                  {
                    v29 = v14[1];
                    v68 = *v14;
                    v65 = v29;
                    v30 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68);
                    if (v30 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65))
                    {
                      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v68, (uint64_t)&v87);
                      v85 = v87;
                      v86 = v88[0];
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v85, (llvm::APInt *)&v74);
                      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v65, (uint64_t)&v87);
                      v85 = v87;
                      v86 = v88[0];
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v85, (llvm::APInt *)&v71);
                      v31 = v75;
                      DWORD2(v85) = v75;
                      if (v75 > 0x40)
                      {
                        llvm::APInt::initSlowCase((llvm::APInt *)&v85, &v74);
                        v31 = DWORD2(v85);
                        v32 = (const void *)v85;
                      }
                      else
                      {
                        v32 = v74;
                        *(_QWORD *)&v85 = v74;
                      }
                      DWORD2(v87) = v31;
                      *(_QWORD *)&v87 = v32;
                      DWORD2(v85) = 0;
                      llvm::APInt::operator+=((uint64_t)&v87, &v71);
                      LOBYTE(v88[0]) = 1;
                      if (DWORD2(v85) >= 0x41 && (_QWORD)v85)
                        MEMORY[0x20BD002D4](v85, 0x1000C8000313F17);
                      if (v72 >= 0x41 && v71)
                        MEMORY[0x20BD002D4](v71, 0x1000C8000313F17);
                      if (v75 >= 0x41 && v74)
                        MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
                      v60 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                      v16 = mlir::DenseElementsAttr::get(canMapOperands, v60, (llvm::APInt *)&v87, 1);
                      if (!LOBYTE(v88[0]))
                        return v16 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_84:
                      if (DWORD2(v87) >= 0x41)
                      {
                        if ((_QWORD)v87)
                          MEMORY[0x20BD002D4](v87, 0x1000C8000313F17);
                      }
                      return v16 & 0xFFFFFFFFFFFFFFFBLL;
                    }
                  }
                  else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v14 + 8)
                         && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v14[1] + 8))
                  {
                    v33 = (_QWORD *)*v14;
                    v34 = *v14 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v33 + 8) : 0;
                    v79 = v33;
                    v80 = v34;
                    v35 = (_QWORD *)v14[1];
                    v36 = v35 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v35 + 8) : 0;
                    v78[0] = v35;
                    v78[1] = v36;
                    Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
                    if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v78))
                    {
                      mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v79, (uint64_t)&v85);
                      mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v78, (uint64_t)&v74);
                      v16 = 0;
                      v38 = v77;
                      if (BYTE8(v86) && v77)
                      {
                        LOWORD(v71) = v85;
                        if ((_BYTE)v85)
                          v72 = *((_QWORD *)&v85 + 1);
                        else
                          (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v85 + 1) + 16))(&v72);
                        v73 = v86;
                        LOWORD(v68) = (_WORD)v74;
                        if ((_BYTE)v74)
                          v69 = v75;
                        else
                          (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v75 + 16))(&v69);
                        v70 = v76;
                        *(_QWORD *)&v87 = v88;
                        *((_QWORD *)&v87 + 1) = 0x400000000;
                        NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v79, v80);
                        llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v87, NumElements);
                        v40 = mlir::ElementsAttr::getNumElements((uint64_t)v79, v80);
                        if (v40)
                        {
                          v41 = v40;
                          v42 = v73;
                          while (1)
                          {
                            if (BYTE1(v71))
                              v43 = 0;
                            else
                              v43 = v42;
                            if ((_BYTE)v71)
                            {
                              v44 = v72 + 16 * v43;
                              v64 = *(_DWORD *)(v44 + 8);
                              if (v64 > 0x40)
                                llvm::APInt::initSlowCase((llvm::APInt *)&v63, (const void **)v44);
                              else
                                v63 = *(const void **)v44;
                            }
                            else
                            {
                              (*(void (**)(const void **__return_ptr))(*(_QWORD *)v72 + 24))(&v63);
                            }
                            if (BYTE1(v68))
                              v45 = 0;
                            else
                              v45 = v70;
                            if ((_BYTE)v68)
                            {
                              v46 = v69 + 16 * v45;
                              v62 = *(_DWORD *)(v46 + 8);
                              if (v62 > 0x40)
                                llvm::APInt::initSlowCase((llvm::APInt *)&v61, (const void **)v46);
                              else
                                v61 = *(_QWORD **)v46;
                            }
                            else
                            {
                              (*(void (**)(_QWORD **__return_ptr))(*(_QWORD *)v69 + 24))(&v61);
                            }
                            v47 = v64;
                            v82 = v64;
                            if (v64 > 0x40)
                            {
                              llvm::APInt::initSlowCase((llvm::APInt *)&v81, &v63);
                              v47 = v82;
                              v48 = v81;
                            }
                            else
                            {
                              v48 = (uint64_t)v63;
                              v81 = (uint64_t)v63;
                            }
                            v84 = v47;
                            v83 = v48;
                            v82 = 0;
                            llvm::APInt::operator+=((uint64_t)&v83, &v61);
                            v66 = v84;
                            v65 = v83;
                            v67 = 1;
                            if (v82 >= 0x41 && v81)
                              MEMORY[0x20BD002D4](v81, 0x1000C8000313F17);
                            if (v62 >= 0x41 && v61)
                              MEMORY[0x20BD002D4](v61, 0x1000C8000313F17);
                            if (v64 >= 0x41 && v63)
                              MEMORY[0x20BD002D4](v63, 0x1000C8000313F17);
                            if (!v67)
                              break;
                            Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v87, (unint64_t)&v65, 1);
                            v50 = (llvm::APInt *)(v87 + 16 * DWORD2(v87));
                            v51 = *((_DWORD *)Address + 2);
                            *((_DWORD *)v50 + 2) = v51;
                            if (v51 > 0x40)
                              llvm::APInt::initSlowCase(v50, (const void **)Address);
                            else
                              *(_QWORD *)v50 = *(_QWORD *)Address;
                            ++DWORD2(v87);
                            if (v67 && v66 >= 0x41 && v65)
                              MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
                            v42 = ++v73;
                            ++v70;
                            if (!--v41)
                              goto LABEL_141;
                          }
                          v16 = 0;
                        }
                        else
                        {
LABEL_141:
                          v52 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                          v16 = mlir::DenseElementsAttr::get(canMapOperands, v52, (llvm::APInt *)v87, DWORD2(v87));
                        }
                        v53 = (char *)v87;
                        if (DWORD2(v87))
                        {
                          v54 = 16 * DWORD2(v87);
                          do
                          {
                            if (*(_DWORD *)&v53[v54 - 8] >= 0x41u)
                            {
                              v55 = *(_QWORD *)&v53[v54 - 16];
                              if (v55)
                                MEMORY[0x20BD002D4](v55, 0x1000C8000313F17);
                            }
                            v54 -= 16;
                          }
                          while (v54);
                          v53 = (char *)v87;
                        }
                        if (v53 != (char *)v88)
                          free(v53);
                        if (!(_BYTE)v68)
                        {
                          v56 = v69;
                          v69 = 0;
                          if (v56)
                            (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
                        }
                        if (!(_BYTE)v71)
                        {
                          v57 = v72;
                          v72 = 0;
                          if (v57)
                            (*(void (**)(uint64_t))(*(_QWORD *)v57 + 8))(v57);
                        }
                        v38 = v77;
                      }
                      if (v38)
                      {
                        if (!(_BYTE)v74)
                        {
                          v58 = v75;
                          v75 = 0;
                          if (v58)
                            (*(void (**)(uint64_t))(*(_QWORD *)v58 + 8))(v58);
                        }
                      }
                      if (BYTE8(v86))
                      {
                        if (!(_BYTE)v85)
                        {
                          v59 = *((_QWORD *)&v85 + 1);
                          *((_QWORD *)&v85 + 1) = 0;
                          if (v59)
                            (*(void (**)(uint64_t))(*(_QWORD *)v59 + 8))(v59);
                        }
                      }
                      return v16 & 0xFFFFFFFFFFFFFFFBLL;
                    }
                  }
                }
              }
              v16 = 0;
            }
          }
        }
        else
        {
          v16 = 0;
          v87 = 0uLL;
        }
      }
      else
      {
        v87 = 0uLL;
      }
    }
  }
  return v16 & 0xFFFFFFFFFFFFFFFBLL;
}

void mlir::arith::AddIOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  uint64_t *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  __int16 v174;
  __int128 v175;
  __int128 v176;
  uint64_t v177;

  v177 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 2);
  v175 = xmmword_24C0609E0;
  v176 = *(_OWORD *)&off_24C0609F0;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.addi", 10, v174, a2, &v175, 2uLL);
  *(_QWORD *)v4 = &off_24C028870;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  *(_QWORD *)&v175 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::AddIAddConstant]";
  *((_QWORD *)&v175 + 1) = 88;
  v9 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v175 + 1) >= v9)
    v10 = v9;
  else
    v10 = *((_QWORD *)&v175 + 1);
  v11 = v175 + v10;
  v12 = *((_QWORD *)&v175 + 1) - v10;
  if (*((_QWORD *)&v175 + 1) - v10 >= 0x12)
    v13 = 18;
  else
    v13 = *((_QWORD *)&v175 + 1) - v10;
  v14 = v11 + v13;
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_192;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_193;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_196;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_196:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 2);
  v175 = xmmword_24C0609E0;
  v176 = *(_OWORD *)&off_24C0609F0;
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"arith.addi", 10, v174, a2, &v175, 2uLL);
  *(_QWORD *)v38 = &off_24C029508;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  *(_QWORD *)&v175 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::AddISubConstantRHS]";
  *((_QWORD *)&v175 + 1) = 91;
  v43 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v175 + 1) >= v43)
    v44 = v43;
  else
    v44 = *((_QWORD *)&v175 + 1);
  v45 = v175 + v44;
  v46 = *((_QWORD *)&v175 + 1) - v44;
  if (*((_QWORD *)&v175 + 1) - v44 >= 0x12)
    v47 = 18;
  else
    v47 = *((_QWORD *)&v175 + 1) - v44;
  v48 = v45 + v47;
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_192;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_193;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_197;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_197:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 2);
  v175 = xmmword_24C060A00;
  v176 = *(_OWORD *)&off_24C060A10;
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"arith.addi", 10, v174, a2, &v175, 2uLL);
  *(_QWORD *)v72 = &off_24C0294C8;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  *(_QWORD *)&v175 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::AddISubConstantLHS]";
  *((_QWORD *)&v175 + 1) = 91;
  v77 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v175 + 1) >= v77)
    v78 = v77;
  else
    v78 = *((_QWORD *)&v175 + 1);
  v79 = v175 + v78;
  v80 = *((_QWORD *)&v175 + 1) - v78;
  if (*((_QWORD *)&v175 + 1) - v78 >= 0x12)
    v81 = 18;
  else
    v81 = *((_QWORD *)&v175 + 1) - v78;
  v82 = v79 + v81;
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_192;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_193;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_198;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_198:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 2);
  *(_QWORD *)&v175 = "arith.subi";
  *((_QWORD *)&v175 + 1) = 10;
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"arith.addi", 10, v174, a2, &v175, 1uLL);
  *(_QWORD *)v106 = &off_24C029DB8;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  *(_QWORD *)&v175 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::AddIMulNegativeOneRhs]";
  *((_QWORD *)&v175 + 1) = 94;
  v111 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v175 + 1) >= v111)
    v112 = v111;
  else
    v112 = *((_QWORD *)&v175 + 1);
  v113 = v175 + v112;
  v114 = *((_QWORD *)&v175 + 1) - v112;
  if (*((_QWORD *)&v175 + 1) - v112 >= 0x12)
    v115 = 18;
  else
    v115 = *((_QWORD *)&v175 + 1) - v112;
  v116 = v113 + v115;
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
    goto LABEL_192;
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (v122)
  {
    if (v122 >> 61)
      goto LABEL_193;
    v123 = (char *)operator new(8 * v122);
    v124 = (uint64_t *)&v123[8 * v119];
    v125 = &v123[8 * v122];
    *v124 = v106;
    v110 = (uint64_t)(v124 + 1);
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
  }
  else
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_199;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v109[-v129];
      v124 = (uint64_t *)((char *)v124 - v129);
      v131 = &v123[8 * v119 - 16];
      v132 = v109 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_199:
        do
        {
          v136 = *((_QWORD *)v109 - 1);
          v109 -= 8;
          *(_QWORD *)v109 = 0;
          *--v124 = v136;
        }
        while (v109 != v118);
      }
      v109 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
  v140 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v174, 2);
  *(_QWORD *)&v175 = "arith.subi";
  *((_QWORD *)&v175 + 1) = 10;
  mlir::Pattern::Pattern(v140 + 8, (uint64_t)"arith.addi", 10, v174, a2, &v175, 1uLL);
  *(_QWORD *)v140 = &off_24C029D78;
  if (*(_QWORD *)(v140 + 72))
  {
    v141 = *(unsigned int *)(v140 + 88);
    if (v141 <= *(_DWORD *)(v140 + 92))
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v140 + 80, (void *)(v140 + 96), v141, 16);
    *(_DWORD *)(v140 + 88) = *(_DWORD *)(v140 + 88);
    v143 = (char *)a1[2];
    v142 = a1[3];
    if ((unint64_t)v143 < v142)
      goto LABEL_156;
    goto LABEL_167;
  }
  *(_QWORD *)&v175 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::AddIMulNegativeOneLhs]";
  *((_QWORD *)&v175 + 1) = 94;
  v145 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v175 + 1) >= v145)
    v146 = v145;
  else
    v146 = *((_QWORD *)&v175 + 1);
  v147 = v175 + v146;
  v148 = *((_QWORD *)&v175 + 1) - v146;
  if (*((_QWORD *)&v175 + 1) - v146 >= 0x12)
    v149 = 18;
  else
    v149 = *((_QWORD *)&v175 + 1) - v146;
  v150 = v147 + v149;
  v151 = v148 - v149;
  if (v151 >= v151 - 1)
    --v151;
  *(_QWORD *)(v140 + 64) = v150;
  *(_QWORD *)(v140 + 72) = v151;
  v141 = *(unsigned int *)(v140 + 88);
  if (v141 > *(_DWORD *)(v140 + 92))
    goto LABEL_166;
LABEL_155:
  *(_DWORD *)(v140 + 88) = v141;
  v143 = (char *)a1[2];
  v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(_QWORD *)v143 = v140;
    v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v152 = (char *)a1[1];
  v153 = (v143 - v152) >> 3;
  v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61)
LABEL_192:
    abort();
  v155 = v142 - (_QWORD)v152;
  if (v155 >> 2 > v154)
    v154 = v155 >> 2;
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8)
    v156 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v156 = v154;
  if (!v156)
  {
    v157 = 0;
    v158 = (uint64_t *)(8 * v153);
    v159 = 0;
    *(_QWORD *)(8 * v153) = v140;
    v144 = 8 * v153 + 8;
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
      goto LABEL_176;
    goto LABEL_188;
  }
  if (v156 >> 61)
LABEL_193:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v157 = (char *)operator new(8 * v156);
  v158 = (uint64_t *)&v157[8 * v153];
  v159 = &v157[8 * v156];
  *v158 = v140;
  v144 = (uint64_t)(v158 + 1);
  v160 = (char *)(v143 - v152);
  if (v143 != v152)
  {
LABEL_176:
    v161 = (unint64_t)(v160 - 8);
    if (v161 < 0x78
      || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v158
      && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
    {
      goto LABEL_200;
    }
    v162 = (v161 >> 3) + 1;
    v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
    v164 = &v143[-v163];
    v158 = (uint64_t *)((char *)v158 - v163);
    v165 = &v157[8 * v153 - 16];
    v166 = v143 - 16;
    v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v169 = *((_OWORD *)v166 - 1);
      v168 = *(_OWORD *)v166;
      *((_OWORD *)v166 - 1) = 0uLL;
      *(_OWORD *)v166 = 0uLL;
      *((_OWORD *)v165 - 1) = v169;
      *(_OWORD *)v165 = v168;
      v165 -= 32;
      v166 -= 32;
      v167 -= 4;
    }
    while (v167);
    v143 = v164;
    if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_200:
      do
      {
        v170 = *((_QWORD *)v143 - 1);
        v143 -= 8;
        *(_QWORD *)v143 = 0;
        *--v158 = v170;
      }
      while (v143 != v152);
    }
    v143 = (char *)a1[1];
    v171 = (char *)a1[2];
    a1[1] = v158;
    a1[2] = v144;
    a1[3] = v159;
    while (v171 != v143)
    {
      v173 = *((_QWORD *)v171 - 1);
      v171 -= 8;
      v172 = v173;
      *(_QWORD *)v171 = 0;
      if (v173)
        (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
    }
    goto LABEL_189;
  }
LABEL_188:
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143)
    operator delete(v143);
LABEL_191:
  a1[2] = v144;
}

void mlir::arith::AddUIExtendedOp::getShapeForUnroll(mlir::arith::AddUIExtendedOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  const void *Value;
  unint64_t v6;
  size_t v7;
  int v8;
  _QWORD *v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[5];

  v16[4] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(*(_QWORD *)this - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v3 + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    v3 = 0;
  v13 = v3;
  if (!v3)
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 48) = 0;
    return;
  }
  Value = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v13);
  v6 = v4;
  v14 = v16;
  v15 = 0x400000000;
  v7 = 8 * v4;
  if (8 * v4 < 0x21)
  {
    v8 = 0;
    v9 = v16;
    if (!v4)
      goto LABEL_10;
    goto LABEL_9;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v4, 8);
  v8 = v15;
  v9 = v14;
  if (v6)
  {
LABEL_9:
    memcpy(&v9[v8], Value, v7);
    v8 = v15;
    v9 = v14;
  }
LABEL_10:
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x400000000;
  v10 = (v8 + v6);
  LODWORD(v15) = v10;
  if ((_DWORD)v10 && &v14 != (void **)a2)
  {
    if (v9 == v16)
    {
      v12 = v10;
      v9 = v16;
      if (v10 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v10, 8),
            v12 = v15,
            v9 = v14,
            (_DWORD)v15))
      {
        memcpy(*(void **)a2, v9, 8 * v12);
        v9 = v14;
      }
      *(_DWORD *)(a2 + 8) = v10;
    }
    else
    {
      *(_QWORD *)a2 = v9;
      v11 = HIDWORD(v15);
      *(_DWORD *)(a2 + 8) = v10;
      *(_DWORD *)(a2 + 12) = v11;
      v14 = v16;
      HIDWORD(v15) = 0;
      v9 = v16;
    }
    LODWORD(v15) = 0;
  }
  *(_BYTE *)(a2 + 48) = 1;
  if (v9 != v16)
    free(v9);
}

uint64_t mlir::arith::AddUIExtendedOp::fold(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  uint64_t v9;
  mlir::Operation *DefiningOp;
  unint64_t ZeroAttr;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t result;
  uint64_t *v18;
  void (*v19)(char **__return_ptr, uint64_t *, uint64_t *);
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *canMapOperands;
  _QWORD *I1SameShape;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t Value;
  unsigned int v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  const void *v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t Type;
  int v46;
  unint64_t NumElements;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  const void *v56;
  char *Address;
  llvm::APInt *v58;
  unsigned int v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  unsigned int v70;
  const void *v71;
  unsigned int v72;
  const void *v73;
  unsigned int v74;
  char v75;
  __int16 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t (*v82)@<X0>(const llvm::APInt *@<X0>, const llvm::APInt *@<X1>, uint64_t@<X8>);
  uint64_t v83;
  uint64_t v84;
  unsigned __int8 v85;
  _QWORD v86[2];
  _QWORD *v87;
  uint64_t v88;
  _QWORD *v89;
  unsigned int v90;
  const void *v91;
  unsigned int v92;
  _QWORD *v93;
  unsigned int v94;
  const void *v95;
  unsigned int v96;
  const void *v97;
  unsigned int v98;
  const void *v99;
  unsigned int v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  _OWORD v104[4];
  uint64_t v105;

  v105 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(*(_QWORD *)a1 + 36))
    v6 = *(_QWORD *)a1 - 16;
  else
    v6 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 1);
  v8 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0) + 8);
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 56);
  *(_QWORD *)&v101 = mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  *(_QWORD *)&v103 = v9;
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v103);
  if (!DefiningOp
    || !mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(uint64_t *))&v101, DefiningOp))
  {
    v18 = *(uint64_t **)(a2 + 40);
    v19 = (void (*)(char **__return_ptr, uint64_t *, uint64_t *))*v18;
    if (*v18 && *(_UNKNOWN **)(*(_QWORD *)v19 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      v20 = *v18;
      goto LABEL_21;
    }
    v20 = v18[1];
    if (v20 && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
LABEL_21:
      *(_QWORD *)&v103 = v20;
      *((_QWORD *)&v103 + 1) = **(_QWORD **)(a2 + 40);
      v24 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v20 + 8);
      *(_QWORD *)&v101 = v20;
      *((_QWORD *)&v101 + 1) = v24;
      canMapOperands = (_QWORD *)mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v101);
      I1SameShape = (_QWORD *)getI1SameShape(canMapOperands);
      v82 = calculateUnsignedOverflow;
      result = mlir::constFoldBinaryOpConditional<mlir::IntegerAttr,llvm::APInt,void,mlir::Attribute mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,void,llvm::APInt (&)(llvm::APInt const&,llvm::APInt const&)>(llvm::ArrayRef<mlir::Attribute>,mlir::Type,llvm::APInt (&)(llvm::APInt const&,llvm::APInt const&) &&)::{lambda(llvm::APInt,llvm::APInt)#1}>((uint64_t *)&v103, 2, I1SameShape, (void (**)(char **__return_ptr, uint64_t *, uint64_t *))&v82);
      if (!result)
        return result;
      ZeroAttr = result;
      v12 = v20 & 0xFFFFFFFFFFFFFFFBLL;
      v13 = *(unsigned int *)(a3 + 8);
      if (v13 < *(_DWORD *)(a3 + 12))
        goto LABEL_7;
      goto LABEL_23;
    }
    if (v19)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v19 + 8))
      {
        v21 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v19 + 8);
        *(_QWORD *)&v103 = v19;
        *((_QWORD *)&v103 + 1) = v21;
        v19 = (void (*)(char **__return_ptr, uint64_t *, uint64_t *))mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v103);
      }
      else
      {
        v19 = 0;
        v103 = 0uLL;
      }
    }
    else
    {
      v103 = 0uLL;
    }
    v22 = (_QWORD *)v18[1];
    if (v22)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v22 + 8))
      {
        v23 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v22 + 8);
        *(_QWORD *)&v103 = v22;
        *((_QWORD *)&v103 + 1) = v23;
        v27 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v103);
        result = 0;
        if (!v19 || !v27 || v19 != (void (*)(char **__return_ptr, uint64_t *, uint64_t *))v27)
          return result;
        v20 = *v18;
        if (*v18
          && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          goto LABEL_21;
        }
        v28 = v18[1];
        if (v28)
        {
          v29 = *(void **)(*(_QWORD *)v28 + 136);
          if (v29 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            v30 = v18[1];
          else
            v30 = 0;
          if (!v20 || v29 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            goto LABEL_81;
          if (v29 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
            && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          {
            v82 = (uint64_t (*)@<X0>(const llvm::APInt *@<X0>, const llvm::APInt *@<X1>, uint64_t@<X8>))*v18;
            v79 = v28;
            Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v82);
            if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v79))
            {
              mlir::IntegerAttr::getValue(&v82, (llvm::APInt *)&v95);
              mlir::IntegerAttr::getValue(&v79, (llvm::APInt *)&v93);
              v32 = v96;
              DWORD2(v101) = v96;
              if (v96 > 0x40)
              {
                llvm::APInt::initSlowCase((llvm::APInt *)&v101, &v95);
                v32 = DWORD2(v101);
                v33 = (const void *)v101;
              }
              else
              {
                v33 = v95;
                *(_QWORD *)&v101 = v95;
              }
              DWORD2(v103) = v32;
              *(_QWORD *)&v103 = v33;
              DWORD2(v101) = 0;
              llvm::APInt::operator+=((uint64_t)&v103, &v93);
              LOBYTE(v104[0]) = 1;
              if (DWORD2(v101) >= 0x41 && (_QWORD)v101)
                MEMORY[0x20BD002D4](v101, 0x1000C8000313F17);
              if (v94 >= 0x41 && v93)
                MEMORY[0x20BD002D4](v93, 0x1000C8000313F17);
              if (v96 >= 0x41 && v95)
                MEMORY[0x20BD002D4](v95, 0x1000C8000313F17);
              v30 = mlir::IntegerAttr::get((uint64_t)v19, (llvm::APInt *)&v103);
              if (LOBYTE(v104[0]))
              {
LABEL_72:
                if (DWORD2(v103) >= 0x41 && (_QWORD)v103)
                  MEMORY[0x20BD002D4](v103, 0x1000C8000313F17);
              }
LABEL_81:
              v20 = v30;
              if (!v30)
                return 0;
              goto LABEL_21;
            }
          }
          else
          {
            if (mlir::DenseElementsAttr::classof(*v18))
              v34 = v20;
            else
              v34 = 0;
            *(_QWORD *)&v103 = v34;
            if (v34
              && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v103)
              && ((v35 = v18[1], !mlir::DenseElementsAttr::classof(v35)) ? (v36 = 0) : (v36 = v35),
                  (*(_QWORD *)&v103 = v36) != 0
               && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v103)))
            {
              v37 = v18[1];
              v82 = (uint64_t (*)@<X0>(const llvm::APInt *@<X0>, const llvm::APInt *@<X1>, uint64_t@<X8>))*v18;
              v79 = v37;
              v38 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v82);
              if (v38 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v79))
              {
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v82, (uint64_t)&v103);
                v101 = v103;
                v102 = v104[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&v91);
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v79, (uint64_t)&v103);
                v101 = v103;
                v102 = v104[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&v89);
                v39 = v92;
                DWORD2(v101) = v92;
                if (v92 > 0x40)
                {
                  llvm::APInt::initSlowCase((llvm::APInt *)&v101, &v91);
                  v39 = DWORD2(v101);
                  v40 = (const void *)v101;
                }
                else
                {
                  v40 = v91;
                  *(_QWORD *)&v101 = v91;
                }
                DWORD2(v103) = v39;
                *(_QWORD *)&v103 = v40;
                DWORD2(v101) = 0;
                llvm::APInt::operator+=((uint64_t)&v103, &v89);
                LOBYTE(v104[0]) = 1;
                if (DWORD2(v101) >= 0x41 && (_QWORD)v101)
                  MEMORY[0x20BD002D4](v101, 0x1000C8000313F17);
                if (v90 >= 0x41 && v89)
                  MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
                if (v92 >= 0x41 && v91)
                  MEMORY[0x20BD002D4](v91, 0x1000C8000313F17);
                v68 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v19 + 8);
                v30 = mlir::DenseElementsAttr::get((uint64_t)v19, v68, (llvm::APInt *)&v103, 1);
                if (LOBYTE(v104[0]))
                  goto LABEL_72;
                goto LABEL_81;
              }
            }
            else
            {
              if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v18 + 8)
                || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v18[1] + 8))
              {
                return 0;
              }
              v41 = (_QWORD *)*v18;
              if (*v18)
                v42 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v41 + 8);
              else
                v42 = 0;
              v87 = v41;
              v88 = v42;
              v43 = (_QWORD *)v18[1];
              if (v43)
                v44 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v43 + 8);
              else
                v44 = 0;
              v86[0] = v43;
              v86[1] = v44;
              Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v87);
              if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v86))
              {
                mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v87, (uint64_t)&v101);
                mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v86, (uint64_t)&v82);
                v30 = 0;
                v46 = v85;
                if (BYTE8(v102) && v85)
                {
                  LOWORD(v79) = v101;
                  if ((_BYTE)v101)
                    v80 = *((_QWORD *)&v101 + 1);
                  else
                    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v101 + 1) + 16))(&v80);
                  v81 = v102;
                  v76 = (__int16)v82;
                  if ((_BYTE)v82)
                    v77 = v83;
                  else
                    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v83 + 16))(&v77);
                  v78 = v84;
                  *(_QWORD *)&v103 = v104;
                  *((_QWORD *)&v103 + 1) = 0x400000000;
                  NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v87, v88);
                  llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v103, NumElements);
                  v48 = mlir::ElementsAttr::getNumElements((uint64_t)v87, v88);
                  if (v48)
                  {
                    v49 = v48;
                    v50 = v81;
                    while (1)
                    {
                      if (BYTE1(v79))
                        v51 = 0;
                      else
                        v51 = v50;
                      if ((_BYTE)v79)
                      {
                        v52 = v80 + 16 * v51;
                        v72 = *(_DWORD *)(v52 + 8);
                        if (v72 > 0x40)
                          llvm::APInt::initSlowCase((llvm::APInt *)&v71, (const void **)v52);
                        else
                          v71 = *(const void **)v52;
                      }
                      else
                      {
                        (*(void (**)(const void **__return_ptr))(*(_QWORD *)v80 + 24))(&v71);
                      }
                      if (HIBYTE(v76))
                        v53 = 0;
                      else
                        v53 = v78;
                      if ((_BYTE)v76)
                      {
                        v54 = v77 + 16 * v53;
                        v70 = *(_DWORD *)(v54 + 8);
                        if (v70 > 0x40)
                          llvm::APInt::initSlowCase((llvm::APInt *)&v69, (const void **)v54);
                        else
                          v69 = *(_QWORD **)v54;
                      }
                      else
                      {
                        (*(void (**)(_QWORD **__return_ptr))(*(_QWORD *)v77 + 24))(&v69);
                      }
                      v55 = v72;
                      v98 = v72;
                      if (v72 > 0x40)
                      {
                        llvm::APInt::initSlowCase((llvm::APInt *)&v97, &v71);
                        v55 = v98;
                        v56 = v97;
                      }
                      else
                      {
                        v56 = v71;
                        v97 = v71;
                      }
                      v100 = v55;
                      v99 = v56;
                      v98 = 0;
                      llvm::APInt::operator+=((uint64_t)&v99, &v69);
                      v74 = v100;
                      v73 = v99;
                      v75 = 1;
                      if (v98 >= 0x41 && v97)
                        MEMORY[0x20BD002D4](v97, 0x1000C8000313F17);
                      if (v70 >= 0x41 && v69)
                        MEMORY[0x20BD002D4](v69, 0x1000C8000313F17);
                      if (v72 >= 0x41 && v71)
                        MEMORY[0x20BD002D4](v71, 0x1000C8000313F17);
                      if (!v75)
                        break;
                      Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v103, (unint64_t)&v73, 1);
                      v58 = (llvm::APInt *)(v103 + 16 * DWORD2(v103));
                      v59 = *((_DWORD *)Address + 2);
                      *((_DWORD *)v58 + 2) = v59;
                      if (v59 > 0x40)
                        llvm::APInt::initSlowCase(v58, (const void **)Address);
                      else
                        *(_QWORD *)v58 = *(_QWORD *)Address;
                      ++DWORD2(v103);
                      if (v75 && v74 >= 0x41 && v73)
                        MEMORY[0x20BD002D4](v73, 0x1000C8000313F17);
                      v50 = ++v81;
                      ++v78;
                      if (!--v49)
                        goto LABEL_131;
                    }
                    v30 = 0;
                  }
                  else
                  {
LABEL_131:
                    v60 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v19 + 8);
                    v30 = mlir::DenseElementsAttr::get((uint64_t)v19, v60, (llvm::APInt *)v103, DWORD2(v103));
                  }
                  v61 = (char *)v103;
                  if (DWORD2(v103))
                  {
                    v62 = 16 * DWORD2(v103);
                    do
                    {
                      if (*(_DWORD *)&v61[v62 - 8] >= 0x41u)
                      {
                        v63 = *(_QWORD *)&v61[v62 - 16];
                        if (v63)
                          MEMORY[0x20BD002D4](v63, 0x1000C8000313F17);
                      }
                      v62 -= 16;
                    }
                    while (v62);
                    v61 = (char *)v103;
                  }
                  if (v61 != (char *)v104)
                    free(v61);
                  if (!(_BYTE)v76)
                  {
                    v64 = v77;
                    v77 = 0;
                    if (v64)
                      (*(void (**)(uint64_t))(*(_QWORD *)v64 + 8))(v64);
                  }
                  if (!(_BYTE)v79)
                  {
                    v65 = v80;
                    v80 = 0;
                    if (v65)
                      (*(void (**)(uint64_t))(*(_QWORD *)v65 + 8))(v65);
                  }
                  v46 = v85;
                }
                if (v46)
                {
                  if (!(_BYTE)v82)
                  {
                    v66 = v83;
                    v83 = 0;
                    if (v66)
                      (*(void (**)(uint64_t))(*(_QWORD *)v66 + 8))(v66);
                  }
                }
                if (BYTE8(v102))
                {
                  if (!(_BYTE)v101)
                  {
                    v67 = *((_QWORD *)&v101 + 1);
                    *((_QWORD *)&v101 + 1) = 0;
                    if (v67)
                      (*(void (**)(uint64_t))(*(_QWORD *)v67 + 8))(v67);
                  }
                }
                goto LABEL_81;
              }
            }
          }
          v30 = 0;
          goto LABEL_81;
        }
      }
      else
      {
        v103 = 0uLL;
      }
    }
    else
    {
      v103 = 0uLL;
    }
    return 0;
  }
  *(_QWORD *)&v103 = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
  ZeroAttr = (unint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v103, (mlir::MLIRContext *)(v8 & 0xFFFFFFFFFFFFFFF8));
  v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
  v13 = *(unsigned int *)(a3 + 8);
  if (v13 >= *(_DWORD *)(a3 + 12))
  {
LABEL_23:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a3 + 8);
  }
LABEL_7:
  *(_QWORD *)(*(_QWORD *)a3 + 8 * v13) = v12;
  v14 = *(_DWORD *)(a3 + 12);
  v15 = (*(_DWORD *)(a3 + 8) + 1);
  *(_DWORD *)(a3 + 8) = v15;
  v16 = ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
  if (v15 >= v14)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a3 + 8 * v15) = v16;
  ++*(_DWORD *)(a3 + 8);
  return 1;
}

uint64_t getI1SameShape(_QWORD *a1)
{
  uint64_t Context;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  __int128 v6;
  char v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = a1;
  Context = mlir::Attribute::getContext((mlir::Attribute *)&v10);
  v2 = mlir::IntegerType::get(Context, 1u, 0);
  v3 = v10;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v10 + 8))
  {
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
    v8 = v3;
    v9 = v4;
    if (v3)
    {
      LOBYTE(v6) = 0;
      v7 = 0;
      return mlir::ShapedType::cloneWith((uint64_t *)&v8, &v6, v2);
    }
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  if (*(_UNKNOWN **)(*v10 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    return mlir::UnrankedTensorType::get(v2);
  else
    return v2;
}

uint64_t calculateUnsignedOverflow@<X0>(const llvm::APInt *a1@<X0>, const llvm::APInt *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;

  result = llvm::APInt::compare(a1, a2);
  *(_DWORD *)(a3 + 8) = 1;
  *(_QWORD *)a3 = result >> 31;
  return result;
}

void mlir::arith::AddUIExtendedOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  unint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  v39 = "arith.addi";
  v40 = 10;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.addui_extended", 20, v38, a2, &v39, 1uLL);
  *(_QWORD *)v4 = &off_24C029848;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v39 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::AddUIExtendedToAddI]";
  v40 = 92;
  v9 = llvm::StringRef::find((uint64_t *)&v39, "DesiredTypeName = ", 0x12uLL, 0);
  if (v40 >= v9)
    v10 = v9;
  else
    v10 = v40;
  v11 = &v39[v10];
  v12 = v40 - v10;
  if (v40 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v40 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::arith::SubIOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t DefiningOp;
  uint64_t *v14;
  uint64_t canMapOperands;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t Value;
  int v28;
  const void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  const void *v36;
  _QWORD *v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t Type;
  int v42;
  unint64_t NumElements;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  char *Address;
  llvm::APInt *v54;
  unsigned int v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  unsigned int v66;
  const void *v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  const void *v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 v81;
  _QWORD v82[2];
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  unsigned int v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  _OWORD v92[4];
  uint64_t v93;

  v93 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(*a1 + 72);
  v4 = *(_QWORD *)(v3 + 24);
  if (v4 == *(_QWORD *)(v3 + 56))
  {
    *(_QWORD *)&v91 = mlir::Attribute::getContext((mlir::Attribute *)(*a1 + 24));
    return (unint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v91, (mlir::MLIRContext *)(*(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8)) & 0xFFFFFFFFFFFFFFFBLL;
  }
  v6 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  if (!v6)
    goto LABEL_13;
  DWORD2(v91) = 1;
  *(_QWORD *)&v91 = 0;
  *(_QWORD *)&v89 = &v91;
  v7 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v89, v6);
  v8 = DWORD2(v91);
  if (!v7)
  {
    v9 = 0;
    if (DWORD2(v91) < 0x41)
      goto LABEL_10;
    goto LABEL_8;
  }
  if (DWORD2(v91) >= 0x41)
  {
    if (v8 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v91) >= 0x41)
    {
      v9 = 0;
      v11 = v91;
      if (!(_QWORD)v91)
        goto LABEL_10;
      goto LABEL_9;
    }
    v9 = *(_QWORD *)v91 == 0;
LABEL_8:
    v11 = v91;
    if (!(_QWORD)v91)
      goto LABEL_10;
LABEL_9:
    MEMORY[0x20BD002D4](v11, 0x1000C8000313F17);
    goto LABEL_10;
  }
  v9 = (_QWORD)v91 == 0;
LABEL_10:
  v12 = *a1;
  if (v9)
    return *(_QWORD *)(*(_QWORD *)(v12 + 72) + 24) | 4;
  v4 = *(_QWORD *)(*(_QWORD *)(v12 + 72) + 24);
LABEL_13:
  *(_QWORD *)&v91 = v4;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v91);
  if (DefiningOp
    && *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::AddIOp,void>::id)
  {
    v19 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 56);
    v20 = *(_QWORD *)(DefiningOp + 72);
    v21 = *(_QWORD *)(v20 + 56);
    v22 = *(_QWORD *)(v20 + 24);
    if (v19 == v21)
      return v22 | 4;
    if (v19 == v22)
      return v21 | 4;
  }
  v14 = *(uint64_t **)(a2 + 40);
  canMapOperands = *v14;
  if (*v14
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v16 = *v14;
  }
  else
  {
    v16 = v14[1];
    if (!v16 || *(_UNKNOWN **)(*(_QWORD *)v16 + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      if (canMapOperands)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
        {
          v17 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
          *(_QWORD *)&v91 = canMapOperands;
          *((_QWORD *)&v91 + 1) = v17;
          canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v91);
        }
        else
        {
          canMapOperands = 0;
          v91 = 0uLL;
        }
      }
      else
      {
        v91 = 0uLL;
      }
      v16 = v14[1];
      if (v16)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v16 + 8))
        {
          v18 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v16 + 8);
          *(_QWORD *)&v91 = v16;
          *((_QWORD *)&v91 + 1) = v18;
          v23 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v91);
          v16 = 0;
          if (canMapOperands && v23 && canMapOperands == v23)
          {
            v24 = *v14;
            if (*v14
              && *(_UNKNOWN **)(*(_QWORD *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            {
              v16 = *v14;
            }
            else
            {
              v25 = v14[1];
              if (v25)
              {
                v26 = *(void **)(*(_QWORD *)v25 + 136);
                if (v26 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
                  v16 = v14[1];
                else
                  v16 = 0;
                if (!v24 || v26 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
                  return v16 & 0xFFFFFFFFFFFFFFFBLL;
                if (v26 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
                  && *(_UNKNOWN **)(*(_QWORD *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
                {
                  v72 = *v14;
                  v69 = v25;
                  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v72);
                  if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v69))
                  {
                    mlir::IntegerAttr::getValue(&v72, (llvm::APInt *)&v78);
                    mlir::IntegerAttr::getValue(&v69, (llvm::APInt *)&v75);
                    v28 = v79;
                    DWORD2(v89) = v79;
                    if (v79 > 0x40)
                    {
                      llvm::APInt::initSlowCase((llvm::APInt *)&v89, &v78);
                      v28 = DWORD2(v89);
                      v29 = (const void *)v89;
                    }
                    else
                    {
                      v29 = v78;
                      *(_QWORD *)&v89 = v78;
                    }
                    DWORD2(v91) = v28;
                    *(_QWORD *)&v91 = v29;
                    DWORD2(v89) = 0;
                    llvm::APInt::operator-=((uint64_t)&v91, &v75);
                    LOBYTE(v92[0]) = 1;
                    if (DWORD2(v89) >= 0x41 && (_QWORD)v89)
                      MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
                    if (v76 >= 0x41 && v75)
                      MEMORY[0x20BD002D4](v75, 0x1000C8000313F17);
                    if (v79 >= 0x41 && v78)
                      MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
                    v16 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v91);
                    if (!LOBYTE(v92[0]))
                      return v16 & 0xFFFFFFFFFFFFFFFBLL;
                    goto LABEL_83;
                  }
                }
                else
                {
                  if (mlir::DenseElementsAttr::classof(*v14))
                    v30 = v24;
                  else
                    v30 = 0;
                  *(_QWORD *)&v91 = v30;
                  if (v30
                    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v91)
                    && ((v31 = v14[1], !mlir::DenseElementsAttr::classof(v31)) ? (v32 = 0) : (v32 = v31),
                        (*(_QWORD *)&v91 = v32) != 0
                     && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v91)))
                  {
                    v33 = v14[1];
                    v72 = *v14;
                    v69 = v33;
                    v34 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v72);
                    if (v34 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69))
                    {
                      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v72, (uint64_t)&v91);
                      v89 = v91;
                      v90 = v92[0];
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v89, (llvm::APInt *)&v78);
                      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v69, (uint64_t)&v91);
                      v89 = v91;
                      v90 = v92[0];
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v89, (llvm::APInt *)&v75);
                      v35 = v79;
                      DWORD2(v89) = v79;
                      if (v79 > 0x40)
                      {
                        llvm::APInt::initSlowCase((llvm::APInt *)&v89, &v78);
                        v35 = DWORD2(v89);
                        v36 = (const void *)v89;
                      }
                      else
                      {
                        v36 = v78;
                        *(_QWORD *)&v89 = v78;
                      }
                      DWORD2(v91) = v35;
                      *(_QWORD *)&v91 = v36;
                      DWORD2(v89) = 0;
                      llvm::APInt::operator-=((uint64_t)&v91, &v75);
                      LOBYTE(v92[0]) = 1;
                      if (DWORD2(v89) >= 0x41 && (_QWORD)v89)
                        MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
                      if (v76 >= 0x41 && v75)
                        MEMORY[0x20BD002D4](v75, 0x1000C8000313F17);
                      if (v79 >= 0x41 && v78)
                        MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
                      v64 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                      v16 = mlir::DenseElementsAttr::get(canMapOperands, v64, (llvm::APInt *)&v91, 1);
                      if (!LOBYTE(v92[0]))
                        return v16 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_83:
                      if (DWORD2(v91) >= 0x41)
                      {
                        if ((_QWORD)v91)
                          MEMORY[0x20BD002D4](v91, 0x1000C8000313F17);
                      }
                      return v16 & 0xFFFFFFFFFFFFFFFBLL;
                    }
                  }
                  else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v14 + 8)
                         && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v14[1] + 8))
                  {
                    v37 = (_QWORD *)*v14;
                    v38 = *v14 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v37 + 8) : 0;
                    v83 = v37;
                    v84 = v38;
                    v39 = (_QWORD *)v14[1];
                    v40 = v39 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v39 + 8) : 0;
                    v82[0] = v39;
                    v82[1] = v40;
                    Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v83);
                    if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v82))
                    {
                      mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v83, (uint64_t)&v89);
                      mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v82, (uint64_t)&v78);
                      v16 = 0;
                      v42 = v81;
                      if (BYTE8(v90) && v81)
                      {
                        LOWORD(v75) = v89;
                        if ((_BYTE)v89)
                          v76 = *((_QWORD *)&v89 + 1);
                        else
                          (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v89 + 1) + 16))(&v76);
                        v77 = v90;
                        LOWORD(v72) = (_WORD)v78;
                        if ((_BYTE)v78)
                          v73 = v79;
                        else
                          (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v79 + 16))(&v73);
                        v74 = v80;
                        *(_QWORD *)&v91 = v92;
                        *((_QWORD *)&v91 + 1) = 0x400000000;
                        NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v83, v84);
                        llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v91, NumElements);
                        v44 = mlir::ElementsAttr::getNumElements((uint64_t)v83, v84);
                        if (v44)
                        {
                          v45 = v44;
                          v46 = v77;
                          while (1)
                          {
                            if (BYTE1(v75))
                              v47 = 0;
                            else
                              v47 = v46;
                            if ((_BYTE)v75)
                            {
                              v48 = v76 + 16 * v47;
                              v68 = *(_DWORD *)(v48 + 8);
                              if (v68 > 0x40)
                                llvm::APInt::initSlowCase((llvm::APInt *)&v67, (const void **)v48);
                              else
                                v67 = *(const void **)v48;
                            }
                            else
                            {
                              (*(void (**)(const void **__return_ptr))(*(_QWORD *)v76 + 24))(&v67);
                            }
                            if (BYTE1(v72))
                              v49 = 0;
                            else
                              v49 = v74;
                            if ((_BYTE)v72)
                            {
                              v50 = v73 + 16 * v49;
                              v66 = *(_DWORD *)(v50 + 8);
                              if (v66 > 0x40)
                                llvm::APInt::initSlowCase((llvm::APInt *)&v65, (const void **)v50);
                              else
                                v65 = *(_QWORD **)v50;
                            }
                            else
                            {
                              (*(void (**)(_QWORD **__return_ptr))(*(_QWORD *)v73 + 24))(&v65);
                            }
                            v51 = v68;
                            v86 = v68;
                            if (v68 > 0x40)
                            {
                              llvm::APInt::initSlowCase((llvm::APInt *)&v85, &v67);
                              v51 = v86;
                              v52 = v85;
                            }
                            else
                            {
                              v52 = (uint64_t)v67;
                              v85 = (uint64_t)v67;
                            }
                            v88 = v51;
                            v87 = v52;
                            v86 = 0;
                            llvm::APInt::operator-=((uint64_t)&v87, &v65);
                            v70 = v88;
                            v69 = v87;
                            v71 = 1;
                            if (v86 >= 0x41 && v85)
                              MEMORY[0x20BD002D4](v85, 0x1000C8000313F17);
                            if (v66 >= 0x41 && v65)
                              MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
                            if (v68 >= 0x41 && v67)
                              MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
                            if (!v71)
                              break;
                            Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v91, (unint64_t)&v69, 1);
                            v54 = (llvm::APInt *)(v91 + 16 * DWORD2(v91));
                            v55 = *((_DWORD *)Address + 2);
                            *((_DWORD *)v54 + 2) = v55;
                            if (v55 > 0x40)
                              llvm::APInt::initSlowCase(v54, (const void **)Address);
                            else
                              *(_QWORD *)v54 = *(_QWORD *)Address;
                            ++DWORD2(v91);
                            if (v71 && v70 >= 0x41 && v69)
                              MEMORY[0x20BD002D4](v69, 0x1000C8000313F17);
                            v46 = ++v77;
                            ++v74;
                            if (!--v45)
                              goto LABEL_140;
                          }
                          v16 = 0;
                        }
                        else
                        {
LABEL_140:
                          v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                          v16 = mlir::DenseElementsAttr::get(canMapOperands, v56, (llvm::APInt *)v91, DWORD2(v91));
                        }
                        v57 = (char *)v91;
                        if (DWORD2(v91))
                        {
                          v58 = 16 * DWORD2(v91);
                          do
                          {
                            if (*(_DWORD *)&v57[v58 - 8] >= 0x41u)
                            {
                              v59 = *(_QWORD *)&v57[v58 - 16];
                              if (v59)
                                MEMORY[0x20BD002D4](v59, 0x1000C8000313F17);
                            }
                            v58 -= 16;
                          }
                          while (v58);
                          v57 = (char *)v91;
                        }
                        if (v57 != (char *)v92)
                          free(v57);
                        if (!(_BYTE)v72)
                        {
                          v60 = v73;
                          v73 = 0;
                          if (v60)
                            (*(void (**)(uint64_t))(*(_QWORD *)v60 + 8))(v60);
                        }
                        if (!(_BYTE)v75)
                        {
                          v61 = v76;
                          v76 = 0;
                          if (v61)
                            (*(void (**)(uint64_t))(*(_QWORD *)v61 + 8))(v61);
                        }
                        v42 = v81;
                      }
                      if (v42)
                      {
                        if (!(_BYTE)v78)
                        {
                          v62 = v79;
                          v79 = 0;
                          if (v62)
                            (*(void (**)(uint64_t))(*(_QWORD *)v62 + 8))(v62);
                        }
                      }
                      if (BYTE8(v90))
                      {
                        if (!(_BYTE)v89)
                        {
                          v63 = *((_QWORD *)&v89 + 1);
                          *((_QWORD *)&v89 + 1) = 0;
                          if (v63)
                            (*(void (**)(uint64_t))(*(_QWORD *)v63 + 8))(v63);
                        }
                      }
                      return v16 & 0xFFFFFFFFFFFFFFFBLL;
                    }
                  }
                }
              }
              v16 = 0;
            }
          }
        }
        else
        {
          v16 = 0;
          v91 = 0uLL;
        }
      }
      else
      {
        v91 = 0uLL;
      }
    }
  }
  return v16 & 0xFFFFFFFFFFFFFFFBLL;
}

void mlir::arith::SubIOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  uint64_t *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  unint64_t v176;
  char *v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  char *v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  char *v191;
  uint64_t *v192;
  char *v193;
  char *v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  uint64_t v201;
  __int128 v202;
  __int128 v203;
  uint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  char *v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  uint64_t v215;
  unint64_t v216;
  uint64_t v217;
  uint64_t v218;
  unint64_t v219;
  char *v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  char *v225;
  uint64_t *v226;
  char *v227;
  char *v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  char *v232;
  char *v233;
  char *v234;
  uint64_t v235;
  __int128 v236;
  __int128 v237;
  uint64_t v238;
  char *v239;
  uint64_t v240;
  uint64_t v241;
  __int16 v242;
  __int128 v243;
  __int128 v244;
  uint64_t v245;

  v245 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C0609E0;
  v244 = *(_OWORD *)&off_24C0609F0;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v4 = &off_24C029788;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubIRHSAddConstant]";
  *((_QWORD *)&v243 + 1) = 91;
  v9 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v9)
    v10 = v9;
  else
    v10 = *((_QWORD *)&v243 + 1);
  v11 = v243 + v10;
  v12 = *((_QWORD *)&v243 + 1) - v10;
  if (*((_QWORD *)&v243 + 1) - v10 >= 0x12)
    v13 = 18;
  else
    v13 = *((_QWORD *)&v243 + 1) - v10;
  v14 = v11 + v13;
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_268;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_269;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_272;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_272:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C060A00;
  v244 = *(_OWORD *)&off_24C060A10;
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v38 = &off_24C029748;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubILHSAddConstant]";
  *((_QWORD *)&v243 + 1) = 91;
  v43 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v43)
    v44 = v43;
  else
    v44 = *((_QWORD *)&v243 + 1);
  v45 = v243 + v44;
  v46 = *((_QWORD *)&v243 + 1) - v44;
  if (*((_QWORD *)&v243 + 1) - v44 >= 0x12)
    v47 = 18;
  else
    v47 = *((_QWORD *)&v243 + 1) - v44;
  v48 = v45 + v47;
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_268;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_269;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_273;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_273:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C060A00;
  v244 = *(_OWORD *)&off_24C060A10;
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v72 = &off_24C029FD8;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubIRHSSubConstantRHS]";
  *((_QWORD *)&v243 + 1) = 94;
  v77 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v77)
    v78 = v77;
  else
    v78 = *((_QWORD *)&v243 + 1);
  v79 = v243 + v78;
  v80 = *((_QWORD *)&v243 + 1) - v78;
  if (*((_QWORD *)&v243 + 1) - v78 >= 0x12)
    v81 = 18;
  else
    v81 = *((_QWORD *)&v243 + 1) - v78;
  v82 = v79 + v81;
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_268;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_269;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_274;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_274:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C060A00;
  v244 = *(_OWORD *)&off_24C060A10;
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v106 = &off_24C029F98;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubIRHSSubConstantLHS]";
  *((_QWORD *)&v243 + 1) = 94;
  v111 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v111)
    v112 = v111;
  else
    v112 = *((_QWORD *)&v243 + 1);
  v113 = v243 + v112;
  v114 = *((_QWORD *)&v243 + 1) - v112;
  if (*((_QWORD *)&v243 + 1) - v112 >= 0x12)
    v115 = 18;
  else
    v115 = *((_QWORD *)&v243 + 1) - v112;
  v116 = v113 + v115;
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
    goto LABEL_268;
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (v122)
  {
    if (v122 >> 61)
      goto LABEL_269;
    v123 = (char *)operator new(8 * v122);
    v124 = (uint64_t *)&v123[8 * v119];
    v125 = &v123[8 * v122];
    *v124 = v106;
    v110 = (uint64_t)(v124 + 1);
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
  }
  else
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_275;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v109[-v129];
      v124 = (uint64_t *)((char *)v124 - v129);
      v131 = &v123[8 * v119 - 16];
      v132 = v109 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_275:
        do
        {
          v136 = *((_QWORD *)v109 - 1);
          v109 -= 8;
          *(_QWORD *)v109 = 0;
          *--v124 = v136;
        }
        while (v109 != v118);
      }
      v109 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
  v140 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C060A00;
  v244 = *(_OWORD *)&off_24C060A10;
  mlir::Pattern::Pattern(v140 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v140 = &off_24C029F58;
  if (*(_QWORD *)(v140 + 72))
  {
    v141 = *(unsigned int *)(v140 + 88);
    if (v141 <= *(_DWORD *)(v140 + 92))
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v140 + 80, (void *)(v140 + 96), v141, 16);
    *(_DWORD *)(v140 + 88) = *(_DWORD *)(v140 + 88);
    v143 = (char *)a1[2];
    v142 = a1[3];
    if ((unint64_t)v143 < v142)
      goto LABEL_156;
    goto LABEL_167;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubILHSSubConstantRHS]";
  *((_QWORD *)&v243 + 1) = 94;
  v145 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v145)
    v146 = v145;
  else
    v146 = *((_QWORD *)&v243 + 1);
  v147 = v243 + v146;
  v148 = *((_QWORD *)&v243 + 1) - v146;
  if (*((_QWORD *)&v243 + 1) - v146 >= 0x12)
    v149 = 18;
  else
    v149 = *((_QWORD *)&v243 + 1) - v146;
  v150 = v147 + v149;
  v151 = v148 - v149;
  if (v151 >= v151 - 1)
    --v151;
  *(_QWORD *)(v140 + 64) = v150;
  *(_QWORD *)(v140 + 72) = v151;
  v141 = *(unsigned int *)(v140 + 88);
  if (v141 > *(_DWORD *)(v140 + 92))
    goto LABEL_166;
LABEL_155:
  *(_DWORD *)(v140 + 88) = v141;
  v143 = (char *)a1[2];
  v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(_QWORD *)v143 = v140;
    v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v152 = (char *)a1[1];
  v153 = (v143 - v152) >> 3;
  v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61)
    goto LABEL_268;
  v155 = v142 - (_QWORD)v152;
  if (v155 >> 2 > v154)
    v154 = v155 >> 2;
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8)
    v156 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v156 = v154;
  if (v156)
  {
    if (v156 >> 61)
      goto LABEL_269;
    v157 = (char *)operator new(8 * v156);
    v158 = (uint64_t *)&v157[8 * v153];
    v159 = &v157[8 * v156];
    *v158 = v140;
    v144 = (uint64_t)(v158 + 1);
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
      goto LABEL_176;
  }
  else
  {
    v157 = 0;
    v158 = (uint64_t *)(8 * v153);
    v159 = 0;
    *(_QWORD *)(8 * v153) = v140;
    v144 = 8 * v153 + 8;
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
    {
LABEL_176:
      v161 = (unint64_t)(v160 - 8);
      if (v161 < 0x78
        || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v158
        && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
      {
        goto LABEL_276;
      }
      v162 = (v161 >> 3) + 1;
      v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      v164 = &v143[-v163];
      v158 = (uint64_t *)((char *)v158 - v163);
      v165 = &v157[8 * v153 - 16];
      v166 = v143 - 16;
      v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v169 = *((_OWORD *)v166 - 1);
        v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      v143 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_276:
        do
        {
          v170 = *((_QWORD *)v143 - 1);
          v143 -= 8;
          *(_QWORD *)v143 = 0;
          *--v158 = v170;
        }
        while (v143 != v152);
      }
      v143 = (char *)a1[1];
      v171 = (char *)a1[2];
      a1[1] = v158;
      a1[2] = v144;
      a1[3] = v159;
      while (v171 != v143)
      {
        v173 = *((_QWORD *)v171 - 1);
        v171 -= 8;
        v172 = v173;
        *(_QWORD *)v171 = 0;
        if (v173)
          (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
      }
      goto LABEL_189;
    }
  }
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143)
    operator delete(v143);
LABEL_191:
  a1[2] = v144;
  v174 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C0609E0;
  v244 = *(_OWORD *)&off_24C0609F0;
  mlir::Pattern::Pattern(v174 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v174 = &off_24C029F18;
  if (*(_QWORD *)(v174 + 72))
  {
    v175 = *(unsigned int *)(v174 + 88);
    if (v175 <= *(_DWORD *)(v174 + 92))
      goto LABEL_193;
LABEL_204:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v174 + 80, (void *)(v174 + 96), v175, 16);
    *(_DWORD *)(v174 + 88) = *(_DWORD *)(v174 + 88);
    v177 = (char *)a1[2];
    v176 = a1[3];
    if ((unint64_t)v177 < v176)
      goto LABEL_194;
    goto LABEL_205;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubILHSSubConstantLHS]";
  *((_QWORD *)&v243 + 1) = 94;
  v179 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v179)
    v180 = v179;
  else
    v180 = *((_QWORD *)&v243 + 1);
  v181 = v243 + v180;
  v182 = *((_QWORD *)&v243 + 1) - v180;
  if (*((_QWORD *)&v243 + 1) - v180 >= 0x12)
    v183 = 18;
  else
    v183 = *((_QWORD *)&v243 + 1) - v180;
  v184 = v181 + v183;
  v185 = v182 - v183;
  if (v185 >= v185 - 1)
    --v185;
  *(_QWORD *)(v174 + 64) = v184;
  *(_QWORD *)(v174 + 72) = v185;
  v175 = *(unsigned int *)(v174 + 88);
  if (v175 > *(_DWORD *)(v174 + 92))
    goto LABEL_204;
LABEL_193:
  *(_DWORD *)(v174 + 88) = v175;
  v177 = (char *)a1[2];
  v176 = a1[3];
  if ((unint64_t)v177 < v176)
  {
LABEL_194:
    *(_QWORD *)v177 = v174;
    v178 = (uint64_t)(v177 + 8);
    goto LABEL_229;
  }
LABEL_205:
  v186 = (char *)a1[1];
  v187 = (v177 - v186) >> 3;
  v188 = v187 + 1;
  if ((unint64_t)(v187 + 1) >> 61)
    goto LABEL_268;
  v189 = v176 - (_QWORD)v186;
  if (v189 >> 2 > v188)
    v188 = v189 >> 2;
  if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8)
    v190 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v190 = v188;
  if (v190)
  {
    if (v190 >> 61)
      goto LABEL_269;
    v191 = (char *)operator new(8 * v190);
    v192 = (uint64_t *)&v191[8 * v187];
    v193 = &v191[8 * v190];
    *v192 = v174;
    v178 = (uint64_t)(v192 + 1);
    v194 = (char *)(v177 - v186);
    if (v177 != v186)
      goto LABEL_214;
  }
  else
  {
    v191 = 0;
    v192 = (uint64_t *)(8 * v187);
    v193 = 0;
    *(_QWORD *)(8 * v187) = v174;
    v178 = 8 * v187 + 8;
    v194 = (char *)(v177 - v186);
    if (v177 != v186)
    {
LABEL_214:
      v195 = (unint64_t)(v194 - 8);
      if (v195 < 0x78
        || &v177[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v192
        && &v191[v177 - v186 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v177)
      {
        goto LABEL_277;
      }
      v196 = (v195 >> 3) + 1;
      v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      v198 = &v177[-v197];
      v192 = (uint64_t *)((char *)v192 - v197);
      v199 = &v191[8 * v187 - 16];
      v200 = v177 - 16;
      v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v203 = *((_OWORD *)v200 - 1);
        v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      v177 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_277:
        do
        {
          v204 = *((_QWORD *)v177 - 1);
          v177 -= 8;
          *(_QWORD *)v177 = 0;
          *--v192 = v204;
        }
        while (v177 != v186);
      }
      v177 = (char *)a1[1];
      v205 = (char *)a1[2];
      a1[1] = v192;
      a1[2] = v178;
      a1[3] = v193;
      while (v205 != v177)
      {
        v207 = *((_QWORD *)v205 - 1);
        v205 -= 8;
        v206 = v207;
        *(_QWORD *)v205 = 0;
        if (v207)
          (*(void (**)(uint64_t))(*(_QWORD *)v206 + 8))(v206);
      }
      goto LABEL_227;
    }
  }
  a1[1] = v192;
  a1[2] = v178;
  a1[3] = v193;
LABEL_227:
  if (v177)
    operator delete(v177);
LABEL_229:
  a1[2] = v178;
  v208 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 2);
  v243 = xmmword_24C060A00;
  v244 = *(_OWORD *)&off_24C060A10;
  mlir::Pattern::Pattern(v208 + 8, (uint64_t)"arith.subi", 10, v242, a2, &v243, 2uLL);
  *(_QWORD *)v208 = &off_24C029430;
  if (*(_QWORD *)(v208 + 72))
  {
    v209 = *(unsigned int *)(v208 + 88);
    if (v209 <= *(_DWORD *)(v208 + 92))
      goto LABEL_231;
LABEL_242:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v208 + 80, (void *)(v208 + 96), v209, 16);
    *(_DWORD *)(v208 + 88) = *(_DWORD *)(v208 + 88);
    v211 = (char *)a1[2];
    v210 = a1[3];
    if ((unint64_t)v211 < v210)
      goto LABEL_232;
    goto LABEL_243;
  }
  *(_QWORD *)&v243 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SubISubILHSRHSLHS]";
  *((_QWORD *)&v243 + 1) = 90;
  v213 = llvm::StringRef::find((uint64_t *)&v243, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v243 + 1) >= v213)
    v214 = v213;
  else
    v214 = *((_QWORD *)&v243 + 1);
  v215 = v243 + v214;
  v216 = *((_QWORD *)&v243 + 1) - v214;
  if (*((_QWORD *)&v243 + 1) - v214 >= 0x12)
    v217 = 18;
  else
    v217 = *((_QWORD *)&v243 + 1) - v214;
  v218 = v215 + v217;
  v219 = v216 - v217;
  if (v219 >= v219 - 1)
    --v219;
  *(_QWORD *)(v208 + 64) = v218;
  *(_QWORD *)(v208 + 72) = v219;
  v209 = *(unsigned int *)(v208 + 88);
  if (v209 > *(_DWORD *)(v208 + 92))
    goto LABEL_242;
LABEL_231:
  *(_DWORD *)(v208 + 88) = v209;
  v211 = (char *)a1[2];
  v210 = a1[3];
  if ((unint64_t)v211 < v210)
  {
LABEL_232:
    *(_QWORD *)v211 = v208;
    v212 = (uint64_t)(v211 + 8);
    goto LABEL_267;
  }
LABEL_243:
  v220 = (char *)a1[1];
  v221 = (v211 - v220) >> 3;
  v222 = v221 + 1;
  if ((unint64_t)(v221 + 1) >> 61)
LABEL_268:
    abort();
  v223 = v210 - (_QWORD)v220;
  if (v223 >> 2 > v222)
    v222 = v223 >> 2;
  if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8)
    v224 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v224 = v222;
  if (!v224)
  {
    v225 = 0;
    v226 = (uint64_t *)(8 * v221);
    v227 = 0;
    *(_QWORD *)(8 * v221) = v208;
    v212 = 8 * v221 + 8;
    v228 = (char *)(v211 - v220);
    if (v211 != v220)
      goto LABEL_252;
    goto LABEL_264;
  }
  if (v224 >> 61)
LABEL_269:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v225 = (char *)operator new(8 * v224);
  v226 = (uint64_t *)&v225[8 * v221];
  v227 = &v225[8 * v224];
  *v226 = v208;
  v212 = (uint64_t)(v226 + 1);
  v228 = (char *)(v211 - v220);
  if (v211 != v220)
  {
LABEL_252:
    v229 = (unint64_t)(v228 - 8);
    if (v229 < 0x78
      || &v211[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v226
      && &v225[v211 - v220 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v211)
    {
      goto LABEL_278;
    }
    v230 = (v229 >> 3) + 1;
    v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
    v232 = &v211[-v231];
    v226 = (uint64_t *)((char *)v226 - v231);
    v233 = &v225[8 * v221 - 16];
    v234 = v211 - 16;
    v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v237 = *((_OWORD *)v234 - 1);
      v236 = *(_OWORD *)v234;
      *((_OWORD *)v234 - 1) = 0uLL;
      *(_OWORD *)v234 = 0uLL;
      *((_OWORD *)v233 - 1) = v237;
      *(_OWORD *)v233 = v236;
      v233 -= 32;
      v234 -= 32;
      v235 -= 4;
    }
    while (v235);
    v211 = v232;
    if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_278:
      do
      {
        v238 = *((_QWORD *)v211 - 1);
        v211 -= 8;
        *(_QWORD *)v211 = 0;
        *--v226 = v238;
      }
      while (v211 != v220);
    }
    v211 = (char *)a1[1];
    v239 = (char *)a1[2];
    a1[1] = v226;
    a1[2] = v212;
    a1[3] = v227;
    while (v239 != v211)
    {
      v241 = *((_QWORD *)v239 - 1);
      v239 -= 8;
      v240 = v241;
      *(_QWORD *)v239 = 0;
      if (v241)
        (*(void (**)(uint64_t))(*(_QWORD *)v240 + 8))(v240);
    }
    goto LABEL_265;
  }
LABEL_264:
  a1[1] = v226;
  a1[2] = v212;
  a1[3] = v227;
LABEL_265:
  if (v211)
    operator delete(v211);
LABEL_267:
  a1[2] = v212;
}

uint64_t mlir::arith::MulIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  int v7;
  _BOOL4 v8;
  uint64_t v10;
  int v11;
  int v12;
  BOOL v13;
  uint64_t canMapOperands;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t Value;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t Type;
  int v34;
  unint64_t NumElements;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *Address;
  llvm::APInt *v44;
  unsigned int v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const unint64_t *v54;
  unsigned int v55;
  const void *v56;
  unsigned int v57;
  uint64_t v58;
  unsigned int v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const unint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 v70;
  _QWORD v71[2];
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  _OWORD v79[4];
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (!v4)
    goto LABEL_29;
  DWORD2(v78) = 1;
  *(_QWORD *)&v78 = 0;
  *(_QWORD *)&v76 = &v78;
  v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v76, v4);
  v7 = DWORD2(v78);
  if (v6)
  {
    if (DWORD2(v78) < 0x41)
    {
      v8 = (_QWORD)v78 == 0;
      goto LABEL_11;
    }
    if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78) > 0x40)
    {
      if ((_QWORD)v78)
        MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
      goto LABEL_15;
    }
    v8 = *(_QWORD *)v78 == 0;
  }
  else
  {
    v8 = 0;
    if (DWORD2(v78) < 0x41)
      goto LABEL_11;
  }
  if (!(_QWORD)v78)
  {
LABEL_11:
    if (v8)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 56) | 4;
    goto LABEL_15;
  }
  MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
  if (v8)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 56) | 4;
LABEL_15:
  v3 = *(uint64_t **)(a2 + 40);
  v10 = v3[1];
  if (v10)
  {
    DWORD2(v78) = 1;
    *(_QWORD *)&v78 = 0;
    *(_QWORD *)&v76 = &v78;
    v11 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v76, v10);
    v12 = DWORD2(v78);
    if (v11)
    {
      if (DWORD2(v78) < 0x41)
      {
        v13 = (_QWORD)v78 == 1;
        goto LABEL_22;
      }
      if (v12 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78) > 0x40)
      {
        if ((_QWORD)v78)
          MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
LABEL_28:
        v3 = *(uint64_t **)(a2 + 40);
        goto LABEL_29;
      }
      v13 = *(_QWORD *)v78 == 1;
    }
    else
    {
      v13 = 0;
      if (DWORD2(v78) < 0x41)
        goto LABEL_22;
    }
    if ((_QWORD)v78)
      MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
LABEL_22:
    if (v13)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
    goto LABEL_28;
  }
LABEL_29:
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v15 = *v3;
  }
  else
  {
    v15 = v3[1];
    if (!v15 || *(_UNKNOWN **)(*(_QWORD *)v15 + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      if (canMapOperands)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
        {
          v16 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
          *(_QWORD *)&v78 = canMapOperands;
          *((_QWORD *)&v78 + 1) = v16;
          canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v78);
        }
        else
        {
          canMapOperands = 0;
          v78 = 0uLL;
        }
      }
      else
      {
        v78 = 0uLL;
      }
      v15 = v3[1];
      if (v15)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v15 + 8))
        {
          v17 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v15 + 8);
          *(_QWORD *)&v78 = v15;
          *((_QWORD *)&v78 + 1) = v17;
          v18 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v78);
          v15 = 0;
          if (canMapOperands && v18 && canMapOperands == v18)
          {
            v19 = *v3;
            if (*v3
              && *(_UNKNOWN **)(*(_QWORD *)v19 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            {
              v15 = *v3;
            }
            else
            {
              v20 = v3[1];
              if (v20)
              {
                v21 = *(void **)(*(_QWORD *)v20 + 136);
                if (v21 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
                  v15 = v3[1];
                else
                  v15 = 0;
                if (!v19 || v21 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
                  return v15 & 0xFFFFFFFFFFFFFFFBLL;
                if (v21 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
                  && *(_UNKNOWN **)(*(_QWORD *)v19 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
                {
                  v61 = *v3;
                  v58 = v20;
                  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v61);
                  if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58))
                  {
                    mlir::IntegerAttr::getValue(&v61, (llvm::APInt *)&v67);
                    mlir::IntegerAttr::getValue(&v58, (llvm::APInt *)&v64);
                    llvm::APInt::operator*((uint64_t)&v67, &v64, (uint64_t)&v76);
                    DWORD2(v78) = DWORD2(v76);
                    *(_QWORD *)&v78 = v76;
                    LOBYTE(v79[0]) = 1;
                    if (v65 >= 0x41 && v64)
                      MEMORY[0x20BD002D4](v64, 0x1000C8000313F17);
                    if (v68 >= 0x41 && v67)
                      MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
                    v15 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v78);
                    if (!LOBYTE(v79[0]))
                      return v15 & 0xFFFFFFFFFFFFFFFBLL;
                    goto LABEL_65;
                  }
                }
                else
                {
                  if (mlir::DenseElementsAttr::classof(*v3))
                    v23 = v19;
                  else
                    v23 = 0;
                  *(_QWORD *)&v78 = v23;
                  if (v23
                    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v78)
                    && ((v24 = v3[1], !mlir::DenseElementsAttr::classof(v24)) ? (v25 = 0) : (v25 = v24),
                        (*(_QWORD *)&v78 = v25) != 0
                     && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v78)))
                  {
                    v26 = v3[1];
                    v61 = *v3;
                    v58 = v26;
                    v27 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v61);
                    if (v27 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58))
                    {
                      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v61, (uint64_t)&v78);
                      v76 = v78;
                      v77 = v79[0];
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v76, (llvm::APInt *)&v67);
                      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v58, (uint64_t)&v78);
                      v76 = v78;
                      v77 = v79[0];
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v76, (llvm::APInt *)&v64);
                      llvm::APInt::operator*((uint64_t)&v67, &v64, (uint64_t)&v76);
                      DWORD2(v78) = DWORD2(v76);
                      *(_QWORD *)&v78 = v76;
                      LOBYTE(v79[0]) = 1;
                      if (v65 >= 0x41 && v64)
                        MEMORY[0x20BD002D4](v64, 0x1000C8000313F17);
                      if (v68 >= 0x41 && v67)
                        MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
                      v28 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                      v15 = mlir::DenseElementsAttr::get(canMapOperands, v28, (llvm::APInt *)&v78, 1);
                      if (!LOBYTE(v79[0]))
                        return v15 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_65:
                      if (DWORD2(v78) >= 0x41)
                      {
                        if ((_QWORD)v78)
                          MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
                      }
                      return v15 & 0xFFFFFFFFFFFFFFFBLL;
                    }
                  }
                  else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
                         && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
                  {
                    v29 = (_QWORD *)*v3;
                    v30 = *v3 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v29 + 8) : 0;
                    v72 = v29;
                    v73 = v30;
                    v31 = (_QWORD *)v3[1];
                    v32 = v31 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v31 + 8) : 0;
                    v71[0] = v31;
                    v71[1] = v32;
                    Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v72);
                    if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v71))
                    {
                      mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v72, (uint64_t)&v76);
                      mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v71, (uint64_t)&v67);
                      v15 = 0;
                      v34 = v70;
                      if (BYTE8(v77) && v70)
                      {
                        LOWORD(v64) = v76;
                        if ((_BYTE)v76)
                          v65 = *((_QWORD *)&v76 + 1);
                        else
                          (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v76 + 1) + 16))(&v65);
                        v66 = v77;
                        LOWORD(v61) = v67;
                        if ((_BYTE)v67)
                          v62 = v68;
                        else
                          (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v68 + 16))(&v62);
                        v63 = v69;
                        *(_QWORD *)&v78 = v79;
                        *((_QWORD *)&v78 + 1) = 0x400000000;
                        NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v72, v73);
                        llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v78, NumElements);
                        v36 = mlir::ElementsAttr::getNumElements((uint64_t)v72, v73);
                        if (v36)
                        {
                          v37 = v36;
                          v38 = v66;
                          while (1)
                          {
                            if (BYTE1(v64))
                              v39 = 0;
                            else
                              v39 = v38;
                            if ((_BYTE)v64)
                            {
                              v40 = v65 + 16 * v39;
                              v57 = *(_DWORD *)(v40 + 8);
                              if (v57 > 0x40)
                                llvm::APInt::initSlowCase((llvm::APInt *)&v56, (const void **)v40);
                              else
                                v56 = *(const void **)v40;
                            }
                            else
                            {
                              (*(void (**)(const void **__return_ptr))(*(_QWORD *)v65 + 24))(&v56);
                            }
                            if (BYTE1(v61))
                              v41 = 0;
                            else
                              v41 = v63;
                            if ((_BYTE)v61)
                            {
                              v42 = v62 + 16 * v41;
                              v55 = *(_DWORD *)(v42 + 8);
                              if (v55 > 0x40)
                                llvm::APInt::initSlowCase((llvm::APInt *)&v54, (const void **)v42);
                              else
                                v54 = *(const unint64_t **)v42;
                            }
                            else
                            {
                              (*(void (**)(const unint64_t **__return_ptr))(*(_QWORD *)v62 + 24))(&v54);
                            }
                            llvm::APInt::operator*((uint64_t)&v56, &v54, (uint64_t)&v74);
                            v59 = v75;
                            v58 = v74;
                            v60 = 1;
                            if (v55 >= 0x41 && v54)
                              MEMORY[0x20BD002D4](v54, 0x1000C8000313F17);
                            if (v57 >= 0x41 && v56)
                              MEMORY[0x20BD002D4](v56, 0x1000C8000313F17);
                            if (!v60)
                              break;
                            Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v78, (unint64_t)&v58, 1);
                            v44 = (llvm::APInt *)(v78 + 16 * DWORD2(v78));
                            v45 = *((_DWORD *)Address + 2);
                            *((_DWORD *)v44 + 2) = v45;
                            if (v45 > 0x40)
                              llvm::APInt::initSlowCase(v44, (const void **)Address);
                            else
                              *(_QWORD *)v44 = *(_QWORD *)Address;
                            ++DWORD2(v78);
                            if (v60 && v59 >= 0x41 && v58)
                              MEMORY[0x20BD002D4](v58, 0x1000C8000313F17);
                            v38 = ++v66;
                            ++v63;
                            if (!--v37)
                              goto LABEL_140;
                          }
                          v15 = 0;
                        }
                        else
                        {
LABEL_140:
                          v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                          v15 = mlir::DenseElementsAttr::get(canMapOperands, v46, (llvm::APInt *)v78, DWORD2(v78));
                        }
                        v47 = (char *)v78;
                        if (DWORD2(v78))
                        {
                          v48 = 16 * DWORD2(v78);
                          do
                          {
                            if (*(_DWORD *)&v47[v48 - 8] >= 0x41u)
                            {
                              v49 = *(_QWORD *)&v47[v48 - 16];
                              if (v49)
                                MEMORY[0x20BD002D4](v49, 0x1000C8000313F17);
                            }
                            v48 -= 16;
                          }
                          while (v48);
                          v47 = (char *)v78;
                        }
                        if (v47 != (char *)v79)
                          free(v47);
                        if (!(_BYTE)v61)
                        {
                          v50 = v62;
                          v62 = 0;
                          if (v50)
                            (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
                        }
                        if (!(_BYTE)v64)
                        {
                          v51 = v65;
                          v65 = 0;
                          if (v51)
                            (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
                        }
                        v34 = v70;
                      }
                      if (v34)
                      {
                        if (!(_BYTE)v67)
                        {
                          v52 = v68;
                          v68 = 0;
                          if (v52)
                            (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
                        }
                      }
                      if (BYTE8(v77))
                      {
                        if (!(_BYTE)v76)
                        {
                          v53 = *((_QWORD *)&v76 + 1);
                          *((_QWORD *)&v76 + 1) = 0;
                          if (v53)
                            (*(void (**)(uint64_t))(*(_QWORD *)v53 + 8))(v53);
                        }
                      }
                      return v15 & 0xFFFFFFFFFFFFFFFBLL;
                    }
                  }
                }
              }
              v15 = 0;
            }
          }
        }
        else
        {
          v15 = 0;
          v78 = 0uLL;
        }
      }
      else
      {
        v78 = 0uLL;
      }
    }
  }
  return v15 & 0xFFFFFFFFFFFFFFFBLL;
}

void mlir::arith::MulIOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  __int16 v38;
  _OWORD v39[2];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 2);
  v39[0] = xmmword_24C060A20;
  v39[1] = *(_OWORD *)&off_24C060A30;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.muli", 10, v38, a2, v39, 2uLL);
  *(_QWORD *)v4 = &off_24C028AA8;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  *(_QWORD *)&v39[0] = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::MulIMulIConstant]";
  *((_QWORD *)&v39[0] + 1) = 89;
  v9 = llvm::StringRef::find((uint64_t *)v39, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v39[0] + 1) >= v9)
    v10 = v9;
  else
    v10 = *((_QWORD *)&v39[0] + 1);
  v11 = *(_QWORD *)&v39[0] + v10;
  v12 = *((_QWORD *)&v39[0] + 1) - v10;
  if (*((_QWORD *)&v39[0] + 1) - v10 >= 0x12)
    v13 = 18;
  else
    v13 = *((_QWORD *)&v39[0] + 1) - v10;
  v14 = v11 + v13;
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::arith::MulSIExtendedOp::fold(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t canMapOperands;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t Value;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t Type;
  uint64_t v58;
  int v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  llvm::APInt *v69;
  unsigned int v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t NumElements;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *Address;
  llvm::APInt *v88;
  unsigned int v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  const unint64_t *v98;
  unsigned int v99;
  const void *v100;
  unsigned int v101;
  _QWORD v102[2];
  _QWORD *v103;
  uint64_t v104;
  const unint64_t *v105;
  unsigned int v106;
  const void *v107;
  unsigned int v108;
  const unint64_t *v109;
  unsigned int v110;
  uint64_t v111;
  unsigned int v112;
  char v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unsigned __int8 v123;
  _QWORD *v124;
  uint64_t v125;
  _QWORD *v126;
  uint64_t v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  _OWORD v131[4];
  uint64_t v132;

  v132 = *MEMORY[0x24BDAC8D0];
  v5 = *(uint64_t **)(a2 + 40);
  v6 = v5[1];
  if (!v6)
  {
LABEL_17:
    v14 = *v5;
    if (*v5 && *(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      v15 = *v5;
      goto LABEL_28;
    }
    v15 = v5[1];
    if (v15 && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
LABEL_28:
      v19 = *(uint64_t **)(a2 + 40);
      canMapOperands = *v19;
      if (*v19
        && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
      {
        v21 = *v19;
        goto LABEL_162;
      }
      v21 = v19[1];
      if (v21 && *(_UNKNOWN **)(*(_QWORD *)v21 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        goto LABEL_162;
      if (canMapOperands)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
        {
          v22 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
          *(_QWORD *)&v130 = canMapOperands;
          *((_QWORD *)&v130 + 1) = v22;
          canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v130);
        }
        else
        {
          canMapOperands = 0;
          v130 = 0uLL;
        }
      }
      else
      {
        v130 = 0uLL;
      }
      v21 = v19[1];
      if (!v21)
      {
        v130 = 0uLL;
        goto LABEL_162;
      }
      if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v21 + 8))
      {
        v21 = 0;
        v130 = 0uLL;
        goto LABEL_162;
      }
      v23 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v21 + 8);
      *(_QWORD *)&v130 = v21;
      *((_QWORD *)&v130 + 1) = v23;
      v30 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v130);
      v21 = 0;
      if (!canMapOperands || !v30 || canMapOperands != v30)
        goto LABEL_162;
      v31 = *v19;
      if (*v19
        && *(_UNKNOWN **)(*(_QWORD *)v31 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
      {
        v21 = *v19;
        goto LABEL_162;
      }
      v32 = v19[1];
      if (v32)
      {
        v33 = *(void **)(*(_QWORD *)v32 + 136);
        if (v33 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          v21 = v19[1];
        else
          v21 = 0;
        if (!v31 || v33 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          goto LABEL_162;
        if (v33 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
          && *(_UNKNOWN **)(*(_QWORD *)v31 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        {
          v117 = *v19;
          v114 = v32;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v117);
          if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v114))
          {
            mlir::IntegerAttr::getValue(&v117, (llvm::APInt *)&v128);
            mlir::IntegerAttr::getValue(&v114, (llvm::APInt *)&v120);
            mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::MulSIExtendedOp::fold(mlir::arith::MulSIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::MulSIExtendedOp::fold(mlir::arith::MulSIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v130, (llvm::APInt *)&v128, &v120);
            if (v121 >= 0x41 && v120)
              MEMORY[0x20BD002D4](v120, 0x1000C8000313F17);
            if (DWORD2(v128) >= 0x41 && (_QWORD)v128)
              MEMORY[0x20BD002D4](v128, 0x1000C8000313F17);
            if (LOBYTE(v131[0]))
            {
              v21 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v130);
              if (LOBYTE(v131[0]))
              {
LABEL_93:
                if (DWORD2(v130) >= 0x41 && (_QWORD)v130)
                  MEMORY[0x20BD002D4](v130, 0x1000C8000313F17);
              }
LABEL_162:
              v58 = *(unsigned int *)(a3 + 8);
              if (v58 >= *(_DWORD *)(a3 + 12))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v58 + 1, 8);
                LODWORD(v58) = *(_DWORD *)(a3 + 8);
              }
              *(_QWORD *)(*(_QWORD *)a3 + 8 * v58) = v15 & 0xFFFFFFFFFFFFFFFBLL;
              v12 = *(_DWORD *)(a3 + 12);
              v13 = (*(_DWORD *)(a3 + 8) + 1);
              *(_DWORD *)(a3 + 8) = v13;
              v10 = v21 & 0xFFFFFFFFFFFFFFFBLL;
              goto LABEL_165;
            }
          }
        }
        else
        {
          if (mlir::DenseElementsAttr::classof(*v19))
            v43 = v31;
          else
            v43 = 0;
          *(_QWORD *)&v130 = v43;
          if (v43
            && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v130)
            && ((v44 = v19[1], !mlir::DenseElementsAttr::classof(v44)) ? (v45 = 0) : (v45 = v44),
                (*(_QWORD *)&v130 = v45) != 0
             && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v130)))
          {
            v46 = v19[1];
            v114 = *v19;
            v111 = v46;
            v47 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v114);
            if (v47 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v111))
            {
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v114, (uint64_t)&v130);
              v128 = v130;
              v129 = v131[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v128, (llvm::APInt *)&v120);
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v111, (uint64_t)&v130);
              v128 = v130;
              v129 = v131[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v128, (llvm::APInt *)&v117);
              mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::MulSIExtendedOp::fold(mlir::arith::MulSIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::MulSIExtendedOp::fold(mlir::arith::MulSIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v130, (llvm::APInt *)&v120, &v117);
              if (v118 >= 0x41 && v117)
                MEMORY[0x20BD002D4](v117, 0x1000C8000313F17);
              if (v121 >= 0x41 && v120)
                MEMORY[0x20BD002D4](v120, 0x1000C8000313F17);
              if (LOBYTE(v131[0]))
              {
                v48 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                v21 = mlir::DenseElementsAttr::get(canMapOperands, v48, (llvm::APInt *)&v130, 1);
                if (LOBYTE(v131[0]))
                  goto LABEL_93;
                goto LABEL_162;
              }
            }
          }
          else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v19 + 8)
                 && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v19[1] + 8))
          {
            v49 = (_QWORD *)*v19;
            v50 = *v19 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v49 + 8) : 0;
            v126 = v49;
            v127 = v50;
            v55 = (_QWORD *)v19[1];
            v56 = v55 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v55 + 8) : 0;
            v124 = v55;
            v125 = v56;
            Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v126);
            if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v124))
            {
              mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v126, (uint64_t)&v128);
              mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v124, (uint64_t)&v120);
              v21 = 0;
              v59 = v123;
              if (BYTE8(v129) && v123)
              {
                LOWORD(v117) = v128;
                if ((_BYTE)v128)
                  v118 = *((_QWORD *)&v128 + 1);
                else
                  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v128 + 1) + 16))(&v118);
                v119 = v129;
                LOWORD(v114) = v120;
                if ((_BYTE)v120)
                  v115 = v121;
                else
                  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v121 + 16))(&v115);
                v116 = v122;
                *(_QWORD *)&v130 = v131;
                *((_QWORD *)&v130 + 1) = 0x400000000;
                NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v126, v127);
                llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v130, NumElements);
                v80 = mlir::ElementsAttr::getNumElements((uint64_t)v126, v127);
                if (v80)
                {
                  v81 = v80;
                  v82 = v119;
                  while (1)
                  {
                    if (BYTE1(v117))
                      v83 = 0;
                    else
                      v83 = v82;
                    if ((_BYTE)v117)
                    {
                      v84 = v118 + 16 * v83;
                      v110 = *(_DWORD *)(v84 + 8);
                      if (v110 > 0x40)
                        llvm::APInt::initSlowCase((llvm::APInt *)&v109, (const void **)v84);
                      else
                        v109 = *(const unint64_t **)v84;
                    }
                    else
                    {
                      (*(void (**)(const unint64_t **__return_ptr))(*(_QWORD *)v118 + 24))(&v109);
                    }
                    if (BYTE1(v114))
                      v85 = 0;
                    else
                      v85 = v116;
                    if ((_BYTE)v114)
                    {
                      v86 = v115 + 16 * v85;
                      v108 = *(_DWORD *)(v86 + 8);
                      if (v108 > 0x40)
                        llvm::APInt::initSlowCase((llvm::APInt *)&v107, (const void **)v86);
                      else
                        v107 = *(const void **)v86;
                    }
                    else
                    {
                      (*(void (**)(const void **__return_ptr))(*(_QWORD *)v115 + 24))(&v107);
                    }
                    mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::MulSIExtendedOp::fold(mlir::arith::MulSIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::MulSIExtendedOp::fold(mlir::arith::MulSIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v111, (llvm::APInt *)&v109, &v107);
                    if (v108 >= 0x41 && v107)
                      MEMORY[0x20BD002D4](v107, 0x1000C8000313F17);
                    if (v110 >= 0x41 && v109)
                      MEMORY[0x20BD002D4](v109, 0x1000C8000313F17);
                    if (!v113)
                      break;
                    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v130, (unint64_t)&v111, 1);
                    v88 = (llvm::APInt *)(v130 + 16 * DWORD2(v130));
                    v89 = *((_DWORD *)Address + 2);
                    *((_DWORD *)v88 + 2) = v89;
                    if (v89 > 0x40)
                      llvm::APInt::initSlowCase(v88, (const void **)Address);
                    else
                      *(_QWORD *)v88 = *(_QWORD *)Address;
                    ++DWORD2(v130);
                    if (v113 && v112 >= 0x41 && v111)
                      MEMORY[0x20BD002D4](v111, 0x1000C8000313F17);
                    v82 = ++v119;
                    ++v116;
                    if (!--v81)
                      goto LABEL_273;
                  }
                  v21 = 0;
                }
                else
                {
LABEL_273:
                  v90 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                  v21 = mlir::DenseElementsAttr::get(canMapOperands, v90, (llvm::APInt *)v130, DWORD2(v130));
                }
                v91 = (char *)v130;
                if (DWORD2(v130))
                {
                  v92 = 16 * DWORD2(v130);
                  do
                  {
                    if (*(_DWORD *)&v91[v92 - 8] >= 0x41u)
                    {
                      v93 = *(_QWORD *)&v91[v92 - 16];
                      if (v93)
                        MEMORY[0x20BD002D4](v93, 0x1000C8000313F17);
                    }
                    v92 -= 16;
                  }
                  while (v92);
                  v91 = (char *)v130;
                }
                if (v91 != (char *)v131)
                  free(v91);
                if (!(_BYTE)v114)
                {
                  v94 = v115;
                  v115 = 0;
                  if (v94)
                    (*(void (**)(uint64_t))(*(_QWORD *)v94 + 8))(v94);
                }
                if (!(_BYTE)v117)
                {
                  v95 = v118;
                  v118 = 0;
                  if (v95)
                    (*(void (**)(uint64_t))(*(_QWORD *)v95 + 8))(v95);
                }
                v59 = v123;
              }
              if (v59)
              {
                if (!(_BYTE)v120)
                {
                  v96 = v121;
                  v121 = 0;
                  if (v96)
                    (*(void (**)(uint64_t))(*(_QWORD *)v96 + 8))(v96);
                }
              }
              if (BYTE8(v129))
              {
                if (!(_BYTE)v128)
                {
                  v97 = *((_QWORD *)&v128 + 1);
                  *((_QWORD *)&v128 + 1) = 0;
                  if (v97)
                    (*(void (**)(uint64_t))(*(_QWORD *)v97 + 8))(v97);
                }
              }
              goto LABEL_162;
            }
          }
        }
      }
      v21 = 0;
      goto LABEL_162;
    }
    if (v14)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v14 + 8))
      {
        v16 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v14 + 8);
        *(_QWORD *)&v130 = v14;
        *((_QWORD *)&v130 + 1) = v16;
        v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v130);
      }
      else
      {
        v14 = 0;
        v130 = 0uLL;
      }
    }
    else
    {
      v130 = 0uLL;
    }
    v17 = (_QWORD *)v5[1];
    if (v17)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v17 + 8))
      {
        v18 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v17 + 8);
        *(_QWORD *)&v130 = v17;
        *((_QWORD *)&v130 + 1) = v18;
        v24 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v130);
        result = 0;
        if (!v14 || !v24 || v14 != v24)
          return result;
        v15 = *v5;
        if (*v5
          && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          goto LABEL_28;
        }
        v26 = v5[1];
        if (v26)
        {
          v27 = *(void **)(*(_QWORD *)v26 + 136);
          if (v27 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            v28 = v5[1];
          else
            v28 = 0;
          if (!v15 || v27 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            goto LABEL_150;
          if (v27 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
            && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          {
            v120 = *v5;
            v117 = v26;
            v29 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v120);
            if (v29 == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v117))
            {
              mlir::IntegerAttr::getValue(&v120, (llvm::APInt *)&v124);
              mlir::IntegerAttr::getValue(&v117, (llvm::APInt *)&v109);
              llvm::APInt::operator*((uint64_t)&v124, &v109, (uint64_t)&v128);
              DWORD2(v130) = DWORD2(v128);
              *(_QWORD *)&v130 = v128;
              LOBYTE(v131[0]) = 1;
              if (v110 >= 0x41 && v109)
                MEMORY[0x20BD002D4](v109, 0x1000C8000313F17);
              if (v125 >= 0x41 && v124)
                MEMORY[0x20BD002D4](v124, 0x1000C8000313F17);
              v28 = mlir::IntegerAttr::get(v14, (llvm::APInt *)&v130);
              if (LOBYTE(v131[0]))
              {
LABEL_63:
                if (DWORD2(v130) >= 0x41 && (_QWORD)v130)
                  MEMORY[0x20BD002D4](v130, 0x1000C8000313F17);
              }
LABEL_150:
              v15 = v28;
              if (!v28)
                return 0;
              goto LABEL_28;
            }
          }
          else
          {
            if (mlir::DenseElementsAttr::classof(*v5))
              v35 = v15;
            else
              v35 = 0;
            *(_QWORD *)&v130 = v35;
            if (v35
              && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v130)
              && ((v36 = v5[1], !mlir::DenseElementsAttr::classof(v36)) ? (v37 = 0) : (v37 = v36),
                  (*(_QWORD *)&v130 = v37) != 0
               && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v130)))
            {
              v38 = v5[1];
              v120 = *v5;
              v117 = v38;
              v39 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v120);
              if (v39 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v117))
              {
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v120, (uint64_t)&v130);
                v128 = v130;
                v129 = v131[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v128, (llvm::APInt *)&v107);
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v117, (uint64_t)&v130);
                v128 = v130;
                v129 = v131[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v128, (llvm::APInt *)&v105);
                llvm::APInt::operator*((uint64_t)&v107, &v105, (uint64_t)&v128);
                DWORD2(v130) = DWORD2(v128);
                *(_QWORD *)&v130 = v128;
                LOBYTE(v131[0]) = 1;
                if (v106 >= 0x41 && v105)
                  MEMORY[0x20BD002D4](v105, 0x1000C8000313F17);
                if (v108 >= 0x41 && v107)
                  MEMORY[0x20BD002D4](v107, 0x1000C8000313F17);
                v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v14 + 8);
                v28 = mlir::DenseElementsAttr::get(v14, v40, (llvm::APInt *)&v130, 1);
                if (LOBYTE(v131[0]))
                  goto LABEL_63;
                goto LABEL_150;
              }
            }
            else
            {
              if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v5 + 8)
                || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5[1] + 8))
              {
                return 0;
              }
              v41 = (_QWORD *)*v5;
              if (*v5)
                v42 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v41 + 8);
              else
                v42 = 0;
              v103 = v41;
              v104 = v42;
              v51 = (_QWORD *)v5[1];
              if (v51)
                v52 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v51 + 8);
              else
                v52 = 0;
              v102[0] = v51;
              v102[1] = v52;
              v53 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v103);
              if (v53 == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v102))
              {
                mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v103, (uint64_t)&v128);
                mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v102, (uint64_t)&v120);
                v28 = 0;
                v54 = v123;
                if (BYTE8(v129) && v123)
                {
                  LOWORD(v117) = v128;
                  if ((_BYTE)v128)
                    v118 = *((_QWORD *)&v128 + 1);
                  else
                    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v128 + 1) + 16))(&v118);
                  v119 = v129;
                  LOWORD(v114) = v120;
                  if ((_BYTE)v120)
                    v115 = v121;
                  else
                    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v121 + 16))(&v115);
                  v116 = v122;
                  *(_QWORD *)&v130 = v131;
                  *((_QWORD *)&v130 + 1) = 0x400000000;
                  v60 = mlir::ElementsAttr::getNumElements((uint64_t)v103, v104);
                  llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v130, v60);
                  v61 = mlir::ElementsAttr::getNumElements((uint64_t)v103, v104);
                  if (v61)
                  {
                    v62 = v61;
                    v63 = v119;
                    while (1)
                    {
                      if (BYTE1(v117))
                        v64 = 0;
                      else
                        v64 = v63;
                      if ((_BYTE)v117)
                      {
                        v65 = v118 + 16 * v64;
                        v101 = *(_DWORD *)(v65 + 8);
                        if (v101 > 0x40)
                          llvm::APInt::initSlowCase((llvm::APInt *)&v100, (const void **)v65);
                        else
                          v100 = *(const void **)v65;
                      }
                      else
                      {
                        (*(void (**)(const void **__return_ptr))(*(_QWORD *)v118 + 24))(&v100);
                      }
                      if (BYTE1(v114))
                        v66 = 0;
                      else
                        v66 = v116;
                      if ((_BYTE)v114)
                      {
                        v67 = v115 + 16 * v66;
                        v99 = *(_DWORD *)(v67 + 8);
                        if (v99 > 0x40)
                          llvm::APInt::initSlowCase((llvm::APInt *)&v98, (const void **)v67);
                        else
                          v98 = *(const unint64_t **)v67;
                      }
                      else
                      {
                        (*(void (**)(const unint64_t **__return_ptr))(*(_QWORD *)v115 + 24))(&v98);
                      }
                      llvm::APInt::operator*((uint64_t)&v100, &v98, (uint64_t)&v126);
                      v112 = v127;
                      v111 = (uint64_t)v126;
                      v113 = 1;
                      if (v99 >= 0x41 && v98)
                        MEMORY[0x20BD002D4](v98, 0x1000C8000313F17);
                      if (v101 >= 0x41 && v100)
                        MEMORY[0x20BD002D4](v100, 0x1000C8000313F17);
                      if (!v113)
                        break;
                      v68 = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v130, (unint64_t)&v111, 1);
                      v69 = (llvm::APInt *)(v130 + 16 * DWORD2(v130));
                      v70 = *((_DWORD *)v68 + 2);
                      *((_DWORD *)v69 + 2) = v70;
                      if (v70 > 0x40)
                        llvm::APInt::initSlowCase(v69, (const void **)v68);
                      else
                        *(_QWORD *)v69 = *(_QWORD *)v68;
                      ++DWORD2(v130);
                      if (v113 && v112 >= 0x41 && v111)
                        MEMORY[0x20BD002D4](v111, 0x1000C8000313F17);
                      v63 = ++v119;
                      ++v116;
                      if (!--v62)
                        goto LABEL_210;
                    }
                    v28 = 0;
                  }
                  else
                  {
LABEL_210:
                    v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v14 + 8);
                    v28 = mlir::DenseElementsAttr::get(v14, v71, (llvm::APInt *)v130, DWORD2(v130));
                  }
                  v72 = (char *)v130;
                  if (DWORD2(v130))
                  {
                    v73 = 16 * DWORD2(v130);
                    do
                    {
                      if (*(_DWORD *)&v72[v73 - 8] >= 0x41u)
                      {
                        v74 = *(_QWORD *)&v72[v73 - 16];
                        if (v74)
                          MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
                      }
                      v73 -= 16;
                    }
                    while (v73);
                    v72 = (char *)v130;
                  }
                  if (v72 != (char *)v131)
                    free(v72);
                  if (!(_BYTE)v114)
                  {
                    v75 = v115;
                    v115 = 0;
                    if (v75)
                      (*(void (**)(uint64_t))(*(_QWORD *)v75 + 8))(v75);
                  }
                  if (!(_BYTE)v117)
                  {
                    v76 = v118;
                    v118 = 0;
                    if (v76)
                      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 8))(v76);
                  }
                  v54 = v123;
                }
                if (v54)
                {
                  if (!(_BYTE)v120)
                  {
                    v77 = v121;
                    v121 = 0;
                    if (v77)
                      (*(void (**)(uint64_t))(*(_QWORD *)v77 + 8))(v77);
                  }
                }
                if (BYTE8(v129))
                {
                  if (!(_BYTE)v128)
                  {
                    v78 = *((_QWORD *)&v128 + 1);
                    *((_QWORD *)&v128 + 1) = 0;
                    if (v78)
                      (*(void (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
                  }
                }
                goto LABEL_150;
              }
            }
          }
          v28 = 0;
          goto LABEL_150;
        }
      }
      else
      {
        v130 = 0uLL;
      }
    }
    else
    {
      v130 = 0uLL;
    }
    return 0;
  }
  DWORD2(v130) = 1;
  *(_QWORD *)&v130 = 0;
  *(_QWORD *)&v128 = &v130;
  v7 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v128, v6);
  v8 = DWORD2(v130);
  if (v7)
  {
    if (DWORD2(v130) < 0x41)
    {
      v9 = (_QWORD)v130 == 0;
      goto LABEL_8;
    }
    if (v8 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v130) > 0x40)
    {
      if ((_QWORD)v130)
        MEMORY[0x20BD002D4](v130, 0x1000C8000313F17);
      goto LABEL_16;
    }
    v9 = *(_QWORD *)v130 == 0;
  }
  else
  {
    v9 = 0;
    if (DWORD2(v130) < 0x41)
      goto LABEL_8;
  }
  if ((_QWORD)v130)
    MEMORY[0x20BD002D4](v130, 0x1000C8000313F17);
LABEL_8:
  if (!v9)
  {
LABEL_16:
    v5 = *(uint64_t **)(a2 + 40);
    goto LABEL_17;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8) & 0xFFFFFFFFFFFFFFFBLL;
  v11 = *(unsigned int *)(a3 + 8);
  if (v11 >= *(_DWORD *)(a3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a3 + 8 * v11) = v10;
  v12 = *(_DWORD *)(a3 + 12);
  v13 = (*(_DWORD *)(a3 + 8) + 1);
  *(_DWORD *)(a3 + 8) = v13;
LABEL_165:
  if (v13 >= v12)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a3 + 8 * v13) = v10;
  ++*(_DWORD *)(a3 + 8);
  return 1;
}

void mlir::arith::MulSIExtendedOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  __int16 v72;
  _OWORD v73[3];
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  *(_QWORD *)&v73[0] = "arith.muli";
  *((_QWORD *)&v73[0] + 1) = 10;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.mulsi_extended", 20, v72, a2, v73, 1uLL);
  *(_QWORD *)v4 = &off_24C029920;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  *(_QWORD *)&v73[0] = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::MulSIExtendedToMulI]";
  *((_QWORD *)&v73[0] + 1) = 92;
  v9 = llvm::StringRef::find((uint64_t *)v73, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v73[0] + 1) >= v9)
    v10 = v9;
  else
    v10 = *((_QWORD *)&v73[0] + 1);
  v11 = *(_QWORD *)&v73[0] + v10;
  v12 = *((_QWORD *)&v73[0] + 1) - v10;
  if (*((_QWORD *)&v73[0] + 1) - v10 >= 0x12)
    v13 = 18;
  else
    v13 = *((_QWORD *)&v73[0] + 1) - v10;
  v14 = v11 + v13;
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_78;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_79;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_82;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_82:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  v73[0] = xmmword_24C060A40;
  v73[1] = *(_OWORD *)&off_24C060A50;
  v73[2] = xmmword_24C060A60;
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"arith.mulsi_extended", 20, v72, a2, v73, 3uLL);
  *(_QWORD *)v38 = &off_24C0298E0;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  *(_QWORD *)&v73[0] = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::MulSIExtendedRHSOne]";
  *((_QWORD *)&v73[0] + 1) = 92;
  v43 = llvm::StringRef::find((uint64_t *)v73, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v73[0] + 1) >= v43)
    v44 = v43;
  else
    v44 = *((_QWORD *)&v73[0] + 1);
  v45 = *(_QWORD *)&v73[0] + v44;
  v46 = *((_QWORD *)&v73[0] + 1) - v44;
  if (*((_QWORD *)&v73[0] + 1) - v44 >= 0x12)
    v47 = 18;
  else
    v47 = *((_QWORD *)&v73[0] + 1) - v44;
  v48 = v45 + v47;
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
LABEL_78:
    abort();
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (!v54)
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
    goto LABEL_74;
  }
  if (v54 >> 61)
LABEL_79:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v55 = (char *)operator new(8 * v54);
  v56 = (uint64_t *)&v55[8 * v51];
  v57 = &v55[8 * v54];
  *v56 = v38;
  v42 = (uint64_t)(v56 + 1);
  v58 = (char *)(v41 - v50);
  if (v41 != v50)
  {
LABEL_62:
    v59 = (unint64_t)(v58 - 8);
    if (v59 < 0x78
      || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
      && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
    {
      goto LABEL_83;
    }
    v60 = (v59 >> 3) + 1;
    v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
    v62 = &v41[-v61];
    v56 = (uint64_t *)((char *)v56 - v61);
    v63 = &v55[8 * v51 - 16];
    v64 = v41 - 16;
    v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v67 = *((_OWORD *)v64 - 1);
      v66 = *(_OWORD *)v64;
      *((_OWORD *)v64 - 1) = 0uLL;
      *(_OWORD *)v64 = 0uLL;
      *((_OWORD *)v63 - 1) = v67;
      *(_OWORD *)v63 = v66;
      v63 -= 32;
      v64 -= 32;
      v65 -= 4;
    }
    while (v65);
    v41 = v62;
    if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_83:
      do
      {
        v68 = *((_QWORD *)v41 - 1);
        v41 -= 8;
        *(_QWORD *)v41 = 0;
        *--v56 = v68;
      }
      while (v41 != v50);
    }
    v41 = (char *)a1[1];
    v69 = (char *)a1[2];
    a1[1] = v56;
    a1[2] = v42;
    a1[3] = v57;
    while (v69 != v41)
    {
      v71 = *((_QWORD *)v69 - 1);
      v69 -= 8;
      v70 = v71;
      *(_QWORD *)v69 = 0;
      if (v71)
        (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
    }
    goto LABEL_75;
  }
LABEL_74:
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
}

uint64_t mlir::arith::MulUIExtendedOp::fold(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  int v8;
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  BOOL v15;
  unint64_t ZeroAttr;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t canMapOperands;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t result;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t Value;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t Type;
  uint64_t v67;
  int v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  llvm::APInt *v78;
  unsigned int v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t NumElements;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *Address;
  llvm::APInt *v97;
  unsigned int v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  const unint64_t *v107;
  unsigned int v108;
  const void *v109;
  unsigned int v110;
  _QWORD v111[2];
  _QWORD *v112;
  uint64_t v113;
  const unint64_t *v114;
  unsigned int v115;
  const void *v116;
  unsigned int v117;
  const unint64_t *v118;
  unsigned int v119;
  uint64_t v120;
  unsigned int v121;
  char v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unsigned __int8 v132;
  _QWORD *v133;
  uint64_t v134;
  _QWORD *v135;
  uint64_t v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  _OWORD v140[4];
  uint64_t v141;

  v141 = *MEMORY[0x24BDAC8D0];
  v5 = *(uint64_t **)(a2 + 40);
  v6 = v5[1];
  if (!v6)
    goto LABEL_31;
  DWORD2(v139) = 1;
  *(_QWORD *)&v139 = 0;
  *(_QWORD *)&v137 = &v139;
  v8 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v137, v6);
  v9 = DWORD2(v139);
  if (!v8)
  {
    v10 = 0;
    if (DWORD2(v139) < 0x41)
      goto LABEL_22;
    goto LABEL_6;
  }
  if (DWORD2(v139) < 0x41)
  {
    v10 = (_QWORD)v139 == 0;
    goto LABEL_22;
  }
  if (v9 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v139) < 0x41)
  {
    v10 = *(_QWORD *)v139 == 0;
LABEL_6:
    v11 = v139;
    if ((_QWORD)v139)
      goto LABEL_7;
LABEL_22:
    v5 = *(uint64_t **)(a2 + 40);
    v12 = v5[1];
    if (v10)
      goto LABEL_23;
LABEL_8:
    if (v12)
    {
      DWORD2(v139) = 1;
      *(_QWORD *)&v139 = 0;
      *(_QWORD *)&v137 = &v139;
      v13 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v137, v12);
      v14 = DWORD2(v139);
      if (v13)
      {
        if (DWORD2(v139) < 0x41)
        {
          v15 = (_QWORD)v139 == 1;
          goto LABEL_17;
        }
        if (v14 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v139) > 0x40)
        {
          if ((_QWORD)v139)
            MEMORY[0x20BD002D4](v139, 0x1000C8000313F17);
LABEL_30:
          v5 = *(uint64_t **)(a2 + 40);
          goto LABEL_31;
        }
        v15 = *(_QWORD *)v139 == 1;
      }
      else
      {
        v15 = 0;
        if (DWORD2(v139) < 0x41)
          goto LABEL_17;
      }
      if ((_QWORD)v139)
        MEMORY[0x20BD002D4](v139, 0x1000C8000313F17);
LABEL_17:
      if (v15)
      {
        *(_QWORD *)&v139 = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
        ZeroAttr = (unint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v139, (mlir::MLIRContext *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72)+ 24)+ 8) & 0xFFFFFFFFFFFFFFF8));
        v17 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
        v18 = *(unsigned int *)(a3 + 8);
        if (v18 >= *(_DWORD *)(a3 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a3 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a3 + 8 * v18) = v17;
        v19 = *(_DWORD *)(a3 + 12);
        v20 = (*(_DWORD *)(a3 + 8) + 1);
        *(_DWORD *)(a3 + 8) = v20;
        v21 = ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
        goto LABEL_179;
      }
      goto LABEL_30;
    }
LABEL_31:
    v23 = *v5;
    if (*v5 && *(_UNKNOWN **)(*(_QWORD *)v23 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      v24 = *v5;
      goto LABEL_42;
    }
    v24 = v5[1];
    if (v24 && *(_UNKNOWN **)(*(_QWORD *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
LABEL_42:
      v28 = *(uint64_t **)(a2 + 40);
      canMapOperands = *v28;
      if (*v28
        && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
      {
        v30 = *v28;
        goto LABEL_176;
      }
      v30 = v28[1];
      if (v30 && *(_UNKNOWN **)(*(_QWORD *)v30 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        goto LABEL_176;
      if (canMapOperands)
      {
        if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
        {
          v31 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
          *(_QWORD *)&v139 = canMapOperands;
          *((_QWORD *)&v139 + 1) = v31;
          canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v139);
        }
        else
        {
          canMapOperands = 0;
          v139 = 0uLL;
        }
      }
      else
      {
        v139 = 0uLL;
      }
      v30 = v28[1];
      if (!v30)
      {
        v139 = 0uLL;
        goto LABEL_176;
      }
      if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v30 + 8))
      {
        v30 = 0;
        v139 = 0uLL;
        goto LABEL_176;
      }
      v32 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v30 + 8);
      *(_QWORD *)&v139 = v30;
      *((_QWORD *)&v139 + 1) = v32;
      v39 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v139);
      v30 = 0;
      if (!canMapOperands || !v39 || canMapOperands != v39)
        goto LABEL_176;
      v40 = *v28;
      if (*v28
        && *(_UNKNOWN **)(*(_QWORD *)v40 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
      {
        v30 = *v28;
        goto LABEL_176;
      }
      v41 = v28[1];
      if (v41)
      {
        v42 = *(void **)(*(_QWORD *)v41 + 136);
        if (v42 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          v30 = v28[1];
        else
          v30 = 0;
        if (!v40 || v42 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          goto LABEL_176;
        if (v42 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
          && *(_UNKNOWN **)(*(_QWORD *)v40 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        {
          v126 = *v28;
          v123 = v41;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v126);
          if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v123))
          {
            mlir::IntegerAttr::getValue(&v126, (llvm::APInt *)&v137);
            mlir::IntegerAttr::getValue(&v123, (llvm::APInt *)&v129);
            mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::MulUIExtendedOp::fold(mlir::arith::MulUIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::MulUIExtendedOp::fold(mlir::arith::MulUIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v139, (llvm::APInt *)&v137, (llvm::APInt *)&v129);
            if (v130 >= 0x41 && v129)
              MEMORY[0x20BD002D4](v129, 0x1000C8000313F17);
            if (DWORD2(v137) >= 0x41 && (_QWORD)v137)
              MEMORY[0x20BD002D4](v137, 0x1000C8000313F17);
            if (LOBYTE(v140[0]))
            {
              v30 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v139);
              if (LOBYTE(v140[0]))
              {
LABEL_107:
                if (DWORD2(v139) >= 0x41 && (_QWORD)v139)
                  MEMORY[0x20BD002D4](v139, 0x1000C8000313F17);
              }
LABEL_176:
              v67 = *(unsigned int *)(a3 + 8);
              if (v67 >= *(_DWORD *)(a3 + 12))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v67 + 1, 8);
                LODWORD(v67) = *(_DWORD *)(a3 + 8);
              }
              *(_QWORD *)(*(_QWORD *)a3 + 8 * v67) = v24 & 0xFFFFFFFFFFFFFFFBLL;
              v19 = *(_DWORD *)(a3 + 12);
              v20 = (*(_DWORD *)(a3 + 8) + 1);
              *(_DWORD *)(a3 + 8) = v20;
              v21 = v30 & 0xFFFFFFFFFFFFFFFBLL;
              goto LABEL_179;
            }
          }
        }
        else
        {
          if (mlir::DenseElementsAttr::classof(*v28))
            v52 = v40;
          else
            v52 = 0;
          *(_QWORD *)&v139 = v52;
          if (v52
            && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v139)
            && ((v53 = v28[1], !mlir::DenseElementsAttr::classof(v53)) ? (v54 = 0) : (v54 = v53),
                (*(_QWORD *)&v139 = v54) != 0
             && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v139)))
          {
            v55 = v28[1];
            v123 = *v28;
            v120 = v55;
            v56 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v123);
            if (v56 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v120))
            {
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v123, (uint64_t)&v139);
              v137 = v139;
              v138 = v140[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v137, (llvm::APInt *)&v129);
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v120, (uint64_t)&v139);
              v137 = v139;
              v138 = v140[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v137, (llvm::APInt *)&v126);
              mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::MulUIExtendedOp::fold(mlir::arith::MulUIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::MulUIExtendedOp::fold(mlir::arith::MulUIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v139, (llvm::APInt *)&v129, (llvm::APInt *)&v126);
              if (v127 >= 0x41 && v126)
                MEMORY[0x20BD002D4](v126, 0x1000C8000313F17);
              if (v130 >= 0x41 && v129)
                MEMORY[0x20BD002D4](v129, 0x1000C8000313F17);
              if (LOBYTE(v140[0]))
              {
                v57 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                v30 = mlir::DenseElementsAttr::get(canMapOperands, v57, (llvm::APInt *)&v139, 1);
                if (LOBYTE(v140[0]))
                  goto LABEL_107;
                goto LABEL_176;
              }
            }
          }
          else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v28 + 8)
                 && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v28[1] + 8))
          {
            v58 = (_QWORD *)*v28;
            v59 = *v28 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v58 + 8) : 0;
            v135 = v58;
            v136 = v59;
            v64 = (_QWORD *)v28[1];
            v65 = v64 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v64 + 8) : 0;
            v133 = v64;
            v134 = v65;
            Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v135);
            if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v133))
            {
              mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v135, (uint64_t)&v137);
              mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v133, (uint64_t)&v129);
              v30 = 0;
              v68 = v132;
              if (BYTE8(v138) && v132)
              {
                LOWORD(v126) = v137;
                if ((_BYTE)v137)
                  v127 = *((_QWORD *)&v137 + 1);
                else
                  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v137 + 1) + 16))(&v127);
                v128 = v138;
                LOWORD(v123) = v129;
                if ((_BYTE)v129)
                  v124 = v130;
                else
                  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v130 + 16))(&v124);
                v125 = v131;
                *(_QWORD *)&v139 = v140;
                *((_QWORD *)&v139 + 1) = 0x400000000;
                NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v135, v136);
                llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v139, NumElements);
                v89 = mlir::ElementsAttr::getNumElements((uint64_t)v135, v136);
                if (v89)
                {
                  v90 = v89;
                  v91 = v128;
                  while (1)
                  {
                    if (BYTE1(v126))
                      v92 = 0;
                    else
                      v92 = v91;
                    if ((_BYTE)v126)
                    {
                      v93 = v127 + 16 * v92;
                      v119 = *(_DWORD *)(v93 + 8);
                      if (v119 > 0x40)
                        llvm::APInt::initSlowCase((llvm::APInt *)&v118, (const void **)v93);
                      else
                        v118 = *(const unint64_t **)v93;
                    }
                    else
                    {
                      (*(void (**)(const unint64_t **__return_ptr))(*(_QWORD *)v127 + 24))(&v118);
                    }
                    if (BYTE1(v123))
                      v94 = 0;
                    else
                      v94 = v125;
                    if ((_BYTE)v123)
                    {
                      v95 = v124 + 16 * v94;
                      v117 = *(_DWORD *)(v95 + 8);
                      if (v117 > 0x40)
                        llvm::APInt::initSlowCase((llvm::APInt *)&v116, (const void **)v95);
                      else
                        v116 = *(const void **)v95;
                    }
                    else
                    {
                      (*(void (**)(const void **__return_ptr))(*(_QWORD *)v124 + 24))(&v116);
                    }
                    mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::MulUIExtendedOp::fold(mlir::arith::MulUIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::MulUIExtendedOp::fold(mlir::arith::MulUIExtendedOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)::$_1 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v120, (llvm::APInt *)&v118, (llvm::APInt *)&v116);
                    if (v117 >= 0x41 && v116)
                      MEMORY[0x20BD002D4](v116, 0x1000C8000313F17);
                    if (v119 >= 0x41 && v118)
                      MEMORY[0x20BD002D4](v118, 0x1000C8000313F17);
                    if (!v122)
                      break;
                    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v139, (unint64_t)&v120, 1);
                    v97 = (llvm::APInt *)(v139 + 16 * DWORD2(v139));
                    v98 = *((_DWORD *)Address + 2);
                    *((_DWORD *)v97 + 2) = v98;
                    if (v98 > 0x40)
                      llvm::APInt::initSlowCase(v97, (const void **)Address);
                    else
                      *(_QWORD *)v97 = *(_QWORD *)Address;
                    ++DWORD2(v139);
                    if (v122 && v121 >= 0x41 && v120)
                      MEMORY[0x20BD002D4](v120, 0x1000C8000313F17);
                    v91 = ++v128;
                    ++v125;
                    if (!--v90)
                      goto LABEL_287;
                  }
                  v30 = 0;
                }
                else
                {
LABEL_287:
                  v99 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                  v30 = mlir::DenseElementsAttr::get(canMapOperands, v99, (llvm::APInt *)v139, DWORD2(v139));
                }
                v100 = (char *)v139;
                if (DWORD2(v139))
                {
                  v101 = 16 * DWORD2(v139);
                  do
                  {
                    if (*(_DWORD *)&v100[v101 - 8] >= 0x41u)
                    {
                      v102 = *(_QWORD *)&v100[v101 - 16];
                      if (v102)
                        MEMORY[0x20BD002D4](v102, 0x1000C8000313F17);
                    }
                    v101 -= 16;
                  }
                  while (v101);
                  v100 = (char *)v139;
                }
                if (v100 != (char *)v140)
                  free(v100);
                if (!(_BYTE)v123)
                {
                  v103 = v124;
                  v124 = 0;
                  if (v103)
                    (*(void (**)(uint64_t))(*(_QWORD *)v103 + 8))(v103);
                }
                if (!(_BYTE)v126)
                {
                  v104 = v127;
                  v127 = 0;
                  if (v104)
                    (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
                }
                v68 = v132;
              }
              if (v68)
              {
                if (!(_BYTE)v129)
                {
                  v105 = v130;
                  v130 = 0;
                  if (v105)
                    (*(void (**)(uint64_t))(*(_QWORD *)v105 + 8))(v105);
                }
              }
              if (BYTE8(v138))
              {
                if (!(_BYTE)v137)
                {
                  v106 = *((_QWORD *)&v137 + 1);
                  *((_QWORD *)&v137 + 1) = 0;
                  if (v106)
                    (*(void (**)(uint64_t))(*(_QWORD *)v106 + 8))(v106);
                }
              }
              goto LABEL_176;
            }
          }
        }
      }
      v30 = 0;
      goto LABEL_176;
    }
    if (v23)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v23 + 8))
      {
        v25 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v23 + 8);
        *(_QWORD *)&v139 = v23;
        *((_QWORD *)&v139 + 1) = v25;
        v23 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v139);
      }
      else
      {
        v23 = 0;
        v139 = 0uLL;
      }
    }
    else
    {
      v139 = 0uLL;
    }
    v26 = (_QWORD *)v5[1];
    if (v26)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v26 + 8))
      {
        v27 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v26 + 8);
        *(_QWORD *)&v139 = v26;
        *((_QWORD *)&v139 + 1) = v27;
        v33 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v139);
        result = 0;
        if (!v23 || !v33 || v23 != v33)
          return result;
        v24 = *v5;
        if (*v5
          && *(_UNKNOWN **)(*(_QWORD *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          goto LABEL_42;
        }
        v35 = v5[1];
        if (v35)
        {
          v36 = *(void **)(*(_QWORD *)v35 + 136);
          if (v36 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            v37 = v5[1];
          else
            v37 = 0;
          if (!v24 || v36 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
            goto LABEL_164;
          if (v36 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
            && *(_UNKNOWN **)(*(_QWORD *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          {
            v129 = *v5;
            v126 = v35;
            v38 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v129);
            if (v38 == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v126))
            {
              mlir::IntegerAttr::getValue(&v129, (llvm::APInt *)&v133);
              mlir::IntegerAttr::getValue(&v126, (llvm::APInt *)&v118);
              llvm::APInt::operator*((uint64_t)&v133, &v118, (uint64_t)&v137);
              DWORD2(v139) = DWORD2(v137);
              *(_QWORD *)&v139 = v137;
              LOBYTE(v140[0]) = 1;
              if (v119 >= 0x41 && v118)
                MEMORY[0x20BD002D4](v118, 0x1000C8000313F17);
              if (v134 >= 0x41 && v133)
                MEMORY[0x20BD002D4](v133, 0x1000C8000313F17);
              v37 = mlir::IntegerAttr::get(v23, (llvm::APInt *)&v139);
              if (LOBYTE(v140[0]))
              {
LABEL_77:
                if (DWORD2(v139) >= 0x41 && (_QWORD)v139)
                  MEMORY[0x20BD002D4](v139, 0x1000C8000313F17);
              }
LABEL_164:
              v24 = v37;
              if (!v37)
                return 0;
              goto LABEL_42;
            }
          }
          else
          {
            if (mlir::DenseElementsAttr::classof(*v5))
              v44 = v24;
            else
              v44 = 0;
            *(_QWORD *)&v139 = v44;
            if (v44
              && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v139)
              && ((v45 = v5[1], !mlir::DenseElementsAttr::classof(v45)) ? (v46 = 0) : (v46 = v45),
                  (*(_QWORD *)&v139 = v46) != 0
               && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v139)))
            {
              v47 = v5[1];
              v129 = *v5;
              v126 = v47;
              v48 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v129);
              if (v48 == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v126))
              {
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v129, (uint64_t)&v139);
                v137 = v139;
                v138 = v140[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v137, (llvm::APInt *)&v116);
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v126, (uint64_t)&v139);
                v137 = v139;
                v138 = v140[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v137, (llvm::APInt *)&v114);
                llvm::APInt::operator*((uint64_t)&v116, &v114, (uint64_t)&v137);
                DWORD2(v139) = DWORD2(v137);
                *(_QWORD *)&v139 = v137;
                LOBYTE(v140[0]) = 1;
                if (v115 >= 0x41 && v114)
                  MEMORY[0x20BD002D4](v114, 0x1000C8000313F17);
                if (v117 >= 0x41 && v116)
                  MEMORY[0x20BD002D4](v116, 0x1000C8000313F17);
                v49 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v23 + 8);
                v37 = mlir::DenseElementsAttr::get(v23, v49, (llvm::APInt *)&v139, 1);
                if (LOBYTE(v140[0]))
                  goto LABEL_77;
                goto LABEL_164;
              }
            }
            else
            {
              if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v5 + 8)
                || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5[1] + 8))
              {
                return 0;
              }
              v50 = (_QWORD *)*v5;
              if (*v5)
                v51 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v50 + 8);
              else
                v51 = 0;
              v112 = v50;
              v113 = v51;
              v60 = (_QWORD *)v5[1];
              if (v60)
                v61 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v60 + 8);
              else
                v61 = 0;
              v111[0] = v60;
              v111[1] = v61;
              v62 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v112);
              if (v62 == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v111))
              {
                mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v112, (uint64_t)&v137);
                mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v111, (uint64_t)&v129);
                v37 = 0;
                v63 = v132;
                if (BYTE8(v138) && v132)
                {
                  LOWORD(v126) = v137;
                  if ((_BYTE)v137)
                    v127 = *((_QWORD *)&v137 + 1);
                  else
                    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v137 + 1) + 16))(&v127);
                  v128 = v138;
                  LOWORD(v123) = v129;
                  if ((_BYTE)v129)
                    v124 = v130;
                  else
                    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v130 + 16))(&v124);
                  v125 = v131;
                  *(_QWORD *)&v139 = v140;
                  *((_QWORD *)&v139 + 1) = 0x400000000;
                  v69 = mlir::ElementsAttr::getNumElements((uint64_t)v112, v113);
                  llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v139, v69);
                  v70 = mlir::ElementsAttr::getNumElements((uint64_t)v112, v113);
                  if (v70)
                  {
                    v71 = v70;
                    v72 = v128;
                    while (1)
                    {
                      if (BYTE1(v126))
                        v73 = 0;
                      else
                        v73 = v72;
                      if ((_BYTE)v126)
                      {
                        v74 = v127 + 16 * v73;
                        v110 = *(_DWORD *)(v74 + 8);
                        if (v110 > 0x40)
                          llvm::APInt::initSlowCase((llvm::APInt *)&v109, (const void **)v74);
                        else
                          v109 = *(const void **)v74;
                      }
                      else
                      {
                        (*(void (**)(const void **__return_ptr))(*(_QWORD *)v127 + 24))(&v109);
                      }
                      if (BYTE1(v123))
                        v75 = 0;
                      else
                        v75 = v125;
                      if ((_BYTE)v123)
                      {
                        v76 = v124 + 16 * v75;
                        v108 = *(_DWORD *)(v76 + 8);
                        if (v108 > 0x40)
                          llvm::APInt::initSlowCase((llvm::APInt *)&v107, (const void **)v76);
                        else
                          v107 = *(const unint64_t **)v76;
                      }
                      else
                      {
                        (*(void (**)(const unint64_t **__return_ptr))(*(_QWORD *)v124 + 24))(&v107);
                      }
                      llvm::APInt::operator*((uint64_t)&v109, &v107, (uint64_t)&v135);
                      v121 = v136;
                      v120 = (uint64_t)v135;
                      v122 = 1;
                      if (v108 >= 0x41 && v107)
                        MEMORY[0x20BD002D4](v107, 0x1000C8000313F17);
                      if (v110 >= 0x41 && v109)
                        MEMORY[0x20BD002D4](v109, 0x1000C8000313F17);
                      if (!v122)
                        break;
                      v77 = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v139, (unint64_t)&v120, 1);
                      v78 = (llvm::APInt *)(v139 + 16 * DWORD2(v139));
                      v79 = *((_DWORD *)v77 + 2);
                      *((_DWORD *)v78 + 2) = v79;
                      if (v79 > 0x40)
                        llvm::APInt::initSlowCase(v78, (const void **)v77);
                      else
                        *(_QWORD *)v78 = *(_QWORD *)v77;
                      ++DWORD2(v139);
                      if (v122 && v121 >= 0x41 && v120)
                        MEMORY[0x20BD002D4](v120, 0x1000C8000313F17);
                      v72 = ++v128;
                      ++v125;
                      if (!--v71)
                        goto LABEL_224;
                    }
                    v37 = 0;
                  }
                  else
                  {
LABEL_224:
                    v80 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v23 + 8);
                    v37 = mlir::DenseElementsAttr::get(v23, v80, (llvm::APInt *)v139, DWORD2(v139));
                  }
                  v81 = (char *)v139;
                  if (DWORD2(v139))
                  {
                    v82 = 16 * DWORD2(v139);
                    do
                    {
                      if (*(_DWORD *)&v81[v82 - 8] >= 0x41u)
                      {
                        v83 = *(_QWORD *)&v81[v82 - 16];
                        if (v83)
                          MEMORY[0x20BD002D4](v83, 0x1000C8000313F17);
                      }
                      v82 -= 16;
                    }
                    while (v82);
                    v81 = (char *)v139;
                  }
                  if (v81 != (char *)v140)
                    free(v81);
                  if (!(_BYTE)v123)
                  {
                    v84 = v124;
                    v124 = 0;
                    if (v84)
                      (*(void (**)(uint64_t))(*(_QWORD *)v84 + 8))(v84);
                  }
                  if (!(_BYTE)v126)
                  {
                    v85 = v127;
                    v127 = 0;
                    if (v85)
                      (*(void (**)(uint64_t))(*(_QWORD *)v85 + 8))(v85);
                  }
                  v63 = v132;
                }
                if (v63)
                {
                  if (!(_BYTE)v129)
                  {
                    v86 = v130;
                    v130 = 0;
                    if (v86)
                      (*(void (**)(uint64_t))(*(_QWORD *)v86 + 8))(v86);
                  }
                }
                if (BYTE8(v138))
                {
                  if (!(_BYTE)v137)
                  {
                    v87 = *((_QWORD *)&v137 + 1);
                    *((_QWORD *)&v137 + 1) = 0;
                    if (v87)
                      (*(void (**)(uint64_t))(*(_QWORD *)v87 + 8))(v87);
                  }
                }
                goto LABEL_164;
              }
            }
          }
          v37 = 0;
          goto LABEL_164;
        }
      }
      else
      {
        v139 = 0uLL;
      }
    }
    else
    {
      v139 = 0uLL;
    }
    return 0;
  }
  v10 = 0;
  v11 = v139;
  if (!(_QWORD)v139)
    goto LABEL_22;
LABEL_7:
  MEMORY[0x20BD002D4](v11, 0x1000C8000313F17);
  v5 = *(uint64_t **)(a2 + 40);
  v12 = v5[1];
  if (!v10)
    goto LABEL_8;
LABEL_23:
  v21 = v12 & 0xFFFFFFFFFFFFFFFBLL;
  v22 = *(unsigned int *)(a3 + 8);
  if (v22 >= *(_DWORD *)(a3 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v22 + 1, 8);
    LODWORD(v22) = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a3 + 8 * v22) = v21;
  v19 = *(_DWORD *)(a3 + 12);
  v20 = (*(_DWORD *)(a3 + 8) + 1);
  *(_DWORD *)(a3 + 8) = v20;
LABEL_179:
  if (v20 >= v19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v20 + 1, 8);
    LODWORD(v20) = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a3 + 8 * v20) = v21;
  ++*(_DWORD *)(a3 + 8);
  return 1;
}

void mlir::arith::MulUIExtendedOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  unint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  v39 = "arith.muli";
  v40 = 10;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.mului_extended", 20, v38, a2, &v39, 1uLL);
  *(_QWORD *)v4 = &off_24C029960;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v39 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::MulUIExtendedToMulI]";
  v40 = 92;
  v9 = llvm::StringRef::find((uint64_t *)&v39, "DesiredTypeName = ", 0x12uLL, 0);
  if (v40 >= v9)
    v10 = v9;
  else
    v10 = v40;
  v11 = &v39[v10];
  v12 = v40 - v10;
  if (v40 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v40 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::arith::DivUIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  unsigned int v7;
  __int128 *v8;
  BOOL v9;
  uint64_t canMapOperands;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t Value;
  _QWORD *v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t Type;
  int v32;
  unint64_t NumElements;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *Address;
  llvm::APInt *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  const void *v55;
  unsigned int v56;
  const void *v57;
  unsigned int v58;
  const void *v59;
  unsigned int v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int8 v71;
  _QWORD v72[2];
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  const void *v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  const void *v81;
  unsigned int v82;
  const void *v83;
  unsigned int v84;
  const void *v85;
  unsigned int v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _OWORD v90[4];
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (v4)
  {
    DWORD2(v89) = 1;
    *(_QWORD *)&v89 = 0;
    *(_QWORD *)&v87 = &v89;
    v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v87, v4);
    v7 = DWORD2(v89);
    if (v6)
    {
      if (DWORD2(v89) >= 0x41)
      {
        if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v89) > 0x40)
        {
          if ((_QWORD)v89)
            MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
LABEL_16:
          v3 = *(uint64_t **)(a2 + 40);
          goto LABEL_17;
        }
        v8 = (__int128 *)v89;
      }
      else
      {
        v8 = &v89;
      }
      v9 = *(_QWORD *)v8 == 1;
      if (v7 < 0x41)
      {
LABEL_12:
        if (v9)
          return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
        goto LABEL_16;
      }
    }
    else
    {
      v9 = 0;
      if (DWORD2(v89) < 0x41)
        goto LABEL_12;
    }
    if ((_QWORD)v89)
      MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
    goto LABEL_12;
  }
LABEL_17:
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v12 = *v3;
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v12 = v3[1];
  if (v12 && *(_UNKNOWN **)(*(_QWORD *)v12 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      *(_QWORD *)&v89 = canMapOperands;
      *((_QWORD *)&v89 + 1) = v13;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v89);
    }
    else
    {
      canMapOperands = 0;
      v89 = 0uLL;
    }
  }
  else
  {
    v89 = 0uLL;
  }
  v12 = v3[1];
  if (!v12)
  {
    v89 = 0uLL;
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v12 + 8))
  {
    v12 = 0;
    v89 = 0uLL;
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v14 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v12 + 8);
  *(_QWORD *)&v89 = v12;
  *((_QWORD *)&v89 + 1) = v14;
  v15 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v89);
  v12 = 0;
  if (!canMapOperands || !v15 || canMapOperands != v15)
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  v16 = *v3;
  if (*v3 && *(_UNKNOWN **)(*(_QWORD *)v16 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v12 = *v3;
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v17 = v3[1];
  if (!v17)
  {
LABEL_92:
    v12 = 0;
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v18 = *(void **)(*(_QWORD *)v17 + 136);
  if (v18 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v12 = v3[1];
  else
    v12 = 0;
  if (!v16 || v18 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    return v12 & 0xFFFFFFFFFFFFFFFBLL;
  if (v18 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)v16 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    if (mlir::DenseElementsAttr::classof(*v3))
      v20 = v16;
    else
      v20 = 0;
    *(_QWORD *)&v89 = v20;
    if (v20 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v89))
    {
      v21 = v3[1];
      v22 = mlir::DenseElementsAttr::classof(v21) ? v21 : 0;
      *(_QWORD *)&v89 = v22;
      if (v22)
      {
        if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v89))
        {
          v23 = v3[1];
          v65 = *v3;
          v62 = v23;
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65);
          if (Value != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62))
            goto LABEL_90;
          mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v65, (uint64_t)&v89);
          v87 = v89;
          v88 = v90[0];
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v87, (llvm::APInt *)&v77);
          mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v62, (uint64_t)&v89);
          v87 = v89;
          v88 = v90[0];
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v87, (llvm::APInt *)&v75);
          LODWORD(v69) = v78;
          if (v78 > 0x40)
            llvm::APInt::initSlowCase((llvm::APInt *)&v68, &v77);
          else
            v68 = v77;
          v53 = v76;
          if (v76 > 0x40)
          {
            if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v75) != v53)
            {
LABEL_178:
              llvm::APInt::udiv(&v68, (const llvm::APInt *)&v75, (uint64_t)&v87);
              v28 = 0;
              DWORD2(v89) = DWORD2(v87);
              *(_QWORD *)&v89 = v87;
              DWORD2(v87) = 0;
              LOBYTE(v90[0]) = 1;
              if (v69 >= 0x41)
              {
                if (v68)
                  MEMORY[0x20BD002D4](v68, 0x1000C8000313F17);
                v28 = 0;
              }
LABEL_184:
              if (v76 >= 0x41 && v75)
                MEMORY[0x20BD002D4](v75, 0x1000C8000313F17);
              if (v78 >= 0x41 && v77)
                MEMORY[0x20BD002D4](v77, 0x1000C8000313F17);
              v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
              v12 = mlir::DenseElementsAttr::get(canMapOperands, v54, (llvm::APInt *)&v89, 1);
              if (LOBYTE(v90[0]))
                goto LABEL_82;
              goto LABEL_91;
            }
          }
          else if (v75)
          {
            goto LABEL_178;
          }
          DWORD2(v89) = v69;
          *(_QWORD *)&v89 = v68;
          v28 = 1;
          LOBYTE(v90[0]) = 1;
          goto LABEL_184;
        }
      }
    }
    if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
      || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
    {
      goto LABEL_92;
    }
    v25 = (_QWORD *)*v3;
    if (*v3)
      v26 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v25 + 8);
    else
      v26 = 0;
    v73 = v25;
    v74 = v26;
    v29 = (_QWORD *)v3[1];
    if (v29)
      v30 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v29 + 8);
    else
      v30 = 0;
    v72[0] = v29;
    v72[1] = v30;
    Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v73);
    if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v72))
      goto LABEL_90;
    mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v73, (uint64_t)&v87);
    mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v72, (uint64_t)&v68);
    v12 = 0;
    v28 = 0;
    v32 = v71;
    if (BYTE8(v88) && v71)
    {
      LOWORD(v65) = v87;
      if ((_BYTE)v87)
        v66 = *((_QWORD *)&v87 + 1);
      else
        (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v87 + 1) + 16))(&v66);
      v67 = v88;
      LOWORD(v62) = (_WORD)v68;
      if ((_BYTE)v68)
        v63 = v69;
      else
        (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v69 + 16))(&v63);
      v64 = v70;
      *(_QWORD *)&v89 = v90;
      *((_QWORD *)&v89 + 1) = 0x400000000;
      NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v73, v74);
      llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v89, NumElements);
      v34 = mlir::ElementsAttr::getNumElements((uint64_t)v73, v74);
      if (v34)
      {
        v35 = v34;
        v28 = 0;
        v36 = v67;
        while (1)
        {
          v37 = BYTE1(v65) ? 0 : v36;
          if ((_BYTE)v65)
          {
            v38 = v66 + 16 * v37;
            v58 = *(_DWORD *)(v38 + 8);
            if (v58 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v57, (const void **)v38);
            else
              v57 = *(const void **)v38;
          }
          else
          {
            (*(void (**)(const void **__return_ptr))(*(_QWORD *)v66 + 24))(&v57);
          }
          v39 = BYTE1(v62) ? 0 : v64;
          if ((_BYTE)v62)
          {
            v40 = v63 + 16 * v39;
            v56 = *(_DWORD *)(v40 + 8);
            if (v56 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v55, (const void **)v40);
            else
              v55 = *(const void **)v40;
          }
          else
          {
            (*(void (**)(const void **__return_ptr))(*(_QWORD *)v63 + 24))(&v55);
          }
          v84 = v58;
          if (v58 > 0x40)
            llvm::APInt::initSlowCase((llvm::APInt *)&v83, &v57);
          else
            v83 = v57;
          if (v28)
            break;
          v44 = v56;
          if (v56 > 0x40)
          {
            if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v55) == v44)
              break;
          }
          else if (!v55)
          {
            break;
          }
          llvm::APInt::udiv(&v83, (const llvm::APInt *)&v55, (uint64_t)&v85);
          v28 = 0;
          v60 = v86;
          v59 = v85;
          v86 = 0;
          v61 = 1;
          if (v84 >= 0x41)
          {
            if (v83)
              MEMORY[0x20BD002D4](v83, 0x1000C8000313F17);
            v28 = 0;
          }
LABEL_126:
          if (v56 >= 0x41 && v55)
            MEMORY[0x20BD002D4](v55, 0x1000C8000313F17);
          if (v58 >= 0x41 && v57)
            MEMORY[0x20BD002D4](v57, 0x1000C8000313F17);
          if (!v61)
          {
            v12 = 0;
            goto LABEL_151;
          }
          Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v89, (unint64_t)&v59, 1);
          v42 = (llvm::APInt *)(v89 + 16 * DWORD2(v89));
          v43 = *((_DWORD *)Address + 2);
          *((_DWORD *)v42 + 2) = v43;
          if (v43 > 0x40)
            llvm::APInt::initSlowCase(v42, (const void **)Address);
          else
            *(_QWORD *)v42 = *(_QWORD *)Address;
          ++DWORD2(v89);
          if (v61 && v60 >= 0x41 && v59)
            MEMORY[0x20BD002D4](v59, 0x1000C8000313F17);
          v36 = ++v67;
          ++v64;
          if (!--v35)
            goto LABEL_149;
        }
        v60 = v84;
        v59 = v83;
        v28 = 1;
        v61 = 1;
        goto LABEL_126;
      }
      v28 = 0;
LABEL_149:
      v45 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
      v12 = mlir::DenseElementsAttr::get(canMapOperands, v45, (llvm::APInt *)v89, DWORD2(v89));
LABEL_151:
      v46 = (char *)v89;
      if (DWORD2(v89))
      {
        v47 = 16 * DWORD2(v89);
        do
        {
          if (*(_DWORD *)&v46[v47 - 8] >= 0x41u)
          {
            v48 = *(_QWORD *)&v46[v47 - 16];
            if (v48)
              MEMORY[0x20BD002D4](v48, 0x1000C8000313F17);
          }
          v47 -= 16;
        }
        while (v47);
        v46 = (char *)v89;
      }
      if (v46 != (char *)v90)
        free(v46);
      if (!(_BYTE)v62)
      {
        v49 = v63;
        v63 = 0;
        if (v49)
          (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
      }
      if (!(_BYTE)v65)
      {
        v50 = v66;
        v66 = 0;
        if (v50)
          (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
      }
      v32 = v71;
    }
    if (v32)
    {
      if (!(_BYTE)v68)
      {
        v51 = v69;
        v69 = 0;
        if (v51)
          (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
      }
    }
    if (BYTE8(v88))
    {
      if (!(_BYTE)v87)
      {
        v52 = *((_QWORD *)&v87 + 1);
        *((_QWORD *)&v87 + 1) = 0;
        if (v52)
          (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
      }
    }
    goto LABEL_91;
  }
  v65 = *v3;
  v62 = v17;
  v19 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65);
  if (v19 != mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62))
  {
LABEL_90:
    v28 = 0;
    v12 = 0;
    goto LABEL_91;
  }
  mlir::IntegerAttr::getValue(&v65, (llvm::APInt *)&v81);
  mlir::IntegerAttr::getValue(&v62, (llvm::APInt *)&v79);
  LODWORD(v69) = v82;
  if (v82 > 0x40)
    llvm::APInt::initSlowCase((llvm::APInt *)&v68, &v81);
  else
    v68 = v81;
  v27 = v80;
  if (v80 <= 0x40)
  {
    if (v79)
      goto LABEL_69;
LABEL_74:
    DWORD2(v89) = v69;
    *(_QWORD *)&v89 = v68;
    v28 = 1;
    LOBYTE(v90[0]) = 1;
    goto LABEL_75;
  }
  if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v79) == v27)
    goto LABEL_74;
LABEL_69:
  llvm::APInt::udiv(&v68, (const llvm::APInt *)&v79, (uint64_t)&v87);
  v28 = 0;
  DWORD2(v89) = DWORD2(v87);
  *(_QWORD *)&v89 = v87;
  DWORD2(v87) = 0;
  LOBYTE(v90[0]) = 1;
  if (v69 >= 0x41)
  {
    if (v68)
      MEMORY[0x20BD002D4](v68, 0x1000C8000313F17);
    v28 = 0;
  }
LABEL_75:
  if (v80 >= 0x41 && v79)
    MEMORY[0x20BD002D4](v79, 0x1000C8000313F17);
  if (v82 >= 0x41 && v81)
    MEMORY[0x20BD002D4](v81, 0x1000C8000313F17);
  v12 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v89);
  if (LOBYTE(v90[0]))
  {
LABEL_82:
    if (DWORD2(v89) >= 0x41)
    {
      if ((_QWORD)v89)
        MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
    }
  }
LABEL_91:
  if (v28)
    goto LABEL_92;
  return v12 & 0xFFFFFFFFFFFFFFFBLL;
}

mlir::Operation *mlir::arith::DivUIOp::getSpeculatability(mlir::arith::DivUIOp *this)
{
  uint64_t v1;
  mlir::Operation *result;
  BOOL (*v3)(llvm::APInt *);
  uint64_t v4;

  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 56);
  v3 = mlir::m_NonZero(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  v4 = v1;
  result = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v4);
  if (result)
    return (mlir::Operation *)mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(uint64_t *))&v3, result);
  return result;
}

unint64_t mlir::arith::DivSIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  int v7;
  BOOL v8;
  uint64_t canMapOperands;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t Value;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t Type;
  int v30;
  unint64_t NumElements;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *Address;
  llvm::APInt *v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  BOOL v53;
  const void *v54;
  unsigned int v55;
  const void *v56;
  unsigned int v57;
  uint64_t v58;
  unsigned int v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const void *v64;
  uint64_t v65;
  uint64_t v66;
  const void *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 v70;
  _QWORD v71[2];
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  unsigned int v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _OWORD v81[4];
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (v4)
  {
    DWORD2(v80) = 1;
    *(_QWORD *)&v80 = 0;
    *(_QWORD *)&v78 = &v80;
    v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v78, v4);
    v7 = DWORD2(v80);
    if (v6)
    {
      if (DWORD2(v80) < 0x41)
      {
        v8 = (_QWORD)v80 == 1;
        goto LABEL_8;
      }
      if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v80) > 0x40)
      {
        if ((_QWORD)v80)
          MEMORY[0x20BD002D4](v80, 0x1000C8000313F17);
LABEL_14:
        v3 = *(uint64_t **)(a2 + 40);
        goto LABEL_15;
      }
      v8 = *(_QWORD *)v80 == 1;
    }
    else
    {
      v8 = 0;
      if (DWORD2(v80) < 0x41)
        goto LABEL_8;
    }
    if ((_QWORD)v80)
      MEMORY[0x20BD002D4](v80, 0x1000C8000313F17);
LABEL_8:
    if (v8)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
    goto LABEL_14;
  }
LABEL_15:
  v53 = 0;
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_85;
  }
  v11 = v3[1];
  if (!v11 || *(_UNKNOWN **)(*(_QWORD *)v11 + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    if (canMapOperands)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
      {
        v12 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
        *(_QWORD *)&v80 = canMapOperands;
        *((_QWORD *)&v80 + 1) = v12;
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v80);
      }
      else
      {
        canMapOperands = 0;
        v80 = 0uLL;
      }
    }
    else
    {
      v80 = 0uLL;
    }
    v11 = v3[1];
    if (!v11)
    {
      v80 = 0uLL;
      goto LABEL_85;
    }
    if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8))
    {
      v11 = 0;
      v80 = 0uLL;
      goto LABEL_85;
    }
    v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8);
    *(_QWORD *)&v80 = v11;
    *((_QWORD *)&v80 + 1) = v13;
    v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v80);
    v11 = 0;
    if (canMapOperands)
    {
      if (v14 && canMapOperands == v14)
      {
        v15 = *v3;
        if (*v3
          && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          v11 = *v3;
          goto LABEL_85;
        }
        v16 = v3[1];
        if (!v16)
          goto LABEL_84;
        v17 = *(void **)(*(_QWORD *)v16 + 136);
        if (v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          v11 = v3[1];
        else
          v11 = 0;
        if (!v15 || v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          goto LABEL_85;
        if (v17 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
          && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        {
          v58 = *v3;
          v76 = v16;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
          if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v76))
          {
            mlir::IntegerAttr::getValue(&v58, (llvm::APInt *)&v64);
            mlir::IntegerAttr::getValue(&v76, (llvm::APInt *)&v61);
            LODWORD(v68) = v65;
            if (v65 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v67, &v64);
            else
              v67 = v64;
            v26 = v62;
            if (v62 > 0x40)
            {
              if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v61) == v26)
              {
LABEL_65:
                v53 = 1;
                DWORD2(v80) = v68;
                *(_QWORD *)&v80 = v67;
                LOBYTE(v81[0]) = 1;
                goto LABEL_66;
              }
            }
            else if (!v61)
            {
              goto LABEL_65;
            }
            llvm::APInt::sdiv_ov(&v67, (const llvm::APInt *)&v61, &v53, (uint64_t)&v78);
            DWORD2(v80) = DWORD2(v78);
            *(_QWORD *)&v80 = v78;
            DWORD2(v78) = 0;
            LOBYTE(v81[0]) = 1;
            if (v68 >= 0x41 && v67)
              MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
LABEL_66:
            if (v62 >= 0x41 && v61)
              MEMORY[0x20BD002D4](v61, 0x1000C8000313F17);
            if (v65 >= 0x41 && v64)
              MEMORY[0x20BD002D4](v64, 0x1000C8000313F17);
            v11 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v80);
            if (!LOBYTE(v81[0]))
              goto LABEL_85;
            goto LABEL_73;
          }
LABEL_84:
          v11 = 0;
          goto LABEL_85;
        }
        if (mlir::DenseElementsAttr::classof(*v3))
          v19 = v15;
        else
          v19 = 0;
        *(_QWORD *)&v80 = v19;
        if (v19 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v80))
        {
          v20 = v3[1];
          v21 = mlir::DenseElementsAttr::classof(v20) ? v20 : 0;
          *(_QWORD *)&v80 = v21;
          if (v21)
          {
            if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v80))
            {
              v22 = v3[1];
              v58 = *v3;
              v76 = v22;
              v23 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58);
              if (v23 != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v76))
                goto LABEL_84;
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v58, (uint64_t)&v80);
              v78 = v80;
              v79 = v81[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v78, (llvm::APInt *)&v64);
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v76, (uint64_t)&v80);
              v78 = v80;
              v79 = v81[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v78, (llvm::APInt *)&v61);
              LODWORD(v68) = v65;
              if (v65 > 0x40)
                llvm::APInt::initSlowCase((llvm::APInt *)&v67, &v64);
              else
                v67 = v64;
              v52 = v62;
              if (v62 > 0x40)
              {
                if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v61) == v52)
                {
LABEL_172:
                  v53 = 1;
                  DWORD2(v80) = v68;
                  *(_QWORD *)&v80 = v67;
                  LOBYTE(v81[0]) = 1;
                  goto LABEL_173;
                }
              }
              else if (!v61)
              {
                goto LABEL_172;
              }
              llvm::APInt::sdiv_ov(&v67, (const llvm::APInt *)&v61, &v53, (uint64_t)&v78);
              DWORD2(v80) = DWORD2(v78);
              *(_QWORD *)&v80 = v78;
              DWORD2(v78) = 0;
              LOBYTE(v81[0]) = 1;
              if (v68 >= 0x41 && v67)
                MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
LABEL_173:
              if (v62 >= 0x41 && v61)
                MEMORY[0x20BD002D4](v61, 0x1000C8000313F17);
              if (v65 >= 0x41 && v64)
                MEMORY[0x20BD002D4](v64, 0x1000C8000313F17);
              v51 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
              v11 = mlir::DenseElementsAttr::get(canMapOperands, v51, (llvm::APInt *)&v80, 1);
              if (!LOBYTE(v81[0]))
                goto LABEL_85;
LABEL_73:
              if (DWORD2(v80) >= 0x41 && (_QWORD)v80)
                MEMORY[0x20BD002D4](v80, 0x1000C8000313F17);
              goto LABEL_85;
            }
          }
        }
        if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
          || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
        {
          goto LABEL_84;
        }
        v24 = (_QWORD *)*v3;
        v25 = *v3 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v24 + 8) : 0;
        v72 = v24;
        v73 = v25;
        v27 = (_QWORD *)v3[1];
        v28 = v27 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v27 + 8) : 0;
        v71[0] = v27;
        v71[1] = v28;
        Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v72);
        if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v71))
          goto LABEL_84;
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v72, (uint64_t)&v78);
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v71, (uint64_t)&v67);
        v11 = 0;
        v30 = v70;
        if (!BYTE8(v79) || !v70)
          goto LABEL_163;
        LOWORD(v64) = v78;
        if ((_BYTE)v78)
          v65 = *((_QWORD *)&v78 + 1);
        else
          (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v78 + 1) + 16))(&v65);
        v66 = v79;
        LOWORD(v61) = (_WORD)v67;
        if ((_BYTE)v67)
          v62 = v68;
        else
          (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v68 + 16))(&v62);
        v63 = v69;
        *(_QWORD *)&v80 = v81;
        *((_QWORD *)&v80 + 1) = 0x400000000;
        NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v72, v73);
        llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v80, NumElements);
        v32 = mlir::ElementsAttr::getNumElements((uint64_t)v72, v73);
        if (!v32)
        {
LABEL_145:
          v43 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
          v11 = mlir::DenseElementsAttr::get(canMapOperands, v43, (llvm::APInt *)v80, DWORD2(v80));
          goto LABEL_147;
        }
        v33 = v32;
        v34 = v66;
        while (1)
        {
          v35 = BYTE1(v64) ? 0 : v34;
          if ((_BYTE)v64)
          {
            v36 = v65 + 16 * v35;
            v57 = *(_DWORD *)(v36 + 8);
            if (v57 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v56, (const void **)v36);
            else
              v56 = *(const void **)v36;
          }
          else
          {
            (*(void (**)(const void **__return_ptr))(*(_QWORD *)v65 + 24))(&v56);
          }
          v37 = BYTE1(v61) ? 0 : v63;
          if ((_BYTE)v61)
          {
            v38 = v62 + 16 * v37;
            v55 = *(_DWORD *)(v38 + 8);
            if (v55 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v54, (const void **)v38);
            else
              v54 = *(const void **)v38;
          }
          else
          {
            (*(void (**)(const void **__return_ptr))(*(_QWORD *)v62 + 24))(&v54);
          }
          v75 = v57;
          if (v57 > 0x40)
            llvm::APInt::initSlowCase((llvm::APInt *)&v74, &v56);
          else
            v74 = (uint64_t)v56;
          if (v53)
            break;
          v42 = v55;
          if (v55 > 0x40)
          {
            if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v54) == v42)
              break;
          }
          else if (!v54)
          {
            break;
          }
          llvm::APInt::sdiv_ov((const void **)&v74, (const llvm::APInt *)&v54, &v53, (uint64_t)&v76);
          v59 = v77;
          v58 = v76;
          v77 = 0;
          v60 = 1;
          if (v75 >= 0x41 && v74)
            MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_124:
          if (v55 >= 0x41 && v54)
            MEMORY[0x20BD002D4](v54, 0x1000C8000313F17);
          if (v57 >= 0x41 && v56)
            MEMORY[0x20BD002D4](v56, 0x1000C8000313F17);
          if (!v60)
          {
            v11 = 0;
LABEL_147:
            v44 = (char *)v80;
            if (DWORD2(v80))
            {
              v45 = 16 * DWORD2(v80);
              do
              {
                if (*(_DWORD *)&v44[v45 - 8] >= 0x41u)
                {
                  v46 = *(_QWORD *)&v44[v45 - 16];
                  if (v46)
                    MEMORY[0x20BD002D4](v46, 0x1000C8000313F17);
                }
                v45 -= 16;
              }
              while (v45);
              v44 = (char *)v80;
            }
            if (v44 != (char *)v81)
              free(v44);
            if (!(_BYTE)v61)
            {
              v47 = v62;
              v62 = 0;
              if (v47)
                (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
            }
            if (!(_BYTE)v64)
            {
              v48 = v65;
              v65 = 0;
              if (v48)
                (*(void (**)(uint64_t))(*(_QWORD *)v48 + 8))(v48);
            }
            v30 = v70;
LABEL_163:
            if (v30)
            {
              if (!(_BYTE)v67)
              {
                v49 = v68;
                v68 = 0;
                if (v49)
                  (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
              }
            }
            if (BYTE8(v79))
            {
              if (!(_BYTE)v78)
              {
                v50 = *((_QWORD *)&v78 + 1);
                *((_QWORD *)&v78 + 1) = 0;
                if (v50)
                  (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
              }
            }
            goto LABEL_85;
          }
          Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v80, (unint64_t)&v58, 1);
          v40 = (llvm::APInt *)(v80 + 16 * DWORD2(v80));
          v41 = *((_DWORD *)Address + 2);
          *((_DWORD *)v40 + 2) = v41;
          if (v41 > 0x40)
            llvm::APInt::initSlowCase(v40, (const void **)Address);
          else
            *(_QWORD *)v40 = *(_QWORD *)Address;
          ++DWORD2(v80);
          if (v60 && v59 >= 0x41 && v58)
            MEMORY[0x20BD002D4](v58, 0x1000C8000313F17);
          v34 = ++v66;
          ++v63;
          if (!--v33)
            goto LABEL_145;
        }
        v53 = 1;
        v59 = v75;
        v58 = v74;
        v60 = 1;
        goto LABEL_124;
      }
    }
  }
LABEL_85:
  if (v53)
    return 0;
  else
    return v11 & 0xFFFFFFFFFFFFFFFBLL;
}

BOOL mlir::arith::DivSIOp::getSpeculatability(mlir::arith::DivSIOp *this)
{
  uint64_t v1;
  uint64_t DefiningOp;
  uint64_t v3;
  unint64_t v4;
  void *v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  int v9;
  unsigned int v10;
  _BOOL8 v12;
  uint64_t *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  void *v18[2];
  _QWORD v19[2];

  v19[1] = *MEMORY[0x24BDAC8D0];
  v16 = 1;
  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 56);
  v14 = &v15;
  v15 = 0;
  v17 = v1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (!DefiningOp)
    goto LABEL_27;
  v3 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    goto LABEL_27;
  v18[0] = v19;
  v18[1] = (void *)0x100000000;
  mlir::Operation::fold(v3, 0, 0, (uint64_t)v18);
  v4 = *(_QWORD *)v18[0] & 0xFFFFFFFFFFFFFFF8;
  if (v18[0] != v19)
    free(v18[0]);
  if (!v4
    || ((v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(v3 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
         v5 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      ? (v6 = v5 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      : (v6 = 1),
        !v6 ? (v7 = v5 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v7 = 1),
        !v7 ? (v8 = v5 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v8 = 1),
        !v8))
  {
LABEL_27:
    v10 = v16;
LABEL_28:
    v12 = 0;
    if (v10 < 0x41)
      return v12;
    goto LABEL_29;
  }
  v9 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v14, v4);
  v10 = v16;
  if (!v9)
    goto LABEL_28;
  if (!v16)
    return 0;
  if (v16 > 0x40)
  {
    v12 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v15) != v10
       && llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v15) != v10;
LABEL_29:
    if (v15)
      MEMORY[0x20BD002D4](v15, 0x1000C8000313F17);
    return v12;
  }
  return v15 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v16 && v15 != 0;
}

unint64_t mlir::arith::CeilDivUIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  int v7;
  BOOL v8;
  uint64_t canMapOperands;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Value;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t Type;
  int v30;
  unint64_t NumElements;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *Address;
  llvm::APInt *v40;
  unsigned int v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL *v50;
  char v51;
  const void *v52;
  unsigned int v53;
  const void *v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 v68;
  _QWORD v69[2];
  _QWORD *v70;
  uint64_t v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  _OWORD v75[4];
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (v4)
  {
    DWORD2(v74) = 1;
    *(_QWORD *)&v74 = 0;
    *(_QWORD *)&v72 = &v74;
    v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v72, v4);
    v7 = DWORD2(v74);
    if (v6)
    {
      if (DWORD2(v74) < 0x41)
      {
        v8 = (_QWORD)v74 == 1;
        goto LABEL_8;
      }
      if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v74) > 0x40)
      {
        if ((_QWORD)v74)
          MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_14:
        v3 = *(uint64_t **)(a2 + 40);
        goto LABEL_15;
      }
      v8 = *(_QWORD *)v74 == 1;
    }
    else
    {
      v8 = 0;
      if (DWORD2(v74) < 0x41)
        goto LABEL_8;
    }
    if ((_QWORD)v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_8:
    if (v8)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
    goto LABEL_14;
  }
LABEL_15:
  v51 = 0;
  v50 = (BOOL *)&v51;
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_86;
  }
  v11 = v3[1];
  if (v11 && *(_UNKNOWN **)(*(_QWORD *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_86;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v12 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      *(_QWORD *)&v74 = canMapOperands;
      *((_QWORD *)&v74 + 1) = v12;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v74);
    }
    else
    {
      canMapOperands = 0;
      v74 = 0uLL;
    }
  }
  else
  {
    v74 = 0uLL;
  }
  v11 = v3[1];
  if (!v11)
  {
    v74 = 0uLL;
    goto LABEL_86;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8))
  {
    v11 = 0;
    v74 = 0uLL;
    goto LABEL_86;
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8);
  *(_QWORD *)&v74 = v11;
  *((_QWORD *)&v74 + 1) = v13;
  v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v74);
  v11 = 0;
  if (!canMapOperands || !v14 || canMapOperands != v14)
    goto LABEL_86;
  v15 = *v3;
  if (*v3 && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_86;
  }
  v16 = v3[1];
  if (!v16)
    goto LABEL_85;
  v17 = *(void **)(*(_QWORD *)v16 + 136);
  if (v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v11 = v3[1];
  else
    v11 = 0;
  if (!v15 || v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_86;
  if (v17 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)v15 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    if (mlir::DenseElementsAttr::classof(*v3))
      v19 = v15;
    else
      v19 = 0;
    *(_QWORD *)&v74 = v19;
    if (v19
      && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v74)
      && ((v20 = v3[1], !mlir::DenseElementsAttr::classof(v20)) ? (v21 = 0) : (v21 = v20),
          (*(_QWORD *)&v74 = v21) != 0
       && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v74)))
    {
      v22 = v3[1];
      v59 = *v3;
      v56 = v22;
      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v59);
      if (Value == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56))
      {
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v59, (uint64_t)&v74);
        v72 = v74;
        v73 = v75[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v72, (llvm::APInt *)&v65);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v56, (uint64_t)&v74);
        v72 = v74;
        v73 = v75[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v72, (llvm::APInt *)&v62);
        mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::CeilDivUIOp::fold(mlir::arith::CeilDivUIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::CeilDivUIOp::fold(mlir::arith::CeilDivUIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v74, &v50, (llvm::APInt *)&v65, (llvm::APInt *)&v62);
        if (v63 >= 0x41 && v62)
          MEMORY[0x20BD002D4](v62, 0x1000C8000313F17);
        if (v66 >= 0x41 && v65)
          MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
        if (LOBYTE(v75[0]))
        {
          v24 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
          v11 = mlir::DenseElementsAttr::get(canMapOperands, v24, (llvm::APInt *)&v74, 1);
          if (LOBYTE(v75[0]))
            goto LABEL_52;
          goto LABEL_86;
        }
      }
    }
    else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
           && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
    {
      v25 = (_QWORD *)*v3;
      v26 = *v3 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v25 + 8) : 0;
      v70 = v25;
      v71 = v26;
      v27 = (_QWORD *)v3[1];
      v28 = v27 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v27 + 8) : 0;
      v69[0] = v27;
      v69[1] = v28;
      Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
      if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v69))
      {
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v70, (uint64_t)&v72);
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v69, (uint64_t)&v65);
        v11 = 0;
        v30 = v68;
        if (BYTE8(v73) && v68)
        {
          LOWORD(v62) = v72;
          if ((_BYTE)v72)
            v63 = *((_QWORD *)&v72 + 1);
          else
            (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v72 + 1) + 16))(&v63);
          v64 = v73;
          LOWORD(v59) = v65;
          if ((_BYTE)v65)
            v60 = v66;
          else
            (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v66 + 16))(&v60);
          v61 = v67;
          *(_QWORD *)&v74 = v75;
          *((_QWORD *)&v74 + 1) = 0x400000000;
          NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v70, v71);
          llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v74, NumElements);
          v32 = mlir::ElementsAttr::getNumElements((uint64_t)v70, v71);
          if (v32)
          {
            v33 = v32;
            v34 = v64;
            while (1)
            {
              if (BYTE1(v62))
                v35 = 0;
              else
                v35 = v34;
              if ((_BYTE)v62)
              {
                v36 = v63 + 16 * v35;
                v55 = *(_DWORD *)(v36 + 8);
                if (v55 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v54, (const void **)v36);
                else
                  v54 = *(const void **)v36;
              }
              else
              {
                (*(void (**)(const void **__return_ptr))(*(_QWORD *)v63 + 24))(&v54);
              }
              if (BYTE1(v59))
                v37 = 0;
              else
                v37 = v61;
              if ((_BYTE)v59)
              {
                v38 = v60 + 16 * v37;
                v53 = *(_DWORD *)(v38 + 8);
                if (v53 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v52, (const void **)v38);
                else
                  v52 = *(const void **)v38;
              }
              else
              {
                (*(void (**)(const void **__return_ptr))(*(_QWORD *)v60 + 24))(&v52);
              }
              mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::CeilDivUIOp::fold(mlir::arith::CeilDivUIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::CeilDivUIOp::fold(mlir::arith::CeilDivUIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v56, &v50, (llvm::APInt *)&v54, (llvm::APInt *)&v52);
              if (v53 >= 0x41 && v52)
                MEMORY[0x20BD002D4](v52, 0x1000C8000313F17);
              if (v55 >= 0x41 && v54)
                MEMORY[0x20BD002D4](v54, 0x1000C8000313F17);
              if (!v58)
                break;
              Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v74, (unint64_t)&v56, 1);
              v40 = (llvm::APInt *)(v74 + 16 * DWORD2(v74));
              v41 = *((_DWORD *)Address + 2);
              *((_DWORD *)v40 + 2) = v41;
              if (v41 > 0x40)
                llvm::APInt::initSlowCase(v40, (const void **)Address);
              else
                *(_QWORD *)v40 = *(_QWORD *)Address;
              ++DWORD2(v74);
              if (v58 && v57 >= 0x41 && v56)
                MEMORY[0x20BD002D4](v56, 0x1000C8000313F17);
              v34 = ++v64;
              ++v61;
              if (!--v33)
                goto LABEL_130;
            }
            v11 = 0;
          }
          else
          {
LABEL_130:
            v42 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            v11 = mlir::DenseElementsAttr::get(canMapOperands, v42, (llvm::APInt *)v74, DWORD2(v74));
          }
          v43 = (char *)v74;
          if (DWORD2(v74))
          {
            v44 = 16 * DWORD2(v74);
            do
            {
              if (*(_DWORD *)&v43[v44 - 8] >= 0x41u)
              {
                v45 = *(_QWORD *)&v43[v44 - 16];
                if (v45)
                  MEMORY[0x20BD002D4](v45, 0x1000C8000313F17);
              }
              v44 -= 16;
            }
            while (v44);
            v43 = (char *)v74;
          }
          if (v43 != (char *)v75)
            free(v43);
          if (!(_BYTE)v59)
          {
            v46 = v60;
            v60 = 0;
            if (v46)
              (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
          }
          if (!(_BYTE)v62)
          {
            v47 = v63;
            v63 = 0;
            if (v47)
              (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
          }
          v30 = v68;
        }
        if (v30)
        {
          if (!(_BYTE)v65)
          {
            v48 = v66;
            v66 = 0;
            if (v48)
              (*(void (**)(uint64_t))(*(_QWORD *)v48 + 8))(v48);
          }
        }
        if (BYTE8(v73))
        {
          if (!(_BYTE)v72)
          {
            v49 = *((_QWORD *)&v72 + 1);
            *((_QWORD *)&v72 + 1) = 0;
            if (v49)
              (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
          }
        }
        goto LABEL_86;
      }
    }
LABEL_85:
    v11 = 0;
    goto LABEL_86;
  }
  v62 = *v3;
  v59 = v16;
  v18 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62);
  if (v18 != mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59))
    goto LABEL_85;
  mlir::IntegerAttr::getValue(&v62, (llvm::APInt *)&v72);
  mlir::IntegerAttr::getValue(&v59, (llvm::APInt *)&v65);
  mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::CeilDivUIOp::fold(mlir::arith::CeilDivUIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::CeilDivUIOp::fold(mlir::arith::CeilDivUIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v74, &v50, (llvm::APInt *)&v72, (llvm::APInt *)&v65);
  if (v66 >= 0x41 && v65)
    MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
  if (DWORD2(v72) >= 0x41 && (_QWORD)v72)
    MEMORY[0x20BD002D4](v72, 0x1000C8000313F17);
  if (!LOBYTE(v75[0]))
    goto LABEL_85;
  v11 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v74);
  if (LOBYTE(v75[0]))
  {
LABEL_52:
    if (DWORD2(v74) >= 0x41 && (_QWORD)v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
  }
LABEL_86:
  if (v51)
    return 0;
  else
    return v11 & 0xFFFFFFFFFFFFFFFBLL;
}

unint64_t mlir::arith::CeilDivSIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  int v7;
  BOOL v8;
  uint64_t canMapOperands;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Value;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t Type;
  int v30;
  unint64_t NumElements;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *Address;
  llvm::APInt *v40;
  unsigned int v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL *v50;
  char v51;
  const void *v52;
  unsigned int v53;
  const void *v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 v68;
  _QWORD v69[2];
  _QWORD *v70;
  uint64_t v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  _OWORD v75[4];
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (v4)
  {
    DWORD2(v74) = 1;
    *(_QWORD *)&v74 = 0;
    *(_QWORD *)&v72 = &v74;
    v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v72, v4);
    v7 = DWORD2(v74);
    if (v6)
    {
      if (DWORD2(v74) < 0x41)
      {
        v8 = (_QWORD)v74 == 1;
        goto LABEL_8;
      }
      if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v74) > 0x40)
      {
        if ((_QWORD)v74)
          MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_14:
        v3 = *(uint64_t **)(a2 + 40);
        goto LABEL_15;
      }
      v8 = *(_QWORD *)v74 == 1;
    }
    else
    {
      v8 = 0;
      if (DWORD2(v74) < 0x41)
        goto LABEL_8;
    }
    if ((_QWORD)v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_8:
    if (v8)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
    goto LABEL_14;
  }
LABEL_15:
  v51 = 0;
  v50 = (BOOL *)&v51;
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_86;
  }
  v11 = v3[1];
  if (v11 && *(_UNKNOWN **)(*(_QWORD *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_86;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v12 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      *(_QWORD *)&v74 = canMapOperands;
      *((_QWORD *)&v74 + 1) = v12;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v74);
    }
    else
    {
      canMapOperands = 0;
      v74 = 0uLL;
    }
  }
  else
  {
    v74 = 0uLL;
  }
  v11 = v3[1];
  if (!v11)
  {
    v74 = 0uLL;
    goto LABEL_86;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8))
  {
    v11 = 0;
    v74 = 0uLL;
    goto LABEL_86;
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8);
  *(_QWORD *)&v74 = v11;
  *((_QWORD *)&v74 + 1) = v13;
  v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v74);
  v11 = 0;
  if (!canMapOperands || !v14 || canMapOperands != v14)
    goto LABEL_86;
  v15 = *v3;
  if (*v3 && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_86;
  }
  v16 = v3[1];
  if (!v16)
    goto LABEL_85;
  v17 = *(void **)(*(_QWORD *)v16 + 136);
  if (v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v11 = v3[1];
  else
    v11 = 0;
  if (!v15 || v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_86;
  if (v17 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)v15 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    if (mlir::DenseElementsAttr::classof(*v3))
      v19 = v15;
    else
      v19 = 0;
    *(_QWORD *)&v74 = v19;
    if (v19
      && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v74)
      && ((v20 = v3[1], !mlir::DenseElementsAttr::classof(v20)) ? (v21 = 0) : (v21 = v20),
          (*(_QWORD *)&v74 = v21) != 0
       && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v74)))
    {
      v22 = v3[1];
      v59 = *v3;
      v56 = v22;
      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v59);
      if (Value == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56))
      {
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v59, (uint64_t)&v74);
        v72 = v74;
        v73 = v75[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v72, (llvm::APInt *)&v65);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v56, (uint64_t)&v74);
        v72 = v74;
        v73 = v75[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v72, (llvm::APInt *)&v62);
        mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::CeilDivSIOp::fold(mlir::arith::CeilDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::CeilDivSIOp::fold(mlir::arith::CeilDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()(&v74, &v50, (llvm::APInt *)&v65, (llvm::APInt *)&v62);
        if (v63 >= 0x41 && v62)
          MEMORY[0x20BD002D4](v62, 0x1000C8000313F17);
        if (v66 >= 0x41 && v65)
          MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
        if (LOBYTE(v75[0]))
        {
          v24 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
          v11 = mlir::DenseElementsAttr::get(canMapOperands, v24, (llvm::APInt *)&v74, 1);
          if (LOBYTE(v75[0]))
            goto LABEL_52;
          goto LABEL_86;
        }
      }
    }
    else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
           && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
    {
      v25 = (_QWORD *)*v3;
      v26 = *v3 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v25 + 8) : 0;
      v70 = v25;
      v71 = v26;
      v27 = (_QWORD *)v3[1];
      v28 = v27 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v27 + 8) : 0;
      v69[0] = v27;
      v69[1] = v28;
      Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
      if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v69))
      {
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v70, (uint64_t)&v72);
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v69, (uint64_t)&v65);
        v11 = 0;
        v30 = v68;
        if (BYTE8(v73) && v68)
        {
          LOWORD(v62) = v72;
          if ((_BYTE)v72)
            v63 = *((_QWORD *)&v72 + 1);
          else
            (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v72 + 1) + 16))(&v63);
          v64 = v73;
          LOWORD(v59) = v65;
          if ((_BYTE)v65)
            v60 = v66;
          else
            (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v66 + 16))(&v60);
          v61 = v67;
          *(_QWORD *)&v74 = v75;
          *((_QWORD *)&v74 + 1) = 0x400000000;
          NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v70, v71);
          llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v74, NumElements);
          v32 = mlir::ElementsAttr::getNumElements((uint64_t)v70, v71);
          if (v32)
          {
            v33 = v32;
            v34 = v64;
            while (1)
            {
              if (BYTE1(v62))
                v35 = 0;
              else
                v35 = v34;
              if ((_BYTE)v62)
              {
                v36 = v63 + 16 * v35;
                v55 = *(_DWORD *)(v36 + 8);
                if (v55 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v54, (const void **)v36);
                else
                  v54 = *(const void **)v36;
              }
              else
              {
                (*(void (**)(const void **__return_ptr))(*(_QWORD *)v63 + 24))(&v54);
              }
              if (BYTE1(v59))
                v37 = 0;
              else
                v37 = v61;
              if ((_BYTE)v59)
              {
                v38 = v60 + 16 * v37;
                v53 = *(_DWORD *)(v38 + 8);
                if (v53 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v52, (const void **)v38);
                else
                  v52 = *(const void **)v38;
              }
              else
              {
                (*(void (**)(const void **__return_ptr))(*(_QWORD *)v60 + 24))(&v52);
              }
              mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::CeilDivSIOp::fold(mlir::arith::CeilDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::CeilDivSIOp::fold(mlir::arith::CeilDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()(&v56, &v50, (llvm::APInt *)&v54, (llvm::APInt *)&v52);
              if (v53 >= 0x41 && v52)
                MEMORY[0x20BD002D4](v52, 0x1000C8000313F17);
              if (v55 >= 0x41 && v54)
                MEMORY[0x20BD002D4](v54, 0x1000C8000313F17);
              if (!v58)
                break;
              Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v74, (unint64_t)&v56, 1);
              v40 = (llvm::APInt *)(v74 + 16 * DWORD2(v74));
              v41 = *((_DWORD *)Address + 2);
              *((_DWORD *)v40 + 2) = v41;
              if (v41 > 0x40)
                llvm::APInt::initSlowCase(v40, (const void **)Address);
              else
                *(_QWORD *)v40 = *(_QWORD *)Address;
              ++DWORD2(v74);
              if (v58 && v57 >= 0x41 && v56)
                MEMORY[0x20BD002D4](v56, 0x1000C8000313F17);
              v34 = ++v64;
              ++v61;
              if (!--v33)
                goto LABEL_130;
            }
            v11 = 0;
          }
          else
          {
LABEL_130:
            v42 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            v11 = mlir::DenseElementsAttr::get(canMapOperands, v42, (llvm::APInt *)v74, DWORD2(v74));
          }
          v43 = (char *)v74;
          if (DWORD2(v74))
          {
            v44 = 16 * DWORD2(v74);
            do
            {
              if (*(_DWORD *)&v43[v44 - 8] >= 0x41u)
              {
                v45 = *(_QWORD *)&v43[v44 - 16];
                if (v45)
                  MEMORY[0x20BD002D4](v45, 0x1000C8000313F17);
              }
              v44 -= 16;
            }
            while (v44);
            v43 = (char *)v74;
          }
          if (v43 != (char *)v75)
            free(v43);
          if (!(_BYTE)v59)
          {
            v46 = v60;
            v60 = 0;
            if (v46)
              (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
          }
          if (!(_BYTE)v62)
          {
            v47 = v63;
            v63 = 0;
            if (v47)
              (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
          }
          v30 = v68;
        }
        if (v30)
        {
          if (!(_BYTE)v65)
          {
            v48 = v66;
            v66 = 0;
            if (v48)
              (*(void (**)(uint64_t))(*(_QWORD *)v48 + 8))(v48);
          }
        }
        if (BYTE8(v73))
        {
          if (!(_BYTE)v72)
          {
            v49 = *((_QWORD *)&v72 + 1);
            *((_QWORD *)&v72 + 1) = 0;
            if (v49)
              (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
          }
        }
        goto LABEL_86;
      }
    }
LABEL_85:
    v11 = 0;
    goto LABEL_86;
  }
  v62 = *v3;
  v59 = v16;
  v18 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62);
  if (v18 != mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59))
    goto LABEL_85;
  mlir::IntegerAttr::getValue(&v62, (llvm::APInt *)&v72);
  mlir::IntegerAttr::getValue(&v59, (llvm::APInt *)&v65);
  mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::CeilDivSIOp::fold(mlir::arith::CeilDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::CeilDivSIOp::fold(mlir::arith::CeilDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()(&v74, &v50, (llvm::APInt *)&v72, (llvm::APInt *)&v65);
  if (v66 >= 0x41 && v65)
    MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
  if (DWORD2(v72) >= 0x41 && (_QWORD)v72)
    MEMORY[0x20BD002D4](v72, 0x1000C8000313F17);
  if (!LOBYTE(v75[0]))
    goto LABEL_85;
  v11 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v74);
  if (LOBYTE(v75[0]))
  {
LABEL_52:
    if (DWORD2(v74) >= 0x41 && (_QWORD)v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
  }
LABEL_86:
  if (v51)
    return 0;
  else
    return v11 & 0xFFFFFFFFFFFFFFFBLL;
}

unint64_t mlir::arith::FloorDivSIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  int v7;
  BOOL v8;
  uint64_t canMapOperands;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Value;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t Type;
  int v30;
  unint64_t NumElements;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *Address;
  llvm::APInt *v40;
  unsigned int v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL *v50;
  char v51;
  const void *v52;
  unsigned int v53;
  const void *v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 v68;
  _QWORD v69[2];
  _QWORD *v70;
  uint64_t v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  _OWORD v75[4];
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (v4)
  {
    DWORD2(v74) = 1;
    *(_QWORD *)&v74 = 0;
    *(_QWORD *)&v72 = &v74;
    v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v72, v4);
    v7 = DWORD2(v74);
    if (v6)
    {
      if (DWORD2(v74) < 0x41)
      {
        v8 = (_QWORD)v74 == 1;
        goto LABEL_8;
      }
      if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v74) > 0x40)
      {
        if ((_QWORD)v74)
          MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_14:
        v3 = *(uint64_t **)(a2 + 40);
        goto LABEL_15;
      }
      v8 = *(_QWORD *)v74 == 1;
    }
    else
    {
      v8 = 0;
      if (DWORD2(v74) < 0x41)
        goto LABEL_8;
    }
    if ((_QWORD)v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
LABEL_8:
    if (v8)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
    goto LABEL_14;
  }
LABEL_15:
  v51 = 0;
  v50 = (BOOL *)&v51;
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_86;
  }
  v11 = v3[1];
  if (v11 && *(_UNKNOWN **)(*(_QWORD *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_86;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v12 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      *(_QWORD *)&v74 = canMapOperands;
      *((_QWORD *)&v74 + 1) = v12;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v74);
    }
    else
    {
      canMapOperands = 0;
      v74 = 0uLL;
    }
  }
  else
  {
    v74 = 0uLL;
  }
  v11 = v3[1];
  if (!v11)
  {
    v74 = 0uLL;
    goto LABEL_86;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8))
  {
    v11 = 0;
    v74 = 0uLL;
    goto LABEL_86;
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v11 + 8);
  *(_QWORD *)&v74 = v11;
  *((_QWORD *)&v74 + 1) = v13;
  v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v74);
  v11 = 0;
  if (!canMapOperands || !v14 || canMapOperands != v14)
    goto LABEL_86;
  v15 = *v3;
  if (*v3 && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v11 = *v3;
    goto LABEL_86;
  }
  v16 = v3[1];
  if (!v16)
    goto LABEL_85;
  v17 = *(void **)(*(_QWORD *)v16 + 136);
  if (v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v11 = v3[1];
  else
    v11 = 0;
  if (!v15 || v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_86;
  if (v17 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)v15 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    if (mlir::DenseElementsAttr::classof(*v3))
      v19 = v15;
    else
      v19 = 0;
    *(_QWORD *)&v74 = v19;
    if (v19
      && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v74)
      && ((v20 = v3[1], !mlir::DenseElementsAttr::classof(v20)) ? (v21 = 0) : (v21 = v20),
          (*(_QWORD *)&v74 = v21) != 0
       && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v74)))
    {
      v22 = v3[1];
      v59 = *v3;
      v56 = v22;
      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v59);
      if (Value == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56))
      {
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v59, (uint64_t)&v74);
        v72 = v74;
        v73 = v75[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v72, (llvm::APInt *)&v65);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v56, (uint64_t)&v74);
        v72 = v74;
        v73 = v75[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v72, (llvm::APInt *)&v62);
        mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::FloorDivSIOp::fold(mlir::arith::FloorDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::FloorDivSIOp::fold(mlir::arith::FloorDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v74, &v50, (llvm::APInt *)&v65, (llvm::APInt *)&v62);
        if (v63 >= 0x41 && v62)
          MEMORY[0x20BD002D4](v62, 0x1000C8000313F17);
        if (v66 >= 0x41 && v65)
          MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
        if (LOBYTE(v75[0]))
        {
          v24 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
          v11 = mlir::DenseElementsAttr::get(canMapOperands, v24, (llvm::APInt *)&v74, 1);
          if (LOBYTE(v75[0]))
            goto LABEL_52;
          goto LABEL_86;
        }
      }
    }
    else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
           && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
    {
      v25 = (_QWORD *)*v3;
      v26 = *v3 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v25 + 8) : 0;
      v70 = v25;
      v71 = v26;
      v27 = (_QWORD *)v3[1];
      v28 = v27 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v27 + 8) : 0;
      v69[0] = v27;
      v69[1] = v28;
      Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
      if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v69))
      {
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v70, (uint64_t)&v72);
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v69, (uint64_t)&v65);
        v11 = 0;
        v30 = v68;
        if (BYTE8(v73) && v68)
        {
          LOWORD(v62) = v72;
          if ((_BYTE)v72)
            v63 = *((_QWORD *)&v72 + 1);
          else
            (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v72 + 1) + 16))(&v63);
          v64 = v73;
          LOWORD(v59) = v65;
          if ((_BYTE)v65)
            v60 = v66;
          else
            (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v66 + 16))(&v60);
          v61 = v67;
          *(_QWORD *)&v74 = v75;
          *((_QWORD *)&v74 + 1) = 0x400000000;
          NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v70, v71);
          llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v74, NumElements);
          v32 = mlir::ElementsAttr::getNumElements((uint64_t)v70, v71);
          if (v32)
          {
            v33 = v32;
            v34 = v64;
            while (1)
            {
              if (BYTE1(v62))
                v35 = 0;
              else
                v35 = v34;
              if ((_BYTE)v62)
              {
                v36 = v63 + 16 * v35;
                v55 = *(_DWORD *)(v36 + 8);
                if (v55 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v54, (const void **)v36);
                else
                  v54 = *(const void **)v36;
              }
              else
              {
                (*(void (**)(const void **__return_ptr))(*(_QWORD *)v63 + 24))(&v54);
              }
              if (BYTE1(v59))
                v37 = 0;
              else
                v37 = v61;
              if ((_BYTE)v59)
              {
                v38 = v60 + 16 * v37;
                v53 = *(_DWORD *)(v38 + 8);
                if (v53 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v52, (const void **)v38);
                else
                  v52 = *(const void **)v38;
              }
              else
              {
                (*(void (**)(const void **__return_ptr))(*(_QWORD *)v60 + 24))(&v52);
              }
              mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::FloorDivSIOp::fold(mlir::arith::FloorDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::FloorDivSIOp::fold(mlir::arith::FloorDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v56, &v50, (llvm::APInt *)&v54, (llvm::APInt *)&v52);
              if (v53 >= 0x41 && v52)
                MEMORY[0x20BD002D4](v52, 0x1000C8000313F17);
              if (v55 >= 0x41 && v54)
                MEMORY[0x20BD002D4](v54, 0x1000C8000313F17);
              if (!v58)
                break;
              Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v74, (unint64_t)&v56, 1);
              v40 = (llvm::APInt *)(v74 + 16 * DWORD2(v74));
              v41 = *((_DWORD *)Address + 2);
              *((_DWORD *)v40 + 2) = v41;
              if (v41 > 0x40)
                llvm::APInt::initSlowCase(v40, (const void **)Address);
              else
                *(_QWORD *)v40 = *(_QWORD *)Address;
              ++DWORD2(v74);
              if (v58 && v57 >= 0x41 && v56)
                MEMORY[0x20BD002D4](v56, 0x1000C8000313F17);
              v34 = ++v64;
              ++v61;
              if (!--v33)
                goto LABEL_130;
            }
            v11 = 0;
          }
          else
          {
LABEL_130:
            v42 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            v11 = mlir::DenseElementsAttr::get(canMapOperands, v42, (llvm::APInt *)v74, DWORD2(v74));
          }
          v43 = (char *)v74;
          if (DWORD2(v74))
          {
            v44 = 16 * DWORD2(v74);
            do
            {
              if (*(_DWORD *)&v43[v44 - 8] >= 0x41u)
              {
                v45 = *(_QWORD *)&v43[v44 - 16];
                if (v45)
                  MEMORY[0x20BD002D4](v45, 0x1000C8000313F17);
              }
              v44 -= 16;
            }
            while (v44);
            v43 = (char *)v74;
          }
          if (v43 != (char *)v75)
            free(v43);
          if (!(_BYTE)v59)
          {
            v46 = v60;
            v60 = 0;
            if (v46)
              (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
          }
          if (!(_BYTE)v62)
          {
            v47 = v63;
            v63 = 0;
            if (v47)
              (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
          }
          v30 = v68;
        }
        if (v30)
        {
          if (!(_BYTE)v65)
          {
            v48 = v66;
            v66 = 0;
            if (v48)
              (*(void (**)(uint64_t))(*(_QWORD *)v48 + 8))(v48);
          }
        }
        if (BYTE8(v73))
        {
          if (!(_BYTE)v72)
          {
            v49 = *((_QWORD *)&v72 + 1);
            *((_QWORD *)&v72 + 1) = 0;
            if (v49)
              (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
          }
        }
        goto LABEL_86;
      }
    }
LABEL_85:
    v11 = 0;
    goto LABEL_86;
  }
  v62 = *v3;
  v59 = v16;
  v18 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62);
  if (v18 != mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59))
    goto LABEL_85;
  mlir::IntegerAttr::getValue(&v62, (llvm::APInt *)&v72);
  mlir::IntegerAttr::getValue(&v59, (llvm::APInt *)&v65);
  mlir::constFoldBinaryOp<mlir::IntegerAttr,llvm::APInt,mlir::ub::PoisonAttr,mlir::arith::FloorDivSIOp::fold(mlir::arith::FloorDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::FloorDivSIOp::fold(mlir::arith::FloorDivSIOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APInt,llvm::APInt)#1}::operator()((uint64_t)&v74, &v50, (llvm::APInt *)&v72, (llvm::APInt *)&v65);
  if (v66 >= 0x41 && v65)
    MEMORY[0x20BD002D4](v65, 0x1000C8000313F17);
  if (DWORD2(v72) >= 0x41 && (_QWORD)v72)
    MEMORY[0x20BD002D4](v72, 0x1000C8000313F17);
  if (!LOBYTE(v75[0]))
    goto LABEL_85;
  v11 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v74);
  if (LOBYTE(v75[0]))
  {
LABEL_52:
    if (DWORD2(v74) >= 0x41 && (_QWORD)v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
  }
LABEL_86:
  if (v51)
    return 0;
  else
    return v11 & 0xFFFFFFFFFFFFFFFBLL;
}

unint64_t mlir::arith::RemUIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  unsigned int v7;
  __int128 *v8;
  BOOL v9;
  uint64_t ZeroAttr;
  uint64_t canMapOperands;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t Value;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t Type;
  int v32;
  unint64_t NumElements;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *Address;
  llvm::APInt *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  const void *v55;
  unsigned int v56;
  const void *v57;
  unsigned int v58;
  const void *v59;
  unsigned int v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int8 v71;
  _QWORD v72[2];
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  const void *v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  const void *v81;
  unsigned int v82;
  const void *v83;
  unsigned int v84;
  const void *v85;
  unsigned int v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _OWORD v90[4];
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (!v4)
    goto LABEL_17;
  DWORD2(v89) = 1;
  *(_QWORD *)&v89 = 0;
  *(_QWORD *)&v87 = &v89;
  v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v87, v4);
  v7 = DWORD2(v89);
  if (!v6)
  {
    v9 = 0;
    if (DWORD2(v89) < 0x41)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (DWORD2(v89) < 0x41)
  {
    v8 = &v89;
    goto LABEL_9;
  }
  if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v89) <= 0x40)
  {
    v8 = (__int128 *)v89;
LABEL_9:
    v9 = *(_QWORD *)v8 == 1;
    if (v7 < 0x41)
      goto LABEL_12;
LABEL_10:
    if ((_QWORD)v89)
      MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
LABEL_12:
    if (v9)
    {
      *(_QWORD *)&v89 = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
      ZeroAttr = (uint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v89, (mlir::MLIRContext *)(*(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8));
      return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
    }
    goto LABEL_16;
  }
  if ((_QWORD)v89)
    MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
LABEL_16:
  v3 = *(uint64_t **)(a2 + 40);
LABEL_17:
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    ZeroAttr = *v3;
    return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
  }
  ZeroAttr = v3[1];
  if (!ZeroAttr
    || *(_UNKNOWN **)(*(_QWORD *)ZeroAttr + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    if (canMapOperands)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
      {
        v12 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
        *(_QWORD *)&v89 = canMapOperands;
        *((_QWORD *)&v89 + 1) = v12;
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v89);
      }
      else
      {
        canMapOperands = 0;
        v89 = 0uLL;
      }
    }
    else
    {
      v89 = 0uLL;
    }
    ZeroAttr = v3[1];
    if (!ZeroAttr)
    {
      v89 = 0uLL;
      return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
    }
    if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)ZeroAttr + 8))
    {
      ZeroAttr = 0;
      v89 = 0uLL;
      return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
    }
    v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)ZeroAttr + 8);
    *(_QWORD *)&v89 = ZeroAttr;
    *((_QWORD *)&v89 + 1) = v13;
    v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v89);
    ZeroAttr = 0;
    if (canMapOperands)
    {
      if (v14 && canMapOperands == v14)
      {
        v15 = *v3;
        if (*v3
          && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          ZeroAttr = *v3;
          return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
        }
        v16 = v3[1];
        if (!v16)
        {
LABEL_92:
          ZeroAttr = 0;
          return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
        }
        v17 = *(void **)(*(_QWORD *)v16 + 136);
        ZeroAttr = v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id ? v3[1] : 0;
        if (v15 && v17 != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          if (v17 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
            && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          {
            v65 = *v3;
            v62 = v16;
            Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65);
            if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62))
            {
              mlir::IntegerAttr::getValue(&v65, (llvm::APInt *)&v81);
              mlir::IntegerAttr::getValue(&v62, (llvm::APInt *)&v79);
              LODWORD(v69) = v82;
              if (v82 > 0x40)
                llvm::APInt::initSlowCase((llvm::APInt *)&v68, &v81);
              else
                v68 = v81;
              v26 = v80;
              if (v80 > 0x40)
              {
                if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v79) != v26)
                {
LABEL_69:
                  llvm::APInt::urem(&v68, (const llvm::APInt *)&v79, (uint64_t)&v87);
                  v27 = 0;
                  DWORD2(v89) = DWORD2(v87);
                  *(_QWORD *)&v89 = v87;
                  DWORD2(v87) = 0;
                  LOBYTE(v90[0]) = 1;
                  if (v69 >= 0x41)
                  {
                    if (v68)
                      MEMORY[0x20BD002D4](v68, 0x1000C8000313F17);
                    v27 = 0;
                  }
LABEL_75:
                  if (v80 >= 0x41 && v79)
                    MEMORY[0x20BD002D4](v79, 0x1000C8000313F17);
                  if (v82 >= 0x41 && v81)
                    MEMORY[0x20BD002D4](v81, 0x1000C8000313F17);
                  ZeroAttr = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v89);
                  if (LOBYTE(v90[0]))
                  {
LABEL_82:
                    if (DWORD2(v89) >= 0x41 && (_QWORD)v89)
                      MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
                  }
LABEL_91:
                  if (!v27)
                    return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
                  goto LABEL_92;
                }
              }
              else if (v79)
              {
                goto LABEL_69;
              }
              DWORD2(v89) = v69;
              *(_QWORD *)&v89 = v68;
              v27 = 1;
              LOBYTE(v90[0]) = 1;
              goto LABEL_75;
            }
LABEL_90:
            v27 = 0;
            ZeroAttr = 0;
            goto LABEL_91;
          }
          if (mlir::DenseElementsAttr::classof(*v3))
            v19 = v15;
          else
            v19 = 0;
          *(_QWORD *)&v89 = v19;
          if (v19 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v89))
          {
            v20 = v3[1];
            v21 = mlir::DenseElementsAttr::classof(v20) ? v20 : 0;
            *(_QWORD *)&v89 = v21;
            if (v21)
            {
              if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v89))
              {
                v22 = v3[1];
                v65 = *v3;
                v62 = v22;
                v23 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65);
                if (v23 != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62))
                  goto LABEL_90;
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v65, (uint64_t)&v89);
                v87 = v89;
                v88 = v90[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v87, (llvm::APInt *)&v77);
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v62, (uint64_t)&v89);
                v87 = v89;
                v88 = v90[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v87, (llvm::APInt *)&v75);
                LODWORD(v69) = v78;
                if (v78 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v68, &v77);
                else
                  v68 = v77;
                v53 = v76;
                if (v76 > 0x40)
                {
                  if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v75) != v53)
                  {
LABEL_178:
                    llvm::APInt::urem(&v68, (const llvm::APInt *)&v75, (uint64_t)&v87);
                    v27 = 0;
                    DWORD2(v89) = DWORD2(v87);
                    *(_QWORD *)&v89 = v87;
                    DWORD2(v87) = 0;
                    LOBYTE(v90[0]) = 1;
                    if (v69 >= 0x41)
                    {
                      if (v68)
                        MEMORY[0x20BD002D4](v68, 0x1000C8000313F17);
                      v27 = 0;
                    }
LABEL_184:
                    if (v76 >= 0x41 && v75)
                      MEMORY[0x20BD002D4](v75, 0x1000C8000313F17);
                    if (v78 >= 0x41 && v77)
                      MEMORY[0x20BD002D4](v77, 0x1000C8000313F17);
                    v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                    ZeroAttr = mlir::DenseElementsAttr::get(canMapOperands, v54, (llvm::APInt *)&v89, 1);
                    if (LOBYTE(v90[0]))
                      goto LABEL_82;
                    goto LABEL_91;
                  }
                }
                else if (v75)
                {
                  goto LABEL_178;
                }
                DWORD2(v89) = v69;
                *(_QWORD *)&v89 = v68;
                v27 = 1;
                LOBYTE(v90[0]) = 1;
                goto LABEL_184;
              }
            }
          }
          if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
            || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
          {
            goto LABEL_92;
          }
          v24 = (_QWORD *)*v3;
          if (*v3)
            v25 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v24 + 8);
          else
            v25 = 0;
          v73 = v24;
          v74 = v25;
          v28 = (_QWORD *)v3[1];
          if (v28)
            v29 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v28 + 8);
          else
            v29 = 0;
          v72[0] = v28;
          v72[1] = v29;
          Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v73);
          if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v72))
            goto LABEL_90;
          mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v73, (uint64_t)&v87);
          mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v72, (uint64_t)&v68);
          ZeroAttr = 0;
          v27 = 0;
          v32 = v71;
          if (BYTE8(v88) && v71)
          {
            LOWORD(v65) = v87;
            if ((_BYTE)v87)
              v66 = *((_QWORD *)&v87 + 1);
            else
              (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v87 + 1) + 16))(&v66);
            v67 = v88;
            LOWORD(v62) = (_WORD)v68;
            if ((_BYTE)v68)
              v63 = v69;
            else
              (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v69 + 16))(&v63);
            v64 = v70;
            *(_QWORD *)&v89 = v90;
            *((_QWORD *)&v89 + 1) = 0x400000000;
            NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v73, v74);
            llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v89, NumElements);
            v34 = mlir::ElementsAttr::getNumElements((uint64_t)v73, v74);
            if (v34)
            {
              v35 = v34;
              v27 = 0;
              v36 = v67;
              while (1)
              {
                v37 = BYTE1(v65) ? 0 : v36;
                if ((_BYTE)v65)
                {
                  v38 = v66 + 16 * v37;
                  v58 = *(_DWORD *)(v38 + 8);
                  if (v58 > 0x40)
                    llvm::APInt::initSlowCase((llvm::APInt *)&v57, (const void **)v38);
                  else
                    v57 = *(const void **)v38;
                }
                else
                {
                  (*(void (**)(const void **__return_ptr))(*(_QWORD *)v66 + 24))(&v57);
                }
                v39 = BYTE1(v62) ? 0 : v64;
                if ((_BYTE)v62)
                {
                  v40 = v63 + 16 * v39;
                  v56 = *(_DWORD *)(v40 + 8);
                  if (v56 > 0x40)
                    llvm::APInt::initSlowCase((llvm::APInt *)&v55, (const void **)v40);
                  else
                    v55 = *(const void **)v40;
                }
                else
                {
                  (*(void (**)(const void **__return_ptr))(*(_QWORD *)v63 + 24))(&v55);
                }
                v84 = v58;
                if (v58 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v83, &v57);
                else
                  v83 = v57;
                if (v27)
                  break;
                v44 = v56;
                if (v56 > 0x40)
                {
                  if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v55) == v44)
                    break;
                }
                else if (!v55)
                {
                  break;
                }
                llvm::APInt::urem(&v83, (const llvm::APInt *)&v55, (uint64_t)&v85);
                v27 = 0;
                v60 = v86;
                v59 = v85;
                v86 = 0;
                v61 = 1;
                if (v84 >= 0x41)
                {
                  if (v83)
                    MEMORY[0x20BD002D4](v83, 0x1000C8000313F17);
                  v27 = 0;
                }
LABEL_126:
                if (v56 >= 0x41 && v55)
                  MEMORY[0x20BD002D4](v55, 0x1000C8000313F17);
                if (v58 >= 0x41 && v57)
                  MEMORY[0x20BD002D4](v57, 0x1000C8000313F17);
                if (!v61)
                {
                  ZeroAttr = 0;
                  goto LABEL_151;
                }
                Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v89, (unint64_t)&v59, 1);
                v42 = (llvm::APInt *)(v89 + 16 * DWORD2(v89));
                v43 = *((_DWORD *)Address + 2);
                *((_DWORD *)v42 + 2) = v43;
                if (v43 > 0x40)
                  llvm::APInt::initSlowCase(v42, (const void **)Address);
                else
                  *(_QWORD *)v42 = *(_QWORD *)Address;
                ++DWORD2(v89);
                if (v61 && v60 >= 0x41 && v59)
                  MEMORY[0x20BD002D4](v59, 0x1000C8000313F17);
                v36 = ++v67;
                ++v64;
                if (!--v35)
                  goto LABEL_149;
              }
              v60 = v84;
              v59 = v83;
              v27 = 1;
              v61 = 1;
              goto LABEL_126;
            }
            v27 = 0;
LABEL_149:
            v45 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            ZeroAttr = mlir::DenseElementsAttr::get(canMapOperands, v45, (llvm::APInt *)v89, DWORD2(v89));
LABEL_151:
            v46 = (char *)v89;
            if (DWORD2(v89))
            {
              v47 = 16 * DWORD2(v89);
              do
              {
                if (*(_DWORD *)&v46[v47 - 8] >= 0x41u)
                {
                  v48 = *(_QWORD *)&v46[v47 - 16];
                  if (v48)
                    MEMORY[0x20BD002D4](v48, 0x1000C8000313F17);
                }
                v47 -= 16;
              }
              while (v47);
              v46 = (char *)v89;
            }
            if (v46 != (char *)v90)
              free(v46);
            if (!(_BYTE)v62)
            {
              v49 = v63;
              v63 = 0;
              if (v49)
                (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
            }
            if (!(_BYTE)v65)
            {
              v50 = v66;
              v66 = 0;
              if (v50)
                (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
            }
            v32 = v71;
          }
          if (v32)
          {
            if (!(_BYTE)v68)
            {
              v51 = v69;
              v69 = 0;
              if (v51)
                (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
            }
          }
          if (BYTE8(v88))
          {
            if (!(_BYTE)v87)
            {
              v52 = *((_QWORD *)&v87 + 1);
              *((_QWORD *)&v87 + 1) = 0;
              if (v52)
                (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
}

unint64_t mlir::arith::RemSIOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v6;
  unsigned int v7;
  __int128 *v8;
  BOOL v9;
  uint64_t ZeroAttr;
  uint64_t canMapOperands;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t Value;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t Type;
  int v32;
  unint64_t NumElements;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *Address;
  llvm::APInt *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  const void *v55;
  unsigned int v56;
  const void *v57;
  unsigned int v58;
  const void *v59;
  unsigned int v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int8 v71;
  _QWORD v72[2];
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  const void *v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  const void *v81;
  unsigned int v82;
  const void *v83;
  unsigned int v84;
  const void *v85;
  unsigned int v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _OWORD v90[4];
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 40);
  v4 = v3[1];
  if (!v4)
    goto LABEL_17;
  DWORD2(v89) = 1;
  *(_QWORD *)&v89 = 0;
  *(_QWORD *)&v87 = &v89;
  v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v87, v4);
  v7 = DWORD2(v89);
  if (!v6)
  {
    v9 = 0;
    if (DWORD2(v89) < 0x41)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (DWORD2(v89) < 0x41)
  {
    v8 = &v89;
    goto LABEL_9;
  }
  if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v89) <= 0x40)
  {
    v8 = (__int128 *)v89;
LABEL_9:
    v9 = *(_QWORD *)v8 == 1;
    if (v7 < 0x41)
      goto LABEL_12;
LABEL_10:
    if ((_QWORD)v89)
      MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
LABEL_12:
    if (v9)
    {
      *(_QWORD *)&v89 = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
      ZeroAttr = (uint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v89, (mlir::MLIRContext *)(*(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8));
      return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
    }
    goto LABEL_16;
  }
  if ((_QWORD)v89)
    MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
LABEL_16:
  v3 = *(uint64_t **)(a2 + 40);
LABEL_17:
  canMapOperands = *v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    ZeroAttr = *v3;
    return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
  }
  ZeroAttr = v3[1];
  if (!ZeroAttr
    || *(_UNKNOWN **)(*(_QWORD *)ZeroAttr + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    if (canMapOperands)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
      {
        v12 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
        *(_QWORD *)&v89 = canMapOperands;
        *((_QWORD *)&v89 + 1) = v12;
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v89);
      }
      else
      {
        canMapOperands = 0;
        v89 = 0uLL;
      }
    }
    else
    {
      v89 = 0uLL;
    }
    ZeroAttr = v3[1];
    if (!ZeroAttr)
    {
      v89 = 0uLL;
      return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
    }
    if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)ZeroAttr + 8))
    {
      ZeroAttr = 0;
      v89 = 0uLL;
      return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
    }
    v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)ZeroAttr + 8);
    *(_QWORD *)&v89 = ZeroAttr;
    *((_QWORD *)&v89 + 1) = v13;
    v14 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v89);
    ZeroAttr = 0;
    if (canMapOperands)
    {
      if (v14 && canMapOperands == v14)
      {
        v15 = *v3;
        if (*v3
          && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          ZeroAttr = *v3;
          return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
        }
        v16 = v3[1];
        if (!v16)
        {
LABEL_92:
          ZeroAttr = 0;
          return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
        }
        v17 = *(void **)(*(_QWORD *)v16 + 136);
        ZeroAttr = v17 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id ? v3[1] : 0;
        if (v15 && v17 != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          if (v17 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
            && *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          {
            v65 = *v3;
            v62 = v16;
            Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65);
            if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62))
            {
              mlir::IntegerAttr::getValue(&v65, (llvm::APInt *)&v81);
              mlir::IntegerAttr::getValue(&v62, (llvm::APInt *)&v79);
              LODWORD(v69) = v82;
              if (v82 > 0x40)
                llvm::APInt::initSlowCase((llvm::APInt *)&v68, &v81);
              else
                v68 = v81;
              v26 = v80;
              if (v80 > 0x40)
              {
                if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v79) != v26)
                {
LABEL_69:
                  llvm::APInt::srem(&v68, (const llvm::APInt *)&v79, (uint64_t)&v87);
                  v27 = 0;
                  DWORD2(v89) = DWORD2(v87);
                  *(_QWORD *)&v89 = v87;
                  DWORD2(v87) = 0;
                  LOBYTE(v90[0]) = 1;
                  if (v69 >= 0x41)
                  {
                    if (v68)
                      MEMORY[0x20BD002D4](v68, 0x1000C8000313F17);
                    v27 = 0;
                  }
LABEL_75:
                  if (v80 >= 0x41 && v79)
                    MEMORY[0x20BD002D4](v79, 0x1000C8000313F17);
                  if (v82 >= 0x41 && v81)
                    MEMORY[0x20BD002D4](v81, 0x1000C8000313F17);
                  ZeroAttr = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v89);
                  if (LOBYTE(v90[0]))
                  {
LABEL_82:
                    if (DWORD2(v89) >= 0x41 && (_QWORD)v89)
                      MEMORY[0x20BD002D4](v89, 0x1000C8000313F17);
                  }
LABEL_91:
                  if (!v27)
                    return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
                  goto LABEL_92;
                }
              }
              else if (v79)
              {
                goto LABEL_69;
              }
              DWORD2(v89) = v69;
              *(_QWORD *)&v89 = v68;
              v27 = 1;
              LOBYTE(v90[0]) = 1;
              goto LABEL_75;
            }
LABEL_90:
            v27 = 0;
            ZeroAttr = 0;
            goto LABEL_91;
          }
          if (mlir::DenseElementsAttr::classof(*v3))
            v19 = v15;
          else
            v19 = 0;
          *(_QWORD *)&v89 = v19;
          if (v19 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v89))
          {
            v20 = v3[1];
            v21 = mlir::DenseElementsAttr::classof(v20) ? v20 : 0;
            *(_QWORD *)&v89 = v21;
            if (v21)
            {
              if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v89))
              {
                v22 = v3[1];
                v65 = *v3;
                v62 = v22;
                v23 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65);
                if (v23 != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62))
                  goto LABEL_90;
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v65, (uint64_t)&v89);
                v87 = v89;
                v88 = v90[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v87, (llvm::APInt *)&v77);
                mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v62, (uint64_t)&v89);
                v87 = v89;
                v88 = v90[0];
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v87, (llvm::APInt *)&v75);
                LODWORD(v69) = v78;
                if (v78 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v68, &v77);
                else
                  v68 = v77;
                v53 = v76;
                if (v76 > 0x40)
                {
                  if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v75) != v53)
                  {
LABEL_178:
                    llvm::APInt::srem(&v68, (const llvm::APInt *)&v75, (uint64_t)&v87);
                    v27 = 0;
                    DWORD2(v89) = DWORD2(v87);
                    *(_QWORD *)&v89 = v87;
                    DWORD2(v87) = 0;
                    LOBYTE(v90[0]) = 1;
                    if (v69 >= 0x41)
                    {
                      if (v68)
                        MEMORY[0x20BD002D4](v68, 0x1000C8000313F17);
                      v27 = 0;
                    }
LABEL_184:
                    if (v76 >= 0x41 && v75)
                      MEMORY[0x20BD002D4](v75, 0x1000C8000313F17);
                    if (v78 >= 0x41 && v77)
                      MEMORY[0x20BD002D4](v77, 0x1000C8000313F17);
                    v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                    ZeroAttr = mlir::DenseElementsAttr::get(canMapOperands, v54, (llvm::APInt *)&v89, 1);
                    if (LOBYTE(v90[0]))
                      goto LABEL_82;
                    goto LABEL_91;
                  }
                }
                else if (v75)
                {
                  goto LABEL_178;
                }
                DWORD2(v89) = v69;
                *(_QWORD *)&v89 = v68;
                v27 = 1;
                LOBYTE(v90[0]) = 1;
                goto LABEL_184;
              }
            }
          }
          if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
            || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
          {
            goto LABEL_92;
          }
          v24 = (_QWORD *)*v3;
          if (*v3)
            v25 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v24 + 8);
          else
            v25 = 0;
          v73 = v24;
          v74 = v25;
          v28 = (_QWORD *)v3[1];
          if (v28)
            v29 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v28 + 8);
          else
            v29 = 0;
          v72[0] = v28;
          v72[1] = v29;
          Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v73);
          if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v72))
            goto LABEL_90;
          mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v73, (uint64_t)&v87);
          mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v72, (uint64_t)&v68);
          ZeroAttr = 0;
          v27 = 0;
          v32 = v71;
          if (BYTE8(v88) && v71)
          {
            LOWORD(v65) = v87;
            if ((_BYTE)v87)
              v66 = *((_QWORD *)&v87 + 1);
            else
              (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v87 + 1) + 16))(&v66);
            v67 = v88;
            LOWORD(v62) = (_WORD)v68;
            if ((_BYTE)v68)
              v63 = v69;
            else
              (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v69 + 16))(&v63);
            v64 = v70;
            *(_QWORD *)&v89 = v90;
            *((_QWORD *)&v89 + 1) = 0x400000000;
            NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v73, v74);
            llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v89, NumElements);
            v34 = mlir::ElementsAttr::getNumElements((uint64_t)v73, v74);
            if (v34)
            {
              v35 = v34;
              v27 = 0;
              v36 = v67;
              while (1)
              {
                v37 = BYTE1(v65) ? 0 : v36;
                if ((_BYTE)v65)
                {
                  v38 = v66 + 16 * v37;
                  v58 = *(_DWORD *)(v38 + 8);
                  if (v58 > 0x40)
                    llvm::APInt::initSlowCase((llvm::APInt *)&v57, (const void **)v38);
                  else
                    v57 = *(const void **)v38;
                }
                else
                {
                  (*(void (**)(const void **__return_ptr))(*(_QWORD *)v66 + 24))(&v57);
                }
                v39 = BYTE1(v62) ? 0 : v64;
                if ((_BYTE)v62)
                {
                  v40 = v63 + 16 * v39;
                  v56 = *(_DWORD *)(v40 + 8);
                  if (v56 > 0x40)
                    llvm::APInt::initSlowCase((llvm::APInt *)&v55, (const void **)v40);
                  else
                    v55 = *(const void **)v40;
                }
                else
                {
                  (*(void (**)(const void **__return_ptr))(*(_QWORD *)v63 + 24))(&v55);
                }
                v84 = v58;
                if (v58 > 0x40)
                  llvm::APInt::initSlowCase((llvm::APInt *)&v83, &v57);
                else
                  v83 = v57;
                if (v27)
                  break;
                v44 = v56;
                if (v56 > 0x40)
                {
                  if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v55) == v44)
                    break;
                }
                else if (!v55)
                {
                  break;
                }
                llvm::APInt::srem(&v83, (const llvm::APInt *)&v55, (uint64_t)&v85);
                v27 = 0;
                v60 = v86;
                v59 = v85;
                v86 = 0;
                v61 = 1;
                if (v84 >= 0x41)
                {
                  if (v83)
                    MEMORY[0x20BD002D4](v83, 0x1000C8000313F17);
                  v27 = 0;
                }
LABEL_126:
                if (v56 >= 0x41 && v55)
                  MEMORY[0x20BD002D4](v55, 0x1000C8000313F17);
                if (v58 >= 0x41 && v57)
                  MEMORY[0x20BD002D4](v57, 0x1000C8000313F17);
                if (!v61)
                {
                  ZeroAttr = 0;
                  goto LABEL_151;
                }
                Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v89, (unint64_t)&v59, 1);
                v42 = (llvm::APInt *)(v89 + 16 * DWORD2(v89));
                v43 = *((_DWORD *)Address + 2);
                *((_DWORD *)v42 + 2) = v43;
                if (v43 > 0x40)
                  llvm::APInt::initSlowCase(v42, (const void **)Address);
                else
                  *(_QWORD *)v42 = *(_QWORD *)Address;
                ++DWORD2(v89);
                if (v61 && v60 >= 0x41 && v59)
                  MEMORY[0x20BD002D4](v59, 0x1000C8000313F17);
                v36 = ++v67;
                ++v64;
                if (!--v35)
                  goto LABEL_149;
              }
              v60 = v84;
              v59 = v83;
              v27 = 1;
              v61 = 1;
              goto LABEL_126;
            }
            v27 = 0;
LABEL_149:
            v45 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            ZeroAttr = mlir::DenseElementsAttr::get(canMapOperands, v45, (llvm::APInt *)v89, DWORD2(v89));
LABEL_151:
            v46 = (char *)v89;
            if (DWORD2(v89))
            {
              v47 = 16 * DWORD2(v89);
              do
              {
                if (*(_DWORD *)&v46[v47 - 8] >= 0x41u)
                {
                  v48 = *(_QWORD *)&v46[v47 - 16];
                  if (v48)
                    MEMORY[0x20BD002D4](v48, 0x1000C8000313F17);
                }
                v47 -= 16;
              }
              while (v47);
              v46 = (char *)v89;
            }
            if (v46 != (char *)v90)
              free(v46);
            if (!(_BYTE)v62)
            {
              v49 = v63;
              v63 = 0;
              if (v49)
                (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
            }
            if (!(_BYTE)v65)
            {
              v50 = v66;
              v66 = 0;
              if (v50)
                (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
            }
            v32 = v71;
          }
          if (v32)
          {
            if (!(_BYTE)v68)
            {
              v51 = v69;
              v69 = 0;
              if (v51)
                (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
            }
          }
          if (BYTE8(v88))
          {
            if (!(_BYTE)v87)
            {
              v52 = *((_QWORD *)&v87 + 1);
              *((_QWORD *)&v87 + 1) = 0;
              if (v52)
                (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  return ZeroAttr & 0xFFFFFFFFFFFFFFFBLL;
}

uint64_t mlir::arith::AndIOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  _BOOL4 v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DefiningOp;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t NextResultAtOffset;
  uint64_t *v32;
  uint64_t canMapOperands;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t Value;
  int v42;
  unint64_t v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  unint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t Type;
  int v57;
  unint64_t NumElements;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  char *Address;
  llvm::APInt *v69;
  unsigned int v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  unint64_t v82;
  unsigned int v83;
  const void *v84;
  unsigned int v85;
  unint64_t v86;
  unsigned int v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unsigned __int8 v98;
  _QWORD v99[2];
  _QWORD *v100;
  uint64_t v101;
  unint64_t v102;
  unsigned int v103;
  unint64_t v104;
  unsigned int v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  _OWORD v109[4];
  uint64_t v110;

  v110 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  if (!v4)
  {
    v81 = 1;
    v80 = 0;
    goto LABEL_21;
  }
  DWORD2(v108) = 1;
  *(_QWORD *)&v108 = 0;
  *(_QWORD *)&v106 = &v108;
  v5 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v106, v4);
  v6 = DWORD2(v108);
  if (v5)
  {
    if (DWORD2(v108) < 0x41)
    {
      v7 = (_QWORD)v108 == 0;
      goto LABEL_12;
    }
    if (v6 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v108) > 0x40)
    {
      if ((_QWORD)v108)
        MEMORY[0x20BD002D4](v108, 0x1000C8000313F17);
      goto LABEL_16;
    }
    v7 = *(_QWORD *)v108 == 0;
  }
  else
  {
    v7 = 0;
    if (DWORD2(v108) < 0x41)
      goto LABEL_12;
  }
  if (!(_QWORD)v108)
  {
LABEL_12:
    if (v7)
      return *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 56) | 4;
    goto LABEL_16;
  }
  MEMORY[0x20BD002D4](v108, 0x1000C8000313F17);
  if (v7)
    return *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 56) | 4;
LABEL_16:
  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  v81 = 1;
  v80 = 0;
  *(_QWORD *)&v108 = &v80;
  if (v9 && mlir::detail::constant_int_value_binder::match((uint64_t *)&v108, v9))
  {
    v10 = v81;
    if (v81)
    {
      if (v81 > 0x40)
      {
        if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v80) != v10)
          goto LABEL_21;
      }
      else if (v80 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v81)
      {
        goto LABEL_21;
      }
    }
    v8 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) | 4;
    if (v81 >= 0x41)
      goto LABEL_94;
    return v8;
  }
LABEL_21:
  v11 = *(_QWORD *)(*a1 + 72);
  v12 = *(_QWORD *)(v11 + 56);
  *(_QWORD *)&v108 = *(_QWORD *)(v11 + 24);
  *((_QWORD *)&v108 + 1) = &v80;
  *(_QWORD *)&v106 = v12;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v106);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id
      && (*(_BYTE *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 2)
    {
      v14 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      v15 = v108;
      if (mlir::detail::matchOperandOrValueAtIndex<mlir::detail::constant_int_value_binder>(DefiningOp, 1u, (uint64_t *)&v108 + 1))
      {
        if (v15 == v14)
        {
          v16 = v81;
          if (!v81)
            goto LABEL_98;
          if (v81 > 0x40)
          {
            if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v80) == v16)
              goto LABEL_98;
          }
          else if (v80 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v81)
          {
LABEL_98:
            *(_QWORD *)&v108 = mlir::Attribute::getContext((mlir::Attribute *)(*a1 + 24));
            v8 = (unint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v108, (mlir::MLIRContext *)(*(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8)) & 0xFFFFFFFFFFFFFFFBLL;
            if (v81 >= 0x41)
              goto LABEL_94;
            return v8;
          }
        }
      }
    }
  }
  v17 = *(_QWORD *)(*a1 + 72);
  v18 = *(_QWORD *)(v17 + 24);
  *(_QWORD *)&v108 = *(_QWORD *)(v17 + 56);
  *((_QWORD *)&v108 + 1) = &v80;
  *(_QWORD *)&v106 = v18;
  v19 = mlir::Value::getDefiningOp((mlir::Value *)&v106);
  if (v19)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v19 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id
      && (*(_BYTE *)(v19 + 46) & 0x80) != 0
      && *(_DWORD *)(v19 + 68) == 2)
    {
      v20 = *(_QWORD *)(*(_QWORD *)(v19 + 72) + 24);
      v21 = v108;
      if (mlir::detail::matchOperandOrValueAtIndex<mlir::detail::constant_int_value_binder>(v19, 1u, (uint64_t *)&v108 + 1))
      {
        if (v21 == v20)
        {
          v22 = v81;
          if (!v81)
            goto LABEL_98;
          if (v81 > 0x40)
          {
            if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v80) == v22)
              goto LABEL_98;
          }
          else if (v80 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v81)
          {
            goto LABEL_98;
          }
        }
      }
    }
  }
  v23 = *a1;
  *(_QWORD *)&v108 = *(_QWORD *)(*(_QWORD *)(v23 + 72) + 24);
  v24 = mlir::Value::getDefiningOp((mlir::Value *)&v108);
  if (!v24)
  {
    v25 = *(_QWORD *)(v23 + 72);
    goto LABEL_50;
  }
  v25 = *(_QWORD *)(v23 + 72);
  if (*(_UNKNOWN **)(*(_QWORD *)(v24 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::arith::AndIOp,void>::id
    || (v26 = *(_QWORD *)(v25 + 56), v27 = *(_QWORD *)(v24 + 72), v26 != *(_QWORD *)(v27 + 24))
    && v26 != *(_QWORD *)(v27 + 56))
  {
LABEL_50:
    *(_QWORD *)&v108 = *(_QWORD *)(v25 + 56);
    v24 = mlir::Value::getDefiningOp((mlir::Value *)&v108);
    if (!v24)
      goto LABEL_60;
    if (*(_UNKNOWN **)(*(_QWORD *)(v24 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::arith::AndIOp,void>::id)
      goto LABEL_60;
    v28 = *(_QWORD *)(*(_QWORD *)(v23 + 72) + 24);
    v29 = *(_QWORD *)(v24 + 72);
    if (v28 != *(_QWORD *)(v29 + 24) && v28 != *(_QWORD *)(v29 + 56))
      goto LABEL_60;
  }
  if (*(_DWORD *)(v24 + 36))
    v30 = v24 - 16;
  else
    v30 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v30, 0);
  if (NextResultAtOffset)
  {
    v8 = NextResultAtOffset | 4;
    if (v81 >= 0x41)
      goto LABEL_94;
    return v8;
  }
LABEL_60:
  v32 = *(uint64_t **)(a2 + 40);
  canMapOperands = *v32;
  if (*v32
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v8 = canMapOperands & 0xFFFFFFFFFFFFFFFBLL;
    if (v81 >= 0x41)
      goto LABEL_94;
    return v8;
  }
  v34 = v32[1];
  if (v34 && *(_UNKNOWN **)(*(_QWORD *)v34 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_93;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v35 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      *(_QWORD *)&v108 = canMapOperands;
      *((_QWORD *)&v108 + 1) = v35;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v108);
    }
    else
    {
      canMapOperands = 0;
      v108 = 0uLL;
    }
  }
  else
  {
    v108 = 0uLL;
  }
  v34 = v32[1];
  if (!v34)
  {
    v108 = 0uLL;
    goto LABEL_93;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v34 + 8))
  {
    v34 = 0;
    v108 = 0uLL;
    goto LABEL_93;
  }
  v36 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v34 + 8);
  *(_QWORD *)&v108 = v34;
  *((_QWORD *)&v108 + 1) = v36;
  v37 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v108);
  v34 = 0;
  if (!canMapOperands || !v37 || canMapOperands != v37)
  {
LABEL_93:
    v8 = v34 & 0xFFFFFFFFFFFFFFFBLL;
    if (v81 >= 0x41)
      goto LABEL_94;
    return v8;
  }
  v38 = *v32;
  if (*v32 && *(_UNKNOWN **)(*(_QWORD *)v38 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v34 = *v32;
    goto LABEL_93;
  }
  v39 = v32[1];
  if (!v39)
    goto LABEL_135;
  v40 = *(void **)(*(_QWORD *)v39 + 136);
  if (v40 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v34 = v32[1];
  else
    v34 = 0;
  if (!v38 || v40 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_93;
  if (v40 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && *(_UNKNOWN **)(*(_QWORD *)v38 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v89 = *v32;
    v86 = v39;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v89);
    if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v86))
    {
      mlir::IntegerAttr::getValue(&v89, (llvm::APInt *)&v95);
      mlir::IntegerAttr::getValue(&v86, (llvm::APInt *)&v92);
      v42 = v96;
      DWORD2(v106) = v96;
      if (v96 > 0x40)
      {
        llvm::APInt::initSlowCase((llvm::APInt *)&v106, (const void **)&v95);
        v42 = DWORD2(v106);
        DWORD2(v108) = DWORD2(v106);
        v43 = v106;
        *(_QWORD *)&v108 = v106;
        DWORD2(v106) = 0;
        if (DWORD2(v108) > 0x40)
        {
          llvm::APInt::andAssignSlowCase((uint64_t)&v108, (const llvm::APInt *)&v92);
          LOBYTE(v109[0]) = 1;
          if (DWORD2(v106) >= 0x41 && (_QWORD)v106)
            MEMORY[0x20BD002D4](v106, 0x1000C8000313F17);
LABEL_119:
          if (v93 >= 0x41 && v92)
            MEMORY[0x20BD002D4](v92, 0x1000C8000313F17);
          if (v96 >= 0x41 && v95)
            MEMORY[0x20BD002D4](v95, 0x1000C8000313F17);
          v34 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v108);
          if (LOBYTE(v109[0]))
            goto LABEL_126;
          goto LABEL_93;
        }
      }
      else
      {
        v43 = v95;
      }
      DWORD2(v108) = v42;
      *(_QWORD *)&v108 = v92 & v43;
      LOBYTE(v109[0]) = 1;
      goto LABEL_119;
    }
LABEL_135:
    v8 = 0;
    if (v81 >= 0x41)
      goto LABEL_94;
    return v8;
  }
  if (mlir::DenseElementsAttr::classof(*v32))
    v45 = v38;
  else
    v45 = 0;
  *(_QWORD *)&v108 = v45;
  if (v45 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v108))
  {
    v46 = v32[1];
    v47 = mlir::DenseElementsAttr::classof(v46) ? v46 : 0;
    *(_QWORD *)&v108 = v47;
    if (v47)
    {
      if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v108))
      {
        v48 = v32[1];
        v89 = *v32;
        v86 = v48;
        v49 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v89);
        if (v49 != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v86))
          goto LABEL_135;
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v89, (uint64_t)&v108);
        v106 = v108;
        v107 = v109[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v106, (llvm::APInt *)&v95);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v86, (uint64_t)&v108);
        v106 = v108;
        v107 = v109[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v106, (llvm::APInt *)&v92);
        v50 = v96;
        DWORD2(v106) = v96;
        if (v96 > 0x40)
        {
          llvm::APInt::initSlowCase((llvm::APInt *)&v106, (const void **)&v95);
          v50 = DWORD2(v106);
          DWORD2(v108) = DWORD2(v106);
          v51 = v106;
          *(_QWORD *)&v108 = v106;
          DWORD2(v106) = 0;
          if (DWORD2(v108) > 0x40)
          {
            llvm::APInt::andAssignSlowCase((uint64_t)&v108, (const llvm::APInt *)&v92);
            LOBYTE(v109[0]) = 1;
            if (DWORD2(v106) >= 0x41 && (_QWORD)v106)
              MEMORY[0x20BD002D4](v106, 0x1000C8000313F17);
LABEL_217:
            if (v93 >= 0x41 && v92)
              MEMORY[0x20BD002D4](v92, 0x1000C8000313F17);
            if (v96 >= 0x41 && v95)
              MEMORY[0x20BD002D4](v95, 0x1000C8000313F17);
            v79 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            v34 = mlir::DenseElementsAttr::get(canMapOperands, v79, (llvm::APInt *)&v108, 1);
            if (LOBYTE(v109[0]))
            {
LABEL_126:
              if (DWORD2(v108) >= 0x41 && (_QWORD)v108)
              {
                MEMORY[0x20BD002D4](v108, 0x1000C8000313F17);
                v8 = v34 & 0xFFFFFFFFFFFFFFFBLL;
                if (v81 >= 0x41)
                  goto LABEL_94;
                return v8;
              }
              goto LABEL_93;
            }
            goto LABEL_93;
          }
        }
        else
        {
          v51 = v95;
        }
        DWORD2(v108) = v50;
        *(_QWORD *)&v108 = v92 & v51;
        LOBYTE(v109[0]) = 1;
        goto LABEL_217;
      }
    }
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v32 + 8)
    || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v32[1] + 8))
  {
    goto LABEL_135;
  }
  v52 = (_QWORD *)*v32;
  v53 = *v32 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v52 + 8) : 0;
  v100 = v52;
  v101 = v53;
  v54 = (_QWORD *)v32[1];
  v55 = v54 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v54 + 8) : 0;
  v99[0] = v54;
  v99[1] = v55;
  Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v100);
  if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v99))
    goto LABEL_135;
  mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v100, (uint64_t)&v106);
  mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v99, (uint64_t)&v95);
  v34 = 0;
  v57 = v98;
  if (!BYTE8(v107) || !v98)
    goto LABEL_206;
  LOWORD(v92) = v106;
  if ((_BYTE)v106)
    v93 = *((_QWORD *)&v106 + 1);
  else
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v106 + 1) + 16))(&v93);
  v94 = v107;
  LOWORD(v89) = v95;
  if ((_BYTE)v95)
    v90 = v96;
  else
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v96 + 16))(&v90);
  v91 = v97;
  *(_QWORD *)&v108 = v109;
  *((_QWORD *)&v108 + 1) = 0x400000000;
  NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v100, v101);
  llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v108, NumElements);
  v59 = mlir::ElementsAttr::getNumElements((uint64_t)v100, v101);
  if (!v59)
  {
LABEL_188:
    v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
    v34 = mlir::DenseElementsAttr::get(canMapOperands, v71, (llvm::APInt *)v108, DWORD2(v108));
    goto LABEL_190;
  }
  v60 = v59;
  v61 = v94;
  while (1)
  {
    if (BYTE1(v92))
      v62 = 0;
    else
      v62 = v61;
    if ((_BYTE)v92)
    {
      v63 = v93 + 16 * v62;
      v85 = *(_DWORD *)(v63 + 8);
      if (v85 > 0x40)
        llvm::APInt::initSlowCase((llvm::APInt *)&v84, (const void **)v63);
      else
        v84 = *(const void **)v63;
    }
    else
    {
      (*(void (**)(const void **__return_ptr))(*(_QWORD *)v93 + 24))(&v84);
    }
    if (BYTE1(v89))
      v64 = 0;
    else
      v64 = v91;
    if ((_BYTE)v89)
    {
      v65 = v90 + 16 * v64;
      v83 = *(_DWORD *)(v65 + 8);
      if (v83 > 0x40)
        llvm::APInt::initSlowCase((llvm::APInt *)&v82, (const void **)v65);
      else
        v82 = *(_QWORD *)v65;
    }
    else
    {
      (*(void (**)(unint64_t *__return_ptr))(*(_QWORD *)v90 + 24))(&v82);
    }
    v66 = v85;
    v103 = v85;
    if (v85 <= 0x40)
    {
      v67 = (unint64_t)v84;
LABEL_170:
      v87 = v66;
      v86 = v82 & v67;
      v88 = 1;
      goto LABEL_171;
    }
    llvm::APInt::initSlowCase((llvm::APInt *)&v102, &v84);
    v66 = v103;
    v105 = v103;
    v67 = v102;
    v104 = v102;
    v103 = 0;
    if (v105 <= 0x40)
      goto LABEL_170;
    llvm::APInt::andAssignSlowCase((uint64_t)&v104, (const llvm::APInt *)&v82);
    v87 = v105;
    v86 = v104;
    v88 = 1;
    if (v103 >= 0x41 && v102)
      MEMORY[0x20BD002D4](v102, 0x1000C8000313F17);
LABEL_171:
    if (v83 >= 0x41 && v82)
      MEMORY[0x20BD002D4](v82, 0x1000C8000313F17);
    if (v85 >= 0x41 && v84)
      MEMORY[0x20BD002D4](v84, 0x1000C8000313F17);
    if (!v88)
      break;
    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v108, (unint64_t)&v86, 1);
    v69 = (llvm::APInt *)(v108 + 16 * DWORD2(v108));
    v70 = *((_DWORD *)Address + 2);
    *((_DWORD *)v69 + 2) = v70;
    if (v70 > 0x40)
      llvm::APInt::initSlowCase(v69, (const void **)Address);
    else
      *(_QWORD *)v69 = *(_QWORD *)Address;
    ++DWORD2(v108);
    if (v88 && v87 >= 0x41 && v86)
      MEMORY[0x20BD002D4](v86, 0x1000C8000313F17);
    v61 = ++v94;
    ++v91;
    if (!--v60)
      goto LABEL_188;
  }
  v34 = 0;
LABEL_190:
  v72 = (char *)v108;
  if (DWORD2(v108))
  {
    v73 = 16 * DWORD2(v108);
    do
    {
      if (*(_DWORD *)&v72[v73 - 8] >= 0x41u)
      {
        v74 = *(_QWORD *)&v72[v73 - 16];
        if (v74)
          MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
      }
      v73 -= 16;
    }
    while (v73);
    v72 = (char *)v108;
  }
  if (v72 != (char *)v109)
    free(v72);
  if (!(_BYTE)v89)
  {
    v75 = v90;
    v90 = 0;
    if (v75)
      (*(void (**)(uint64_t))(*(_QWORD *)v75 + 8))(v75);
  }
  if (!(_BYTE)v92)
  {
    v76 = v93;
    v93 = 0;
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v76 + 8))(v76);
  }
  v57 = v98;
LABEL_206:
  if (v57)
  {
    if (!(_BYTE)v95)
    {
      v77 = v96;
      v96 = 0;
      if (v77)
        (*(void (**)(uint64_t))(*(_QWORD *)v77 + 8))(v77);
    }
  }
  if (!BYTE8(v107))
    goto LABEL_93;
  if ((_BYTE)v106)
    goto LABEL_93;
  v78 = *((_QWORD *)&v106 + 1);
  *((_QWORD *)&v106 + 1) = 0;
  if (!v78)
    goto LABEL_93;
  (*(void (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
  v8 = v34 & 0xFFFFFFFFFFFFFFFBLL;
  if (v81 < 0x41)
    return v8;
LABEL_94:
  if (v80)
    MEMORY[0x20BD002D4](v80, 0x1000C8000313F17);
  return v8;
}

unint64_t mlir::arith::OrIOp::fold(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v5;
  int v6;
  char v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t DefiningOp;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t *v21;
  uint64_t canMapOperands;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t Value;
  int v31;
  unint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t Type;
  int v49;
  unint64_t NumElements;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  unint64_t v59;
  char *Address;
  llvm::APInt *v61;
  unsigned int v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  unint64_t v74;
  unsigned int v75;
  const void *v76;
  unsigned int v77;
  unint64_t v78;
  unsigned int v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned __int8 v90;
  _QWORD v91[2];
  _QWORD *v92;
  uint64_t v93;
  unint64_t v94;
  unsigned int v95;
  unint64_t v96;
  unsigned int v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  _OWORD v101[4];
  uint64_t v102;

  v102 = *MEMORY[0x24BDAC8D0];
  DWORD2(v100) = 1;
  *(_QWORD *)&v100 = 0;
  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  *(_QWORD *)&v98 = &v100;
  if (!v5)
    goto LABEL_16;
  v6 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v98, v5);
  v7 = v6;
  v8 = DWORD2(v100);
  if (v6)
  {
    if (DWORD2(v100) > 0x40)
    {
      if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v100) != v8)
      {
        if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v100) != v8)
        {
          if ((_QWORD)v100)
            MEMORY[0x20BD002D4](v100, 0x1000C8000313F17);
          goto LABEL_16;
        }
LABEL_14:
        v2 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8) & 0xFFFFFFFFFFFFFFFBLL;
        if (v8 < 0x41)
          goto LABEL_15;
        goto LABEL_11;
      }
    }
    else if ((_QWORD)v100)
    {
      if (DWORD2(v100) && (_QWORD)v100 != 0xFFFFFFFFFFFFFFFFLL >> -BYTE8(v100))
        goto LABEL_16;
      goto LABEL_14;
    }
    v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
  }
  if (v8 < 0x41)
    goto LABEL_15;
LABEL_11:
  if ((_QWORD)v100)
    MEMORY[0x20BD002D4](v100, 0x1000C8000313F17);
LABEL_15:
  if ((v7 & 1) != 0)
    return v2;
LABEL_16:
  v73 = 1;
  v72 = 0;
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 72);
  v10 = *(_QWORD *)(v9 + 56);
  *(_QWORD *)&v100 = *(_QWORD *)(v9 + 24);
  *((_QWORD *)&v100 + 1) = &v72;
  *(_QWORD *)&v98 = v10;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v98);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id
      && (*(_BYTE *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 2)
    {
      v12 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
      v13 = v100;
      if (mlir::detail::matchOperandOrValueAtIndex<mlir::detail::constant_int_value_binder>(DefiningOp, 1u, (uint64_t *)&v100 + 1))
      {
        if (v13 == v12)
        {
          v14 = v73;
          if (v73)
          {
            if (v73 > 0x40)
            {
              if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v72) != v14)
                goto LABEL_25;
            }
            else if (v72 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v73)
            {
              goto LABEL_25;
            }
          }
          v41 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 56);
          goto LABEL_94;
        }
      }
    }
  }
LABEL_25:
  v15 = *(_QWORD *)(*(_QWORD *)a1 + 72);
  v16 = *(_QWORD *)(v15 + 24);
  *(_QWORD *)&v100 = *(_QWORD *)(v15 + 56);
  *((_QWORD *)&v100 + 1) = &v72;
  *(_QWORD *)&v98 = v16;
  v17 = mlir::Value::getDefiningOp((mlir::Value *)&v98);
  if (v17)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v17 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id
      && (*(_BYTE *)(v17 + 46) & 0x80) != 0
      && *(_DWORD *)(v17 + 68) == 2)
    {
      v18 = *(_QWORD *)(*(_QWORD *)(v17 + 72) + 24);
      v19 = v100;
      if (mlir::detail::matchOperandOrValueAtIndex<mlir::detail::constant_int_value_binder>(v17, 1u, (uint64_t *)&v100 + 1))
      {
        if (v19 == v18)
        {
          v20 = v73;
          if (v73)
          {
            if (v73 > 0x40)
            {
              if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v72) != v20)
                goto LABEL_34;
            }
            else if (v72 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v73)
            {
              goto LABEL_34;
            }
          }
          v41 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
LABEL_94:
          *(_QWORD *)&v100 = v41;
          v44 = mlir::Value::getDefiningOp((mlir::Value *)&v100);
          if (*(_UNKNOWN **)(*(_QWORD *)(v44 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id)
            v45 = v44;
          else
            v45 = 0;
          v2 = *(_QWORD *)(*(_QWORD *)(v45 + 72) + 56) | 4;
          if (v73 >= 0x41)
            goto LABEL_70;
          return v2;
        }
      }
    }
  }
LABEL_34:
  v21 = *(uint64_t **)(a2 + 40);
  canMapOperands = *v21;
  if (*v21
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v2 = canMapOperands & 0xFFFFFFFFFFFFFFFBLL;
    if (v73 >= 0x41)
      goto LABEL_70;
    return v2;
  }
  v23 = v21[1];
  if (v23 && *(_UNKNOWN **)(*(_QWORD *)v23 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_69;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v24 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      *(_QWORD *)&v100 = canMapOperands;
      *((_QWORD *)&v100 + 1) = v24;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v100);
    }
    else
    {
      canMapOperands = 0;
      v100 = 0uLL;
    }
  }
  else
  {
    v100 = 0uLL;
  }
  v23 = v21[1];
  if (!v23)
  {
    v100 = 0uLL;
    goto LABEL_69;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v23 + 8))
  {
    v23 = 0;
    v100 = 0uLL;
    goto LABEL_69;
  }
  v25 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v23 + 8);
  *(_QWORD *)&v100 = v23;
  *((_QWORD *)&v100 + 1) = v25;
  v26 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v100);
  v23 = 0;
  if (!canMapOperands || !v26 || canMapOperands != v26)
  {
LABEL_69:
    v2 = v23 & 0xFFFFFFFFFFFFFFFBLL;
    if (v73 >= 0x41)
      goto LABEL_70;
    return v2;
  }
  v27 = *v21;
  if (*v21 && *(_UNKNOWN **)(*(_QWORD *)v27 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v23 = *v21;
    goto LABEL_69;
  }
  v28 = v21[1];
  if (!v28)
    goto LABEL_117;
  v29 = *(void **)(*(_QWORD *)v28 + 136);
  if (v29 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v23 = v21[1];
  else
    v23 = 0;
  if (!v27 || v29 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    goto LABEL_69;
  if (v29 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && *(_UNKNOWN **)(*(_QWORD *)v27 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v81 = *v21;
    v78 = v28;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v81);
    if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v78))
    {
      mlir::IntegerAttr::getValue(&v81, (llvm::APInt *)&v87);
      mlir::IntegerAttr::getValue(&v78, (llvm::APInt *)&v84);
      v31 = v88;
      DWORD2(v98) = v88;
      if (v88 > 0x40)
      {
        llvm::APInt::initSlowCase((llvm::APInt *)&v98, (const void **)&v87);
        v31 = DWORD2(v98);
        DWORD2(v100) = DWORD2(v98);
        v32 = v98;
        *(_QWORD *)&v100 = v98;
        DWORD2(v98) = 0;
        if (DWORD2(v100) > 0x40)
        {
          llvm::APInt::orAssignSlowCase((uint64_t)&v100, (const llvm::APInt *)&v84);
          LOBYTE(v101[0]) = 1;
          if (DWORD2(v98) >= 0x41 && (_QWORD)v98)
            MEMORY[0x20BD002D4](v98, 0x1000C8000313F17);
LABEL_101:
          if (v85 >= 0x41 && v84)
            MEMORY[0x20BD002D4](v84, 0x1000C8000313F17);
          if (v88 >= 0x41 && v87)
            MEMORY[0x20BD002D4](v87, 0x1000C8000313F17);
          v23 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v100);
          if (LOBYTE(v101[0]))
            goto LABEL_108;
          goto LABEL_69;
        }
      }
      else
      {
        v32 = v87;
      }
      DWORD2(v100) = v31;
      *(_QWORD *)&v100 = v84 | v32;
      LOBYTE(v101[0]) = 1;
      goto LABEL_101;
    }
LABEL_117:
    v2 = 0;
    if (v73 >= 0x41)
      goto LABEL_70;
    return v2;
  }
  if (mlir::DenseElementsAttr::classof(*v21))
    v34 = v27;
  else
    v34 = 0;
  *(_QWORD *)&v100 = v34;
  if (v34 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v100))
  {
    v35 = v21[1];
    v36 = mlir::DenseElementsAttr::classof(v35) ? v35 : 0;
    *(_QWORD *)&v100 = v36;
    if (v36)
    {
      if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v100))
      {
        v37 = v21[1];
        v81 = *v21;
        v78 = v37;
        v38 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v81);
        if (v38 != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v78))
          goto LABEL_117;
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v81, (uint64_t)&v100);
        v98 = v100;
        v99 = v101[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v98, (llvm::APInt *)&v87);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v78, (uint64_t)&v100);
        v98 = v100;
        v99 = v101[0];
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v98, (llvm::APInt *)&v84);
        v39 = v88;
        DWORD2(v98) = v88;
        if (v88 > 0x40)
        {
          llvm::APInt::initSlowCase((llvm::APInt *)&v98, (const void **)&v87);
          v39 = DWORD2(v98);
          DWORD2(v100) = DWORD2(v98);
          v40 = v98;
          *(_QWORD *)&v100 = v98;
          DWORD2(v98) = 0;
          if (DWORD2(v100) > 0x40)
          {
            llvm::APInt::orAssignSlowCase((uint64_t)&v100, (const llvm::APInt *)&v84);
            LOBYTE(v101[0]) = 1;
            if (DWORD2(v98) >= 0x41 && (_QWORD)v98)
              MEMORY[0x20BD002D4](v98, 0x1000C8000313F17);
LABEL_199:
            if (v85 >= 0x41 && v84)
              MEMORY[0x20BD002D4](v84, 0x1000C8000313F17);
            if (v88 >= 0x41 && v87)
              MEMORY[0x20BD002D4](v87, 0x1000C8000313F17);
            v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            v23 = mlir::DenseElementsAttr::get(canMapOperands, v71, (llvm::APInt *)&v100, 1);
            if (LOBYTE(v101[0]))
            {
LABEL_108:
              if (DWORD2(v100) >= 0x41 && (_QWORD)v100)
              {
                MEMORY[0x20BD002D4](v100, 0x1000C8000313F17);
                v2 = v23 & 0xFFFFFFFFFFFFFFFBLL;
                if (v73 >= 0x41)
                  goto LABEL_70;
                return v2;
              }
              goto LABEL_69;
            }
            goto LABEL_69;
          }
        }
        else
        {
          v40 = v87;
        }
        DWORD2(v100) = v39;
        *(_QWORD *)&v100 = v84 | v40;
        LOBYTE(v101[0]) = 1;
        goto LABEL_199;
      }
    }
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v21 + 8)
    || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v21[1] + 8))
  {
    goto LABEL_117;
  }
  v42 = (_QWORD *)*v21;
  v43 = *v21 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v42 + 8) : 0;
  v92 = v42;
  v93 = v43;
  v46 = (_QWORD *)v21[1];
  v47 = v46 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v46 + 8) : 0;
  v91[0] = v46;
  v91[1] = v47;
  Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v92);
  if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v91))
    goto LABEL_117;
  mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v92, (uint64_t)&v98);
  mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v91, (uint64_t)&v87);
  v23 = 0;
  v49 = v90;
  if (!BYTE8(v99) || !v90)
    goto LABEL_188;
  LOWORD(v84) = v98;
  if ((_BYTE)v98)
    v85 = *((_QWORD *)&v98 + 1);
  else
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v98 + 1) + 16))(&v85);
  v86 = v99;
  LOWORD(v81) = v87;
  if ((_BYTE)v87)
    v82 = v88;
  else
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v88 + 16))(&v82);
  v83 = v89;
  *(_QWORD *)&v100 = v101;
  *((_QWORD *)&v100 + 1) = 0x400000000;
  NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v92, v93);
  llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v100, NumElements);
  v51 = mlir::ElementsAttr::getNumElements((uint64_t)v92, v93);
  if (!v51)
  {
LABEL_170:
    v63 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
    v23 = mlir::DenseElementsAttr::get(canMapOperands, v63, (llvm::APInt *)v100, DWORD2(v100));
    goto LABEL_172;
  }
  v52 = v51;
  v53 = v86;
  while (1)
  {
    if (BYTE1(v84))
      v54 = 0;
    else
      v54 = v53;
    if ((_BYTE)v84)
    {
      v55 = v85 + 16 * v54;
      v77 = *(_DWORD *)(v55 + 8);
      if (v77 > 0x40)
        llvm::APInt::initSlowCase((llvm::APInt *)&v76, (const void **)v55);
      else
        v76 = *(const void **)v55;
    }
    else
    {
      (*(void (**)(const void **__return_ptr))(*(_QWORD *)v85 + 24))(&v76);
    }
    if (BYTE1(v81))
      v56 = 0;
    else
      v56 = v83;
    if ((_BYTE)v81)
    {
      v57 = v82 + 16 * v56;
      v75 = *(_DWORD *)(v57 + 8);
      if (v75 > 0x40)
        llvm::APInt::initSlowCase((llvm::APInt *)&v74, (const void **)v57);
      else
        v74 = *(_QWORD *)v57;
    }
    else
    {
      (*(void (**)(unint64_t *__return_ptr))(*(_QWORD *)v82 + 24))(&v74);
    }
    v58 = v77;
    v95 = v77;
    if (v77 <= 0x40)
    {
      v59 = (unint64_t)v76;
LABEL_152:
      v79 = v58;
      v78 = v74 | v59;
      v80 = 1;
      goto LABEL_153;
    }
    llvm::APInt::initSlowCase((llvm::APInt *)&v94, &v76);
    v58 = v95;
    v97 = v95;
    v59 = v94;
    v96 = v94;
    v95 = 0;
    if (v58 <= 0x40)
      goto LABEL_152;
    llvm::APInt::orAssignSlowCase((uint64_t)&v96, (const llvm::APInt *)&v74);
    v79 = v97;
    v78 = v96;
    v80 = 1;
    if (v95 >= 0x41 && v94)
      MEMORY[0x20BD002D4](v94, 0x1000C8000313F17);
LABEL_153:
    if (v75 >= 0x41 && v74)
      MEMORY[0x20BD002D4](v74, 0x1000C8000313F17);
    if (v77 >= 0x41 && v76)
      MEMORY[0x20BD002D4](v76, 0x1000C8000313F17);
    if (!v80)
      break;
    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v100, (unint64_t)&v78, 1);
    v61 = (llvm::APInt *)(v100 + 16 * DWORD2(v100));
    v62 = *((_DWORD *)Address + 2);
    *((_DWORD *)v61 + 2) = v62;
    if (v62 > 0x40)
      llvm::APInt::initSlowCase(v61, (const void **)Address);
    else
      *(_QWORD *)v61 = *(_QWORD *)Address;
    ++DWORD2(v100);
    if (v80 && v79 >= 0x41 && v78)
      MEMORY[0x20BD002D4](v78, 0x1000C8000313F17);
    v53 = ++v86;
    ++v83;
    if (!--v52)
      goto LABEL_170;
  }
  v23 = 0;
LABEL_172:
  v64 = (char *)v100;
  if (DWORD2(v100))
  {
    v65 = 16 * DWORD2(v100);
    do
    {
      if (*(_DWORD *)&v64[v65 - 8] >= 0x41u)
      {
        v66 = *(_QWORD *)&v64[v65 - 16];
        if (v66)
          MEMORY[0x20BD002D4](v66, 0x1000C8000313F17);
      }
      v65 -= 16;
    }
    while (v65);
    v64 = (char *)v100;
  }
  if (v64 != (char *)v101)
    free(v64);
  if (!(_BYTE)v81)
  {
    v67 = v82;
    v82 = 0;
    if (v67)
      (*(void (**)(uint64_t))(*(_QWORD *)v67 + 8))(v67);
  }
  if (!(_BYTE)v84)
  {
    v68 = v85;
    v85 = 0;
    if (v68)
      (*(void (**)(uint64_t))(*(_QWORD *)v68 + 8))(v68);
  }
  v49 = v90;
LABEL_188:
  if (v49)
  {
    if (!(_BYTE)v87)
    {
      v69 = v88;
      v88 = 0;
      if (v69)
        (*(void (**)(uint64_t))(*(_QWORD *)v69 + 8))(v69);
    }
  }
  if (!BYTE8(v99))
    goto LABEL_69;
  if ((_BYTE)v98)
    goto LABEL_69;
  v70 = *((_QWORD *)&v98 + 1);
  *((_QWORD *)&v98 + 1) = 0;
  if (!v70)
    goto LABEL_69;
  (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
  v2 = v23 & 0xFFFFFFFFFFFFFFFBLL;
  if (v73 < 0x41)
    return v2;
LABEL_70:
  if (v72)
    MEMORY[0x20BD002D4](v72, 0x1000C8000313F17);
  return v2;
}

uint64_t mlir::arith::XOrIOp::fold(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  _BOOL4 v7;
  uint64_t v9;
  uint64_t DefiningOp;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t canMapOperands;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t Value;
  int v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t Type;
  int v44;
  unint64_t NumElements;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  unint64_t v54;
  char *Address;
  llvm::APInt *v56;
  unsigned int v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unsigned int v68;
  const void *v69;
  unsigned int v70;
  unint64_t v71;
  unsigned int v72;
  char v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 v83;
  _QWORD v84[2];
  _QWORD *v85;
  uint64_t v86;
  unint64_t v87;
  unsigned int v88;
  unint64_t v89;
  unsigned int v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  _OWORD v94[4];
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8);
  if (!v4)
    goto LABEL_15;
  DWORD2(v93) = 1;
  *(_QWORD *)&v93 = 0;
  *(_QWORD *)&v91 = &v93;
  v5 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v91, v4);
  v6 = DWORD2(v93);
  if (v5)
  {
    if (DWORD2(v93) < 0x41)
    {
      v7 = (_QWORD)v93 == 0;
      goto LABEL_11;
    }
    if (v6 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v93) > 0x40)
    {
      if ((_QWORD)v93)
        MEMORY[0x20BD002D4](v93, 0x1000C8000313F17);
      goto LABEL_15;
    }
    v7 = *(_QWORD *)v93 == 0;
  }
  else
  {
    v7 = 0;
    if (DWORD2(v93) < 0x41)
      goto LABEL_11;
  }
  if (!(_QWORD)v93)
  {
LABEL_11:
    if (v7)
      return *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) | 4;
    goto LABEL_15;
  }
  MEMORY[0x20BD002D4](v93, 0x1000C8000313F17);
  if (v7)
    return *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24) | 4;
LABEL_15:
  v9 = *(_QWORD *)(*a1 + 72);
  if (*(_QWORD *)(v9 + 24) == *(_QWORD *)(v9 + 56))
  {
    *(_QWORD *)&v93 = mlir::Attribute::getContext((mlir::Attribute *)(*a1 + 24));
    return (unint64_t)mlir::Builder::getZeroAttr((mlir::IndexType **)&v93, (mlir::MLIRContext *)(*(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8)) & 0xFFFFFFFFFFFFFFFBLL;
  }
  *(_QWORD *)&v93 = *(_QWORD *)(v9 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v93);
  if (DefiningOp)
  {
    v11 = *a1;
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id)
    {
      v12 = *(_QWORD *)(DefiningOp + 72);
      v13 = *(_QWORD *)(v12 + 56);
      v14 = *(_QWORD *)(*(_QWORD *)(v11 + 72) + 56);
      v15 = *(_QWORD *)(v12 + 24);
      if (v13 == v14)
        return v15 | 4;
      if (v15 == v14)
        return v13 | 4;
    }
  }
  else
  {
    v11 = *a1;
  }
  *(_QWORD *)&v93 = *(_QWORD *)(*(_QWORD *)(v11 + 72) + 56);
  v16 = mlir::Value::getDefiningOp((mlir::Value *)&v93);
  if (v16
    && *(_UNKNOWN **)(*(_QWORD *)(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id)
  {
    v22 = *(_QWORD *)(v16 + 72);
    v23 = *(_QWORD *)(v22 + 56);
    v24 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
    v13 = *(_QWORD *)(v22 + 24);
    if (v23 == v24)
      return v13 | 4;
    if (v13 == v24)
      return v23 | 4;
  }
  v17 = *(uint64_t **)(a2 + 40);
  canMapOperands = *v17;
  if (*v17
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v19 = *v17;
    return v19 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v19 = v17[1];
  if (!v19 || *(_UNKNOWN **)(*(_QWORD *)v19 + 136) != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    if (canMapOperands)
    {
      if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
      {
        v20 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
        *(_QWORD *)&v93 = canMapOperands;
        *((_QWORD *)&v93 + 1) = v20;
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v93);
      }
      else
      {
        canMapOperands = 0;
        v93 = 0uLL;
      }
    }
    else
    {
      v93 = 0uLL;
    }
    v19 = v17[1];
    if (!v19)
    {
      v93 = 0uLL;
      return v19 & 0xFFFFFFFFFFFFFFFBLL;
    }
    if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v19 + 8))
    {
      v19 = 0;
      v93 = 0uLL;
      return v19 & 0xFFFFFFFFFFFFFFFBLL;
    }
    v21 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)v19 + 8);
    *(_QWORD *)&v93 = v19;
    *((_QWORD *)&v93 + 1) = v21;
    v25 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v93);
    v19 = 0;
    if (canMapOperands)
    {
      if (v25 && canMapOperands == v25)
      {
        v26 = *v17;
        if (*v17
          && *(_UNKNOWN **)(*(_QWORD *)v26 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
        {
          v19 = *v17;
          return v19 & 0xFFFFFFFFFFFFFFFBLL;
        }
        v27 = v17[1];
        if (!v27)
          goto LABEL_96;
        v28 = *(void **)(*(_QWORD *)v27 + 136);
        if (v28 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          v19 = v17[1];
        else
          v19 = 0;
        if (!v26 || v28 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
          return v19 & 0xFFFFFFFFFFFFFFFBLL;
        if (v28 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
          && *(_UNKNOWN **)(*(_QWORD *)v26 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        {
          v74 = *v17;
          v71 = v27;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v74);
          if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v71))
          {
            mlir::IntegerAttr::getValue(&v74, (llvm::APInt *)&v80);
            mlir::IntegerAttr::getValue(&v71, (llvm::APInt *)&v77);
            v30 = v81;
            DWORD2(v91) = v81;
            if (v81 > 0x40)
            {
              llvm::APInt::initSlowCase((llvm::APInt *)&v91, (const void **)&v80);
              v30 = DWORD2(v91);
              DWORD2(v93) = DWORD2(v91);
              v31 = v91;
              *(_QWORD *)&v93 = v91;
              DWORD2(v91) = 0;
              if (DWORD2(v93) > 0x40)
              {
                llvm::APInt::xorAssignSlowCase((uint64_t)&v93, (const llvm::APInt *)&v77);
                LOBYTE(v94[0]) = 1;
                if (DWORD2(v91) >= 0x41 && (_QWORD)v91)
                  MEMORY[0x20BD002D4](v91, 0x1000C8000313F17);
LABEL_81:
                if (v78 >= 0x41 && v77)
                  MEMORY[0x20BD002D4](v77, 0x1000C8000313F17);
                if (v81 >= 0x41 && v80)
                  MEMORY[0x20BD002D4](v80, 0x1000C8000313F17);
                v19 = mlir::IntegerAttr::get(canMapOperands, (llvm::APInt *)&v93);
                if (!LOBYTE(v94[0]))
                  return v19 & 0xFFFFFFFFFFFFFFFBLL;
                goto LABEL_88;
              }
            }
            else
            {
              v31 = v80;
            }
            DWORD2(v93) = v30;
            *(_QWORD *)&v93 = v77 ^ v31;
            LOBYTE(v94[0]) = 1;
            goto LABEL_81;
          }
LABEL_96:
          v19 = 0;
          return v19 & 0xFFFFFFFFFFFFFFFBLL;
        }
        if (mlir::DenseElementsAttr::classof(*v17))
          v32 = v26;
        else
          v32 = 0;
        *(_QWORD *)&v93 = v32;
        if (v32 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v93))
        {
          v33 = v17[1];
          v34 = mlir::DenseElementsAttr::classof(v33) ? v33 : 0;
          *(_QWORD *)&v93 = v34;
          if (v34)
          {
            if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v93))
            {
              v35 = v17[1];
              v74 = *v17;
              v71 = v35;
              v36 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v74);
              if (v36 != mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v71))
                goto LABEL_96;
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v74, (uint64_t)&v93);
              v91 = v93;
              v92 = v94[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v91, (llvm::APInt *)&v80);
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v71, (uint64_t)&v93);
              v91 = v93;
              v92 = v94[0];
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v91, (llvm::APInt *)&v77);
              v37 = v81;
              DWORD2(v91) = v81;
              if (v81 > 0x40)
              {
                llvm::APInt::initSlowCase((llvm::APInt *)&v91, (const void **)&v80);
                v37 = DWORD2(v91);
                DWORD2(v93) = DWORD2(v91);
                v38 = v91;
                *(_QWORD *)&v93 = v91;
                DWORD2(v91) = 0;
                if (DWORD2(v93) > 0x40)
                {
                  llvm::APInt::xorAssignSlowCase((uint64_t)&v93, (const llvm::APInt *)&v77);
                  LOBYTE(v94[0]) = 1;
                  if (DWORD2(v91) >= 0x41 && (_QWORD)v91)
                    MEMORY[0x20BD002D4](v91, 0x1000C8000313F17);
LABEL_177:
                  if (v78 >= 0x41 && v77)
                    MEMORY[0x20BD002D4](v77, 0x1000C8000313F17);
                  if (v81 >= 0x41 && v80)
                    MEMORY[0x20BD002D4](v80, 0x1000C8000313F17);
                  v66 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
                  v19 = mlir::DenseElementsAttr::get(canMapOperands, v66, (llvm::APInt *)&v93, 1);
                  if (!LOBYTE(v94[0]))
                    return v19 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_88:
                  if (DWORD2(v93) >= 0x41)
                  {
                    if ((_QWORD)v93)
                      MEMORY[0x20BD002D4](v93, 0x1000C8000313F17);
                  }
                  return v19 & 0xFFFFFFFFFFFFFFFBLL;
                }
              }
              else
              {
                v38 = v80;
              }
              DWORD2(v93) = v37;
              *(_QWORD *)&v93 = v77 ^ v38;
              LOBYTE(v94[0]) = 1;
              goto LABEL_177;
            }
          }
        }
        if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v17 + 8)
          || !mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v17[1] + 8))
        {
          goto LABEL_96;
        }
        v39 = (_QWORD *)*v17;
        v40 = *v17 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v39 + 8) : 0;
        v85 = v39;
        v86 = v40;
        v41 = (_QWORD *)v17[1];
        v42 = v41 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v41 + 8) : 0;
        v84[0] = v41;
        v84[1] = v42;
        Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v85);
        if (Type != mlir::ElementsAttr::getType((mlir::ElementsAttr *)v84))
          goto LABEL_96;
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)&v85, (uint64_t)&v91);
        mlir::ElementsAttr::try_value_begin<llvm::APInt>((mlir::BranchOpInterface *)v84, (uint64_t)&v80);
        v19 = 0;
        v44 = v83;
        if (!BYTE8(v92) || !v83)
          goto LABEL_167;
        LOWORD(v77) = v91;
        if ((_BYTE)v91)
          v78 = *((_QWORD *)&v91 + 1);
        else
          (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)&v91 + 1) + 16))(&v78);
        v79 = v92;
        LOWORD(v74) = v80;
        if ((_BYTE)v80)
          v75 = v81;
        else
          (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v81 + 16))(&v75);
        v76 = v82;
        *(_QWORD *)&v93 = v94;
        *((_QWORD *)&v93 + 1) = 0x400000000;
        NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v85, v86);
        llvm::SmallVectorImpl<llvm::APInt>::reserve((uint64_t)&v93, NumElements);
        v46 = mlir::ElementsAttr::getNumElements((uint64_t)v85, v86);
        if (!v46)
        {
LABEL_149:
          v58 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
          v19 = mlir::DenseElementsAttr::get(canMapOperands, v58, (llvm::APInt *)v93, DWORD2(v93));
          goto LABEL_151;
        }
        v47 = v46;
        v48 = v79;
        while (1)
        {
          v49 = BYTE1(v77) ? 0 : v48;
          if ((_BYTE)v77)
          {
            v50 = v78 + 16 * v49;
            v70 = *(_DWORD *)(v50 + 8);
            if (v70 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v69, (const void **)v50);
            else
              v69 = *(const void **)v50;
          }
          else
          {
            (*(void (**)(const void **__return_ptr))(*(_QWORD *)v78 + 24))(&v69);
          }
          v51 = BYTE1(v74) ? 0 : v76;
          if ((_BYTE)v74)
          {
            v52 = v75 + 16 * v51;
            v68 = *(_DWORD *)(v52 + 8);
            if (v68 > 0x40)
              llvm::APInt::initSlowCase((llvm::APInt *)&v67, (const void **)v52);
            else
              v67 = *(_QWORD *)v52;
          }
          else
          {
            (*(void (**)(unint64_t *__return_ptr))(*(_QWORD *)v75 + 24))(&v67);
          }
          v53 = v70;
          v88 = v70;
          if (v70 <= 0x40)
            break;
          llvm::APInt::initSlowCase((llvm::APInt *)&v87, &v69);
          v53 = v88;
          v90 = v88;
          v54 = v87;
          v89 = v87;
          v88 = 0;
          if (v90 <= 0x40)
            goto LABEL_131;
          llvm::APInt::xorAssignSlowCase((uint64_t)&v89, (const llvm::APInt *)&v67);
          v72 = v90;
          v71 = v89;
          v73 = 1;
          if (v88 >= 0x41 && v87)
            MEMORY[0x20BD002D4](v87, 0x1000C8000313F17);
LABEL_132:
          if (v68 >= 0x41 && v67)
            MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
          if (v70 >= 0x41 && v69)
            MEMORY[0x20BD002D4](v69, 0x1000C8000313F17);
          if (!v73)
          {
            v19 = 0;
LABEL_151:
            v59 = (char *)v93;
            if (DWORD2(v93))
            {
              v60 = 16 * DWORD2(v93);
              do
              {
                if (*(_DWORD *)&v59[v60 - 8] >= 0x41u)
                {
                  v61 = *(_QWORD *)&v59[v60 - 16];
                  if (v61)
                    MEMORY[0x20BD002D4](v61, 0x1000C8000313F17);
                }
                v60 -= 16;
              }
              while (v60);
              v59 = (char *)v93;
            }
            if (v59 != (char *)v94)
              free(v59);
            if (!(_BYTE)v74)
            {
              v62 = v75;
              v75 = 0;
              if (v62)
                (*(void (**)(uint64_t))(*(_QWORD *)v62 + 8))(v62);
            }
            if (!(_BYTE)v77)
            {
              v63 = v78;
              v78 = 0;
              if (v63)
                (*(void (**)(uint64_t))(*(_QWORD *)v63 + 8))(v63);
            }
            v44 = v83;
LABEL_167:
            if (v44)
            {
              if (!(_BYTE)v80)
              {
                v64 = v81;
                v81 = 0;
                if (v64)
                  (*(void (**)(uint64_t))(*(_QWORD *)v64 + 8))(v64);
              }
            }
            if (BYTE8(v92))
            {
              if (!(_BYTE)v91)
              {
                v65 = *((_QWORD *)&v91 + 1);
                *((_QWORD *)&v91 + 1) = 0;
                if (v65)
                  (*(void (**)(uint64_t))(*(_QWORD *)v65 + 8))(v65);
              }
            }
            return v19 & 0xFFFFFFFFFFFFFFFBLL;
          }
          Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v93, (unint64_t)&v71, 1);
          v56 = (llvm::APInt *)(v93 + 16 * DWORD2(v93));
          v57 = *((_DWORD *)Address + 2);
          *((_DWORD *)v56 + 2) = v57;
          if (v57 > 0x40)
            llvm::APInt::initSlowCase(v56, (const void **)Address);
          else
            *(_QWORD *)v56 = *(_QWORD *)Address;
          ++DWORD2(v93);
          if (v73 && v72 >= 0x41 && v71)
            MEMORY[0x20BD002D4](v71, 0x1000C8000313F17);
          v48 = ++v79;
          ++v76;
          if (!--v47)
            goto LABEL_149;
        }
        v54 = (unint64_t)v69;
LABEL_131:
        v72 = v53;
        v71 = v67 ^ v54;
        v73 = 1;
        goto LABEL_132;
      }
    }
  }
  return v19 & 0xFFFFFFFFFFFFFFFBLL;
}

void mlir::arith::XOrIOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  __int16 v106;
  __int128 v107;
  __int128 v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 2);
  *(_QWORD *)&v107 = "arith.cmpi";
  *((_QWORD *)&v107 + 1) = 10;
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"arith.xori", 10, v106, a2, &v107, 1uLL);
  *(_QWORD *)v4 = &off_24C0285B8;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  *(_QWORD *)&v107 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::XOrINotCmpI]";
  *((_QWORD *)&v107 + 1) = 84;
  v9 = llvm::StringRef::find((uint64_t *)&v107, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v107 + 1) >= v9)
    v10 = v9;
  else
    v10 = *((_QWORD *)&v107 + 1);
  v11 = v107 + v10;
  v12 = *((_QWORD *)&v107 + 1) - v10;
  if (*((_QWORD *)&v107 + 1) - v10 >= 0x12)
    v13 = 18;
  else
    v13 = *((_QWORD *)&v107 + 1) - v10;
  v14 = v11 + v13;
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_116;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_117;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_120;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_120:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 3);
  v107 = xmmword_24C060A70;
  v108 = *(_OWORD *)&off_24C060A80;
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"arith.xori", 10, v106, a2, &v107, 2uLL);
  *(_QWORD *)v38 = &off_24C028638;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  *(_QWORD *)&v107 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::XOrIOfExtUI]";
  *((_QWORD *)&v107 + 1) = 84;
  v43 = llvm::StringRef::find((uint64_t *)&v107, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v107 + 1) >= v43)
    v44 = v43;
  else
    v44 = *((_QWORD *)&v107 + 1);
  v45 = v107 + v44;
  v46 = *((_QWORD *)&v107 + 1) - v44;
  if (*((_QWORD *)&v107 + 1) - v44 >= 0x12)
    v47 = 18;
  else
    v47 = *((_QWORD *)&v107 + 1) - v44;
  v48 = v45 + v47;
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_116;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_117;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_121;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_121:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v106, 3);
  v107 = xmmword_24C060A90;
  v108 = *(_OWORD *)&off_24C060AA0;
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"arith.xori", 10, v106, a2, &v107, 2uLL);
  *(_QWORD *)v72 = &off_24C0285F8;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  *(_QWORD *)&v107 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::XOrIOfExtSI]";
  *((_QWORD *)&v107 + 1) = 84;
  v77 = llvm::StringRef::find((uint64_t *)&v107, "DesiredTypeName = ", 0x12uLL, 0);
  if (*((_QWORD *)&v107 + 1) >= v77)
    v78 = v77;
  else
    v78 = *((_QWORD *)&v107 + 1);
  v79 = v107 + v78;
  v80 = *((_QWORD *)&v107 + 1) - v78;
  if (*((_QWORD *)&v107 + 1) - v78 >= 0x12)
    v81 = 18;
  else
    v81 = *((_QWORD *)&v107 + 1) - v78;
  v82 = v79 + v81;
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
LABEL_116:
    abort();
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (!v88)
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
    goto LABEL_112;
  }
  if (v88 >> 61)
LABEL_117:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v89 = (char *)operator new(8 * v88);
  v90 = (uint64_t *)&v89[8 * v85];
  v91 = &v89[8 * v88];
  *v90 = v72;
  v76 = (uint64_t)(v90 + 1);
  v92 = (char *)(v75 - v84);
  if (v75 != v84)
  {
LABEL_100:
    v93 = (unint64_t)(v92 - 8);
    if (v93 < 0x78
      || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
      && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
    {
      goto LABEL_122;
    }
    v94 = (v93 >> 3) + 1;
    v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
    v96 = &v75[-v95];
    v90 = (uint64_t *)((char *)v90 - v95);
    v97 = &v89[8 * v85 - 16];
    v98 = v75 - 16;
    v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v101 = *((_OWORD *)v98 - 1);
      v100 = *(_OWORD *)v98;
      *((_OWORD *)v98 - 1) = 0uLL;
      *(_OWORD *)v98 = 0uLL;
      *((_OWORD *)v97 - 1) = v101;
      *(_OWORD *)v97 = v100;
      v97 -= 32;
      v98 -= 32;
      v99 -= 4;
    }
    while (v99);
    v75 = v96;
    if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_122:
      do
      {
        v102 = *((_QWORD *)v75 - 1);
        v75 -= 8;
        *(_QWORD *)v75 = 0;
        *--v90 = v102;
      }
      while (v75 != v84);
    }
    v75 = (char *)a1[1];
    v103 = (char *)a1[2];
    a1[1] = v90;
    a1[2] = v76;
    a1[3] = v91;
    while (v103 != v75)
    {
      v105 = *((_QWORD *)v103 - 1);
      v103 -= 8;
      v104 = v105;
      *(_QWORD *)v103 = 0;
      if (v105)
        (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
    }
    goto LABEL_113;
  }
LABEL_112:
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
}

uint64_t mlir::arith::NegFOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  llvm::APFloatBase *v9;
  void *v10;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  llvm::APFloatBase *v15;
  void *v16;
  uint64_t v17;
  llvm::APFloatBase *Value;
  uint64_t v19;
  unint64_t NumElements;
  llvm::APFloatBase *v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  uint64_t v27;
  void **v28;
  void **v29;
  uint64_t v30;
  llvm::detail::DoubleAPFloat *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  const llvm::detail::DoubleAPFloat *v38;
  void *v39;
  void *v40;
  llvm::APFloatBase *v41;
  void *v42;
  llvm::APFloatBase *v43;
  char *Address;
  llvm::detail::IEEEFloat *v45;
  const llvm::detail::DoubleAPFloat *v46;
  void *v47;
  llvm::APFloatBase *ArgOperands;
  uint64_t v49;
  void **v50;
  uint64_t v51;
  void *v52;
  char *v53;
  uint64_t v54;
  llvm::detail::DoubleAPFloat *v55;
  llvm::APFloatBase *v56;
  llvm::APFloatBase *v57;
  __int16 v58;
  llvm::APFloatBase *v59;
  uint64_t v60;
  uint64_t v61;
  llvm::APFloatBase *v62;
  uint64_t v63;
  char v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[3];
  unint64_t v69;
  _QWORD v70[3];
  char v71;
  void **v72;
  uint64_t v73;
  _BYTE v74[16];
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v72 = *(void ***)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v72);
  if (DefiningOp
    && *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::NegFOp,void>::id)
  {
    return *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24) | 4;
  }
  v4 = *(uint64_t **)(a2 + 48);
  v5 = *v4;
  if (*v4)
  {
    v6 = *(void **)(*(_QWORD *)v5 + 136);
    if (v6 != &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    {
      if (v6 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        if (mlir::DenseElementsAttr::classof(*v4))
          v7 = v5;
        else
          v7 = 0;
        v72 = (void **)v7;
        if (v7 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v72))
        {
          v61 = *v4;
          mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v61, (uint64_t)&v69);
          mlir::constFoldUnaryOp<mlir::FloatAttr,llvm::APFloat,mlir::ub::PoisonAttr,mlir::arith::NegFOp::fold(mlir::arith::NegFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::NegFOp::fold(mlir::arith::NegFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APFloat)#1}::operator()(&v72, (uint64_t)&v69);
          v8 = (void *)v70[0];
          v10 = llvm::APFloatBase::PPCDoubleDouble(v9);
          if (v10 != v8)
          {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v70);
            if (!v75)
              goto LABEL_33;
            goto LABEL_30;
          }
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v70);
          if (v75)
          {
LABEL_30:
            Value = (llvm::APFloatBase *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v61);
            v5 = mlir::DenseElementsAttr::get(Value, v19, (uint64_t)&v72, 1);
            if (!v75)
              return v5 & 0xFFFFFFFFFFFFFFFBLL;
            if (v10 == (void *)v73)
              goto LABEL_32;
            goto LABEL_25;
          }
LABEL_33:
          v5 = 0;
          return v5 & 0xFFFFFFFFFFFFFFFBLL;
        }
        if (!mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v4 + 8))
          goto LABEL_33;
        v12 = (_QWORD *)*v4;
        if (v12)
        {
          v13 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v12 + 8);
          v65 = v12;
          v66 = v13;
          mlir::ElementsAttr::try_value_begin<llvm::APFloat>((mlir::BranchOpInterface *)&v65, (uint64_t)&v61);
          if (!v64)
            goto LABEL_33;
        }
        else
        {
          v65 = 0;
          v66 = 0;
          mlir::ElementsAttr::try_value_begin<llvm::APFloat>((mlir::BranchOpInterface *)&v65, (uint64_t)&v61);
          if (!v64)
            goto LABEL_33;
        }
        v58 = v61;
        if ((_BYTE)v61)
          v59 = v62;
        else
          (*(void (**)(llvm::APFloatBase **__return_ptr))(*(_QWORD *)v62 + 16))(&v59);
        v60 = v63;
        v72 = (void **)v74;
        v73 = 0x100000000;
        NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v65, v66);
        if (NumElements > HIDWORD(v73))
        {
          v69 = 0;
          v21 = (llvm::APFloatBase *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&v72, v74, NumElements, 32, &v69);
          v22 = (uint64_t)v21;
          v23 = v72;
          v24 = v73;
          if ((_DWORD)v73)
          {
            v25 = llvm::APFloatBase::PPCDoubleDouble(v21);
            v26 = (_QWORD *)(v22 + 8);
            v27 = 32 * v24;
            v28 = v23 + 1;
            do
            {
              while (v25 == *v28)
              {
                v26 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v26, v28) + 4;
                v28 += 4;
                v27 -= 32;
                if (!v27)
                  goto LABEL_42;
              }
              v26 = (_QWORD *)(llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v26, (uint64_t)v28) + 32);
              v28 += 4;
              v27 -= 32;
            }
            while (v27);
LABEL_42:
            v23 = v72;
            if ((_DWORD)v73)
            {
              v29 = v72 - 3;
              v30 = 4 * v73;
              do
              {
                while (1)
                {
                  v31 = (llvm::detail::DoubleAPFloat *)&v29[v30];
                  if (v25 != v29[v30])
                    break;
                  llvm::detail::DoubleAPFloat::~DoubleAPFloat(v31);
                  v30 -= 4;
                  if (!(v30 * 8))
                    goto LABEL_47;
                }
                llvm::detail::IEEEFloat::~IEEEFloat(v31);
                v30 -= 4;
              }
              while (v30 * 8);
LABEL_47:
              v23 = v72;
            }
          }
          v32 = v69;
          if (v23 != (void **)v74)
            free(v23);
          v72 = (void **)v22;
          HIDWORD(v73) = v32;
        }
        v33 = mlir::ElementsAttr::getNumElements((uint64_t)v65, v66);
        if (!v33)
        {
LABEL_73:
          ArgOperands = (llvm::APFloatBase *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v65);
          v43 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(ArgOperands, v49, (uint64_t)v72, v73);
          v5 = (uint64_t)v43;
          v50 = v72;
          v51 = v73;
          if ((_DWORD)v73)
          {
LABEL_76:
            v52 = llvm::APFloatBase::PPCDoubleDouble(v43);
            v53 = (char *)(v50 - 3);
            v54 = 32 * v51;
            do
            {
              while (1)
              {
                v55 = (llvm::detail::DoubleAPFloat *)&v53[v54];
                if (v52 != *(void **)&v53[v54])
                  break;
                llvm::detail::DoubleAPFloat::~DoubleAPFloat(v55);
                v54 -= 32;
                if (!v54)
                  goto LABEL_80;
              }
              llvm::detail::IEEEFloat::~IEEEFloat(v55);
              v54 -= 32;
            }
            while (v54);
LABEL_80:
            v50 = v72;
          }
LABEL_81:
          if (v50 != (void **)v74)
            free(v50);
          if (!(_BYTE)v58)
          {
            v56 = v59;
            v59 = 0;
            if (v56)
              (*(void (**)(llvm::APFloatBase *))(*(_QWORD *)v56 + 8))(v56);
          }
          if (v64 && !(_BYTE)v61)
          {
            v57 = v62;
            v62 = 0;
            if (v57)
              (*(void (**)(llvm::APFloatBase *))(*(_QWORD *)v57 + 8))(v57);
          }
          return v5 & 0xFFFFFFFFFFFFFFFBLL;
        }
        v34 = v33;
        v35 = v60;
        while (1)
        {
          if (HIBYTE(v58))
            v36 = 0;
          else
            v36 = v35;
          if ((_BYTE)v58)
          {
            v37 = (char *)v59 + 32 * v36;
            v39 = (void *)*((_QWORD *)v37 + 1);
            v38 = (const llvm::detail::DoubleAPFloat *)(v37 + 8);
            if (llvm::APFloatBase::PPCDoubleDouble(v59) == v39)
              llvm::detail::DoubleAPFloat::DoubleAPFloat(v68, v38);
            else
              llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v68, v38);
          }
          else
          {
            (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v59 + 24))(&v67);
          }
          mlir::constFoldUnaryOp<mlir::FloatAttr,llvm::APFloat,mlir::ub::PoisonAttr,mlir::arith::NegFOp::fold(mlir::arith::NegFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::NegFOp::fold(mlir::arith::NegFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APFloat)#1}::operator()(&v69, (uint64_t)&v67);
          v40 = (void *)v68[0];
          v42 = llvm::APFloatBase::PPCDoubleDouble(v41);
          if (v42 == v40)
          {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v68);
            if (!v71)
            {
LABEL_75:
              v5 = 0;
              v50 = v72;
              v51 = v73;
              if ((_DWORD)v73)
                goto LABEL_76;
              goto LABEL_81;
            }
          }
          else
          {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v68);
            if (!v71)
              goto LABEL_75;
          }
          Address = llvm::SmallVectorTemplateBase<llvm::APFloat,false>::reserveForParamAndGetAddress((unsigned int *)&v72, (unint64_t)&v69, 1);
          v45 = (llvm::detail::IEEEFloat *)&v72[4 * v73 + 1];
          v47 = (void *)*((_QWORD *)Address + 1);
          v46 = (const llvm::detail::DoubleAPFloat *)(Address + 8);
          if (v42 == v47)
          {
            llvm::detail::DoubleAPFloat::DoubleAPFloat(v45, v46);
            LODWORD(v73) = v73 + 1;
            if (v71)
            {
LABEL_71:
              if (v42 == (void *)v70[0])
                llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v70);
              else
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v70);
            }
          }
          else
          {
            llvm::detail::IEEEFloat::IEEEFloat(v45, v46);
            LODWORD(v73) = v73 + 1;
            if (v71)
              goto LABEL_71;
          }
          v35 = ++v60;
          if (!--v34)
            goto LABEL_73;
        }
      }
      v61 = *v4;
      mlir::FloatAttr::getValue((mlir::FloatAttr *)&v61, (uint64_t)&v69);
      mlir::constFoldUnaryOp<mlir::FloatAttr,llvm::APFloat,mlir::ub::PoisonAttr,mlir::arith::NegFOp::fold(mlir::arith::NegFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::NegFOp::fold(mlir::arith::NegFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APFloat)#1}::operator()(&v72, (uint64_t)&v69);
      v14 = (void *)v70[0];
      v16 = llvm::APFloatBase::PPCDoubleDouble(v15);
      if (v16 == v14)
      {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v70);
        if (!v75)
          goto LABEL_33;
      }
      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v70);
        if (!v75)
          goto LABEL_33;
      }
      v17 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v61);
      v5 = mlir::FloatAttr::get(v17, (uint64_t)&v72);
      if (v75)
      {
        if (v16 == (void *)v73)
        {
LABEL_32:
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v73);
          return v5 & 0xFFFFFFFFFFFFFFFBLL;
        }
LABEL_25:
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v73);
      }
    }
  }
  return v5 & 0xFFFFFFFFFFFFFFFBLL;
}

uint64_t mlir::arith::AddFOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  void *canMapOperands;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  llvm::APFloatBase *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t Value;
  void *v25;
  llvm::APFloatBase *v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t Type;
  int v33;
  unint64_t NumElements;
  llvm::APFloatBase *v35;
  llvm::APFloatBase *v36;
  void **v37;
  uint64_t v38;
  void *v39;
  _QWORD *v40;
  uint64_t v41;
  void **v42;
  char *v43;
  uint64_t v44;
  llvm::detail::DoubleAPFloat *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  const llvm::detail::DoubleAPFloat *v52;
  void *v53;
  uint64_t v54;
  char *v55;
  const llvm::detail::DoubleAPFloat *v56;
  void *v57;
  void *v58;
  llvm::APFloatBase *v59;
  void *v60;
  llvm::APFloatBase *v61;
  char *Address;
  llvm::detail::IEEEFloat *v63;
  const llvm::detail::DoubleAPFloat *v64;
  void *v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  void *v69;
  char *v70;
  uint64_t v71;
  llvm::detail::DoubleAPFloat *v72;
  llvm::APFloatBase *v73;
  llvm::APFloatBase *v74;
  llvm::APFloatBase *v75;
  uint64_t v76;
  uint64_t v77;
  __int16 v78;
  llvm::APFloatBase *v79;
  uint64_t v80;
  char v81;
  char v82;
  llvm::APFloatBase *v83;
  uint64_t v84;
  uint64_t v85;
  llvm::APFloatBase *v86;
  uint64_t v87;
  unsigned __int8 v88;
  _QWORD v89[2];
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD v93[3];
  uint64_t v94;
  _QWORD v95[3];
  unint64_t v96;
  _QWORD v97[3];
  char v98;
  void *v99;
  uint64_t v100;
  _BYTE v101[16];
  char v102;
  _BYTE v103[8];
  _QWORD v104[2];
  char v105;
  uint64_t v106;

  v106 = *MEMORY[0x24BDAC8D0];
  v3 = *(uint64_t **)(a2 + 48);
  v4 = v3[1];
  v99 = mlir::m_NegZeroFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  if (v4)
  {
    if ((mlir::detail::constant_float_predicate_matcher::match((llvm::APFloatBase *)&v99, v4) & 1) != 0)
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
    v3 = *(uint64_t **)(a2 + 48);
  }
  canMapOperands = (void *)*v3;
  if (*v3
    && *(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v8 = *v3;
    return v8 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v8 = v3[1];
  if (v8 && *(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    return v8 & 0xFFFFFFFFFFFFFFFBLL;
  if (canMapOperands)
  {
    if (mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8))
    {
      v9 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*(_QWORD *)canMapOperands + 8);
      v99 = canMapOperands;
      v100 = v9;
      canMapOperands = (void *)mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v99);
    }
    else
    {
      canMapOperands = 0;
      v99 = 0;
      v100 = 0;
    }
  }
  else
  {
    v99 = 0;
    v100 = 0;
  }
  v10 = (_QWORD *)v3[1];
  if (!v10)
  {
    v99 = 0;
    v100 = 0;
    goto LABEL_67;
  }
  if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v10 + 8))
  {
    v99 = 0;
    v100 = 0;
    goto LABEL_67;
  }
  v11 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v10 + 8);
  v99 = v10;
  v100 = v11;
  v12 = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v99);
  v8 = 0;
  if (!canMapOperands || !v12 || canMapOperands != (void *)v12)
    return v8 & 0xFFFFFFFFFFFFFFFBLL;
  v13 = (void *)*v3;
  if (*v3 && *(_UNKNOWN **)(*(_QWORD *)v13 + 136) == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
  {
    v8 = *v3;
    return v8 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v14 = v3[1];
  if (!v14)
  {
LABEL_67:
    v8 = 0;
    return v8 & 0xFFFFFFFFFFFFFFFBLL;
  }
  v15 = *(void **)(*(_QWORD *)v14 + 136);
  if (v15 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    v8 = v3[1];
  else
    v8 = 0;
  if (!v13 || v15 == &mlir::detail::TypeIDResolver<mlir::ub::PoisonAttr,void>::id)
    return v8 & 0xFFFFFFFFFFFFFFFBLL;
  if (v15 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)v13 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    if (mlir::DenseElementsAttr::classof(*v3))
      v20 = v13;
    else
      v20 = 0;
    v99 = v20;
    if (v20
      && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v99)
      && ((v21 = v3[1], !mlir::DenseElementsAttr::classof(v21)) ? (v22 = 0) : (v22 = (void *)v21),
          (v99 = v22) != 0 && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v99)))
    {
      v23 = v3[1];
      v85 = *v3;
      v94 = v23;
      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v85);
      if (Value == mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v94))
      {
        mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v85, (uint64_t)&v96);
        mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v94, (uint64_t)v103);
        mlir::constFoldBinaryOp<mlir::FloatAttr,llvm::APFloat,mlir::ub::PoisonAttr,mlir::arith::AddFOp::fold(mlir::arith::AddFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::AddFOp::fold(mlir::arith::AddFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APFloat,llvm::APFloat)#1}::operator()(&v99, (uint64_t)&v96, (uint64_t)v103);
        v25 = (void *)v104[0];
        v27 = llvm::APFloatBase::PPCDoubleDouble(v26);
        if (v27 == v25)
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v104);
        else
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v104);
        if (v27 == (void *)v97[0])
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v97);
        else
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v97);
        if (v102)
        {
          v77 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
          v8 = mlir::DenseElementsAttr::get((llvm::APFloatBase *)canMapOperands, v77, (uint64_t)&v99, 1);
          if (!v102)
            return v8 & 0xFFFFFFFFFFFFFFFBLL;
          if (v27 != (void *)v100)
            goto LABEL_61;
          goto LABEL_157;
        }
      }
    }
    else if (mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)*v3 + 8)
           && mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3[1] + 8))
    {
      v28 = (_QWORD *)*v3;
      v29 = *v3 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v28 + 8) : 0;
      v90 = v28;
      v91 = v29;
      v30 = (_QWORD *)v3[1];
      v31 = v30 ? mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v30 + 8) : 0;
      v89[0] = v30;
      v89[1] = v31;
      Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v90);
      if (Type == mlir::ElementsAttr::getType((mlir::ElementsAttr *)v89))
      {
        mlir::ElementsAttr::try_value_begin<llvm::APFloat>((mlir::BranchOpInterface *)&v90, (uint64_t)v103);
        mlir::ElementsAttr::try_value_begin<llvm::APFloat>((mlir::BranchOpInterface *)v89, (uint64_t)&v85);
        v8 = 0;
        v33 = v88;
        if (v105 && v88)
        {
          v81 = v103[0];
          v82 = v103[1];
          if (v103[0])
            v83 = (llvm::APFloatBase *)v104[0];
          else
            (*(void (**)(llvm::APFloatBase **__return_ptr))(*(_QWORD *)v104[0] + 16))(&v83);
          v84 = v104[1];
          v78 = v85;
          if ((_BYTE)v85)
            v79 = v86;
          else
            (*(void (**)(llvm::APFloatBase **__return_ptr))(*(_QWORD *)v86 + 16))(&v79);
          v80 = v87;
          v99 = v101;
          v100 = 0x400000000;
          NumElements = mlir::ElementsAttr::getNumElements((uint64_t)v90, v91);
          if (NumElements > HIDWORD(v100))
          {
            v96 = 0;
            v35 = (llvm::APFloatBase *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&v99, v101, NumElements, 32, &v96);
            v36 = v35;
            v37 = (void **)v99;
            v38 = v100;
            if ((_DWORD)v100)
            {
              v39 = llvm::APFloatBase::PPCDoubleDouble(v35);
              v40 = (_QWORD *)((char *)v36 + 8);
              v41 = 32 * v38;
              v42 = v37 + 1;
              do
              {
                while (v39 == *v42)
                {
                  v40 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v40, v42) + 4;
                  v42 += 4;
                  v41 -= 32;
                  if (!v41)
                    goto LABEL_83;
                }
                v40 = (_QWORD *)(llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v40, (uint64_t)v42) + 32);
                v42 += 4;
                v41 -= 32;
              }
              while (v41);
LABEL_83:
              v37 = (void **)v99;
              if ((_DWORD)v100)
              {
                v43 = (char *)v99 - 24;
                v44 = 32 * v100;
                do
                {
                  while (1)
                  {
                    v45 = (llvm::detail::DoubleAPFloat *)&v43[v44];
                    if (v39 != *(void **)&v43[v44])
                      break;
                    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v45);
                    v44 -= 32;
                    if (!v44)
                      goto LABEL_88;
                  }
                  llvm::detail::IEEEFloat::~IEEEFloat(v45);
                  v44 -= 32;
                }
                while (v44);
LABEL_88:
                v37 = (void **)v99;
              }
            }
            v46 = v96;
            if (v37 != (void **)v101)
              free(v37);
            v99 = v36;
            HIDWORD(v100) = v46;
          }
          v47 = mlir::ElementsAttr::getNumElements((uint64_t)v90, v91);
          if (v47)
          {
            v48 = v47;
            v49 = v84;
            while (1)
            {
              v50 = v82 ? 0 : v49;
              if (v81)
              {
                v51 = (char *)v83 + 32 * v50;
                v53 = (void *)*((_QWORD *)v51 + 1);
                v52 = (const llvm::detail::DoubleAPFloat *)(v51 + 8);
                if (llvm::APFloatBase::PPCDoubleDouble(v83) == v53)
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(v95, v52);
                else
                  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v95, v52);
              }
              else
              {
                (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v83 + 24))(&v94);
              }
              v54 = HIBYTE(v78) ? 0 : v80;
              if ((_BYTE)v78)
              {
                v55 = (char *)v79 + 32 * v54;
                v57 = (void *)*((_QWORD *)v55 + 1);
                v56 = (const llvm::detail::DoubleAPFloat *)(v55 + 8);
                if (llvm::APFloatBase::PPCDoubleDouble(v79) == v57)
                  llvm::detail::DoubleAPFloat::DoubleAPFloat(v93, v56);
                else
                  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v93, v56);
              }
              else
              {
                (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v79 + 24))(&v92);
              }
              mlir::constFoldBinaryOp<mlir::FloatAttr,llvm::APFloat,mlir::ub::PoisonAttr,mlir::arith::AddFOp::fold(mlir::arith::AddFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::AddFOp::fold(mlir::arith::AddFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APFloat,llvm::APFloat)#1}::operator()(&v96, (uint64_t)&v94, (uint64_t)&v92);
              v58 = (void *)v93[0];
              v60 = llvm::APFloatBase::PPCDoubleDouble(v59);
              if (v60 == v58)
                llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v93);
              else
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v93);
              if (v60 == (void *)v95[0])
                llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v95);
              else
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v95);
              if (!v98)
                break;
              Address = llvm::SmallVectorTemplateBase<llvm::APFloat,false>::reserveForParamAndGetAddress((unsigned int *)&v99, (unint64_t)&v96, 1);
              v63 = (llvm::detail::IEEEFloat *)((char *)v99 + 32 * v100 + 8);
              v65 = (void *)*((_QWORD *)Address + 1);
              v64 = (const llvm::detail::DoubleAPFloat *)(Address + 8);
              if (v60 == v65)
                llvm::detail::DoubleAPFloat::DoubleAPFloat(v63, v64);
              else
                llvm::detail::IEEEFloat::IEEEFloat(v63, v64);
              LODWORD(v100) = v100 + 1;
              if (v98)
              {
                if (v60 == (void *)v97[0])
                  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v97);
                else
                  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v97);
              }
              v49 = ++v84;
              ++v80;
              if (!--v48)
                goto LABEL_125;
            }
            v8 = 0;
          }
          else
          {
LABEL_125:
            v66 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)canMapOperands + 8);
            v61 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)canMapOperands, v66, (uint64_t)v99, v100);
            v8 = (uint64_t)v61;
          }
          v67 = (char *)v99;
          v68 = v100;
          if ((_DWORD)v100)
          {
            v69 = llvm::APFloatBase::PPCDoubleDouble(v61);
            v70 = v67 - 24;
            v71 = 32 * v68;
            do
            {
              while (1)
              {
                v72 = (llvm::detail::DoubleAPFloat *)&v70[v71];
                if (v69 != *(void **)&v70[v71])
                  break;
                llvm::detail::DoubleAPFloat::~DoubleAPFloat(v72);
                v71 -= 32;
                if (!v71)
                  goto LABEL_132;
              }
              llvm::detail::IEEEFloat::~IEEEFloat(v72);
              v71 -= 32;
            }
            while (v71);
LABEL_132:
            v67 = (char *)v99;
          }
          if (v67 != v101)
            free(v67);
          if (!(_BYTE)v78)
          {
            v73 = v79;
            v79 = 0;
            if (v73)
              (*(void (**)(llvm::APFloatBase *))(*(_QWORD *)v73 + 8))(v73);
          }
          if (!v81)
          {
            v74 = v83;
            v83 = 0;
            if (v74)
              (*(void (**)(llvm::APFloatBase *))(*(_QWORD *)v74 + 8))(v74);
          }
          v33 = v88;
        }
        if (v33)
        {
          if (!(_BYTE)v85)
          {
            v75 = v86;
            v86 = 0;
            if (v75)
              (*(void (**)(llvm::APFloatBase *))(*(_QWORD *)v75 + 8))(v75);
          }
        }
        if (v105)
        {
          if (!v103[0])
          {
            v76 = v104[0];
            v104[0] = 0;
            if (v76)
              (*(void (**)(uint64_t))(*(_QWORD *)v76 + 8))(v76);
          }
        }
        return v8 & 0xFFFFFFFFFFFFFFFBLL;
      }
    }
    goto LABEL_67;
  }
  v85 = *v3;
  v94 = v14;
  v16 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v85);
  if (v16 != mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v94))
    goto LABEL_67;
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&v85, (uint64_t)&v96);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&v94, (uint64_t)v103);
  mlir::constFoldBinaryOp<mlir::FloatAttr,llvm::APFloat,mlir::ub::PoisonAttr,mlir::arith::AddFOp::fold(mlir::arith::AddFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0>(llvm::ArrayRef<mlir::Attribute>,mlir::arith::AddFOp::fold(mlir::arith::AddFOpGenericAdaptor<llvm::ArrayRef<mlir::Attribute>>)::$_0 &&)::{lambda(llvm::APFloat,llvm::APFloat)#1}::operator()(&v99, (uint64_t)&v96, (uint64_t)v103);
  v17 = (void *)v104[0];
  v19 = llvm::APFloatBase::PPCDoubleDouble(v18);
  if (v19 == v17)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v104);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v104);
  if (v19 == (void *)v97[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v97);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v97);
  if (!v102)
    goto LABEL_67;
  v8 = mlir::FloatAttr::get((uint64_t)canMapOperands, (uint64_t)&v99);
  if (v102)
  {
    if (v19 != (void *)v100)
    {
LABEL_61:
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v100);
      return v8 & 0xFFFFFFFFFFFFFFFBLL;
    }
LABEL_157:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v100);
  }
  return v8 & 0xFFFFFFFFFFFFFFFBLL;
}

