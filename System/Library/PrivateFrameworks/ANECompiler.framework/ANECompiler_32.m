uint64_t mlir::mps::Conv2DOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, _DWORD *a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t Context;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  _OWORD *Shape;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::MLIRContext *v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  uint64_t ElementTypeOrSelf;
  uint64_t v54;
  uint64_t *v55;
  void *v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  _OWORD v62[8];
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  void *v66[2];
  _BYTE v67[16];
  void *v68[2];
  _BYTE v69[16];
  void *v70[2];
  _BYTE v71[32];
  void *v72[2];
  _BYTE v73[32];
  uint64_t v74;
  char v75[8];
  char v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  v85 = a4;
  v86 = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
    v19 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v19 = 0;
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
  }
  v74 = a6;
  v75[0] = 0;
  v76 = 0;
  v77 = v16;
  v78 = v17;
  v79 = v18;
  v80 = v19;
  v81 = a9;
  v20 = a5;
  v82 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v74);
    if (v76)
      v76 = 0;
    mlir::OperationName::OperationName(v75, "mps.conv_2d", 11, Context);
    v76 = 1;
    v20 = v86;
  }
  v83 = a4;
  v84 = a5;
  if (v20 >= 2
    && (v22 = mlir::UnknownLoc::get(this, a2), mlir::mps::Conv2DOpAdaptor::verify(&v74, v22)))
  {
    v24 = (_QWORD *)*((_QWORD *)&v77 + 1);
    v23 = (_QWORD *)v78;
    v25 = (_QWORD *)*((_QWORD *)&v79 + 1);
    v72[0] = *((void **)&v78 + 1);
    mlir::IntegerAttr::getValue(v72, (llvm::APInt *)v62);
    if (DWORD2(v62[0]) > 0x40)
    {
      v60 = **(_QWORD **)&v62[0];
      MEMORY[0x20BD002D4]();
    }
    else
    {
      v60 = *(_QWORD *)&v62[0];
    }
    v29 = *(_DWORD *)(v77 + 8);
    v58 = *(_DWORD *)(v80 + 8);
    v59 = *(_DWORD *)(v79 + 8);
    v30 = mlir::ValueRange::dereference_iterator(&v85, 0);
    v57 = mlir::ValueRange::dereference_iterator(&v85, 1);
    v31 = (_QWORD *)(*(_QWORD *)(v30 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v31 + 8))
    {
      v32 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v31 + 8);
      v64 = v31;
      v65 = v32;
      if (v31 && (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v64) & 1) != 0)
      {
        Shape = operator new(0x20uLL);
        v34 = Shape;
        *Shape = 0u;
        Shape[1] = 0u;
        if (v64)
        {
          Shape = (_OWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v64);
          if (v35 != 4)
          {
            v36 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "Conv2DOp input should be rank 4");
LABEL_50:
            operator delete(v34);
            return v36;
          }
        }
        v55 = (uint64_t *)Shape;
        v72[0] = v73;
        v72[1] = (void *)0x400000000;
        v70[0] = v71;
        v70[1] = (void *)0x400000000;
        v68[0] = v69;
        v68[1] = (void *)0x200000000;
        v66[0] = v67;
        v66[1] = (void *)0x200000000;
        if (v25)
        {
          v54 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v25 + 8);
          v56 = v34;
          if (v24)
            goto LABEL_33;
        }
        else
        {
          v54 = 0;
          v56 = v34;
          if (v24)
          {
LABEL_33:
            v42 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v24 + 8);
            if (v23)
            {
LABEL_34:
              v43 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v23 + 8);
              goto LABEL_38;
            }
LABEL_37:
            v43 = 0;
            if (!mlir::mps::inferConv2DParams((uint64_t)a2, a3, v55, 4, (uint64_t)v25, v54, (uint64_t)v24, v42, (uint64_t)v23, v43, v29, (uint64_t)v72, (unsigned int *)v70, (uint64_t)v68, (uint64_t)v66))goto LABEL_41;
LABEL_38:
            v44 = *((_QWORD *)v70[0] + 3);
            v45 = *(_QWORD *)v70[0];
            v46 = *((_QWORD *)v70[0] + 1);
            v48 = *(_QWORD *)v68[0];
            v47 = *((_QWORD *)v68[0] + 1);
            v50 = *(_QWORD *)v66[0];
            v49 = *((_QWORD *)v66[0] + 1);
            v63 = 0;
            memset(v62, 0, sizeof(v62));
            mlir::mps::buildConv2DDescriptor(v30, v57, v60, v47, v48, v49, v50, (uint64_t)v62, v44, v45, v46, v59, v29, v58, 0, 0, 0, 0);
            v61 = 0;
            v51 = (void *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v85, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
            v52 = mlir::ValueRange::dereference_iterator(&v85, 1);
            {
              llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back((uint64_t)a11, v61);
              v36 = 1;
            }
            else
            {
LABEL_41:
              ElementTypeOrSelf = mlir::getElementTypeOrSelf(v30);
            }
            v34 = v56;
            if (v66[0] != v67)
              free(v66[0]);
            if (v68[0] != v69)
              free(v68[0]);
            if (v70[0] != v71)
              free(v70[0]);
            if (v72[0] != v73)
              free(v72[0]);
            goto LABEL_50;
          }
        }
        v42 = 0;
        if (v23)
          goto LABEL_34;
        goto LABEL_37;
      }
    }
    else
    {
      v64 = 0;
      v65 = 0;
    }
    v37 = mlir::getElementTypeOrSelf(v30);
    if (!v37)
      v37 = mlir::Float32Type::get(this, v38);
    v39 = mlir::UnrankedTensorType::get(v37);
    v40 = a11[2];
    if (v40 >= a11[3])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a11, a11 + 4, v40 + 1, 8);
      v40 = a11[2];
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v40) = v39;
  }
  else
  {
    v26 = mlir::Float32Type::get(this, a2);
    v27 = mlir::UnrankedTensorType::get(v26);
    v28 = a11[2];
    if (v28 >= a11[3])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a11, a11 + 4, v28 + 1, 8);
      LODWORD(v28) = a11[2];
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v28) = v27;
  }
  ++a11[2];
  return 1;
}

uint64_t mlir::mps::Conv2DOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *Type;
  _QWORD *v8;
  _QWORD *Shape;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const char *v59;
  const char *v60;
  uint64_t OperandRange;
  const char *v62;
  uint64_t v63;
  __int16 v64;
  _QWORD v65[2];
  __int128 v66;
  uint64_t Value;
  _QWORD *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (a1[3])
  {
    v3 = (const char *)a1[4];
    if (v3)
    {
      v4 = (const char *)a1[5];
      if (v4)
      {
        if (a1[6])
        {
          if (a1[7])
          {
            v5 = (const char *)a1[8];
            if (v5)
            {
              if (a1[9])
              {
                v62 = (const char *)a1[6];
                Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62);
                if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
                {
                  v6 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                  v62 = v5;
                  v63 = v6;
                  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                  v8 = Type;
                  if (Type)
                    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
                  Value = (uint64_t)v8;
                  v68 = Type;
                  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                  v65[0] = 4;
                  if (v10 == 1
                    && *Shape == v65[0]
                    && (v60 = v5,
                        *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                        *((_QWORD *)&v66 + 1) = v11,
                        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                        mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                  {
                    v12 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
                    v62 = v3;
                    v63 = v12;
                    v13 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                    v14 = v13;
                    if (v13)
                      v13 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
                    Value = (uint64_t)v14;
                    v68 = v13;
                    v15 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                    v65[0] = 4;
                    if (v16 == 1
                      && *v15 == v65[0]
                      && (v60 = v3,
                          *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                          *((_QWORD *)&v66 + 1) = v17,
                          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                    {
                      v18 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                      v62 = v4;
                      v63 = v18;
                      v19 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                      v20 = v19;
                      if (v19)
                        v19 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
                      Value = (uint64_t)v20;
                      v68 = v19;
                      v21 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                      v66 = xmmword_207A7D550;
                      if (v22 == 2 && *v21 == (_QWORD)v66 && v21[1] == *((_QWORD *)&v66 + 1))
                      {
                        v60 = v4;
                        v65[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
                        v65[1] = v24;
                        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v65);
                        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
                          return 1;
                      }
                      v59 = "'mps.conv_2d' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements at"
                            "tribute of shape {4, 2}";
                    }
                    else
                    {
                      v59 = "'mps.conv_2d' op attribute 'dilation_rates' failed to satisfy constraint: ui64 elements attr"
                            "ibute of shape {4}";
                    }
                  }
                  else
                  {
                    v59 = "'mps.conv_2d' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {4}";
                  }
                }
                else
                {
                  v59 = "'mps.conv_2d' op attribute 'groups' failed to satisfy constraint: 64-bit unsigned integer attribute";
                }
              }
              else
              {
                v59 = "'mps.conv_2d' op requires attribute 'weights_layout'";
              }
            }
            else
            {
              v59 = "'mps.conv_2d' op requires attribute 'strides'";
            }
            v62 = v59;
            v64 = 259;
            mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
            v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
            return v25;
          }
          v62 = "'mps.conv_2d' op requires attribute 'padding_style'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v75)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v74;
              v54 = __p;
              if (v74 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v74 = v52;
              operator delete(v54);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_101;
            v55 = v72;
            v31 = v71;
            if (v72 == v71)
            {
LABEL_100:
              v72 = v29;
              operator delete(v31);
LABEL_101:
              if (v69 != &v70)
                free(v69);
              return v25;
            }
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v29);
LABEL_99:
            v31 = v71;
            goto LABEL_100;
          }
        }
        else
        {
          v62 = "'mps.conv_2d' op requires attribute 'groups'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v75)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v74;
              v48 = __p;
              if (v74 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v74 = v46;
              operator delete(v48);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_101;
            v49 = v72;
            v31 = v71;
            if (v72 == v71)
              goto LABEL_100;
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
            goto LABEL_99;
          }
        }
      }
      else
      {
        v62 = "'mps.conv_2d' op requires attribute 'explicit_padding'";
        v64 = 259;
        mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v75)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v74;
            v42 = __p;
            if (v74 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v74 = v40;
            operator delete(v42);
          }
          v29 = v71;
          if (!v71)
            goto LABEL_101;
          v43 = v72;
          v31 = v71;
          if (v72 == v71)
            goto LABEL_100;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_99;
        }
      }
    }
    else
    {
      v62 = "'mps.conv_2d' op requires attribute 'dilation_rates'";
      v64 = 259;
      mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v75)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v74;
          v36 = __p;
          if (v74 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v74 = v34;
          operator delete(v36);
        }
        v29 = v71;
        if (!v71)
          goto LABEL_101;
        v37 = v72;
        v31 = v71;
        if (v72 == v71)
          goto LABEL_100;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_99;
      }
    }
  }
  else
  {
    v62 = "'mps.conv_2d' op requires attribute 'data_layout'";
    v64 = 259;
    mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v75)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v74;
        v28 = __p;
        if (v74 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v74 = v26;
        operator delete(v28);
      }
      v29 = v71;
      if (!v71)
        goto LABEL_101;
      v30 = v72;
      v31 = v71;
      if (v72 == v71)
        goto LABEL_100;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_99;
    }
  }
  return v25;
}

uint64_t mlir::mps::`anonymous namespace'::inferConv2DReturnType(uint64_t a1, char a2, void *a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t *Shape;
  char *v15;
  uint64_t v16;
  void *v17;
  void *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  _BYTE v23[32];
  unint64_t v24[3];

  v24[2] = *MEMORY[0x24BDAC8D0];
  v21 = a3;
  v22 = a4;
  mlir::ValueRange::ValueRange(v24, (uint64_t)&v21, 2uLL);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a3 + 8))
  {
    v19 = 0;
    v20 = 0;
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2D a non-shaped inputType");
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a3 + 8);
  v19 = a3;
  v20 = v13;
  if (!a3)
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2D a non-shaped inputType");
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a4 + 8))
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2D a non-shaped weightsType");
  mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a4 + 8);
  if (*(_UNKNOWN **)(*(_QWORD *)a3 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    *a6 = mlir::UnrankedTensorType::get(v12);
    return 1;
  }
  else
  {
    v21 = v23;
    v22 = 0x400000000;
    Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v19);
    {
      *a6 = mlir::RankedTensorType::get((uint64_t)v21, v22, v12, 0);
      v16 = 1;
      v17 = v21;
      if (v21 == v23)
        return v16;
      goto LABEL_14;
    }
    v16 = 0;
    v17 = v21;
    if (v21 != v23)
LABEL_14:
      free(v17);
  }
  return v16;
}

uint64_t mlir::mps::Conv2DDataGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t Context;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  unint64_t v38;
  int64x2_t *v39;
  int64x2_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int32x2_t v45;
  int32x2_t v46;
  _BYTE *v47;
  uint64_t Shape;
  uint64_t v49;
  char v50;
  int v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t *v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t UInt;
  int v60;
  int v61;
  uint64_t v62;
  char v63;
  uint64_t *v64;
  int v65;
  uint64_t v66;
  __int128 v67;
  _QWORD *v68;
  _QWORD v69[2];
  uint64_t v70;
  __int128 v71;
  _QWORD v72[2];
  __int128 v73;
  uint64_t v74;
  char v75[8];
  char v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  void *v87[2];
  uint64_t v88;
  void *v89;
  uint64_t v90;
  _BYTE v91[32];
  void *v92;
  uint64_t v93;
  _BYTE v94[40];
  void *v95[2];
  _BYTE v96[16];
  void *v97[2];
  _BYTE v98[16];
  void *v99[2];
  _BYTE v100[32];
  void *v101[2];
  _BYTE v102[32];
  _OWORD *v103;
  uint64_t v104;
  _OWORD v105[2];
  uint64_t *v106;
  uint64_t v107;
  _BYTE v108[32];
  unint64_t v109[4];

  v109[2] = *MEMORY[0x24BDAC8D0];
  v85 = a4;
  v86 = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
    v19 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v19 = 0;
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
  }
  v74 = a6;
  v75[0] = 0;
  v76 = 0;
  v77 = v16;
  v78 = v17;
  v79 = v18;
  v80 = v19;
  v81 = a9;
  v20 = a5;
  v82 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v74);
    if (v76)
      v76 = 0;
    mlir::OperationName::OperationName(v75, "mps.conv_2d_data_gradient", 25, Context);
    v76 = 1;
    v20 = v86;
  }
  v83 = a4;
  v84 = a5;
  if (v20 < 2
    || (v22 = mlir::UnknownLoc::get(this, a2),
        !mlir::mps::Conv2DDataGradientOpAdaptor::verify(&v74, v22)))
  {
    v32 = mlir::Float32Type::get(this, a2);
LABEL_28:
    v42 = mlir::UnrankedTensorType::get(v32);
    goto LABEL_29;
  }
  v23 = mlir::ValueRange::dereference_iterator(&v85, 0);
  v24 = mlir::ValueRange::dereference_iterator(&v85, 1);
  v25 = 0;
  if (v86 == 3)
    v25 = mlir::ValueRange::dereference_iterator(&v85, 2);
  v26 = v77;
  v27 = v78;
  v68 = (_QWORD *)*((_QWORD *)&v77 + 1);
  v66 = v80;
  v67 = v79;
  v28 = (_QWORD *)(*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v28)
  {
    v29 = 0;
    v30 = (_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v30)
      goto LABEL_14;
LABEL_17:
    v31 = 0;
    goto LABEL_18;
  }
  v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v28 + 8);
  v30 = (_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_17;
LABEL_14:
  v31 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v30 + 8);
LABEL_18:
  *(_QWORD *)&v73 = v28;
  *((_QWORD *)&v73 + 1) = v29;
  v72[0] = v30;
  v72[1] = v31;
  v71 = v73;
  v92 = v28;
  v93 = (uint64_t)v30;
  mlir::ValueRange::ValueRange(v109, (uint64_t)&v92, 2uLL);
  if (!v28
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v71)
    || !v72[0]
    || (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v72) & 1) == 0)
  {
    v32 = v33;
    goto LABEL_28;
  }
  v106 = (uint64_t *)v108;
  v107 = 0x400000000;
  if (!v25)
  {
    v70 = *((_QWORD *)&v27 + 1);
    v47 = v105;
    v103 = v105;
    memset(v105, 0, sizeof(v105));
    v104 = 0x400000004;
    if ((_QWORD)v71)
    {
      Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v71);
      if (v49 != 4)
      {
        v50 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "Conv2DDataGradientOp input should be rank 4");
        v42 = 0;
LABEL_99:
        v55 = v103;
        goto LABEL_100;
      }
      v64 = (uint64_t *)Shape;
    }
    else
    {
      v64 = (uint64_t *)v105;
    }
    v101[0] = v102;
    v101[1] = (void *)0x400000000;
    v99[0] = v100;
    v99[1] = (void *)0x400000000;
    v97[0] = v98;
    v97[1] = (void *)0x200000000;
    v95[0] = v96;
    v95[1] = (void *)0x200000000;
    if (v26)
      v51 = *(_DWORD *)(v26 + 8);
    else
      v51 = 1;
    v65 = v51;
    if (*((_QWORD *)&v67 + 1))
    {
      v56 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v67 + 1) + 8);
    }
    else
    {
      *((_QWORD *)&v67 + 1) = 0;
      v56 = 0;
    }
    if (v68)
    {
      v57 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v68 + 8);
    }
    else
    {
      v68 = 0;
      v57 = 0;
    }
    if ((_QWORD)v27)
      v58 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v27 + 8);
    else
      v58 = 0;
    if (mlir::mps::inferConv2DParams((uint64_t)a2, a3, v64, 4, *((uint64_t *)&v67 + 1), v56, (uint64_t)v68, v57, v27, v58, v65, (uint64_t)v101, (unsigned int *)v99, (uint64_t)v97, (uint64_t)v95))
    {
      if (v70)
        UInt = (uint64_t)mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&v70);
      else
        UInt = 1;
      if (v66)
        v60 = *(_DWORD *)(v66 + 8);
      else
        v60 = 3;
      if ((_QWORD)v67)
        v61 = *(_DWORD *)(v67 + 8);
      else
        v61 = 2;
      v69[0] = mlir::ShapedType::getShape((mlir::ShapedType *)v72);
      v69[1] = v62;
      if (v62 == 4)
      {
        mlir::mps::ShapeWithLayout::ShapeWithLayout((uint64_t)&v92, (uint64_t)v69, v60);
        v89 = v91;
        v90 = 0x400000000;
        mlir::mps::ShapeWithLayout::ShapeWithLayout((uint64_t)v87, (uint64_t)&v92);
        if (v87[0] != &v88)
          free(v87[0]);
        if (v63)
        {
          v42 = mlir::RankedTensorType::get((uint64_t)v89, v90, v33, 0);
          v50 = 1;
        }
        else
        {
          v42 = 0;
          v50 = 0;
        }
        v47 = v105;
        if (v89 != v91)
          free(v89);
        if (v92 != v94)
          free(v92);
      }
      else
      {
        v50 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "Conv2dGradient weights should be rank 4");
        v42 = 0;
        v47 = v105;
      }
    }
    else
    {
      v42 = 0;
      v50 = 0;
    }
    if (v95[0] != v96)
      free(v95[0]);
    if (v97[0] != v98)
      free(v97[0]);
    if (v99[0] != v100)
      free(v99[0]);
    if (v101[0] != v102)
      free(v101[0]);
    goto LABEL_99;
  }
  if (!mlir::matchConstantWithIntVector<long long>(v25, (uint64_t)&v106))
  {
    v42 = mlir::UnrankedTensorType::get(v33);
    v50 = 1;
    goto LABEL_102;
  }
  v34 = v107;
  if (!(_DWORD)v107)
    goto LABEL_50;
  v35 = v106;
  v36 = (v107 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  v37 = v106;
  if (v36 >= 3)
  {
    v38 = v36 + 1;
    v37 = &v106[v38 & 0x3FFFFFFFFFFFFFFCLL];
    v39 = (int64x2_t *)(v106 + 2);
    v40.i64[0] = -1;
    v40.i64[1] = -1;
    v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
    while (1)
    {
      v45 = vmovn_s64(vceqq_s64(v39[-1], v40));
      if ((v45.i8[0] & 1) != 0)
      {
        v39[-1].i64[0] = 0x8000000000000000;
        if ((v45.i8[4] & 1) == 0)
          goto LABEL_35;
      }
      else if ((v45.i8[4] & 1) == 0)
      {
LABEL_35:
        v46 = vmovn_s64(vceqq_s64(*v39, v40));
        if ((v46.i8[0] & 1) != 0)
          goto LABEL_36;
        goto LABEL_40;
      }
      v39[-1].i64[1] = 0x8000000000000000;
      v46 = vmovn_s64(vceqq_s64(*v39, v40));
      if ((v46.i8[0] & 1) != 0)
      {
LABEL_36:
        v39->i64[0] = 0x8000000000000000;
        if ((v46.i8[4] & 1) != 0)
          goto LABEL_41;
        goto LABEL_32;
      }
LABEL_40:
      if ((v46.i8[4] & 1) != 0)
LABEL_41:
        v39->i64[1] = 0x8000000000000000;
LABEL_32:
      v39 += 2;
      v41 -= 4;
      if (!v41)
      {
        if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_50;
        break;
      }
    }
  }
  v54 = &v35[v34];
  do
  {
    if (*v37 == -1)
      *v37 = 0x8000000000000000;
    ++v37;
  }
  while (v37 != v54);
LABEL_50:
  v52 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
  v47 = v94;
  v92 = v94;
  v93 = 0x400000000;
  {
    v42 = mlir::RankedTensorType::get((uint64_t)v92, v93, v33, 0);
    v50 = 1;
  }
  else
  {
    v42 = 0;
    v50 = 0;
  }
  v55 = v92;
LABEL_100:
  if (v55 != v47)
    free(v55);
LABEL_102:
  if (v106 != (uint64_t *)v108)
    free(v106);
  if (!v50)
    return 0;
LABEL_29:
  v43 = *(_DWORD *)(a11 + 8);
  if (v43 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v43 + 1, 8);
    v43 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v43) = v42;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::Conv2DDataGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *Type;
  _QWORD *v8;
  _QWORD *Shape;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const char *v59;
  const char *v60;
  uint64_t OperandRange;
  const char *v62;
  uint64_t v63;
  __int16 v64;
  _QWORD v65[2];
  __int128 v66;
  uint64_t Value;
  _QWORD *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (a1[3])
  {
    v3 = (const char *)a1[4];
    if (v3)
    {
      v4 = (const char *)a1[5];
      if (v4)
      {
        if (a1[6])
        {
          if (a1[7])
          {
            v5 = (const char *)a1[8];
            if (v5)
            {
              if (a1[9])
              {
                v62 = (const char *)a1[6];
                Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62);
                if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
                {
                  v6 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                  v62 = v5;
                  v63 = v6;
                  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                  v8 = Type;
                  if (Type)
                    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
                  Value = (uint64_t)v8;
                  v68 = Type;
                  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                  v65[0] = 4;
                  if (v10 == 1
                    && *Shape == v65[0]
                    && (v60 = v5,
                        *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                        *((_QWORD *)&v66 + 1) = v11,
                        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                        mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                  {
                    v12 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
                    v62 = v3;
                    v63 = v12;
                    v13 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                    v14 = v13;
                    if (v13)
                      v13 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
                    Value = (uint64_t)v14;
                    v68 = v13;
                    v15 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                    v65[0] = 4;
                    if (v16 == 1
                      && *v15 == v65[0]
                      && (v60 = v3,
                          *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                          *((_QWORD *)&v66 + 1) = v17,
                          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                    {
                      v18 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                      v62 = v4;
                      v63 = v18;
                      v19 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                      v20 = v19;
                      if (v19)
                        v19 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
                      Value = (uint64_t)v20;
                      v68 = v19;
                      v21 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                      v66 = xmmword_207A7D550;
                      if (v22 == 2 && *v21 == (_QWORD)v66 && v21[1] == *((_QWORD *)&v66 + 1))
                      {
                        v60 = v4;
                        v65[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
                        v65[1] = v24;
                        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v65);
                        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
                          return 1;
                      }
                      v59 = "'mps.conv_2d_data_gradient' op attribute 'explicit_padding' failed to satisfy constraint: ui"
                            "64 elements attribute of shape {4, 2}";
                    }
                    else
                    {
                      v59 = "'mps.conv_2d_data_gradient' op attribute 'dilation_rates' failed to satisfy constraint: ui64"
                            " elements attribute of shape {4}";
                    }
                  }
                  else
                  {
                    v59 = "'mps.conv_2d_data_gradient' op attribute 'strides' failed to satisfy constraint: ui64 elements"
                          " attribute of shape {4}";
                  }
                }
                else
                {
                  v59 = "'mps.conv_2d_data_gradient' op attribute 'groups' failed to satisfy constraint: 64-bit unsigned "
                        "integer attribute";
                }
              }
              else
              {
                v59 = "'mps.conv_2d_data_gradient' op requires attribute 'weights_layout'";
              }
            }
            else
            {
              v59 = "'mps.conv_2d_data_gradient' op requires attribute 'strides'";
            }
            v62 = v59;
            v64 = 259;
            mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
            v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
            return v25;
          }
          v62 = "'mps.conv_2d_data_gradient' op requires attribute 'padding_style'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v75)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v74;
              v54 = __p;
              if (v74 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v74 = v52;
              operator delete(v54);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_101;
            v55 = v72;
            v31 = v71;
            if (v72 == v71)
            {
LABEL_100:
              v72 = v29;
              operator delete(v31);
LABEL_101:
              if (v69 != &v70)
                free(v69);
              return v25;
            }
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v29);
LABEL_99:
            v31 = v71;
            goto LABEL_100;
          }
        }
        else
        {
          v62 = "'mps.conv_2d_data_gradient' op requires attribute 'groups'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v75)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v74;
              v48 = __p;
              if (v74 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v74 = v46;
              operator delete(v48);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_101;
            v49 = v72;
            v31 = v71;
            if (v72 == v71)
              goto LABEL_100;
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
            goto LABEL_99;
          }
        }
      }
      else
      {
        v62 = "'mps.conv_2d_data_gradient' op requires attribute 'explicit_padding'";
        v64 = 259;
        mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v75)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v74;
            v42 = __p;
            if (v74 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v74 = v40;
            operator delete(v42);
          }
          v29 = v71;
          if (!v71)
            goto LABEL_101;
          v43 = v72;
          v31 = v71;
          if (v72 == v71)
            goto LABEL_100;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_99;
        }
      }
    }
    else
    {
      v62 = "'mps.conv_2d_data_gradient' op requires attribute 'dilation_rates'";
      v64 = 259;
      mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v75)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v74;
          v36 = __p;
          if (v74 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v74 = v34;
          operator delete(v36);
        }
        v29 = v71;
        if (!v71)
          goto LABEL_101;
        v37 = v72;
        v31 = v71;
        if (v72 == v71)
          goto LABEL_100;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_99;
      }
    }
  }
  else
  {
    v62 = "'mps.conv_2d_data_gradient' op requires attribute 'data_layout'";
    v64 = 259;
    mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v75)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v74;
        v28 = __p;
        if (v74 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v74 = v26;
        operator delete(v28);
      }
      v29 = v71;
      if (!v71)
        goto LABEL_101;
      v30 = v72;
      v31 = v71;
      if (v72 == v71)
        goto LABEL_100;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_99;
    }
  }
  return v25;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t Context;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  unint64_t v38;
  int64x2_t *v39;
  int64x2_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int32x2_t v45;
  int32x2_t v46;
  _BYTE *v47;
  uint64_t Shape;
  uint64_t v49;
  char v50;
  int v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t *v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t UInt;
  int v60;
  int v61;
  uint64_t v62;
  char v63;
  uint64_t *v64;
  int v65;
  uint64_t v66;
  __int128 v67;
  _QWORD *v68;
  _QWORD v69[2];
  uint64_t v70;
  __int128 v71;
  _QWORD v72[2];
  __int128 v73;
  uint64_t v74;
  char v75[8];
  char v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  void *v87[2];
  uint64_t v88;
  void *v89;
  uint64_t v90;
  _BYTE v91[32];
  void *v92;
  uint64_t v93;
  _BYTE v94[40];
  void *v95[2];
  _BYTE v96[16];
  void *v97[2];
  _BYTE v98[16];
  void *v99[2];
  _BYTE v100[32];
  void *v101[2];
  _BYTE v102[32];
  _OWORD *v103;
  uint64_t v104;
  _OWORD v105[2];
  uint64_t *v106;
  uint64_t v107;
  _BYTE v108[32];
  unint64_t v109[4];

  v109[2] = *MEMORY[0x24BDAC8D0];
  v85 = a4;
  v86 = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
    v19 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v19 = 0;
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
  }
  v74 = a6;
  v75[0] = 0;
  v76 = 0;
  v77 = v16;
  v78 = v17;
  v79 = v18;
  v80 = v19;
  v81 = a9;
  v20 = a5;
  v82 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v74);
    if (v76)
      v76 = 0;
    mlir::OperationName::OperationName(v75, "mps.conv_2d_weights_gradient", 28, Context);
    v76 = 1;
    v20 = v86;
  }
  v83 = a4;
  v84 = a5;
  if (v20 < 3
    || (v22 = mlir::UnknownLoc::get(this, a2),
        !mlir::mps::Conv2DWeightsGradientOpAdaptor::verify(&v74, v22)))
  {
    v32 = mlir::Float32Type::get(this, a2);
LABEL_26:
    v42 = mlir::UnrankedTensorType::get(v32);
    goto LABEL_27;
  }
  v23 = mlir::ValueRange::dereference_iterator(&v85, 0);
  v24 = mlir::ValueRange::dereference_iterator(&v85, 1);
  v25 = mlir::ValueRange::dereference_iterator(&v85, 2);
  v26 = v77;
  v27 = v78;
  v68 = (_QWORD *)*((_QWORD *)&v77 + 1);
  v66 = v80;
  v67 = v79;
  v28 = (_QWORD *)(*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v28)
  {
    v29 = 0;
    v30 = (_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v30)
      goto LABEL_12;
LABEL_15:
    v31 = 0;
    goto LABEL_16;
  }
  v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v28 + 8);
  v30 = (_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_15;
LABEL_12:
  v31 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v30 + 8);
LABEL_16:
  *(_QWORD *)&v73 = v28;
  *((_QWORD *)&v73 + 1) = v29;
  v72[0] = v30;
  v72[1] = v31;
  v71 = v73;
  v92 = v28;
  v93 = (uint64_t)v30;
  mlir::ValueRange::ValueRange(v109, (uint64_t)&v92, 2uLL);
  if (!v28
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v71)
    || !v72[0]
    || (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v72) & 1) == 0)
  {
    v32 = v33;
    goto LABEL_26;
  }
  v106 = (uint64_t *)v108;
  v107 = 0x400000000;
  if (!v25)
  {
    v70 = *((_QWORD *)&v27 + 1);
    v47 = v105;
    v103 = v105;
    memset(v105, 0, sizeof(v105));
    v104 = 0x400000004;
    if ((_QWORD)v71)
    {
      Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v71);
      if (v49 != 4)
      {
        v50 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "Conv2DDataGradientOp input should be rank 4");
        v42 = 0;
LABEL_97:
        v55 = v103;
        goto LABEL_98;
      }
      v64 = (uint64_t *)Shape;
    }
    else
    {
      v64 = (uint64_t *)v105;
    }
    v101[0] = v102;
    v101[1] = (void *)0x400000000;
    v99[0] = v100;
    v99[1] = (void *)0x400000000;
    v97[0] = v98;
    v97[1] = (void *)0x200000000;
    v95[0] = v96;
    v95[1] = (void *)0x200000000;
    if (v26)
      v51 = *(_DWORD *)(v26 + 8);
    else
      v51 = 1;
    v65 = v51;
    if (*((_QWORD *)&v67 + 1))
    {
      v56 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v67 + 1) + 8);
    }
    else
    {
      *((_QWORD *)&v67 + 1) = 0;
      v56 = 0;
    }
    if (v68)
    {
      v57 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v68 + 8);
    }
    else
    {
      v68 = 0;
      v57 = 0;
    }
    if ((_QWORD)v27)
      v58 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v27 + 8);
    else
      v58 = 0;
    if (mlir::mps::inferConv2DParams((uint64_t)a2, a3, v64, 4, *((uint64_t *)&v67 + 1), v56, (uint64_t)v68, v57, v27, v58, v65, (uint64_t)v101, (unsigned int *)v99, (uint64_t)v97, (uint64_t)v95))
    {
      if (v70)
        UInt = (uint64_t)mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&v70);
      else
        UInt = 1;
      if (v66)
        v60 = *(_DWORD *)(v66 + 8);
      else
        v60 = 3;
      if ((_QWORD)v67)
        v61 = *(_DWORD *)(v67 + 8);
      else
        v61 = 2;
      v69[0] = mlir::ShapedType::getShape((mlir::ShapedType *)v72);
      v69[1] = v62;
      if (v62 == 4)
      {
        mlir::mps::ShapeWithLayout::ShapeWithLayout((uint64_t)&v92, (uint64_t)v69, v60);
        v89 = v91;
        v90 = 0x400000000;
        mlir::mps::ShapeWithLayout::ShapeWithLayout((uint64_t)v87, (uint64_t)&v92);
        if (v87[0] != &v88)
          free(v87[0]);
        if (v63)
        {
          v42 = mlir::RankedTensorType::get((uint64_t)v89, v90, v33, 0);
          v50 = 1;
        }
        else
        {
          v42 = 0;
          v50 = 0;
        }
        v47 = v105;
        if (v89 != v91)
          free(v89);
        if (v92 != v94)
          free(v92);
      }
      else
      {
        v50 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "Conv2dGradient weights should be rank 4");
        v42 = 0;
        v47 = v105;
      }
    }
    else
    {
      v42 = 0;
      v50 = 0;
    }
    if (v95[0] != v96)
      free(v95[0]);
    if (v97[0] != v98)
      free(v97[0]);
    if (v99[0] != v100)
      free(v99[0]);
    if (v101[0] != v102)
      free(v101[0]);
    goto LABEL_97;
  }
  if (!mlir::matchConstantWithIntVector<long long>(v25, (uint64_t)&v106))
  {
    v42 = mlir::UnrankedTensorType::get(v33);
    v50 = 1;
    goto LABEL_100;
  }
  v34 = v107;
  if (!(_DWORD)v107)
    goto LABEL_48;
  v35 = v106;
  v36 = (v107 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  v37 = v106;
  if (v36 >= 3)
  {
    v38 = v36 + 1;
    v37 = &v106[v38 & 0x3FFFFFFFFFFFFFFCLL];
    v39 = (int64x2_t *)(v106 + 2);
    v40.i64[0] = -1;
    v40.i64[1] = -1;
    v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
    while (1)
    {
      v45 = vmovn_s64(vceqq_s64(v39[-1], v40));
      if ((v45.i8[0] & 1) != 0)
      {
        v39[-1].i64[0] = 0x8000000000000000;
        if ((v45.i8[4] & 1) == 0)
          goto LABEL_33;
      }
      else if ((v45.i8[4] & 1) == 0)
      {
LABEL_33:
        v46 = vmovn_s64(vceqq_s64(*v39, v40));
        if ((v46.i8[0] & 1) != 0)
          goto LABEL_34;
        goto LABEL_38;
      }
      v39[-1].i64[1] = 0x8000000000000000;
      v46 = vmovn_s64(vceqq_s64(*v39, v40));
      if ((v46.i8[0] & 1) != 0)
      {
LABEL_34:
        v39->i64[0] = 0x8000000000000000;
        if ((v46.i8[4] & 1) != 0)
          goto LABEL_39;
        goto LABEL_30;
      }
LABEL_38:
      if ((v46.i8[4] & 1) != 0)
LABEL_39:
        v39->i64[1] = 0x8000000000000000;
LABEL_30:
      v39 += 2;
      v41 -= 4;
      if (!v41)
      {
        if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_48;
        break;
      }
    }
  }
  v54 = &v35[v34];
  do
  {
    if (*v37 == -1)
      *v37 = 0x8000000000000000;
    ++v37;
  }
  while (v37 != v54);
LABEL_48:
  v52 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
  v47 = v94;
  v92 = v94;
  v93 = 0x400000000;
  {
    v42 = mlir::RankedTensorType::get((uint64_t)v92, v93, v33, 0);
    v50 = 1;
  }
  else
  {
    v42 = 0;
    v50 = 0;
  }
  v55 = v92;
LABEL_98:
  if (v55 != v47)
    free(v55);
LABEL_100:
  if (v106 != (uint64_t *)v108)
    free(v106);
  if (!v50)
    return 0;
LABEL_27:
  v43 = *(_DWORD *)(a11 + 8);
  if (v43 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v43 + 1, 8);
    v43 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v43) = v42;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::Conv2DWeightsGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *Type;
  _QWORD *v8;
  _QWORD *Shape;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const char *v59;
  const char *v60;
  uint64_t OperandRange;
  const char *v62;
  uint64_t v63;
  __int16 v64;
  _QWORD v65[2];
  __int128 v66;
  uint64_t Value;
  _QWORD *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (a1[3])
  {
    v3 = (const char *)a1[4];
    if (v3)
    {
      v4 = (const char *)a1[5];
      if (v4)
      {
        if (a1[6])
        {
          if (a1[7])
          {
            v5 = (const char *)a1[8];
            if (v5)
            {
              if (a1[9])
              {
                v62 = (const char *)a1[6];
                Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v62);
                if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
                {
                  v6 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                  v62 = v5;
                  v63 = v6;
                  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                  v8 = Type;
                  if (Type)
                    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
                  Value = (uint64_t)v8;
                  v68 = Type;
                  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                  v65[0] = 4;
                  if (v10 == 1
                    && *Shape == v65[0]
                    && (v60 = v5,
                        *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                        *((_QWORD *)&v66 + 1) = v11,
                        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                        mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                  {
                    v12 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
                    v62 = v3;
                    v63 = v12;
                    v13 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                    v14 = v13;
                    if (v13)
                      v13 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
                    Value = (uint64_t)v14;
                    v68 = v13;
                    v15 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                    v65[0] = 4;
                    if (v16 == 1
                      && *v15 == v65[0]
                      && (v60 = v3,
                          *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                          *((_QWORD *)&v66 + 1) = v17,
                          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                    {
                      v18 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                      v62 = v4;
                      v63 = v18;
                      v19 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                      v20 = v19;
                      if (v19)
                        v19 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
                      Value = (uint64_t)v20;
                      v68 = v19;
                      v21 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                      v66 = xmmword_207A7D550;
                      if (v22 == 2 && *v21 == (_QWORD)v66 && v21[1] == *((_QWORD *)&v66 + 1))
                      {
                        v60 = v4;
                        v65[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
                        v65[1] = v24;
                        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v65);
                        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
                          return 1;
                      }
                      v59 = "'mps.conv_2d_weights_gradient' op attribute 'explicit_padding' failed to satisfy constraint:"
                            " ui64 elements attribute of shape {4, 2}";
                    }
                    else
                    {
                      v59 = "'mps.conv_2d_weights_gradient' op attribute 'dilation_rates' failed to satisfy constraint: u"
                            "i64 elements attribute of shape {4}";
                    }
                  }
                  else
                  {
                    v59 = "'mps.conv_2d_weights_gradient' op attribute 'strides' failed to satisfy constraint: ui64 eleme"
                          "nts attribute of shape {4}";
                  }
                }
                else
                {
                  v59 = "'mps.conv_2d_weights_gradient' op attribute 'groups' failed to satisfy constraint: 64-bit unsign"
                        "ed integer attribute";
                }
              }
              else
              {
                v59 = "'mps.conv_2d_weights_gradient' op requires attribute 'weights_layout'";
              }
            }
            else
            {
              v59 = "'mps.conv_2d_weights_gradient' op requires attribute 'strides'";
            }
            v62 = v59;
            v64 = 259;
            mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
            v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
            return v25;
          }
          v62 = "'mps.conv_2d_weights_gradient' op requires attribute 'padding_style'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v75)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v74;
              v54 = __p;
              if (v74 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v74 = v52;
              operator delete(v54);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_101;
            v55 = v72;
            v31 = v71;
            if (v72 == v71)
            {
LABEL_100:
              v72 = v29;
              operator delete(v31);
LABEL_101:
              if (v69 != &v70)
                free(v69);
              return v25;
            }
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v29);
LABEL_99:
            v31 = v71;
            goto LABEL_100;
          }
        }
        else
        {
          v62 = "'mps.conv_2d_weights_gradient' op requires attribute 'groups'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v75)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v74;
              v48 = __p;
              if (v74 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v74 = v46;
              operator delete(v48);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_101;
            v49 = v72;
            v31 = v71;
            if (v72 == v71)
              goto LABEL_100;
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
            goto LABEL_99;
          }
        }
      }
      else
      {
        v62 = "'mps.conv_2d_weights_gradient' op requires attribute 'explicit_padding'";
        v64 = 259;
        mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v75)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v74;
            v42 = __p;
            if (v74 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v74 = v40;
            operator delete(v42);
          }
          v29 = v71;
          if (!v71)
            goto LABEL_101;
          v43 = v72;
          v31 = v71;
          if (v72 == v71)
            goto LABEL_100;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_99;
        }
      }
    }
    else
    {
      v62 = "'mps.conv_2d_weights_gradient' op requires attribute 'dilation_rates'";
      v64 = 259;
      mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v75)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v74;
          v36 = __p;
          if (v74 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v74 = v34;
          operator delete(v36);
        }
        v29 = v71;
        if (!v71)
          goto LABEL_101;
        v37 = v72;
        v31 = v71;
        if (v72 == v71)
          goto LABEL_100;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_99;
      }
    }
  }
  else
  {
    v62 = "'mps.conv_2d_weights_gradient' op requires attribute 'data_layout'";
    v64 = 259;
    mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&Value);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v75)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v74;
        v28 = __p;
        if (v74 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v74 = v26;
        operator delete(v28);
      }
      v29 = v71;
      if (!v71)
        goto LABEL_101;
      v30 = v72;
      v31 = v71;
      if (v72 == v71)
        goto LABEL_100;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_99;
    }
  }
  return v25;
}

void mlir::mps::getSpatialPaddingValues(_QWORD *a1@<X0>, int a2@<W2>, _QWORD *a3@<X8>)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v4 = a3 + 2;
  if (a2 == 7)
  {
    v6 = a1[8];
    v5 = a1[9];
    v7 = a1[6];
    v8 = a1[7];
    v9 = a1[4];
    v10 = a1[5];
  }
  else
  {
    v6 = a1[6];
    v5 = a1[7];
    v7 = a1[4];
    v8 = a1[5];
    v9 = a1[2];
    v10 = a1[3];
  }
  *a3 = v4;
  a3[1] = 0x500000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, v4, 6uLL, 8);
  v11 = (_QWORD *)(*a3 + 8 * *((unsigned int *)a3 + 2));
  *v11 = v6;
  v11[1] = v5;
  v11[2] = v7;
  v11[3] = v8;
  v11[4] = v9;
  v11[5] = v10;
  *((_DWORD *)a3 + 2) += 6;
}

uint64_t mlir::mps::getSpatialValues(uint64_t a1, uint64_t a2, int a3)
{
  return ((uint64_t (*)(void))((char *)sub_2077063FC + 4 * byte_207AC7AB0[a3 - 7]))();
}

int8x16_t sub_2077063FC@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  int8x16_t v4;
  int8x16_t result;

  v3 = a1 + 8 * a2;
  v4 = *(int8x16_t *)(v3 - 24);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(v3 - 8);
  *(_QWORD *)a3 = a3 + 16;
  *(_DWORD *)(a3 + 8) = 3;
  *(_DWORD *)(a3 + 12) = 3;
  result = vextq_s8(v4, v4, 8uLL);
  *(int8x16_t *)(a3 + 24) = result;
  return result;
}

void mlir::mps::computeSpatialPaddings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11)
{
  __asm { BR              X9 }
}

void sub_207706488(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t *v15;
  uint64_t v16;
  uint64_t *i;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;

  v15 = (unint64_t *)(v7 + 16);
  *(_QWORD *)v7 = v7 + 16;
  *(_DWORD *)(v7 + 12) = 6;
  if (v8 < 7)
  {
    if (!v8)
      goto LABEL_5;
  }
  else
  {
    *(_DWORD *)(v7 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v8, 8);
    v15 = *(unint64_t **)v7;
  }
  bzero(v15, 8 * v8);
LABEL_5:
  *(_DWORD *)(v7 + 8) = v8;
  if (a2)
  {
    v16 = 8 * a2;
    for (i = a1; *i; ++i)
    {
      v16 -= 8;
      if (!v16)
      {
        v18 = v15 + 1;
        do
        {
          v20 = *a3++;
          v19 = v20;
          v21 = *a7++;
          v22 = (v19 - 1) * v21;
          v24 = *a1++;
          v23 = v24;
          v26 = *a5++;
          v25 = v26;
          v27 = v23 % v26;
          if (!v27)
            v27 = v25;
          v28 = (v22 - v27 + 1) & ~((v22 - v27 + 1) >> 63);
          v29 = v28 >> 1;
          v30 = v28 - (v28 >> 1);
          *(v18 - 1) = v29;
          *v18 = v30;
          if (v9 == 4)
          {
            *(v18 - 1) = v30;
            *v18 = v29;
          }
          v18 += 2;
          --a2;
        }
        while (a2);
        return;
      }
    }
  }
}

void mlir::mps::computeConvResultSpatialShape(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X4>, _QWORD *a5@<X6>, _QWORD *a6@<X8>, uint64_t a7)
{
  unint64_t v7;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;

  v7 = a2;
  *a6 = a6 + 2;
  a6[1] = 0x300000000;
  if (!a2)
    return;
  if (a2 < 4)
  {
    v13 = 0;
    v14 = a7;
    v15 = a2;
    goto LABEL_6;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a6, a6 + 2, a2, 8);
  v13 = *((unsigned int *)a6 + 2);
  v14 = a7;
  v15 = v7 - v13;
  if (v7 != v13)
LABEL_6:
    bzero((void *)(*a6 + 8 * v13), 8 * v15);
  *((_DWORD *)a6 + 2) = v7;
  v16 = (uint64_t *)*a6;
  v17 = (_QWORD *)(v14 + 8);
  do
  {
    v19 = *a3++;
    v18 = v19;
    v21 = *a1++;
    v20 = v21;
    v22 = v21 == 0x8000000000000000 || v18 == 0x8000000000000000;
    v23 = 0x8000000000000000;
    if (!v22)
      v23 = (*(v17 - 1) + v20 + *v17 + *a4 + ~(*a5 * (v18 - 1))) / *a4;
    *v16++ = v23;
    v17 += 2;
    ++a5;
    ++a4;
    --v7;
  }
  while (v7);
}

void mlir::mps::convertNCDHWShapeToLayout(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  size_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  if (a3 != 7)
  {
    v9 = a1[4];
    v10 = a1[1];
    v11 = *((_OWORD *)a1 + 1);
    *(_QWORD *)(a4 + 16) = *a1;
    *(_QWORD *)a4 = a4 + 16;
    *(_OWORD *)(a4 + 24) = v11;
    *(_QWORD *)(a4 + 40) = v9;
    *(_QWORD *)(a4 + 48) = v10;
    *(_QWORD *)(a4 + 8) = 0x500000005;
    return;
  }
  v7 = 8 * a2;
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x500000000;
  if ((unint64_t)(8 * a2) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), (8 * a2) >> 3, 8);
    v8 = *(_DWORD *)(a4 + 8);
    if (!a2)
      goto LABEL_8;
    goto LABEL_7;
  }
  v8 = 0;
  if (a2)
  {
LABEL_7:
    memcpy((void *)(*(_QWORD *)a4 + 8 * v8), a1, v7);
    v8 = *(_DWORD *)(a4 + 8);
  }
LABEL_8:
  *(_DWORD *)(a4 + 8) = v8 + (v7 >> 3);
}

_QWORD *llvm::SmallVector<long long,5u>::SmallVector<long long const*,void>(_QWORD *a1, _BYTE *a2, _BYTE *a3)
{
  int64_t v6;
  unsigned int v7;

  *a1 = a1 + 2;
  a1[1] = 0x500000000;
  v6 = a3 - a2;
  if ((unint64_t)(a3 - a2) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, v6 >> 3, 8);
    v7 = *((_DWORD *)a1 + 2);
    if (a2 == a3)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = 0;
  if (a2 != a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + ((unint64_t)v6 >> 3);
  return a1;
}

uint64_t mlir::mps::Conv3DOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t Shape;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  _QWORD v59[2];
  void *v60[2];
  uint64_t v61;
  void *v62[2];
  _QWORD v63[5];
  void *v64;
  uint64_t v65;
  void *v66;
  unsigned int v67;
  _BYTE v68[48];
  void *v69;
  unsigned int v70;
  uint64_t v71;
  void *v72;
  uint64_t v73;
  _BYTE v74[80];
  void *v75;
  unsigned int v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  _BYTE v80[40];
  void *v81;
  unsigned int v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  _BYTE v86[40];
  void *v87;
  unsigned int v88;
  uint64_t v89;
  void *v90;
  unsigned int v91;
  uint64_t v92;
  unint64_t v93[2];
  uint64_t v94;
  char v95[8];
  char v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  v105 = a4;
  v106 = a5;
  if (a7)
  {
    v14 = *a7;
    v15 = a7[1];
    v16 = a7[2];
    v17 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v17 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
  }
  v94 = a6;
  v95[0] = 0;
  v96 = 0;
  v97 = v14;
  v98 = v15;
  v99 = v16;
  v100 = v17;
  v101 = a9;
  v18 = a5;
  v102 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v94);
    if (v96)
      v96 = 0;
    mlir::OperationName::OperationName(v95, "mps.conv_3d", 11, Context);
    v96 = 1;
    v18 = v106;
  }
  v103 = a4;
  v104 = a5;
  if (v18 < 2
    || (v20 = mlir::UnknownLoc::get(this, a2), !mlir::mps::Conv3DOpAdaptor::verify(&v94, v20)))
  {
    v27 = mlir::Float32Type::get(this, a2);
    v28 = mlir::UnrankedTensorType::get(v27);
    v29 = *(unsigned int *)(a11 + 8);
    if (v29 >= *(_DWORD *)(a11 + 12))
    {
LABEL_28:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v29 + 1, 8);
      LODWORD(v29) = *(_DWORD *)(a11 + 8);
    }
LABEL_13:
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v29) = v28;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  v21 = mlir::ValueRange::dereference_iterator(&v105, 0);
  v22 = mlir::ValueRange::dereference_iterator(&v105, 1);
  v23 = *(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8;
  v72 = (void *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
  v73 = v23;
  mlir::ValueRange::ValueRange(v93, (uint64_t)&v72, 2uLL);
  v25 = (_QWORD *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
  v26 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v25 + 8);
  if (v26)
    v26 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v25 + 8);
  else
    v25 = 0;
  v59[0] = v25;
  v59[1] = v26;
  v31 = (_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v31 + 8))
  {
    v32 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v31 + 8);
    v57 = v31;
    v58 = v32;
    if (!v59[0])
      goto LABEL_27;
  }
  else
  {
    v57 = 0;
    v58 = 0;
    if (!v59[0])
      goto LABEL_27;
  }
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v59)
    || (mlir::ShapedType::getShape((mlir::ShapedType *)v59), v33 < 5)
    || !v57
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v57)
    || (mlir::ShapedType::getShape((mlir::ShapedType *)&v57), v34 != 5))
  {
LABEL_27:
    v28 = mlir::UnrankedTensorType::get(v24);
    v29 = *(unsigned int *)(a11 + 8);
    if (v29 >= *(_DWORD *)(a11 + 12))
      goto LABEL_28;
    goto LABEL_13;
  }
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v59);
  mlir::mps::getSpatialValues(Shape, v36, *(_DWORD *)(v97 + 8));
  v37 = mlir::ShapedType::getShape((mlir::ShapedType *)&v57);
  mlir::mps::getSpatialValues(v37, v38, *(_DWORD *)(v100 + 8));
  v84 = v86;
  v85 = 0x500000000;
  v39 = *((_QWORD *)&v99 + 1);
  if (*((_QWORD *)&v99 + 1))
    v40 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v99 + 1) + 8);
  else
    v40 = 0;
  mlir::getIntValues<long long>(v39, v40, (uint64_t)&v84, 1);
  mlir::mps::getSpatialValues((uint64_t)v84, v85, *(_DWORD *)(v97 + 8));
  v78 = v80;
  v79 = 0x500000000;
  v41 = *((_QWORD *)&v97 + 1);
  if (*((_QWORD *)&v97 + 1))
    v42 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v97 + 1) + 8);
  else
    v42 = 0;
  mlir::getIntValues<long long>(v41, v42, (uint64_t)&v78, 1);
  mlir::mps::getSpatialValues((uint64_t)v78, v79, *(_DWORD *)(v97 + 8));
  v72 = v74;
  v73 = 0xA00000000;
  v43 = v98;
  if ((_QWORD)v98)
    v44 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v98 + 8);
  else
    v44 = 0;
  mlir::getIntValues<long long>(v43, v44, (uint64_t)&v72, 1);
  mlir::mps::getSpatialPaddingValues(v72, *(_DWORD *)(v97 + 8), &v69);
  mlir::mps::computeSpatialPaddings((uint64_t)v90, v91, (uint64_t)v87, v88, (uint64_t)v81, v82, (uint64_t)v75, v76, (uint64_t)v69, v70, *(_DWORD *)(v99 + 8));
  llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v69, (uint64_t)&v66);
  if (v66 != v68)
    free(v66);
  mlir::mps::computeConvResultSpatialShape((uint64_t *)v90, v91, (uint64_t *)v87, v81, v75, &v64, (uint64_t)v69);
  v45 = mlir::ShapedType::getShape((mlir::ShapedType *)v59);
  v47 = *(void **)(v45 + 8 * v46 - 40);
  v48 = mlir::ShapedType::getShape((mlir::ShapedType *)&v57);
  v50 = -5;
  if (*(_DWORD *)(v100 + 8) == 10)
    v50 = -1;
  v51 = *(void **)(v48 + 8 * (v50 + v49));
  v62[0] = v47;
  v62[1] = v51;
  v63[0] = *((_QWORD *)v64 + 2);
  v63[1] = *((_QWORD *)v64 + 1);
  v63[2] = *(_QWORD *)v64;
  llvm::SmallVector<long long,5u>::SmallVector<long long,void>(&v66, v62, 5);
  mlir::mps::convertNCDHWShapeToLayout(v66, v67, *(_DWORD *)(v97 + 8), (uint64_t)v62);
  llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v66, (uint64_t)v62);
  if (v62[0] != v63)
    free(v62[0]);
  mlir::ShapedType::getShape((mlir::ShapedType *)v59);
  if (v52 >= 6)
  {
    llvm::SmallVector<long long,5u>::SmallVector(v62, (uint64_t)&v66);
    v53 = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)v59);
    v54 = mlir::ShapedType::getShape((mlir::ShapedType *)v59);
    llvm::SmallVector<long long,5u>::SmallVector<long long const*,void>(v60, v53, (_BYTE *)(v54 + 8 * v55 - 40));
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v66, (uint64_t)v60);
    if (v60[0] != &v61)
      free(v60[0]);
    llvm::SmallVectorImpl<long long>::append((uint64_t)&v66, (uint64_t)v62);
    if (v62[0] != v63)
      free(v62[0]);
  }
  v56 = mlir::RankedTensorType::get((uint64_t)v66, v67, v24, 0);
  llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v56);
  if (v66 != v68)
    free(v66);
  if (v64 != &v65)
    free(v64);
  if (v69 != &v71)
    free(v69);
  if (v72 != v74)
    free(v72);
  if (v75 != &v77)
    free(v75);
  if (v78 != v80)
    free(v78);
  if (v81 != &v83)
    free(v81);
  if (v84 != v86)
    free(v84);
  if (v87 != &v89)
    free(v87);
  if (v90 != &v92)
    free(v90);
  return 1;
}

uint64_t mlir::mps::Conv3DOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *Type;
  _QWORD *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  const char *v62;
  uint64_t v63;
  const char *OperandRange;
  const char *v65;
  uint64_t v66;
  __int16 v67;
  _QWORD v68[2];
  __int128 v69;
  uint64_t Value;
  _QWORD *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD *v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v3 = a1[3];
  if (v3)
  {
    v4 = (const char *)a1[4];
    if (v4)
    {
      v5 = (const char *)a1[5];
      if (v5)
      {
        if (a1[6])
        {
          if (a1[7])
          {
            v6 = (const char *)a1[8];
            if (v6)
            {
              v7 = a1[9];
              if (v7)
              {
                v65 = (const char *)a1[6];
                Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65);
                if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
                {
                  v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
                  v65 = v6;
                  v66 = v8;
                  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                  v10 = Type;
                  if (Type)
                    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
                  Value = (uint64_t)v10;
                  v71 = Type;
                  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                  v68[0] = 5;
                  if (v12 == 1
                    && *Shape == v68[0]
                    && (OperandRange = v6,
                        llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                    && (v62 = v6,
                        *(_QWORD *)&v69 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                        *((_QWORD *)&v69 + 1) = v13,
                        v63 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69),
                        mlir::Type::isUnsignedInteger((mlir::Type *)&v63, 64)))
                  {
                    v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                    v65 = v4;
                    v66 = v14;
                    v15 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                    v16 = v15;
                    if (v15)
                      v15 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
                    Value = (uint64_t)v16;
                    v71 = v15;
                    v17 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                    v68[0] = 5;
                    if (v18 == 1
                      && *v17 == v68[0]
                      && (OperandRange = v4,
                          llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                      && (v62 = v4,
                          *(_QWORD *)&v69 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                          *((_QWORD *)&v69 + 1) = v19,
                          v63 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69),
                          mlir::Type::isUnsignedInteger((mlir::Type *)&v63, 64)))
                    {
                      v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                      v65 = v5;
                      v66 = v20;
                      v21 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                      v22 = v21;
                      if (v21)
                        v21 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
                      Value = (uint64_t)v22;
                      v71 = v21;
                      v23 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                      v69 = xmmword_207AB5440;
                      if (v24 == 2
                        && (*v23 == (_QWORD)v69 ? (v25 = v23[1] == *((_QWORD *)&v69 + 1)) : (v25 = 0),
                            v25
                         && (v63 = (uint64_t)v5,
                             v68[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63),
                             v68[1] = v26,
                             OperandRange = (const char *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68),
                             mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))))
                      {
                        if ((*(_DWORD *)(v3 + 8) - 7) >= 2)
                        {
                          v61 = "'mps.conv_3d' op attribute 'data_layout' failed to satisfy constraint: valid TensorDataL"
                                "ayout is one of NDHWC or NCDHW";
                        }
                        else
                        {
                          if ((*(_DWORD *)(v7 + 8) - 9) < 2)
                            return 1;
                          v61 = "'mps.conv_3d' op attribute 'weights_layout' failed to satisfy constraint: valid TensorDa"
                                "taLayout is one of DHWIO or OIDHW";
                        }
                      }
                      else
                      {
                        v61 = "'mps.conv_3d' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements "
                              "attribute of shape {5, 2}";
                      }
                    }
                    else
                    {
                      v61 = "'mps.conv_3d' op attribute 'dilation_rates' failed to satisfy constraint: positive ui64 elem"
                            "ents attribute of shape {5}";
                    }
                  }
                  else
                  {
                    v61 = "'mps.conv_3d' op attribute 'strides' failed to satisfy constraint: positive ui64 elements attr"
                          "ibute of shape {5}";
                  }
                }
                else
                {
                  v61 = "'mps.conv_3d' op attribute 'groups' failed to satisfy constraint: 64-bit unsigned integer attribute";
                }
              }
              else
              {
                v61 = "'mps.conv_3d' op requires attribute 'weights_layout'";
              }
            }
            else
            {
              v61 = "'mps.conv_3d' op requires attribute 'strides'";
            }
            v65 = v61;
            v67 = 259;
            mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
            v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
            return v27;
          }
          v65 = "'mps.conv_3d' op requires attribute 'padding_style'";
          v67 = 259;
          mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
          v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v78)
          {
            v54 = __p;
            if (__p)
            {
              v55 = v77;
              v56 = __p;
              if (v77 != __p)
              {
                do
                  v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
                while (v55 != v54);
                v56 = __p;
              }
              v77 = v54;
              operator delete(v56);
            }
            v31 = v74;
            if (!v74)
              goto LABEL_105;
            v57 = v75;
            v33 = v74;
            if (v75 == v74)
            {
LABEL_104:
              v75 = v31;
              operator delete(v33);
LABEL_105:
              if (v72 != &v73)
                free(v72);
              return v27;
            }
            do
            {
              v59 = *--v57;
              v58 = v59;
              *v57 = 0;
              if (v59)
                MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
            }
            while (v57 != v31);
LABEL_103:
            v33 = v74;
            goto LABEL_104;
          }
        }
        else
        {
          v65 = "'mps.conv_3d' op requires attribute 'groups'";
          v67 = 259;
          mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
          v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v78)
          {
            v48 = __p;
            if (__p)
            {
              v49 = v77;
              v50 = __p;
              if (v77 != __p)
              {
                do
                  v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
                while (v49 != v48);
                v50 = __p;
              }
              v77 = v48;
              operator delete(v50);
            }
            v31 = v74;
            if (!v74)
              goto LABEL_105;
            v51 = v75;
            v33 = v74;
            if (v75 == v74)
              goto LABEL_104;
            do
            {
              v53 = *--v51;
              v52 = v53;
              *v51 = 0;
              if (v53)
                MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
            }
            while (v51 != v31);
            goto LABEL_103;
          }
        }
      }
      else
      {
        v65 = "'mps.conv_3d' op requires attribute 'explicit_padding'";
        v67 = 259;
        mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
        v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v78)
        {
          v42 = __p;
          if (__p)
          {
            v43 = v77;
            v44 = __p;
            if (v77 != __p)
            {
              do
                v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
              while (v43 != v42);
              v44 = __p;
            }
            v77 = v42;
            operator delete(v44);
          }
          v31 = v74;
          if (!v74)
            goto LABEL_105;
          v45 = v75;
          v33 = v74;
          if (v75 == v74)
            goto LABEL_104;
          do
          {
            v47 = *--v45;
            v46 = v47;
            *v45 = 0;
            if (v47)
              MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
          }
          while (v45 != v31);
          goto LABEL_103;
        }
      }
    }
    else
    {
      v65 = "'mps.conv_3d' op requires attribute 'dilation_rates'";
      v67 = 259;
      mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
      v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v78)
      {
        v36 = __p;
        if (__p)
        {
          v37 = v77;
          v38 = __p;
          if (v77 != __p)
          {
            do
              v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
            while (v37 != v36);
            v38 = __p;
          }
          v77 = v36;
          operator delete(v38);
        }
        v31 = v74;
        if (!v74)
          goto LABEL_105;
        v39 = v75;
        v33 = v74;
        if (v75 == v74)
          goto LABEL_104;
        do
        {
          v41 = *--v39;
          v40 = v41;
          *v39 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v39 != v31);
        goto LABEL_103;
      }
    }
  }
  else
  {
    v65 = "'mps.conv_3d' op requires attribute 'data_layout'";
    v67 = 259;
    mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v78)
    {
      v28 = __p;
      if (__p)
      {
        v29 = v77;
        v30 = __p;
        if (v77 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v77 = v28;
        operator delete(v30);
      }
      v31 = v74;
      if (!v74)
        goto LABEL_105;
      v32 = v75;
      v33 = v74;
      if (v75 == v74)
        goto LABEL_104;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
      goto LABEL_103;
    }
  }
  return v27;
}

_QWORD *llvm::SmallVector<long long,5u>::SmallVector(_QWORD *a1, uint64_t a2)
{
  void *v3;
  unint64_t v5;
  unsigned int v6;

  v3 = a1 + 2;
  *a1 = a1 + 2;
  a1[1] = 0x500000000;
  if (a1 != (_QWORD *)a2)
  {
    v5 = *(unsigned int *)(a2 + 8);
    if ((_DWORD)v5)
    {
      if (v5 < 6)
      {
        v6 = *(_DWORD *)(a2 + 8);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, v5, 8);
        v6 = *(_DWORD *)(a2 + 8);
        if (!v6)
        {
LABEL_8:
          *((_DWORD *)a1 + 2) = v5;
          return a1;
        }
        v3 = (void *)*a1;
      }
      memcpy(v3, *(const void **)a2, 8 * v6);
      goto LABEL_8;
    }
  }
  return a1;
}

void llvm::SmallVectorImpl<long long>::append(uint64_t a1, uint64_t a2)
{
  const void *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(const void **)a2;
  v4 = *(unsigned int *)(a2 + 8);
  v5 = *(unsigned int *)(a1 + 8);
  if (v5 + v4 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v5 + v4, 8);
    LODWORD(v5) = *(_DWORD *)(a1 + 8);
  }
  if ((_DWORD)v4)
  {
    memcpy((void *)(*(_QWORD *)a1 + 8 * v5), v3, 8 * v4);
    LODWORD(v5) = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v5 + v4;
}

uint64_t mlir::mps::verifyConvolutionInputChannels(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  const void **v23;
  __int16 v24;
  _QWORD v25[3];
  void *v26;
  uint64_t v27;
  void *v28;
  _QWORD *v29;
  void *__p;
  _QWORD *v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v8 = 1;
  if (a3 && a6)
  {
    v9 = -4;
    if (a4 != 7)
      v9 = -1;
    v10 = *(_QWORD *)(a2 + 8 * (v9 + a3));
    if (v10 != 0x8000000000000000)
    {
      v11 = 8;
      if (a7 == 10)
        v11 = 24;
      v12 = *(_QWORD *)(a5 + v11);
      if (v12 != 0x8000000000000000 && v12 * a8 != v10)
      {
        v23 = (const void **)"failed: inputChannels must be equal to groups * inputWeightChannels";
        v24 = 259;
        mlir::Operation::emitOpError(a1, &v23, (uint64_t)v25);
        v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v25);
        if (v25[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v25);
        if (v32)
        {
          v14 = __p;
          if (__p)
          {
            v15 = v31;
            v16 = __p;
            if (v31 != __p)
            {
              do
                v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
              while (v15 != v14);
              v16 = __p;
            }
            v31 = v14;
            operator delete(v16);
          }
          v17 = v28;
          if (v28)
          {
            v18 = v29;
            v19 = v28;
            if (v29 != v28)
            {
              do
              {
                v21 = *--v18;
                v20 = v21;
                *v18 = 0;
                if (v21)
                  MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
              }
              while (v18 != v17);
              v19 = v28;
            }
            v29 = v17;
            operator delete(v19);
          }
          if (v26 != &v27)
            free(v26);
        }
      }
    }
  }
  return v8;
}

uint64_t mlir::mps::verifyConvolutionOutputChannels(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, int a7, unint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  const void **v28[4];
  __int16 v29;
  _QWORD v30[3];
  void *v31;
  uint64_t v32;
  void *v33;
  _QWORD *v34;
  void *__p;
  _QWORD *v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v8 = 1;
  if (!a3)
    return v8;
  if (!a6)
    return v8;
  v9 = *(_QWORD *)(a5 + 32 * (a7 == 10));
  if (v9 == 0x8000000000000000)
    return v8;
  v10 = -4;
  if (a4 != 7)
    v10 = -1;
  v11 = *(_QWORD *)(a2 + 8 * (v10 + a3));
  if (v11 == 0x8000000000000000 || v9 == v11)
  {
    if (v9 % a8)
    {
      v28[0] = (const void **)"failed: weights output channels needs to be divisible by groups";
      v29 = 259;
      mlir::Operation::emitOpError(a1, v28, (uint64_t)v30);
      v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
      if (v30[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
      if (v37)
      {
        v13 = __p;
        if (__p)
        {
          v14 = v36;
          v15 = __p;
          if (v36 != __p)
          {
            do
              v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
            while (v14 != v13);
            v15 = __p;
          }
          v36 = v13;
          operator delete(v15);
        }
        v16 = v33;
        if (!v33)
          goto LABEL_42;
        v17 = v34;
        v18 = v33;
        if (v34 == v33)
          goto LABEL_41;
        do
        {
          v20 = *--v17;
          v19 = v20;
          *v17 = 0;
          if (v20)
            MEMORY[0x20BD002D4](v19, 0x1000C8077774924);
        }
        while (v17 != v16);
        goto LABEL_40;
      }
    }
  }
  else
  {
    v28[0] = (const void **)"failed: weights output channels are inconsistent with those of the operands or result";
    v29 = 259;
    mlir::Operation::emitOpError(a1, v28, (uint64_t)v30);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    if (v37)
    {
      v21 = __p;
      if (__p)
      {
        v22 = v36;
        v23 = __p;
        if (v36 != __p)
        {
          do
            v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
          while (v22 != v21);
          v23 = __p;
        }
        v36 = v21;
        operator delete(v23);
      }
      v16 = v33;
      if (!v33)
        goto LABEL_42;
      v24 = v34;
      v18 = v33;
      if (v34 == v33)
      {
LABEL_41:
        v34 = v16;
        operator delete(v18);
LABEL_42:
        if (v31 != &v32)
          free(v31);
        return v8;
      }
      do
      {
        v26 = *--v24;
        v25 = v26;
        *v24 = 0;
        if (v26)
          MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
      }
      while (v24 != v16);
LABEL_40:
      v18 = v33;
      goto LABEL_41;
    }
  }
  return v8;
}

uint64_t mlir::mps::Conv3DOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  const void **v22;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  const void **v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  const void **v44;
  const void **v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t Shape;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  int v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t *v80;
  _QWORD v81[2];
  _QWORD v82[2];
  const void **v83[4];
  __int16 v84;
  uint64_t v85;
  const void **v86[2];
  _WORD v87[24];
  const void **v88[2];
  _WORD v89[24];
  uint64_t *v90;
  unsigned int v91;
  void *v92;
  _BYTE v93[96];
  void *v94;
  _QWORD *v95;
  void *__p;
  _QWORD *v97;
  char v98;
  void *v99[2];
  _QWORD v100[8];

  v100[6] = *MEMORY[0x24BDAC8D0];
  v99[0] = v100;
  v99[1] = (void *)0x600000000;
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v3 = *(_QWORD **)(v2 + 16);
  if (v3)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  else
    v4 = 0;
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v99, 1);
  v5 = *((unsigned int *)*this + 11);
  v6 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1) + 8];
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v7 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1) + 8];
  else
    v7 = 0;
  v8 = *(_DWORD *)(*(_QWORD *)(v7 + 32) + 8);
  if (v8 == 3)
    goto LABEL_21;
  if (v8)
    goto LABEL_35;
  v9 = *(_QWORD *)v99[0];
  if (*(_DWORD *)(*(_QWORD *)v6 + 8) == 7)
  {
    if (!v9 && !*((_QWORD *)v99[0] + 1) && !*((_QWORD *)v99[0] + 2))
    {
      v10 = 3;
      goto LABEL_20;
    }
LABEL_21:
    v88[0] = (const void **)"failed: explicit padding incompatible with with given tensor data layout.";
    v89[8] = 259;
    mlir::OpState::emitOpError(this, v88, (uint64_t)&v90);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v90);
    if (v90)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v90);
    if (v98)
    {
      v12 = __p;
      if (__p)
      {
        v13 = v97;
        v14 = __p;
        if (v97 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v97 = v12;
        operator delete(v14);
      }
      v15 = v94;
      if (v94)
      {
        v16 = v95;
        v17 = v94;
        if (v95 != v94)
        {
          do
          {
            v19 = *--v16;
            v18 = v19;
            *v16 = 0;
            if (v19)
              MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
          }
          while (v16 != v15);
          v17 = v94;
        }
        v95 = v15;
        operator delete(v17);
      }
      v22 = (const void **)v92;
      if (v92 != v93)
        goto LABEL_40;
    }
    goto LABEL_41;
  }
  if (v9 || *((_QWORD *)v99[0] + 1) || *((_QWORD *)v99[0] + 8))
    goto LABEL_21;
  v10 = 9;
LABEL_20:
  if (*((_QWORD *)v99[0] + v10))
    goto LABEL_21;
LABEL_35:
  v88[0] = (const void **)v89;
  v88[1] = (const void **)0x600000000;
  v20 = *(_QWORD **)(v7 + 40);
  if (v20)
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v20 + 8);
  else
    v21 = 0;
  mlir::getIntValues<long long>((uint64_t)v20, v21, (uint64_t)v88, 1);
  if (*v88[0] == (const void *)1)
  {
    v24 = *((unsigned int *)*this + 11);
    v25 = (uint64_t)&(*this)[2 * ((v24 >> 23) & 1)];
    v27 = *(_QWORD *)(v25 + 64);
    v26 = v25 + 64;
    v28 = 4;
    if (*(_DWORD *)(v27 + 8) == 7)
      v28 = 1;
    if (v88[0][v28] == (const void *)1)
    {
      v86[0] = (const void **)v87;
      v86[1] = (const void **)0x600000000;
      if (BYTE3(v24))
        v29 = v26;
      else
        v29 = 0;
      v30 = *(_QWORD **)(v29 + 8);
      if (v30)
        v31 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v30 + 8);
      else
        v31 = 0;
      mlir::getIntValues<long long>((uint64_t)v30, v31, (uint64_t)v86, 1);
      if (*v86[0] != (const void *)1)
        goto LABEL_81;
      v41 = *this;
      v42 = 4;
      if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8) == 7)
        v42 = 1;
      if (v86[0][v42] == (const void *)1)
      {
        v43 = v41[9];
        v44 = (const void **)(*(_QWORD *)(*(_QWORD *)(v43 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v44)
        {
          v45 = (const void **)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v44 + 8);
          v41 = *this;
          v43 = (*this)[9];
        }
        else
        {
          v45 = 0;
        }
        v83[0] = v44;
        v83[1] = v45;
        v54 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v54)
        {
          v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v54 + 8);
          v41 = *this;
        }
        else
        {
          v55 = 0;
        }
        v82[0] = v54;
        v82[1] = v55;
        Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v83);
        v78 = v57;
        v79 = Shape;
        v58 = *(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8);
        v59 = mlir::ShapedType::getShape((mlir::ShapedType *)v82);
        v61 = v60;
        v62 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
        if (!HIBYTE(*((_DWORD *)*this + 11)))
          v62 = 0;
        v63 = *(_DWORD *)(*(_QWORD *)(v62 + 48) + 8);
        v81[0] = *(_QWORD *)(v62 + 24);
        mlir::IntegerAttr::getValue(v81, (llvm::APInt *)&v90);
        if (v91 > 0x40)
        {
          v64 = *v90;
          MEMORY[0x20BD002D4]();
        }
        else
        {
          v64 = (uint64_t)v90;
        }
        if (mlir::mps::verifyConvolutionInputChannels(v41, v79, v78, v58, v59, v61, v63, v64))
        {
          if (*((_DWORD *)*this + 9))
            v65 = (uint64_t)(*this - 2);
          else
            v65 = 0;
          v66 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v65, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (v66)
            v67 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v66 + 8);
          else
            v67 = 0;
          v81[0] = v66;
          v81[1] = v67;
          v80 = *this;
          v68 = mlir::ShapedType::getShape((mlir::ShapedType *)v81);
          v70 = v69;
          v71 = *(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8);
          v72 = mlir::ShapedType::getShape((mlir::ShapedType *)v82);
          v74 = v73;
          v75 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
          if (!HIBYTE(*((_DWORD *)*this + 11)))
            v75 = 0;
          v76 = *(_DWORD *)(*(_QWORD *)(v75 + 48) + 8);
          v85 = *(_QWORD *)(v75 + 24);
          mlir::IntegerAttr::getValue(&v85, (llvm::APInt *)&v90);
          if (v91 > 0x40)
          {
            v77 = *v90;
            MEMORY[0x20BD002D4]();
          }
          else
          {
            v77 = (unint64_t)v90;
          }
          v11 = mlir::mps::verifyConvolutionOutputChannels(v80, v68, v70, v71, v72, v74, v76, v77);
        }
        else
        {
          v11 = 0;
        }
      }
      else
      {
LABEL_81:
        v83[0] = (const void **)"failed: dilation values incompatible with given tensor layout.";
        v84 = 259;
        mlir::OpState::emitOpError(this, v83, (uint64_t)&v90);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v90);
        if (v90)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v90);
        if (v98)
        {
          v46 = __p;
          if (__p)
          {
            v47 = v97;
            v48 = __p;
            if (v97 != __p)
            {
              do
                v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
              while (v47 != v46);
              v48 = __p;
            }
            v97 = v46;
            operator delete(v48);
          }
          v49 = v94;
          if (v94)
          {
            v50 = v95;
            v51 = v94;
            if (v95 != v94)
            {
              do
              {
                v53 = *--v50;
                v52 = v53;
                *v50 = 0;
                if (v53)
                  MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
              }
              while (v50 != v49);
              v51 = v94;
            }
            v95 = v49;
            operator delete(v51);
          }
          if (v92 != v93)
            free(v92);
        }
      }
      v40 = v86[0];
      if ((_WORD *)v86[0] == v87)
        goto LABEL_72;
LABEL_71:
      free(v40);
      goto LABEL_72;
    }
  }
  v86[0] = (const void **)"failed: strides incompatible with given tensor data layout.";
  v87[8] = 259;
  mlir::OpState::emitOpError(this, v86, (uint64_t)&v90);
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v90);
  if (v90)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v90);
  if (v98)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v97;
      v34 = __p;
      if (v97 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v97 = v32;
      operator delete(v34);
    }
    v35 = v94;
    if (v94)
    {
      v36 = v95;
      v37 = v94;
      if (v95 != v94)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v94;
      }
      v95 = v35;
      operator delete(v37);
    }
    v40 = (const void **)v92;
    if (v92 != v93)
      goto LABEL_71;
  }
LABEL_72:
  v22 = v88[0];
  if ((_WORD *)v88[0] != v89)
LABEL_40:
    free(v22);
LABEL_41:
  if (v99[0] != v100)
    free(v99[0]);
  return v11;
}

uint64_t mlir::mps::Conv3DOp::getPaddingStyle(mlir::mps::Conv3DOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(unsigned int *)(*(_QWORD *)(v1 + 32) + 8);
}

uint64_t mlir::mps::Conv3DOp::getStrides(mlir::mps::Conv3DOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(_QWORD *)(v1 + 40);
}

uint64_t mlir::mps::Conv3DOp::getWeightsLayout(mlir::mps::Conv3DOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(unsigned int *)(*(_QWORD *)(v1 + 48) + 8);
}

void mlir::mps::computeConv3DTransposeResultSpatialShape(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X4>, _QWORD *a5@<X6>, _QWORD *a6@<X8>, uint64_t a7)
{
  unint64_t v7;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;

  v7 = a2;
  *a6 = a6 + 2;
  a6[1] = 0x300000000;
  if (!a2)
    return;
  if (a2 < 4)
  {
    v13 = 0;
    v14 = a7;
    v15 = a2;
    goto LABEL_6;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a6, a6 + 2, a2, 8);
  v13 = *((unsigned int *)a6 + 2);
  v14 = a7;
  v15 = v7 - v13;
  if (v7 != v13)
LABEL_6:
    bzero((void *)(*a6 + 8 * v13), 8 * v15);
  *((_DWORD *)a6 + 2) = v7;
  v16 = (uint64_t *)*a6;
  v17 = (_QWORD *)(v14 + 8);
  do
  {
    v19 = *a3++;
    v18 = v19;
    v21 = *a1++;
    v20 = v21;
    v22 = v21 == 0x8000000000000000 || v18 == 0x8000000000000000;
    v23 = 0x8000000000000000;
    if (!v22)
      v23 = *a4 * (v20 - 1) + *a5 * (v18 - 1) - (*(v17 - 1) + *v17) + 1;
    *v16++ = v23;
    v17 += 2;
    ++a5;
    ++a4;
    --v7;
  }
  while (v7);
}

uint64_t mlir::mps::Conv3DDataGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  unint64_t v30;
  int64x2_t *v31;
  int64x2_t v32;
  uint64_t v33;
  int32x2_t v34;
  int32x2_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t Shape;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *Groups;
  uint64_t v66;
  _BYTE *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  _QWORD v73[2];
  void *v74[2];
  uint64_t v75;
  void *__src[2];
  _QWORD v77[5];
  void *v78[2];
  _BYTE v79[48];
  void *v80;
  unsigned int v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  _BYTE v85[80];
  void *v86;
  unsigned int v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  _BYTE v91[40];
  void *v92;
  unsigned int v93;
  uint64_t v94;
  void *v95;
  uint64_t v96;
  _BYTE v97[40];
  void *v98;
  unsigned int v99;
  uint64_t v100;
  void *v101;
  unsigned int v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  _BYTE v106[40];
  unint64_t v107[2];
  uint64_t v108;
  char v109[8];
  char v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;

  v121 = *MEMORY[0x24BDAC8D0];
  v119 = a4;
  v120 = a5;
  if (a7)
  {
    v14 = *a7;
    v15 = a7[1];
    v16 = a7[2];
    v17 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v17 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
  }
  v108 = a6;
  v109[0] = 0;
  v110 = 0;
  v111 = v14;
  v112 = v15;
  v113 = v16;
  v114 = v17;
  v115 = a9;
  v18 = a5;
  v116 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v108);
    if (v110)
      v110 = 0;
    mlir::OperationName::OperationName(v109, "mps.conv_3d_data_gradient", 25, Context);
    v110 = 1;
    v18 = v120;
  }
  v117 = a4;
  v118 = a5;
  if (v18 >= 2)
  {
    v20 = mlir::UnknownLoc::get(this, a2);
    if (mlir::mps::Conv3DDataGradientOpAdaptor::verify(&v108, v20))
    {
      v21 = mlir::ValueRange::dereference_iterator(&v119, 0);
      v22 = mlir::ValueRange::dereference_iterator(&v119, 1);
      v23 = 0;
      if (v120 >= 3)
        v23 = mlir::ValueRange::dereference_iterator(&v119, 2);
      v24 = *(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8;
      v83 = (void *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
      v84 = v24;
      mlir::ValueRange::ValueRange(v107, (uint64_t)&v83, 2uLL);
      v104 = v106;
      v105 = 0x500000000;
      if (v23 && mlir::matchConstantWithIntVector<long long>(v23, (uint64_t)&v104))
      {
        v26 = (char *)v104;
        v27 = v105;
        if (!(_DWORD)v105)
          goto LABEL_50;
        v28 = (v105 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        v29 = (char *)v104;
        if (v28 >= 3)
        {
          v30 = v28 + 1;
          v29 = (char *)v104 + 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
          v31 = (int64x2_t *)((char *)v104 + 16);
          v32.i64[0] = -1;
          v32.i64[1] = -1;
          v33 = v30 & 0x3FFFFFFFFFFFFFFCLL;
          while (1)
          {
            v34 = vmovn_s64(vceqq_s64(v31[-1], v32));
            if ((v34.i8[0] & 1) != 0)
            {
              v31[-1].i64[0] = 0x8000000000000000;
              if ((v34.i8[4] & 1) == 0)
              {
LABEL_20:
                v35 = vmovn_s64(vceqq_s64(*v31, v32));
                if ((v35.i8[0] & 1) == 0)
                  goto LABEL_21;
                goto LABEL_25;
              }
            }
            else if ((v34.i8[4] & 1) == 0)
            {
              goto LABEL_20;
            }
            v31[-1].i64[1] = 0x8000000000000000;
            v35 = vmovn_s64(vceqq_s64(*v31, v32));
            if ((v35.i8[0] & 1) == 0)
            {
LABEL_21:
              if ((v35.i8[4] & 1) != 0)
                goto LABEL_26;
              goto LABEL_17;
            }
LABEL_25:
            v31->i64[0] = 0x8000000000000000;
            if ((v35.i8[4] & 1) != 0)
LABEL_26:
              v31->i64[1] = 0x8000000000000000;
LABEL_17:
            v31 += 2;
            v33 -= 4;
            if (!v33)
            {
              if (v30 == (v30 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_50;
              goto LABEL_54;
            }
          }
        }
        do
        {
LABEL_54:
          if (*(_QWORD *)v29 == -1)
            *(_QWORD *)v29 = 0x8000000000000000;
          v29 += 8;
        }
        while (v29 != &v26[8 * v27]);
LABEL_50:
        v51 = mlir::RankedTensorType::get((uint64_t)v26, v27, v25, 0);
        v52 = *(unsigned int *)(a11 + 8);
        if (v52 < *(_DWORD *)(a11 + 12))
          goto LABEL_45;
        goto LABEL_51;
      }
      v39 = (_QWORD *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
      v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v39 + 8);
      if (v40)
        v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v39 + 8);
      else
        v39 = 0;
      v73[0] = v39;
      v73[1] = v40;
      v41 = (_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v41 + 8))
      {
        v42 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v41 + 8);
        v71 = v41;
        v72 = v42;
        if (!v73[0])
          goto LABEL_44;
      }
      else
      {
        v71 = 0;
        v72 = 0;
        if (!v73[0])
          goto LABEL_44;
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v73))
      {
        mlir::ShapedType::getShape((mlir::ShapedType *)v73);
        if (v43 >= 5)
        {
          if (v71)
          {
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v71))
            {
              mlir::ShapedType::getShape((mlir::ShapedType *)&v71);
              if (v44 == 5)
              {
                Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
                mlir::mps::getSpatialValues(Shape, v46, *(_DWORD *)(v111 + 8));
                v47 = mlir::ShapedType::getShape((mlir::ShapedType *)&v71);
                mlir::mps::getSpatialValues(v47, v48, *(_DWORD *)(v114 + 8));
                v95 = v97;
                v96 = 0x500000000;
                v49 = *((_QWORD *)&v113 + 1);
                if (*((_QWORD *)&v113 + 1))
                  v50 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v113 + 1) + 8);
                else
                  v50 = 0;
                mlir::getIntValues<long long>(v49, v50, (uint64_t)&v95, 1);
                mlir::mps::getSpatialValues((uint64_t)v95, v96, *(_DWORD *)(v111 + 8));
                v89 = v91;
                v90 = 0x500000000;
                v54 = *((_QWORD *)&v111 + 1);
                if (*((_QWORD *)&v111 + 1))
                  v55 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v111 + 1) + 8);
                else
                  v55 = 0;
                mlir::getIntValues<long long>(v54, v55, (uint64_t)&v89, 1);
                mlir::mps::getSpatialValues((uint64_t)v89, v90, *(_DWORD *)(v111 + 8));
                v83 = v85;
                v84 = 0xA00000000;
                v56 = v112;
                if ((_QWORD)v112)
                  v57 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v112 + 8);
                else
                  v57 = 0;
                mlir::getIntValues<long long>(v56, v57, (uint64_t)&v83, 1);
                mlir::mps::getSpatialPaddingValues(v83, *(_DWORD *)(v111 + 8), &v80);
                mlir::mps::computeSpatialPaddings((uint64_t)v101, v102, (uint64_t)v98, v99, (uint64_t)v92, v93, (uint64_t)v86, v87, (uint64_t)v80, v81, *(_DWORD *)(v113 + 8));
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v80, (uint64_t)v78);
                if (v78[0] != v79)
                  free(v78[0]);
                v78[0] = v79;
                v78[1] = (void *)0x500000000;
                mlir::mps::computeConv3DTransposeResultSpatialShape((uint64_t *)v101, v102, (uint64_t *)v98, v92, v86, __src, (uint64_t)v80);
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v78, (uint64_t)__src);
                if (__src[0] != v77)
                  free(__src[0]);
                v58 = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
                v60 = *(void **)(v58 + 8 * v59 - 40);
                v61 = mlir::ShapedType::getShape((mlir::ShapedType *)&v71);
                v63 = -4;
                if (*(_DWORD *)(v114 + 8) == 10)
                  v63 = -2;
                v64 = *(_QWORD *)(v61 + 8 * (v63 + v62));
                Groups = mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::getGroups((mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase *)&v108);
                __src[0] = v60;
                __src[1] = (void *)((_QWORD)Groups * v64);
                v77[0] = *((_QWORD *)v78[0] + 2);
                v77[1] = *((_QWORD *)v78[0] + 1);
                v77[2] = *(_QWORD *)v78[0];
                llvm::SmallVector<long long,5u>::operator=((uint64_t)&v104, __src, 5);
                mlir::mps::convertNCDHWShapeToLayout(v104, v105, *(_DWORD *)(v111 + 8), (uint64_t)__src);
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v104, (uint64_t)__src);
                if (__src[0] != v77)
                  free(__src[0]);
                mlir::ShapedType::getShape((mlir::ShapedType *)v73);
                if (v66 >= 6)
                {
                  llvm::SmallVector<long long,5u>::SmallVector(__src, (uint64_t)&v104);
                  v67 = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)v73);
                  v68 = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
                  llvm::SmallVector<long long,5u>::SmallVector<long long const*,void>(v74, v67, (_BYTE *)(v68 + 8 * v69 - 40));
                  llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v104, (uint64_t)v74);
                  if (v74[0] != &v75)
                    free(v74[0]);
                  llvm::SmallVectorImpl<long long>::append((uint64_t)&v104, (uint64_t)__src);
                  if (__src[0] != v77)
                    free(__src[0]);
                }
                v70 = mlir::RankedTensorType::get((uint64_t)v104, v105, v25, 0);
                llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v70);
                if (v78[0] != v79)
                  free(v78[0]);
                if (v80 != &v82)
                  free(v80);
                if (v83 != v85)
                  free(v83);
                if (v86 != &v88)
                  free(v86);
                if (v89 != v91)
                  free(v89);
                if (v92 != &v94)
                  free(v92);
                if (v95 != v97)
                  free(v95);
                if (v98 != &v100)
                  free(v98);
                if (v101 != &v103)
                  free(v101);
                goto LABEL_46;
              }
            }
          }
        }
      }
LABEL_44:
      v51 = mlir::UnrankedTensorType::get(v25);
      v52 = *(unsigned int *)(a11 + 8);
      if (v52 < *(_DWORD *)(a11 + 12))
      {
LABEL_45:
        *(_QWORD *)(*(_QWORD *)a11 + 8 * v52) = v51;
        ++*(_DWORD *)(a11 + 8);
LABEL_46:
        if (v104 != v106)
          free(v104);
        return 1;
      }
LABEL_51:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v52 + 1, 8);
      LODWORD(v52) = *(_DWORD *)(a11 + 8);
      goto LABEL_45;
    }
  }
  v36 = mlir::Float32Type::get(this, a2);
  v37 = mlir::UnrankedTensorType::get(v36);
  v38 = *(unsigned int *)(a11 + 8);
  if (v38 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v38 + 1, 8);
    LODWORD(v38) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v38) = v37;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::Conv3DDataGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *Type;
  _QWORD *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  const char *v62;
  uint64_t v63;
  const char *OperandRange;
  const char *v65;
  uint64_t v66;
  __int16 v67;
  _QWORD v68[2];
  __int128 v69;
  uint64_t Value;
  _QWORD *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD *v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v3 = a1[3];
  if (v3)
  {
    v4 = (const char *)a1[4];
    if (v4)
    {
      v5 = (const char *)a1[5];
      if (v5)
      {
        if (a1[6])
        {
          if (a1[7])
          {
            v6 = (const char *)a1[8];
            if (v6)
            {
              v7 = a1[9];
              if (v7)
              {
                v65 = (const char *)a1[6];
                Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65);
                if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
                {
                  v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
                  v65 = v6;
                  v66 = v8;
                  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                  v10 = Type;
                  if (Type)
                    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
                  Value = (uint64_t)v10;
                  v71 = Type;
                  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                  v68[0] = 5;
                  if (v12 == 1
                    && *Shape == v68[0]
                    && (OperandRange = v6,
                        llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                    && (v62 = v6,
                        *(_QWORD *)&v69 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                        *((_QWORD *)&v69 + 1) = v13,
                        v63 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69),
                        mlir::Type::isUnsignedInteger((mlir::Type *)&v63, 64)))
                  {
                    v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                    v65 = v4;
                    v66 = v14;
                    v15 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                    v16 = v15;
                    if (v15)
                      v15 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
                    Value = (uint64_t)v16;
                    v71 = v15;
                    v17 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                    v68[0] = 5;
                    if (v18 == 1
                      && *v17 == v68[0]
                      && (OperandRange = v4,
                          llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                      && (v62 = v4,
                          *(_QWORD *)&v69 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                          *((_QWORD *)&v69 + 1) = v19,
                          v63 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69),
                          mlir::Type::isUnsignedInteger((mlir::Type *)&v63, 64)))
                    {
                      v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                      v65 = v5;
                      v66 = v20;
                      v21 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                      v22 = v21;
                      if (v21)
                        v21 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
                      Value = (uint64_t)v22;
                      v71 = v21;
                      v23 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                      v69 = xmmword_207AB5440;
                      if (v24 == 2
                        && (*v23 == (_QWORD)v69 ? (v25 = v23[1] == *((_QWORD *)&v69 + 1)) : (v25 = 0),
                            v25
                         && (v63 = (uint64_t)v5,
                             v68[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63),
                             v68[1] = v26,
                             OperandRange = (const char *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68),
                             mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))))
                      {
                        if ((*(_DWORD *)(v3 + 8) - 7) >= 2)
                        {
                          v61 = "'mps.conv_3d_data_gradient' op attribute 'data_layout' failed to satisfy constraint: val"
                                "id TensorDataLayout is one of NDHWC or NCDHW";
                        }
                        else
                        {
                          if ((*(_DWORD *)(v7 + 8) - 9) < 2)
                            return 1;
                          v61 = "'mps.conv_3d_data_gradient' op attribute 'weights_layout' failed to satisfy constraint: "
                                "valid TensorDataLayout is one of DHWIO or OIDHW";
                        }
                      }
                      else
                      {
                        v61 = "'mps.conv_3d_data_gradient' op attribute 'explicit_padding' failed to satisfy constraint: "
                              "ui64 elements attribute of shape {5, 2}";
                      }
                    }
                    else
                    {
                      v61 = "'mps.conv_3d_data_gradient' op attribute 'dilation_rates' failed to satisfy constraint: posi"
                            "tive ui64 elements attribute of shape {5}";
                    }
                  }
                  else
                  {
                    v61 = "'mps.conv_3d_data_gradient' op attribute 'strides' failed to satisfy constraint: positive ui64"
                          " elements attribute of shape {5}";
                  }
                }
                else
                {
                  v61 = "'mps.conv_3d_data_gradient' op attribute 'groups' failed to satisfy constraint: 64-bit unsigned "
                        "integer attribute";
                }
              }
              else
              {
                v61 = "'mps.conv_3d_data_gradient' op requires attribute 'weights_layout'";
              }
            }
            else
            {
              v61 = "'mps.conv_3d_data_gradient' op requires attribute 'strides'";
            }
            v65 = v61;
            v67 = 259;
            mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
            v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
            return v27;
          }
          v65 = "'mps.conv_3d_data_gradient' op requires attribute 'padding_style'";
          v67 = 259;
          mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
          v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v78)
          {
            v54 = __p;
            if (__p)
            {
              v55 = v77;
              v56 = __p;
              if (v77 != __p)
              {
                do
                  v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
                while (v55 != v54);
                v56 = __p;
              }
              v77 = v54;
              operator delete(v56);
            }
            v31 = v74;
            if (!v74)
              goto LABEL_105;
            v57 = v75;
            v33 = v74;
            if (v75 == v74)
            {
LABEL_104:
              v75 = v31;
              operator delete(v33);
LABEL_105:
              if (v72 != &v73)
                free(v72);
              return v27;
            }
            do
            {
              v59 = *--v57;
              v58 = v59;
              *v57 = 0;
              if (v59)
                MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
            }
            while (v57 != v31);
LABEL_103:
            v33 = v74;
            goto LABEL_104;
          }
        }
        else
        {
          v65 = "'mps.conv_3d_data_gradient' op requires attribute 'groups'";
          v67 = 259;
          mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
          v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v78)
          {
            v48 = __p;
            if (__p)
            {
              v49 = v77;
              v50 = __p;
              if (v77 != __p)
              {
                do
                  v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
                while (v49 != v48);
                v50 = __p;
              }
              v77 = v48;
              operator delete(v50);
            }
            v31 = v74;
            if (!v74)
              goto LABEL_105;
            v51 = v75;
            v33 = v74;
            if (v75 == v74)
              goto LABEL_104;
            do
            {
              v53 = *--v51;
              v52 = v53;
              *v51 = 0;
              if (v53)
                MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
            }
            while (v51 != v31);
            goto LABEL_103;
          }
        }
      }
      else
      {
        v65 = "'mps.conv_3d_data_gradient' op requires attribute 'explicit_padding'";
        v67 = 259;
        mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
        v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v78)
        {
          v42 = __p;
          if (__p)
          {
            v43 = v77;
            v44 = __p;
            if (v77 != __p)
            {
              do
                v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
              while (v43 != v42);
              v44 = __p;
            }
            v77 = v42;
            operator delete(v44);
          }
          v31 = v74;
          if (!v74)
            goto LABEL_105;
          v45 = v75;
          v33 = v74;
          if (v75 == v74)
            goto LABEL_104;
          do
          {
            v47 = *--v45;
            v46 = v47;
            *v45 = 0;
            if (v47)
              MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
          }
          while (v45 != v31);
          goto LABEL_103;
        }
      }
    }
    else
    {
      v65 = "'mps.conv_3d_data_gradient' op requires attribute 'dilation_rates'";
      v67 = 259;
      mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
      v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v78)
      {
        v36 = __p;
        if (__p)
        {
          v37 = v77;
          v38 = __p;
          if (v77 != __p)
          {
            do
              v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
            while (v37 != v36);
            v38 = __p;
          }
          v77 = v36;
          operator delete(v38);
        }
        v31 = v74;
        if (!v74)
          goto LABEL_105;
        v39 = v75;
        v33 = v74;
        if (v75 == v74)
          goto LABEL_104;
        do
        {
          v41 = *--v39;
          v40 = v41;
          *v39 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v39 != v31);
        goto LABEL_103;
      }
    }
  }
  else
  {
    v65 = "'mps.conv_3d_data_gradient' op requires attribute 'data_layout'";
    v67 = 259;
    mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v78)
    {
      v28 = __p;
      if (__p)
      {
        v29 = v77;
        v30 = __p;
        if (v77 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v77 = v28;
        operator delete(v30);
      }
      v31 = v74;
      if (!v74)
        goto LABEL_105;
      v32 = v75;
      v33 = v74;
      if (v75 == v74)
        goto LABEL_104;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
      goto LABEL_103;
    }
  }
  return v27;
}

uint64_t *mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::getGroups(mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase *this)
{
  uint64_t v2;
  uint64_t *v3;
  unsigned int v4;
  uint64_t v5;

  v5 = *((_QWORD *)this + 6);
  mlir::IntegerAttr::getValue(&v5, (llvm::APInt *)&v3);
  if (v4 <= 0x40)
    return v3;
  v2 = *v3;
  MEMORY[0x20BD002D4]();
  return (uint64_t *)v2;
}

uint64_t llvm::SmallVector<long long,5u>::operator=(uint64_t a1, void *__src, uint64_t a3)
{
  unsigned int v6;
  unint64_t v7;

  v6 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  v7 = (8 * a3) >> 3;
  if (v7 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v7, 8);
    v6 = *(_DWORD *)(a1 + 8);
  }
  if (a3)
  {
    memcpy((void *)(*(_QWORD *)a1 + 8 * v6), __src, 8 * a3);
    v6 = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v6 + a3;
  return a1;
}

uint64_t mlir::mps::verifyConvolutionBatches(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  const void **v28[4];
  _QWORD v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  const void ***v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[3];
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v5 = 1;
  if (!a3 || !a5)
    return v5;
  if (a3 == a5)
  {
    v6 = a3 - 4;
    if (a3 != 4)
    {
      while (1)
      {
        v8 = *a2++;
        v7 = v8;
        v35 = v8;
        v10 = *a4++;
        v9 = v10;
        v34 = v10;
        v11 = v35 == 0x8000000000000000 || v9 == 0x8000000000000000;
        if (!v11 && v7 != v9)
          break;
        if (!--v6)
          return 1;
      }
      v28[0] = (const void **)"failed: input batch {0} differs from output batch {1}";
      v28[1] = (const void **)53;
      v28[2] = (const void **)v31;
      v28[3] = (const void **)2;
      v29[0] = &off_24C02E3D8;
      v29[1] = &v35;
      v30[0] = &off_24C02E3D8;
      v30[1] = &v34;
      v31[0] = v29;
      v31[1] = v30;
      v33 = 263;
      v32 = v28;
      mlir::Operation::emitOpError(a1, (const void ***)&v32, (uint64_t)v36);
      v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v36);
      if (v36[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v36);
      if (v43)
      {
        v21 = __p;
        if (__p)
        {
          v22 = v42;
          v23 = __p;
          if (v42 != __p)
          {
            do
              v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            v23 = __p;
          }
          v42 = v21;
          operator delete(v23);
        }
        v16 = v39;
        if (!v39)
          goto LABEL_45;
        v24 = v40;
        v18 = v39;
        if (v40 == v39)
        {
LABEL_44:
          v40 = v16;
          operator delete(v18);
LABEL_45:
          if (v37 != &v38)
            free(v37);
          return v5;
        }
        do
        {
          v26 = *--v24;
          v25 = v26;
          *v24 = 0;
          if (v26)
            MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
        }
        while (v24 != v16);
LABEL_43:
        v18 = v39;
        goto LABEL_44;
      }
    }
  }
  else
  {
    v28[0] = (const void **)"failed: number of batches are inconsistent between input and output";
    LOWORD(v29[0]) = 259;
    mlir::Operation::emitOpError(a1, v28, (uint64_t)v36);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v36);
    if (v36[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v36);
    if (v43)
    {
      v13 = __p;
      if (__p)
      {
        v14 = v42;
        v15 = __p;
        if (v42 != __p)
        {
          do
            v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          v15 = __p;
        }
        v42 = v13;
        operator delete(v15);
      }
      v16 = v39;
      if (!v39)
        goto LABEL_45;
      v17 = v40;
      v18 = v39;
      if (v40 == v39)
        goto LABEL_44;
      do
      {
        v20 = *--v17;
        v19 = v20;
        *v17 = 0;
        if (v20)
          MEMORY[0x20BD002D4](v19, 0x1000C8077774924);
      }
      while (v17 != v16);
      goto LABEL_43;
    }
  }
  return v5;
}

uint64_t mlir::mps::Conv3DDataGradientOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  const void **v22;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  const void **v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  _QWORD *v55;
  uint64_t v56;
  int v57;
  uint64_t *v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  _BYTE *Shape;
  uint64_t v63;
  uint64_t v64;
  _BYTE *v65;
  uint64_t v66;
  int v67;
  uint64_t DefiningOp;
  uint64_t v69;
  _QWORD *v70;
  int v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  int v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  int v90;
  void *v91;
  uint64_t *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t *v95;
  uint64_t *v96;
  _QWORD v97[2];
  _QWORD v98[2];
  _QWORD v99[2];
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _WORD v103[12];
  const void **v104[2];
  _WORD v105[24];
  const void **v106[2];
  _WORD v107[24];
  uint64_t *v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  _BYTE v112[96];
  void *v113;
  _QWORD *v114;
  void *__p;
  _QWORD *v116;
  char v117;
  void *v118[2];
  _QWORD v119[8];

  v119[6] = *MEMORY[0x24BDAC8D0];
  v118[0] = v119;
  v118[1] = (void *)0x600000000;
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v3 = *(_QWORD **)(v2 + 16);
  if (v3)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  else
    v4 = 0;
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v118, 1);
  v5 = *((unsigned int *)*this + 11);
  v6 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1) + 8];
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v7 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1) + 8];
  else
    v7 = 0;
  v8 = *(_DWORD *)(*(_QWORD *)(v7 + 32) + 8);
  if (v8 == 3)
    goto LABEL_21;
  if (v8)
    goto LABEL_35;
  v9 = *(_QWORD *)v118[0];
  if (*(_DWORD *)(*(_QWORD *)v6 + 8) == 7)
  {
    if (!v9 && !*((_QWORD *)v118[0] + 1) && !*((_QWORD *)v118[0] + 2))
    {
      v10 = 3;
      goto LABEL_20;
    }
LABEL_21:
    v106[0] = (const void **)"failed: explicit padding incompatible with with given tensor data layout.";
    v107[8] = 259;
    mlir::OpState::emitOpError(this, v106, (uint64_t)&v108);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v108);
    if (v108)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v108);
    if (v117)
    {
      v12 = __p;
      if (__p)
      {
        v13 = v116;
        v14 = __p;
        if (v116 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v116 = v12;
        operator delete(v14);
      }
      v15 = v113;
      if (v113)
      {
        v16 = v114;
        v17 = v113;
        if (v114 != v113)
        {
          do
          {
            v19 = *--v16;
            v18 = v19;
            *v16 = 0;
            if (v19)
              MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
          }
          while (v16 != v15);
          v17 = v113;
        }
        v114 = v15;
        operator delete(v17);
      }
      v22 = (const void **)v111;
      if (v111 != v112)
        goto LABEL_40;
    }
    goto LABEL_41;
  }
  if (v9 || *((_QWORD *)v118[0] + 1) || *((_QWORD *)v118[0] + 8))
    goto LABEL_21;
  v10 = 9;
LABEL_20:
  if (*((_QWORD *)v118[0] + v10))
    goto LABEL_21;
LABEL_35:
  v106[0] = (const void **)v107;
  v106[1] = (const void **)0x600000000;
  v20 = *(_QWORD **)(v7 + 40);
  if (v20)
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v20 + 8);
  else
    v21 = 0;
  mlir::getIntValues<long long>((uint64_t)v20, v21, (uint64_t)v106, 1);
  if (*v106[0] == (const void *)1)
  {
    v24 = *((unsigned int *)*this + 11);
    v25 = (uint64_t)&(*this)[2 * ((v24 >> 23) & 1)];
    v27 = *(_QWORD *)(v25 + 64);
    v26 = v25 + 64;
    v28 = 4;
    if (*(_DWORD *)(v27 + 8) == 7)
      v28 = 1;
    if (v106[0][v28] == (const void *)1)
    {
      v104[0] = (const void **)v105;
      v104[1] = (const void **)0x600000000;
      if (BYTE3(v24))
        v29 = v26;
      else
        v29 = 0;
      v30 = *(_QWORD **)(v29 + 8);
      if (v30)
        v31 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v30 + 8);
      else
        v31 = 0;
      mlir::getIntValues<long long>((uint64_t)v30, v31, (uint64_t)v104, 1);
      if (*v104[0] != (const void *)1)
        goto LABEL_81;
      v41 = *this;
      v42 = 4;
      if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8) == 7)
        v42 = 1;
      if (v104[0][v42] == (const void *)1)
      {
        v43 = v41[9];
        v44 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v44)
        {
          v45 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v44 + 8);
          v41 = *this;
          v43 = (*this)[9];
        }
        else
        {
          v45 = 0;
        }
        v99[0] = v44;
        v99[1] = v45;
        v55 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v55)
        {
          v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v55 + 8);
          v41 = *this;
        }
        else
        {
          v56 = 0;
        }
        v98[0] = v55;
        v98[1] = v56;
        v57 = *((_DWORD *)v41 + 9);
        v58 = v41 - 2;
        if (v57)
          v59 = (uint64_t)v58;
        else
          v59 = 0;
        v60 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v59, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v60)
          v61 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v60 + 8);
        else
          v61 = 0;
        v97[0] = v60;
        v97[1] = v61;
        Shape = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)v97);
        v63 = mlir::ShapedType::getShape((mlir::ShapedType *)v97);
        v65 = (_BYTE *)(v63 + 8 * v64);
        v108 = &v110;
        v109 = 0x500000000;
        v66 = v65 - Shape;
        if ((unint64_t)(v65 - Shape) < 0x29)
        {
          v67 = 0;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, &v110, v66 >> 3, 8);
          v67 = v109;
        }
        if (v65 != Shape)
        {
          memcpy(&v108[v67], Shape, v65 - Shape);
          v67 = v109;
        }
        LODWORD(v109) = v67 + ((unint64_t)v66 >> 3);
        if (*((_DWORD *)*this + 17) != 2)
        {
          if (*(_QWORD *)((*this)[9] + 88))
          {
            v100 = *(_QWORD *)((*this)[9] + 88);
            DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v100);
            if (DefiningOp)
            {
              v69 = DefiningOp;
              if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
              {
                v101 = v103;
                v102 = 0x100000000;
                mlir::Operation::fold(v69, 0, 0, (uint64_t)&v101);
                v70 = (_QWORD *)(*(_QWORD *)v101 & 0xFFFFFFFFFFFFFFF8);
                v71 = mlir::DenseIntElementsAttr::classof((uint64_t)v70) & (v70 != 0);
                if (!v71)
                  v70 = 0;
                if (v101 != v103)
                  free(v101);
                if ((v71 & 1) != 0)
                {
                  LODWORD(v109) = 0;
                  if (v70)
                    v72 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v70 + 8);
                  else
                    v72 = 0;
                  mlir::getIntValues<long long>((uint64_t)v70, v72, (uint64_t)&v108, 1);
                }
              }
            }
          }
        }
        v73 = *this;
        v95 = v108;
        v74 = v109;
        v75 = *(_DWORD *)(v73[2 * (((unint64_t)*((unsigned int *)v73 + 11) >> 23) & 1) + 8] + 8);
        v76 = mlir::ShapedType::getShape((mlir::ShapedType *)v98);
        v78 = v77;
        v79 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
        if (!HIBYTE(*((_DWORD *)*this + 11)))
          v79 = 0;
        v80 = *(_DWORD *)(*(_QWORD *)(v79 + 48) + 8);
        v100 = *(_QWORD *)(v79 + 24);
        mlir::IntegerAttr::getValue(&v100, (llvm::APInt *)&v101);
        if (v102 > 0x40)
        {
          v81 = *(void **)v101;
          MEMORY[0x20BD002D4]();
        }
        else
        {
          v81 = v101;
        }
        if (!mlir::mps::verifyConvolutionInputChannels(v73, (uint64_t)v95, v74, v75, v76, v78, v80, (uint64_t)v81))goto LABEL_142;
        v96 = *this;
        v82 = mlir::ShapedType::getShape((mlir::ShapedType *)v99);
        v84 = v83;
        v85 = *(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8);
        v86 = mlir::ShapedType::getShape((mlir::ShapedType *)v98);
        v88 = v87;
        v89 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
        if (!HIBYTE(*((_DWORD *)*this + 11)))
          v89 = 0;
        v90 = *(_DWORD *)(*(_QWORD *)(v89 + 48) + 8);
        v100 = *(_QWORD *)(v89 + 24);
        mlir::IntegerAttr::getValue(&v100, (llvm::APInt *)&v101);
        if (v102 > 0x40)
        {
          v91 = *(void **)v101;
          MEMORY[0x20BD002D4]();
        }
        else
        {
          v91 = v101;
        }
        if (mlir::mps::verifyConvolutionOutputChannels(v96, v82, v84, v85, v86, v88, v90, (unint64_t)v91))
        {
          v92 = *this;
          v93 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v99);
          v11 = mlir::mps::verifyConvolutionBatches(v92, v93, v94, v108, v109);
        }
        else
        {
LABEL_142:
          v11 = 0;
        }
        v54 = v108;
        if (v108 == &v110)
          goto LABEL_99;
      }
      else
      {
LABEL_81:
        v101 = "failed: dilation values incompatible with given tensor layout.";
        v103[8] = 259;
        mlir::OpState::emitOpError(this, (const void ***)&v101, (uint64_t)&v108);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v108);
        if (v108)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v108);
        if (!v117)
          goto LABEL_99;
        v46 = __p;
        if (__p)
        {
          v47 = v116;
          v48 = __p;
          if (v116 != __p)
          {
            do
              v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
            while (v47 != v46);
            v48 = __p;
          }
          v116 = v46;
          operator delete(v48);
        }
        v49 = v113;
        if (v113)
        {
          v50 = v114;
          v51 = v113;
          if (v114 != v113)
          {
            do
            {
              v53 = *--v50;
              v52 = v53;
              *v50 = 0;
              if (v53)
                MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
            }
            while (v50 != v49);
            v51 = v113;
          }
          v114 = v49;
          operator delete(v51);
        }
        v54 = (uint64_t *)v111;
        if (v111 == v112)
        {
LABEL_99:
          v40 = v104[0];
          if ((_WORD *)v104[0] == v105)
            goto LABEL_72;
LABEL_71:
          free(v40);
          goto LABEL_72;
        }
      }
      free(v54);
      goto LABEL_99;
    }
  }
  v104[0] = (const void **)"failed: strides incompatible with given tensor data layout.";
  v105[8] = 259;
  mlir::OpState::emitOpError(this, v104, (uint64_t)&v108);
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v108);
  if (v108)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v108);
  if (v117)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v116;
      v34 = __p;
      if (v116 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v116 = v32;
      operator delete(v34);
    }
    v35 = v113;
    if (v113)
    {
      v36 = v114;
      v37 = v113;
      if (v114 != v113)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v113;
      }
      v114 = v35;
      operator delete(v37);
    }
    v40 = (const void **)v111;
    if (v111 != v112)
      goto LABEL_71;
  }
LABEL_72:
  v22 = v106[0];
  if ((_WORD *)v106[0] != v107)
LABEL_40:
    free(v22);
LABEL_41:
  if (v118[0] != v119)
    free(v118[0]);
  return v11;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t Context;
  uint64_t v19;
  uint64_t v20;
  uint64_t DefiningOp;
  uint64_t v22;
  uint64_t v23;
  char v24;
  _QWORD *v25;
  char v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  unint64_t v32;
  int64x2_t *v33;
  int64x2_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int32x2_t v40;
  int32x2_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  _BYTE v47[40];
  unint64_t v48[2];
  uint64_t v49;
  char v50[8];
  char v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  unint64_t v59;
  _QWORD v60[3];

  v60[2] = *MEMORY[0x24BDAC8D0];
  v60[0] = a4;
  v60[1] = a5;
  if (a7)
  {
    v14 = *a7;
    v15 = a7[1];
    v16 = a7[2];
    v17 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v17 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
  }
  v49 = a6;
  v50[0] = 0;
  v51 = 0;
  v52 = v14;
  v53 = v15;
  v54 = v16;
  v55 = v17;
  v56 = a9;
  v57 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v49);
    if (v51)
      v51 = 0;
    mlir::OperationName::OperationName(v50, "mps.conv_3d_weights_gradient", 28, Context);
    v51 = 1;
  }
  v58 = a4;
  v59 = a5;
  if (a5 < 3
    || (v19 = mlir::UnknownLoc::get(this, a2),
        !mlir::mps::Conv3DWeightsGradientOpAdaptor::verify(&v49, v19)))
  {
    v36 = mlir::Float32Type::get(this, a2);
    v37 = mlir::UnrankedTensorType::get(v36);
    v38 = *(unsigned int *)(a11 + 8);
    if (v38 >= *(_DWORD *)(a11 + 12))
    {
LABEL_35:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v38 + 1, 8);
      LODWORD(v38) = *(_DWORD *)(a11 + 8);
    }
LABEL_22:
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v38) = v37;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  v45 = (void *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v46 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v60, 1) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v48, (uint64_t)&v45, 2uLL);
  v45 = v58;
  v46 = 2;
  v45 = (void *)mlir::ValueRange::offset_base(&v45, 2);
  v46 = 0;
  v44 = mlir::ValueRange::dereference_iterator(&v45, 0);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v44);
  if (!DefiningOp)
    goto LABEL_34;
  v22 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    goto LABEL_34;
  v45 = v47;
  v46 = 0x100000000;
  mlir::Operation::fold(v22, 0, 0, (uint64_t)&v45);
  v23 = *(_QWORD *)v45;
  v24 = mlir::DenseIntElementsAttr::classof(*(_QWORD *)v45 & 0xFFFFFFFFFFFFFFF8);
  v25 = (_QWORD *)(v23 & 0xFFFFFFFFFFFFFFF8);
  if (v25)
    v26 = v24;
  else
    v26 = 0;
  if (v45 != v47)
    free(v45);
  if ((v26 & 1) == 0)
  {
LABEL_34:
    v37 = mlir::UnrankedTensorType::get(v20);
    v38 = *(unsigned int *)(a11 + 8);
    if (v38 >= *(_DWORD *)(a11 + 12))
      goto LABEL_35;
    goto LABEL_22;
  }
  v45 = v47;
  v46 = 0x500000000;
  v27 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v25 + 8);
  mlir::getIntValues<long long>((uint64_t)v25, v27, (uint64_t)&v45, 1);
  v28 = (char *)v45;
  v29 = v46;
  if (!(_DWORD)v46)
    goto LABEL_37;
  v30 = (v46 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  v31 = (char *)v45;
  if (v30 >= 3)
  {
    v32 = v30 + 1;
    v31 = (char *)v45 + 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
    v33 = (int64x2_t *)((char *)v45 + 16);
    v34.i64[0] = -1;
    v34.i64[1] = -1;
    v35 = v32 & 0x3FFFFFFFFFFFFFFCLL;
    while (1)
    {
      v40 = vmovn_s64(vceqq_s64(v33[-1], v34));
      if ((v40.i8[0] & 1) != 0)
      {
        v33[-1].i64[0] = 0x8000000000000000;
        if ((v40.i8[4] & 1) == 0)
        {
LABEL_27:
          v41 = vmovn_s64(vceqq_s64(*v33, v34));
          if ((v41.i8[0] & 1) == 0)
            goto LABEL_28;
          goto LABEL_32;
        }
      }
      else if ((v40.i8[4] & 1) == 0)
      {
        goto LABEL_27;
      }
      v33[-1].i64[1] = 0x8000000000000000;
      v41 = vmovn_s64(vceqq_s64(*v33, v34));
      if ((v41.i8[0] & 1) == 0)
      {
LABEL_28:
        if ((v41.i8[4] & 1) != 0)
          goto LABEL_33;
        goto LABEL_24;
      }
LABEL_32:
      v33->i64[0] = 0x8000000000000000;
      if ((v41.i8[4] & 1) != 0)
LABEL_33:
        v33->i64[1] = 0x8000000000000000;
LABEL_24:
      v33 += 2;
      v35 -= 4;
      if (!v35)
      {
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_37;
        goto LABEL_43;
      }
    }
  }
  do
  {
LABEL_43:
    if (*(_QWORD *)v31 == -1)
      *(_QWORD *)v31 = 0x8000000000000000;
    v31 += 8;
  }
  while (v31 != &v28[8 * v29]);
LABEL_37:
  v42 = mlir::RankedTensorType::get((uint64_t)v28, v29, v20, 0);
  v43 = *(unsigned int *)(a11 + 8);
  if (v43 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v43 + 1, 8);
    LODWORD(v43) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v43) = v42;
  ++*(_DWORD *)(a11 + 8);
  if (v45 != v47)
    free(v45);
  return 1;
}

uint64_t mlir::mps::Conv3DWeightsGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *Type;
  _QWORD *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  const char *v62;
  uint64_t v63;
  const char *OperandRange;
  const char *v65;
  uint64_t v66;
  __int16 v67;
  _QWORD v68[2];
  __int128 v69;
  uint64_t Value;
  _QWORD *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD *v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v3 = a1[3];
  if (v3)
  {
    v4 = (const char *)a1[4];
    if (v4)
    {
      v5 = (const char *)a1[5];
      if (v5)
      {
        if (a1[6])
        {
          if (a1[7])
          {
            v6 = (const char *)a1[8];
            if (v6)
            {
              v7 = a1[9];
              if (v7)
              {
                v65 = (const char *)a1[6];
                Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v65);
                if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
                {
                  v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
                  v65 = v6;
                  v66 = v8;
                  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                  v10 = Type;
                  if (Type)
                    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
                  Value = (uint64_t)v10;
                  v71 = Type;
                  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                  v68[0] = 5;
                  if (v12 == 1
                    && *Shape == v68[0]
                    && (OperandRange = v6,
                        llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                    && (v62 = v6,
                        *(_QWORD *)&v69 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                        *((_QWORD *)&v69 + 1) = v13,
                        v63 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69),
                        mlir::Type::isUnsignedInteger((mlir::Type *)&v63, 64)))
                  {
                    v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                    v65 = v4;
                    v66 = v14;
                    v15 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                    v16 = v15;
                    if (v15)
                      v15 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
                    Value = (uint64_t)v16;
                    v71 = v15;
                    v17 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                    v68[0] = 5;
                    if (v18 == 1
                      && *v17 == v68[0]
                      && (OperandRange = v4,
                          llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                      && (v62 = v4,
                          *(_QWORD *)&v69 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                          *((_QWORD *)&v69 + 1) = v19,
                          v63 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69),
                          mlir::Type::isUnsignedInteger((mlir::Type *)&v63, 64)))
                    {
                      v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                      v65 = v5;
                      v66 = v20;
                      v21 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v65);
                      v22 = v21;
                      if (v21)
                        v21 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
                      Value = (uint64_t)v22;
                      v71 = v21;
                      v23 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
                      v69 = xmmword_207AB5440;
                      if (v24 == 2
                        && (*v23 == (_QWORD)v69 ? (v25 = v23[1] == *((_QWORD *)&v69 + 1)) : (v25 = 0),
                            v25
                         && (v63 = (uint64_t)v5,
                             v68[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63),
                             v68[1] = v26,
                             OperandRange = (const char *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68),
                             mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))))
                      {
                        if ((*(_DWORD *)(v3 + 8) - 7) >= 2)
                        {
                          v61 = "'mps.conv_3d_weights_gradient' op attribute 'data_layout' failed to satisfy constraint: "
                                "valid TensorDataLayout is one of NDHWC or NCDHW";
                        }
                        else
                        {
                          if ((*(_DWORD *)(v7 + 8) - 9) < 2)
                            return 1;
                          v61 = "'mps.conv_3d_weights_gradient' op attribute 'weights_layout' failed to satisfy constrain"
                                "t: valid TensorDataLayout is one of DHWIO or OIDHW";
                        }
                      }
                      else
                      {
                        v61 = "'mps.conv_3d_weights_gradient' op attribute 'explicit_padding' failed to satisfy constrain"
                              "t: ui64 elements attribute of shape {5, 2}";
                      }
                    }
                    else
                    {
                      v61 = "'mps.conv_3d_weights_gradient' op attribute 'dilation_rates' failed to satisfy constraint: p"
                            "ositive ui64 elements attribute of shape {5}";
                    }
                  }
                  else
                  {
                    v61 = "'mps.conv_3d_weights_gradient' op attribute 'strides' failed to satisfy constraint: positive u"
                          "i64 elements attribute of shape {5}";
                  }
                }
                else
                {
                  v61 = "'mps.conv_3d_weights_gradient' op attribute 'groups' failed to satisfy constraint: 64-bit unsign"
                        "ed integer attribute";
                }
              }
              else
              {
                v61 = "'mps.conv_3d_weights_gradient' op requires attribute 'weights_layout'";
              }
            }
            else
            {
              v61 = "'mps.conv_3d_weights_gradient' op requires attribute 'strides'";
            }
            v65 = v61;
            v67 = 259;
            mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
            v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
            return v27;
          }
          v65 = "'mps.conv_3d_weights_gradient' op requires attribute 'padding_style'";
          v67 = 259;
          mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
          v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v78)
          {
            v54 = __p;
            if (__p)
            {
              v55 = v77;
              v56 = __p;
              if (v77 != __p)
              {
                do
                  v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
                while (v55 != v54);
                v56 = __p;
              }
              v77 = v54;
              operator delete(v56);
            }
            v31 = v74;
            if (!v74)
              goto LABEL_105;
            v57 = v75;
            v33 = v74;
            if (v75 == v74)
            {
LABEL_104:
              v75 = v31;
              operator delete(v33);
LABEL_105:
              if (v72 != &v73)
                free(v72);
              return v27;
            }
            do
            {
              v59 = *--v57;
              v58 = v59;
              *v57 = 0;
              if (v59)
                MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
            }
            while (v57 != v31);
LABEL_103:
            v33 = v74;
            goto LABEL_104;
          }
        }
        else
        {
          v65 = "'mps.conv_3d_weights_gradient' op requires attribute 'groups'";
          v67 = 259;
          mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
          v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v78)
          {
            v48 = __p;
            if (__p)
            {
              v49 = v77;
              v50 = __p;
              if (v77 != __p)
              {
                do
                  v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
                while (v49 != v48);
                v50 = __p;
              }
              v77 = v48;
              operator delete(v50);
            }
            v31 = v74;
            if (!v74)
              goto LABEL_105;
            v51 = v75;
            v33 = v74;
            if (v75 == v74)
              goto LABEL_104;
            do
            {
              v53 = *--v51;
              v52 = v53;
              *v51 = 0;
              if (v53)
                MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
            }
            while (v51 != v31);
            goto LABEL_103;
          }
        }
      }
      else
      {
        v65 = "'mps.conv_3d_weights_gradient' op requires attribute 'explicit_padding'";
        v67 = 259;
        mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
        v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v78)
        {
          v42 = __p;
          if (__p)
          {
            v43 = v77;
            v44 = __p;
            if (v77 != __p)
            {
              do
                v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
              while (v43 != v42);
              v44 = __p;
            }
            v77 = v42;
            operator delete(v44);
          }
          v31 = v74;
          if (!v74)
            goto LABEL_105;
          v45 = v75;
          v33 = v74;
          if (v75 == v74)
            goto LABEL_104;
          do
          {
            v47 = *--v45;
            v46 = v47;
            *v45 = 0;
            if (v47)
              MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
          }
          while (v45 != v31);
          goto LABEL_103;
        }
      }
    }
    else
    {
      v65 = "'mps.conv_3d_weights_gradient' op requires attribute 'dilation_rates'";
      v67 = 259;
      mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
      v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v78)
      {
        v36 = __p;
        if (__p)
        {
          v37 = v77;
          v38 = __p;
          if (v77 != __p)
          {
            do
              v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
            while (v37 != v36);
            v38 = __p;
          }
          v77 = v36;
          operator delete(v38);
        }
        v31 = v74;
        if (!v74)
          goto LABEL_105;
        v39 = v75;
        v33 = v74;
        if (v75 == v74)
          goto LABEL_104;
        do
        {
          v41 = *--v39;
          v40 = v41;
          *v39 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v39 != v31);
        goto LABEL_103;
      }
    }
  }
  else
  {
    v65 = "'mps.conv_3d_weights_gradient' op requires attribute 'data_layout'";
    v67 = 259;
    mlir::emitError(a2, (uint64_t)&v65, (uint64_t)&Value);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v78)
    {
      v28 = __p;
      if (__p)
      {
        v29 = v77;
        v30 = __p;
        if (v77 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v77 = v28;
        operator delete(v30);
      }
      v31 = v74;
      if (!v74)
        goto LABEL_105;
      v32 = v75;
      v33 = v74;
      if (v75 == v74)
        goto LABEL_104;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
      goto LABEL_103;
    }
  }
  return v27;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  const void **v22;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  const void **v40;
  uint64_t *v41;
  uint64_t v42;
  int v43;
  uint64_t *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  _QWORD *v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  _BYTE *Shape;
  uint64_t v58;
  uint64_t v59;
  _BYTE *v60;
  uint64_t v61;
  int v62;
  uint64_t DefiningOp;
  uint64_t v64;
  _QWORD *v65;
  int v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  void *v94;
  uint64_t *v95;
  uint64_t *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;
  _QWORD v103[2];
  _QWORD v104[2];
  _QWORD v105[2];
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[12];
  const void **v110[2];
  _WORD v111[24];
  const void **v112[2];
  _WORD v113[24];
  uint64_t *v114;
  uint64_t v115;
  uint64_t v116;
  void *v117;
  _BYTE v118[96];
  void *v119;
  _QWORD *v120;
  void *__p;
  _QWORD *v122;
  char v123;
  void *v124[2];
  _QWORD v125[8];

  v125[6] = *MEMORY[0x24BDAC8D0];
  v124[0] = v125;
  v124[1] = (void *)0x600000000;
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v3 = *(_QWORD **)(v2 + 16);
  if (v3)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  else
    v4 = 0;
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v124, 1);
  v5 = *((unsigned int *)*this + 11);
  v6 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1) + 8];
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v7 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1) + 8];
  else
    v7 = 0;
  v8 = *(_DWORD *)(*(_QWORD *)(v7 + 32) + 8);
  if (v8 == 3)
    goto LABEL_21;
  if (v8)
    goto LABEL_35;
  v9 = *(_QWORD *)v124[0];
  if (*(_DWORD *)(*(_QWORD *)v6 + 8) == 7)
  {
    if (!v9 && !*((_QWORD *)v124[0] + 1) && !*((_QWORD *)v124[0] + 2))
    {
      v10 = 3;
      goto LABEL_20;
    }
LABEL_21:
    v112[0] = (const void **)"failed: explicit padding incompatible with with given tensor data layout.";
    v113[8] = 259;
    mlir::OpState::emitOpError(this, v112, (uint64_t)&v114);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v114);
    if (v114)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v114);
    if (v123)
    {
      v12 = __p;
      if (__p)
      {
        v13 = v122;
        v14 = __p;
        if (v122 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v122 = v12;
        operator delete(v14);
      }
      v15 = v119;
      if (v119)
      {
        v16 = v120;
        v17 = v119;
        if (v120 != v119)
        {
          do
          {
            v19 = *--v16;
            v18 = v19;
            *v16 = 0;
            if (v19)
              MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
          }
          while (v16 != v15);
          v17 = v119;
        }
        v120 = v15;
        operator delete(v17);
      }
      v22 = (const void **)v117;
      if (v117 != v118)
        goto LABEL_40;
    }
    goto LABEL_41;
  }
  if (v9 || *((_QWORD *)v124[0] + 1) || *((_QWORD *)v124[0] + 8))
    goto LABEL_21;
  v10 = 9;
LABEL_20:
  if (*((_QWORD *)v124[0] + v10))
    goto LABEL_21;
LABEL_35:
  v112[0] = (const void **)v113;
  v112[1] = (const void **)0x600000000;
  v20 = *(_QWORD **)(v7 + 40);
  if (v20)
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v20 + 8);
  else
    v21 = 0;
  mlir::getIntValues<long long>((uint64_t)v20, v21, (uint64_t)v112, 1);
  if (*v112[0] == (const void *)1)
  {
    v24 = *((unsigned int *)*this + 11);
    v25 = (uint64_t)&(*this)[2 * ((v24 >> 23) & 1)];
    v27 = *(_QWORD *)(v25 + 64);
    v26 = v25 + 64;
    v28 = 4;
    if (*(_DWORD *)(v27 + 8) == 7)
      v28 = 1;
    if (v112[0][v28] == (const void *)1)
    {
      v110[0] = (const void **)v111;
      v110[1] = (const void **)0x600000000;
      if (BYTE3(v24))
        v29 = v26;
      else
        v29 = 0;
      v30 = *(_QWORD **)(v29 + 8);
      if (v30)
        v31 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v30 + 8);
      else
        v31 = 0;
      mlir::getIntValues<long long>((uint64_t)v30, v31, (uint64_t)v110, 1);
      if (*v110[0] != (const void *)1)
        goto LABEL_84;
      v41 = *this;
      v42 = 4;
      if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8) == 7)
        v42 = 1;
      if (v110[0][v42] == (const void *)1)
      {
        v43 = *((_DWORD *)v41 + 9);
        v44 = v41 - 2;
        if (v43)
          v45 = (uint64_t)v44;
        else
          v45 = 0;
        v46 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v45, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v46)
          v47 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v46 + 8);
        else
          v47 = 0;
        v105[0] = v46;
        v105[1] = v47;
        Shape = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)v105);
        v58 = mlir::ShapedType::getShape((mlir::ShapedType *)v105);
        v60 = (_BYTE *)(v58 + 8 * v59);
        v114 = &v116;
        v115 = 0x500000000;
        v61 = v60 - Shape;
        if ((unint64_t)(v60 - Shape) < 0x29)
        {
          v62 = 0;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, &v116, v61 >> 3, 8);
          v62 = v115;
        }
        if (v60 != Shape)
        {
          memcpy(&v114[v62], Shape, v60 - Shape);
          v62 = v115;
        }
        LODWORD(v115) = v62 + ((unint64_t)v61 >> 3);
        v104[0] = *(_QWORD *)((*this)[9] + 88);
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v104);
        if (DefiningOp)
        {
          v64 = DefiningOp;
          if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
          {
            v107 = v109;
            v108 = 0x100000000;
            mlir::Operation::fold(v64, 0, 0, (uint64_t)&v107);
            v65 = (_QWORD *)(*(_QWORD *)v107 & 0xFFFFFFFFFFFFFFF8);
            v66 = mlir::DenseIntElementsAttr::classof((uint64_t)v65) & (v65 != 0);
            if (!v66)
              v65 = 0;
            if (v107 != v109)
              free(v107);
            if ((v66 & 1) != 0)
            {
              LODWORD(v115) = 0;
              if (v65)
                v67 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v65 + 8);
              else
                v67 = 0;
              mlir::getIntValues<long long>((uint64_t)v65, v67, (uint64_t)&v114, 1);
            }
          }
        }
        v68 = *this;
        v69 = (*this)[9];
        v70 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v69 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v70)
        {
          v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8);
          v68 = *this;
          v69 = (*this)[9];
        }
        else
        {
          v71 = 0;
        }
        v104[0] = v70;
        v104[1] = v71;
        v72 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v69 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (v72)
        {
          v73 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v72 + 8);
          v68 = *this;
        }
        else
        {
          v73 = 0;
        }
        v103[0] = v72;
        v103[1] = v73;
        v74 = mlir::ShapedType::getShape((mlir::ShapedType *)v104);
        v101 = v75;
        v76 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)];
        v78 = *(_QWORD *)(v76 + 64);
        v77 = v76 + 64;
        v79 = *(_DWORD *)(v78 + 8);
        v80 = (uint64_t)v114;
        v81 = v115;
        if (!HIBYTE(*((_DWORD *)*this + 11)))
          v77 = 0;
        v82 = *(_DWORD *)(*(_QWORD *)(v77 + 48) + 8);
        v106 = *(_QWORD *)(v77 + 24);
        mlir::IntegerAttr::getValue(&v106, (llvm::APInt *)&v107);
        if (v108 > 0x40)
        {
          v83 = *(void **)v107;
          MEMORY[0x20BD002D4]();
        }
        else
        {
          v83 = v107;
        }
        if (!mlir::mps::verifyConvolutionOutputChannels(v68, v74, v101, v79, v80, v81, v82, (unint64_t)v83))goto LABEL_140;
        v102 = *this;
        v84 = mlir::ShapedType::getShape((mlir::ShapedType *)v103);
        v86 = v85;
        v87 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)];
        v89 = *(_QWORD *)(v87 + 64);
        v88 = v87 + 64;
        v90 = *(_DWORD *)(v89 + 8);
        v91 = (uint64_t)v114;
        v92 = v115;
        if (!HIBYTE(*((_DWORD *)*this + 11)))
          v88 = 0;
        v93 = *(_DWORD *)(*(_QWORD *)(v88 + 48) + 8);
        v106 = *(_QWORD *)(v88 + 24);
        mlir::IntegerAttr::getValue(&v106, (llvm::APInt *)&v107);
        if (v108 > 0x40)
        {
          v94 = *(void **)v107;
          MEMORY[0x20BD002D4]();
        }
        else
        {
          v94 = v107;
        }
        if (mlir::mps::verifyConvolutionInputChannels(v102, v84, v86, v90, v91, v92, v93, (uint64_t)v94))
        {
          v95 = *this;
          v96 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v103);
          v98 = v97;
          v99 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v104);
          v11 = mlir::mps::verifyConvolutionBatches(v95, v96, v98, v99, v100);
        }
        else
        {
LABEL_140:
          v11 = 0;
        }
        v56 = v114;
        if (v114 == &v116)
          goto LABEL_102;
      }
      else
      {
LABEL_84:
        v107 = "failed: dilation values incompatible with given tensor layout.";
        v109[8] = 259;
        mlir::OpState::emitOpError(this, (const void ***)&v107, (uint64_t)&v114);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v114);
        if (v114)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v114);
        if (!v123)
          goto LABEL_102;
        v48 = __p;
        if (__p)
        {
          v49 = v122;
          v50 = __p;
          if (v122 != __p)
          {
            do
              v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
            while (v49 != v48);
            v50 = __p;
          }
          v122 = v48;
          operator delete(v50);
        }
        v51 = v119;
        if (v119)
        {
          v52 = v120;
          v53 = v119;
          if (v120 != v119)
          {
            do
            {
              v55 = *--v52;
              v54 = v55;
              *v52 = 0;
              if (v55)
                MEMORY[0x20BD002D4](v54, 0x1000C8077774924);
            }
            while (v52 != v51);
            v53 = v119;
          }
          v120 = v51;
          operator delete(v53);
        }
        v56 = v117;
        if (v117 == v118)
        {
LABEL_102:
          v40 = v110[0];
          if ((_WORD *)v110[0] == v111)
            goto LABEL_72;
LABEL_71:
          free(v40);
          goto LABEL_72;
        }
      }
      free(v56);
      goto LABEL_102;
    }
  }
  v110[0] = (const void **)"failed: strides incompatible with given tensor data layout.";
  v111[8] = 259;
  mlir::OpState::emitOpError(this, v110, (uint64_t)&v114);
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v114);
  if (v114)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v114);
  if (v123)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v122;
      v34 = __p;
      if (v122 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v122 = v32;
      operator delete(v34);
    }
    v35 = v119;
    if (v119)
    {
      v36 = v120;
      v37 = v119;
      if (v120 != v119)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v119;
      }
      v120 = v35;
      operator delete(v37);
    }
    v40 = (const void **)v117;
    if (v117 != v118)
      goto LABEL_71;
  }
LABEL_72:
  v22 = v112[0];
  if ((_WORD *)v112[0] != v113)
LABEL_40:
    free(v22);
LABEL_41:
  if (v124[0] != v125)
    free(v124[0]);
  return v11;
}

uint64_t mlir::mps::DepthwiseConv2DOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  uint64_t Context;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  _OWORD v67[8];
  uint64_t v68;
  unint64_t v69;
  void *v70;
  uint64_t v71;
  _BYTE v72[32];
  void *v73;
  uint64_t v74;
  _BYTE v75[32];
  void *v76;
  uint64_t v77;
  _BYTE v78[32];
  uint64_t v79;
  char v80[8];
  char v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v89 = a4;
  v90 = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
  }
  else
  {
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
  }
  v79 = a6;
  v80[0] = 0;
  v81 = 0;
  v82 = v16;
  v83 = v17;
  v84 = v18;
  v19 = a5;
  v85 = a9;
  v86 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v79);
    if (v81)
      v81 = 0;
    mlir::OperationName::OperationName(v80, "mps.depthwise_conv_2d", 21, Context);
    v81 = 1;
    v19 = v90;
  }
  v87 = a4;
  v88 = a5;
  if (v19 < 2
    || (v21 = mlir::UnknownLoc::get(this, a2), !mlir::mps::DepthwiseConv2DOpAdaptor::verify(&v79, v21)))
  {
    v32 = mlir::Float32Type::get(this, a2);
    v33 = mlir::UnrankedTensorType::get(v32);
    v34 = *(unsigned int *)(a11 + 8);
    if (v34 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v34 + 1, 8);
      LODWORD(v34) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v34) = v33;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  v22 = v83;
  v23 = v82;
  v24 = v84;
  v25 = mlir::ValueRange::dereference_iterator(&v89, 0);
  v26 = mlir::ValueRange::dereference_iterator(&v89, 1);
  v27 = *(_QWORD *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v27 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v27 = 0;
  v69 = v27;
  if (v27)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
    if (v28 != 4)
      return mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "DepthwiseConv2DOp input should be rank 4");
  }
  v76 = v78;
  v77 = 0x400000000;
  v73 = v75;
  v74 = 0x400000000;
  v70 = v72;
  v71 = 0x400000000;
  if ((_QWORD)v24)
  {
    v29 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v24 + 8);
    mlir::getIntValues<long long>(v24, v29, (uint64_t)&v76, 1);
    if (*((_QWORD *)&v23 + 1))
      goto LABEL_16;
LABEL_24:
    mlir::getIntValues<long long>(*((uint64_t *)&v23 + 1), 0, (uint64_t)&v73, 1);
    if ((_QWORD)v22)
      goto LABEL_17;
LABEL_25:
    v31 = 0;
    goto LABEL_26;
  }
  mlir::getIntValues<long long>(0, 0, (uint64_t)&v76, 1);
  if (!*((_QWORD *)&v23 + 1))
    goto LABEL_24;
LABEL_16:
  v30 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v23 + 1) + 8);
  mlir::getIntValues<long long>(*((uint64_t *)&v23 + 1), v30, (uint64_t)&v73, 1);
  if (!(_QWORD)v22)
    goto LABEL_25;
LABEL_17:
  v31 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v22 + 8);
LABEL_26:
  mlir::getIntValues<long long>(v22, v31, (uint64_t)&v70, 1);
  v37 = *(_DWORD *)(v23 + 8);
  if (v37 != 1)
  {
    if (v37)
    {
      v47 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "Unsupported dataLayout");
      goto LABEL_92;
    }
    if ((_DWORD)v77)
    {
      v38 = 0;
      v39 = 0;
      v40 = 0;
      v41 = 8 * v77;
      while (2)
      {
        v42 = *((_QWORD *)v76 + v38);
        switch((int)v38)
        {
          case 0:
            v43 = v42 == 1;
            v42 = v39;
            if (v43)
              goto LABEL_31;
            v65 = "stride != 1 not supported for dim 3 of NCHW";
            goto LABEL_91;
          case 1:
            v43 = v42 == 1;
            v42 = v39;
            if (v43)
              goto LABEL_31;
            v65 = "stride != 1 not supported for dim 2 of NCHW";
            goto LABEL_91;
          case 2:
            goto LABEL_31;
          case 3:
            v40 = *((_QWORD *)v76 + v38);
            v42 = v39;
LABEL_31:
            ++v38;
            v39 = v42;
            v41 -= 8;
            if (v41)
              continue;
            goto LABEL_48;
          default:
            v65 = "stride attr num dimensions should be <= 4";
            goto LABEL_91;
        }
      }
    }
    v40 = 0;
    v42 = 0;
LABEL_48:
    if ((_DWORD)v74)
    {
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 8 * v74;
      while (2)
      {
        v52 = *((_QWORD *)v73 + v48);
        switch((int)v48)
        {
          case 0:
            v43 = v52 == 1;
            v52 = v49;
            if (!v43)
              goto LABEL_88;
            goto LABEL_51;
          case 1:
            v43 = v52 == 1;
            v52 = v49;
            if (v43)
              goto LABEL_51;
            v65 = "dilationRate != 1 not supported for dim 2";
            goto LABEL_91;
          case 2:
            goto LABEL_51;
          case 3:
            v50 = *((_QWORD *)v73 + v48);
            v52 = v49;
LABEL_51:
            ++v48;
            v49 = v52;
            v51 -= 8;
            if (v51)
              continue;
            goto LABEL_68;
          default:
            goto LABEL_87;
        }
      }
    }
    v50 = 0;
    v52 = 0;
LABEL_68:
    if ((_DWORD)v71)
    {
      v56 = 0;
      v57 = 0;
      v58 = 0;
      v59 = 0;
      v60 = 8 * v71;
      do
      {
        switch((int)v56)
        {
          case 4:
            v58 = *((_QWORD *)v70 + v56);
            break;
          case 5:
            v59 = *((_QWORD *)v70 + v56);
            break;
          case 7:
            v57 = *((_QWORD *)v70 + v56);
            break;
          default:
            break;
        }
        ++v56;
        v60 -= 8;
      }
      while (v60);
      goto LABEL_84;
    }
LABEL_83:
    v59 = 0;
    v58 = 0;
    v57 = 0;
LABEL_84:
    v68 = 0;
    memset(v67, 0, sizeof(v67));
    mlir::mps::buildConv2DDescriptor(v25, v26, 1, v40, v42, v50, v52, (uint64_t)v67, v57, v58, v59, *(_DWORD *)(*((_QWORD *)&v22 + 1) + 8), v37, *(_DWORD *)(*((_QWORD *)&v24 + 1) + 8), 0, 0, 0, 1);
    v66 = 0;
    v63 = (void *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v89, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    v64 = mlir::ValueRange::dereference_iterator(&v89, 1);
    {
      llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v66);
      v35 = 1;
    }
    else
    {
      v35 = 0;
    }
    goto LABEL_93;
  }
  if ((_DWORD)v77)
  {
    v44 = 0;
    v45 = 0;
    v40 = 0;
    v46 = 8 * v77;
    while (2)
    {
      v42 = *((_QWORD *)v76 + v44);
      switch((int)v44)
      {
        case 0:
          v43 = v42 == 1;
          v42 = v45;
          if (v43)
            goto LABEL_40;
          v65 = "stride != 1 not supported for dim 3";
          goto LABEL_91;
        case 1:
          goto LABEL_40;
        case 2:
          v40 = *((_QWORD *)v76 + v44);
          v42 = v45;
          goto LABEL_40;
        case 3:
          v43 = v42 == 1;
          v42 = v45;
          if (!v43)
          {
            v65 = "stride != 1 not supported for dim 0";
            goto LABEL_91;
          }
LABEL_40:
          ++v44;
          v45 = v42;
          v46 -= 8;
          if (v46)
            continue;
          goto LABEL_58;
        default:
          v47 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "stride num dimensions should be <= 4");
          goto LABEL_92;
      }
    }
  }
  v40 = 0;
  v42 = 0;
LABEL_58:
  if (!(_DWORD)v74)
  {
    v50 = 0;
    v52 = 0;
LABEL_76:
    if ((_DWORD)v71)
    {
      v61 = 0;
      v57 = 0;
      v58 = 0;
      v59 = 0;
      v62 = 8 * v71;
      do
      {
        switch((int)v61)
        {
          case 2:
            v58 = *((_QWORD *)v70 + v61);
            break;
          case 3:
            v59 = *((_QWORD *)v70 + v61);
            break;
          case 5:
            v57 = *((_QWORD *)v70 + v61);
            break;
          default:
            break;
        }
        ++v61;
        v62 -= 8;
      }
      while (v62);
      goto LABEL_84;
    }
    goto LABEL_83;
  }
  v53 = 0;
  v54 = 0;
  v50 = 0;
  v55 = 8 * v74;
  while (2)
  {
    v52 = *((_QWORD *)v73 + v53);
    switch((int)v53)
    {
      case 0:
        v43 = v52 == 1;
        v52 = v54;
        if (v43)
          goto LABEL_61;
LABEL_88:
        v65 = "dilationRate != 1 not supported for dim 3";
        goto LABEL_91;
      case 1:
        goto LABEL_61;
      case 2:
        v50 = *((_QWORD *)v73 + v53);
        v52 = v54;
        goto LABEL_61;
      case 3:
        v43 = v52 == 1;
        v52 = v54;
        if (v43)
        {
LABEL_61:
          ++v53;
          v54 = v52;
          v55 -= 8;
          if (!v55)
            goto LABEL_76;
          continue;
        }
        v65 = "dilationRate != 1 not supported for dim 0";
LABEL_91:
        v47 = mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, v65);
LABEL_92:
        v35 = v47;
LABEL_93:
        if (v70 != v72)
          free(v70);
        if (v73 != v75)
          free(v73);
        if (v76 != v78)
          free(v76);
        return v35;
      default:
LABEL_87:
        v47 = mlir::emitOptionalError<char const(&)[43]>((uint64_t)a2, a3, "dilationRate num dimensions should be <= 4");
        goto LABEL_92;
    }
  }
}

uint64_t mlir::mps::DepthwiseConv2DOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *Type;
  _QWORD *v8;
  _QWORD *Shape;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const char *v59;
  const char *v60;
  uint64_t OperandRange;
  const char *v62;
  uint64_t v63;
  __int16 v64;
  _QWORD v65[2];
  __int128 v66;
  _QWORD *v67;
  _QWORD *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (a1[3])
  {
    v3 = (const char *)a1[4];
    if (v3)
    {
      v4 = (const char *)a1[5];
      if (v4)
      {
        if (a1[6])
        {
          v5 = (const char *)a1[7];
          if (v5)
          {
            if (a1[8])
            {
              v6 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
              v62 = v5;
              v63 = v6;
              Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
              v8 = Type;
              if (Type)
                Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
              v67 = v8;
              v68 = Type;
              Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
              v65[0] = 4;
              if (v10 == 1
                && *Shape == v65[0]
                && (v60 = v5,
                    *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                    *((_QWORD *)&v66 + 1) = v11,
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
              {
                v12 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
                v62 = v3;
                v63 = v12;
                v13 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                v14 = v13;
                if (v13)
                  v13 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
                v67 = v14;
                v68 = v13;
                v15 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
                v65[0] = 4;
                if (v16 == 1
                  && *v15 == v65[0]
                  && (v60 = v3,
                      *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                      *((_QWORD *)&v66 + 1) = v17,
                      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                {
                  v18 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                  v62 = v4;
                  v63 = v18;
                  v19 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                  v20 = v19;
                  if (v19)
                    v19 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
                  v67 = v20;
                  v68 = v19;
                  v21 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
                  v66 = xmmword_207A7D550;
                  if (v22 == 2 && *v21 == (_QWORD)v66 && v21[1] == *((_QWORD *)&v66 + 1))
                  {
                    v60 = v4;
                    v65[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
                    v65[1] = v24;
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v65);
                    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
                      return 1;
                  }
                  v59 = "'mps.depthwise_conv_2d' op attribute 'explicit_padding' failed to satisfy constraint: ui64 eleme"
                        "nts attribute of shape {4, 2}";
                }
                else
                {
                  v59 = "'mps.depthwise_conv_2d' op attribute 'dilation_rates' failed to satisfy constraint: ui64 element"
                        "s attribute of shape {4}";
                }
              }
              else
              {
                v59 = "'mps.depthwise_conv_2d' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {4}";
              }
            }
            else
            {
              v59 = "'mps.depthwise_conv_2d' op requires attribute 'weights_layout'";
            }
            v62 = v59;
            v64 = 259;
            mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
            v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v67);
            return v25;
          }
          v62 = "'mps.depthwise_conv_2d' op requires attribute 'strides'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
          if (v67)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
          if (v75)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v74;
              v54 = __p;
              if (v74 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v74 = v52;
              operator delete(v54);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_99;
            v55 = v72;
            v31 = v71;
            if (v72 == v71)
            {
LABEL_98:
              v72 = v29;
              operator delete(v31);
LABEL_99:
              if (v69 != &v70)
                free(v69);
              return v25;
            }
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v29);
LABEL_97:
            v31 = v71;
            goto LABEL_98;
          }
        }
        else
        {
          v62 = "'mps.depthwise_conv_2d' op requires attribute 'padding_style'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
          if (v67)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
          if (v75)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v74;
              v48 = __p;
              if (v74 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v74 = v46;
              operator delete(v48);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_99;
            v49 = v72;
            v31 = v71;
            if (v72 == v71)
              goto LABEL_98;
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
            goto LABEL_97;
          }
        }
      }
      else
      {
        v62 = "'mps.depthwise_conv_2d' op requires attribute 'explicit_padding'";
        v64 = 259;
        mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
        if (v67)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
        if (v75)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v74;
            v42 = __p;
            if (v74 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v74 = v40;
            operator delete(v42);
          }
          v29 = v71;
          if (!v71)
            goto LABEL_99;
          v43 = v72;
          v31 = v71;
          if (v72 == v71)
            goto LABEL_98;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_97;
        }
      }
    }
    else
    {
      v62 = "'mps.depthwise_conv_2d' op requires attribute 'dilation_rates'";
      v64 = 259;
      mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
      if (v67)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
      if (v75)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v74;
          v36 = __p;
          if (v74 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v74 = v34;
          operator delete(v36);
        }
        v29 = v71;
        if (!v71)
          goto LABEL_99;
        v37 = v72;
        v31 = v71;
        if (v72 == v71)
          goto LABEL_98;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_97;
      }
    }
  }
  else
  {
    v62 = "'mps.depthwise_conv_2d' op requires attribute 'data_layout'";
    v64 = 259;
    mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
    if (v67)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
    if (v75)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v74;
        v28 = __p;
        if (v74 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v74 = v26;
        operator delete(v28);
      }
      v29 = v71;
      if (!v71)
        goto LABEL_99;
      v30 = v72;
      v31 = v71;
      if (v72 == v71)
        goto LABEL_98;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_97;
    }
  }
  return v25;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[8];
  char v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD v39[3];

  v39[2] = *MEMORY[0x24BDAC8D0];
  v39[0] = a4;
  v39[1] = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
  }
  else
  {
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
  }
  v29 = a6;
  v30[0] = 0;
  v31 = 0;
  v32 = v16;
  v33 = v17;
  v34 = v18;
  v35 = a9;
  v36 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v29);
    if (v31)
      v31 = 0;
    mlir::OperationName::OperationName(v30, "mps.depthwise_conv_2d_data_gradient", 35, Context);
    v31 = 1;
  }
  v37 = a4;
  v38 = a5;
  if (a5 >= 3
    && (v20 = mlir::UnknownLoc::get(this, a2),
        mlir::mps::DepthwiseConv2DDataGradientOpAdaptor::verify(&v29, v20)))
  {
    v21 = mlir::ValueRange::dereference_iterator(v39, 0);
    v22 = mlir::ValueRange::dereference_iterator(v39, 1);
    v23 = mlir::ValueRange::dereference_iterator(v39, 2);
    v28 = 0;
    v24 = v28;
  }
  else
  {
    v25 = mlir::Float32Type::get(this, a2);
    v24 = mlir::UnrankedTensorType::get(v25);
  }
  v26 = *(unsigned int *)(a11 + 8);
  if (v26 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v26 + 1, 8);
    LODWORD(v26) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v26) = v24;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *Type;
  _QWORD *v8;
  _QWORD *Shape;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const char *v59;
  const char *v60;
  uint64_t OperandRange;
  const char *v62;
  uint64_t v63;
  __int16 v64;
  _QWORD v65[2];
  __int128 v66;
  _QWORD *v67;
  _QWORD *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (a1[3])
  {
    v3 = (const char *)a1[4];
    if (v3)
    {
      v4 = (const char *)a1[5];
      if (v4)
      {
        if (a1[6])
        {
          v5 = (const char *)a1[7];
          if (v5)
          {
            if (a1[8])
            {
              v6 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
              v62 = v5;
              v63 = v6;
              Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
              v8 = Type;
              if (Type)
                Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
              v67 = v8;
              v68 = Type;
              Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
              v65[0] = 4;
              if (v10 == 1
                && *Shape == v65[0]
                && (v60 = v5,
                    *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                    *((_QWORD *)&v66 + 1) = v11,
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
              {
                v12 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
                v62 = v3;
                v63 = v12;
                v13 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                v14 = v13;
                if (v13)
                  v13 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
                v67 = v14;
                v68 = v13;
                v15 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
                v65[0] = 4;
                if (v16 == 1
                  && *v15 == v65[0]
                  && (v60 = v3,
                      *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                      *((_QWORD *)&v66 + 1) = v17,
                      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                {
                  v18 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                  v62 = v4;
                  v63 = v18;
                  v19 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                  v20 = v19;
                  if (v19)
                    v19 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
                  v67 = v20;
                  v68 = v19;
                  v21 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
                  v66 = xmmword_207A7D550;
                  if (v22 == 2 && *v21 == (_QWORD)v66 && v21[1] == *((_QWORD *)&v66 + 1))
                  {
                    v60 = v4;
                    v65[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
                    v65[1] = v24;
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v65);
                    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
                      return 1;
                  }
                  v59 = "'mps.depthwise_conv_2d_data_gradient' op attribute 'explicit_padding' failed to satisfy constrai"
                        "nt: ui64 elements attribute of shape {4, 2}";
                }
                else
                {
                  v59 = "'mps.depthwise_conv_2d_data_gradient' op attribute 'dilation_rates' failed to satisfy constraint"
                        ": ui64 elements attribute of shape {4}";
                }
              }
              else
              {
                v59 = "'mps.depthwise_conv_2d_data_gradient' op attribute 'strides' failed to satisfy constraint: ui64 el"
                      "ements attribute of shape {4}";
              }
            }
            else
            {
              v59 = "'mps.depthwise_conv_2d_data_gradient' op requires attribute 'weights_layout'";
            }
            v62 = v59;
            v64 = 259;
            mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
            v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v67);
            return v25;
          }
          v62 = "'mps.depthwise_conv_2d_data_gradient' op requires attribute 'strides'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
          if (v67)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
          if (v75)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v74;
              v54 = __p;
              if (v74 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v74 = v52;
              operator delete(v54);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_99;
            v55 = v72;
            v31 = v71;
            if (v72 == v71)
            {
LABEL_98:
              v72 = v29;
              operator delete(v31);
LABEL_99:
              if (v69 != &v70)
                free(v69);
              return v25;
            }
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v29);
LABEL_97:
            v31 = v71;
            goto LABEL_98;
          }
        }
        else
        {
          v62 = "'mps.depthwise_conv_2d_data_gradient' op requires attribute 'padding_style'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
          if (v67)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
          if (v75)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v74;
              v48 = __p;
              if (v74 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v74 = v46;
              operator delete(v48);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_99;
            v49 = v72;
            v31 = v71;
            if (v72 == v71)
              goto LABEL_98;
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
            goto LABEL_97;
          }
        }
      }
      else
      {
        v62 = "'mps.depthwise_conv_2d_data_gradient' op requires attribute 'explicit_padding'";
        v64 = 259;
        mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
        if (v67)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
        if (v75)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v74;
            v42 = __p;
            if (v74 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v74 = v40;
            operator delete(v42);
          }
          v29 = v71;
          if (!v71)
            goto LABEL_99;
          v43 = v72;
          v31 = v71;
          if (v72 == v71)
            goto LABEL_98;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_97;
        }
      }
    }
    else
    {
      v62 = "'mps.depthwise_conv_2d_data_gradient' op requires attribute 'dilation_rates'";
      v64 = 259;
      mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
      if (v67)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
      if (v75)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v74;
          v36 = __p;
          if (v74 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v74 = v34;
          operator delete(v36);
        }
        v29 = v71;
        if (!v71)
          goto LABEL_99;
        v37 = v72;
        v31 = v71;
        if (v72 == v71)
          goto LABEL_98;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_97;
      }
    }
  }
  else
  {
    v62 = "'mps.depthwise_conv_2d_data_gradient' op requires attribute 'data_layout'";
    v64 = 259;
    mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
    if (v67)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
    if (v75)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v74;
        v28 = __p;
        if (v74 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v74 = v26;
        operator delete(v28);
      }
      v29 = v71;
      if (!v71)
        goto LABEL_99;
      v30 = v72;
      v31 = v71;
      if (v72 == v71)
        goto LABEL_98;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_97;
    }
  }
  return v25;
}

uint64_t mlir::mps::`anonymous namespace'::inferDepthwiseConv2DDataGradReturnType(uint64_t a1, char a2, void *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12;
  _QWORD *v13;
  int v14;
  _BYTE *v15;
  unsigned int v16;
  uint64_t Value;
  uint64_t *v18;
  __int128 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  unint64_t v25;
  void *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  void *v30;
  uint64_t v31;
  _BYTE v32[32];
  void *__src;
  uint64_t v34;
  _BYTE v35[32];
  unint64_t v36[3];

  v36[2] = *MEMORY[0x24BDAC8D0];
  __src = a3;
  v34 = a4;
  mlir::ValueRange::ValueRange(v36, (uint64_t)&__src, 2uLL);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a3 + 8))
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2DDataGrad a non-shaped inputType");
  mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a3 + 8);
  if (!a3)
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2DDataGrad a non-shaped inputType");
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a4 + 8))
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2DDataGrad a non-shaped weightsType");
  mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)a4 + 8);
  if (!a4)
    return mlir::emitOptionalError<char const(&)[39]>(a1, a2, "cannot conv2DDataGrad a non-shaped weightsType");
  if (*(_UNKNOWN **)(*(_QWORD *)a3 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    *a6 = mlir::UnrankedTensorType::get(v12);
    return 1;
  }
  __src = v35;
  v34 = 0x400000000;
  if (mlir::matchConstantWithIntVector<long long>(a5, (uint64_t)&__src))
  {
    if ((_DWORD)v34 == 4)
    {
      v13 = __src;
      if (*(_QWORD *)__src == -1)
      {
        *(_QWORD *)__src = 0x8000000000000000;
        if (v13[1] != -1)
        {
LABEL_11:
          if (v13[2] != -1)
            goto LABEL_12;
          goto LABEL_42;
        }
      }
      else if (*((_QWORD *)__src + 1) != -1)
      {
        goto LABEL_11;
      }
      v13[1] = 0x8000000000000000;
      if (v13[2] != -1)
      {
LABEL_12:
        if (v13[3] != -1)
        {
LABEL_13:
          v30 = v32;
          v31 = 0x400000000;
          v14 = 4;
          goto LABEL_14;
        }
LABEL_43:
        v13[3] = 0x8000000000000000;
        goto LABEL_13;
      }
LABEL_42:
      v13[2] = 0x8000000000000000;
      if (v13[3] != -1)
        goto LABEL_13;
      goto LABEL_43;
    }
    if (mlir::emitOptionalError<char const(&)[39]>(a1, a2, "unexpected output shape passed"))
    {
      v14 = v34;
      v30 = v32;
      v31 = 0x400000000;
      if (!(_DWORD)v34)
      {
LABEL_17:
        v26 = a3;
        Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v26);
        v27 = 0x400000000;
        v25 = v31;
        v26 = &v28;
        if ((_DWORD)v31 == 4)
        {
          v18 = (uint64_t *)Value;
          v19 = &v28;
          v28 = 0u;
          v29 = 0u;
          v28 = *(_OWORD *)v30;
          v29 = *((_OWORD *)v30 + 1);
          LODWORD(v27) = 4;
          if (*(_QWORD *)v30 == 0x8000000000000000)
          {
            v20 = *v18;
            if (v20 >= 1)
              *(_QWORD *)&v28 = v20;
          }
          v21 = 4;
        }
        else
        {
          if (!mlir::emitOptionalError<char const(&)[19],unsigned long &,char const(&)[11]>(a1, a2, "conv2D input rank ", (char **)&v25, "must be 4 "))
          {
            v22 = 0;
            v23 = v26;
            if (v26 == &v28)
            {
LABEL_35:
              if (v30 != v32)
                free(v30);
              goto LABEL_37;
            }
LABEL_34:
            free(v23);
            goto LABEL_35;
          }
          v19 = (__int128 *)v26;
          v21 = v27;
        }
        *a6 = mlir::RankedTensorType::get((uint64_t)v19, v21, v12, 0);
        v22 = 1;
        v23 = v26;
        if (v26 == &v28)
          goto LABEL_35;
        goto LABEL_34;
      }
      if (v34 >= 5)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v34, 8);
        v16 = v34;
        if (!(_DWORD)v34)
          goto LABEL_16;
        v15 = v30;
LABEL_15:
        memcpy(v15, __src, 8 * v16);
LABEL_16:
        LODWORD(v31) = v14;
        goto LABEL_17;
      }
LABEL_14:
      v15 = v32;
      v16 = v14;
      goto LABEL_15;
    }
  }
  *a6 = mlir::UnrankedTensorType::get(v12);
  v22 = 1;
LABEL_37:
  if (__src != v35)
    free(__src);
  return v22;
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[8];
  char v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD v39[3];

  v39[2] = *MEMORY[0x24BDAC8D0];
  v39[0] = a4;
  v39[1] = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
  }
  else
  {
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
  }
  v29 = a6;
  v30[0] = 0;
  v31 = 0;
  v32 = v16;
  v33 = v17;
  v34 = v18;
  v35 = a9;
  v36 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v29);
    if (v31)
      v31 = 0;
    mlir::OperationName::OperationName(v30, "mps.depthwise_conv_2d_weights_gradient", 38, Context);
    v31 = 1;
  }
  v37 = a4;
  v38 = a5;
  if (a5 >= 3
    && (v20 = mlir::UnknownLoc::get(this, a2),
        mlir::mps::DepthwiseConv2DWeightsGradientOpAdaptor::verify(&v29, v20)))
  {
    v21 = mlir::ValueRange::dereference_iterator(v39, 0);
    v22 = mlir::ValueRange::dereference_iterator(v39, 1);
    v23 = mlir::ValueRange::dereference_iterator(v39, 2);
    v28 = 0;
    v24 = v28;
  }
  else
  {
    v25 = mlir::Float32Type::get(this, a2);
    v24 = mlir::UnrankedTensorType::get(v25);
  }
  v26 = *(unsigned int *)(a11 + 8);
  if (v26 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v26 + 1, 8);
    LODWORD(v26) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v26) = v24;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  uint64_t v6;
  _QWORD *Type;
  _QWORD *v8;
  _QWORD *Shape;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const char *v59;
  const char *v60;
  uint64_t OperandRange;
  const char *v62;
  uint64_t v63;
  __int16 v64;
  _QWORD v65[2];
  __int128 v66;
  _QWORD *v67;
  _QWORD *v68;
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (a1[3])
  {
    v3 = (const char *)a1[4];
    if (v3)
    {
      v4 = (const char *)a1[5];
      if (v4)
      {
        if (a1[6])
        {
          v5 = (const char *)a1[7];
          if (v5)
          {
            if (a1[8])
            {
              v6 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
              v62 = v5;
              v63 = v6;
              Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
              v8 = Type;
              if (Type)
                Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
              v67 = v8;
              v68 = Type;
              Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
              v65[0] = 4;
              if (v10 == 1
                && *Shape == v65[0]
                && (v60 = v5,
                    *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                    *((_QWORD *)&v66 + 1) = v11,
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
              {
                v12 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
                v62 = v3;
                v63 = v12;
                v13 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                v14 = v13;
                if (v13)
                  v13 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
                v67 = v14;
                v68 = v13;
                v15 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
                v65[0] = 4;
                if (v16 == 1
                  && *v15 == v65[0]
                  && (v60 = v3,
                      *(_QWORD *)&v66 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60),
                      *((_QWORD *)&v66 + 1) = v17,
                      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                {
                  v18 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                  v62 = v4;
                  v63 = v18;
                  v19 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v62);
                  v20 = v19;
                  if (v19)
                    v19 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
                  v67 = v20;
                  v68 = v19;
                  v21 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v67);
                  v66 = xmmword_207A7D550;
                  if (v22 == 2 && *v21 == (_QWORD)v66 && v21[1] == *((_QWORD *)&v66 + 1))
                  {
                    v60 = v4;
                    v65[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
                    v65[1] = v24;
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v65);
                    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
                      return 1;
                  }
                  v59 = "'mps.depthwise_conv_2d_weights_gradient' op attribute 'explicit_padding' failed to satisfy const"
                        "raint: ui64 elements attribute of shape {4, 2}";
                }
                else
                {
                  v59 = "'mps.depthwise_conv_2d_weights_gradient' op attribute 'dilation_rates' failed to satisfy constra"
                        "int: ui64 elements attribute of shape {4}";
                }
              }
              else
              {
                v59 = "'mps.depthwise_conv_2d_weights_gradient' op attribute 'strides' failed to satisfy constraint: ui64"
                      " elements attribute of shape {4}";
              }
            }
            else
            {
              v59 = "'mps.depthwise_conv_2d_weights_gradient' op requires attribute 'weights_layout'";
            }
            v62 = v59;
            v64 = 259;
            mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
            v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v67);
            return v25;
          }
          v62 = "'mps.depthwise_conv_2d_weights_gradient' op requires attribute 'strides'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
          if (v67)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
          if (v75)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v74;
              v54 = __p;
              if (v74 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v74 = v52;
              operator delete(v54);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_99;
            v55 = v72;
            v31 = v71;
            if (v72 == v71)
            {
LABEL_98:
              v72 = v29;
              operator delete(v31);
LABEL_99:
              if (v69 != &v70)
                free(v69);
              return v25;
            }
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v29);
LABEL_97:
            v31 = v71;
            goto LABEL_98;
          }
        }
        else
        {
          v62 = "'mps.depthwise_conv_2d_weights_gradient' op requires attribute 'padding_style'";
          v64 = 259;
          mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
          if (v67)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
          if (v75)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v74;
              v48 = __p;
              if (v74 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v74 = v46;
              operator delete(v48);
            }
            v29 = v71;
            if (!v71)
              goto LABEL_99;
            v49 = v72;
            v31 = v71;
            if (v72 == v71)
              goto LABEL_98;
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
            goto LABEL_97;
          }
        }
      }
      else
      {
        v62 = "'mps.depthwise_conv_2d_weights_gradient' op requires attribute 'explicit_padding'";
        v64 = 259;
        mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
        if (v67)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
        if (v75)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v74;
            v42 = __p;
            if (v74 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v74 = v40;
            operator delete(v42);
          }
          v29 = v71;
          if (!v71)
            goto LABEL_99;
          v43 = v72;
          v31 = v71;
          if (v72 == v71)
            goto LABEL_98;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_97;
        }
      }
    }
    else
    {
      v62 = "'mps.depthwise_conv_2d_weights_gradient' op requires attribute 'dilation_rates'";
      v64 = 259;
      mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
      if (v67)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
      if (v75)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v74;
          v36 = __p;
          if (v74 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v74 = v34;
          operator delete(v36);
        }
        v29 = v71;
        if (!v71)
          goto LABEL_99;
        v37 = v72;
        v31 = v71;
        if (v72 == v71)
          goto LABEL_98;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_97;
      }
    }
  }
  else
  {
    v62 = "'mps.depthwise_conv_2d_weights_gradient' op requires attribute 'data_layout'";
    v64 = 259;
    mlir::emitError(a2, (uint64_t)&v62, (uint64_t)&v67);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v67);
    if (v67)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v67);
    if (v75)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v74;
        v28 = __p;
        if (v74 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v74 = v26;
        operator delete(v28);
      }
      v29 = v71;
      if (!v71)
        goto LABEL_99;
      v30 = v72;
      v31 = v71;
      if (v72 == v71)
        goto LABEL_98;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_97;
    }
  }
  return v25;
}

uint64_t mlir::mps::DepthwiseConv3DOp::verify(mlir::mps::DepthwiseConv3DOp *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t NumElements;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unint64_t *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  char *v19;
  unint64_t *v20;
  char *v21;
  __int128 v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  BOOL v33;
  int64_t v34;
  int64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  unint64_t *v42;
  char *v43;
  __int128 v44;
  uint64_t v45;
  char *v46;
  unint64_t *v47;
  char *v48;
  __int128 v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  _QWORD *v53;
  _QWORD *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  BOOL v60;
  int64_t v61;
  int64_t v62;
  uint64_t v63;
  uint64_t v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  unint64_t *v69;
  char *v70;
  __int128 v71;
  uint64_t v72;
  char *v73;
  unint64_t *v74;
  char *v75;
  __int128 v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  BOOL v87;
  int64_t v88;
  int64_t v89;
  uint64_t v90;
  unint64_t v91;
  void *v92;
  uint64_t v93;
  const char *v94;
  const void ***v95;
  char *v96;
  char *v97;
  __int128 v98;
  uint64_t v99;
  const void ***v100;
  char *v101;
  char *v102;
  __int128 v103;
  _QWORD *v104;
  _QWORD *v105;
  void *v106;
  _QWORD *v107;
  _QWORD *v108;
  void *v109;
  unint64_t v110;
  void *v111;
  uint64_t v112;
  const char *v113;
  const void ***v114;
  char *v115;
  char *v116;
  __int128 v117;
  uint64_t v118;
  const void ***v119;
  char *v120;
  char *v121;
  __int128 v122;
  _QWORD *v123;
  _QWORD *v124;
  void *v125;
  _QWORD *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  const char *v133;
  const void ***v134;
  char *v135;
  char *v136;
  __int128 v137;
  uint64_t v138;
  const void ***v139;
  char *v140;
  char *v141;
  __int128 v142;
  uint64_t v143;
  const void ***v144;
  char *v145;
  char *v146;
  __int128 v147;
  uint64_t v148;
  const void ***v149;
  char *v150;
  char *v151;
  __int128 v152;
  _QWORD *v153;
  _QWORD *v154;
  void *v155;
  _QWORD *v156;
  _QWORD *v157;
  void *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  void *v163;
  const char *v165;
  const void ***v166;
  char *v167;
  char *v168;
  __int128 v169;
  uint64_t v170;
  const void ***v171;
  char *v172;
  char *v173;
  __int128 v174;
  uint64_t v175;
  const void ***v176;
  char *v177;
  char *v178;
  __int128 v179;
  uint64_t v180;
  const void ***v181;
  char *v182;
  char *v183;
  __int128 v184;
  _QWORD *v185;
  _QWORD *v186;
  void *v187;
  _QWORD *v188;
  uint64_t v189;
  uint64_t v190;
  const void ***v191;
  char *v192;
  char *v193;
  __int128 v194;
  uint64_t v195;
  const void ***v196;
  char *v197;
  char *v198;
  __int128 v199;
  uint64_t v200;
  const void ***v201;
  char *v202;
  char *v203;
  __int128 v204;
  _QWORD *v205;
  _QWORD *v206;
  void *v207;
  _QWORD *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  const void ***v212;
  char *v213;
  char *v214;
  __int128 v215;
  uint64_t v216;
  const void ***v217;
  char *v218;
  char *v219;
  __int128 v220;
  uint64_t v221;
  const void ***v222;
  char *v223;
  char *v224;
  __int128 v225;
  uint64_t v226;
  const void ***v227;
  char *v228;
  char *v229;
  __int128 v230;
  _QWORD *v231;
  _QWORD *v232;
  void *v233;
  _QWORD *v234;
  uint64_t v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  BOOL v243;
  unint64_t v244;
  BOOL v245;
  unint64_t v246;
  BOOL v247;
  unint64_t v248;
  BOOL v249;
  unint64_t v250;
  BOOL v251;
  unint64_t v252;
  BOOL v253;
  unint64_t v254;
  BOOL v255;
  unint64_t v256;
  unint64_t v257;
  BOOL v258;
  unint64_t v259;
  BOOL v260;
  unint64_t v261;
  BOOL v262;
  unint64_t v263;
  BOOL v264;
  unint64_t v265;
  BOOL v266;
  unint64_t v267;
  BOOL v268;
  int64_t v269;
  int64_t v270;
  int64_t v271;
  int64_t v272;
  int64_t v273;
  int64_t v274;
  int64_t v275;
  int64_t v276;
  int64_t v277;
  int64_t v278;
  int64_t v279;
  int64_t v280;
  int64_t v281;
  int64_t v282;
  int64_t v283;
  int64_t v284;
  int64_t v285;
  int64_t v286;
  int64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  const void **v294;
  const char *v295;
  uint64_t v296;
  __int16 v297;
  unint64_t v298;
  uint64_t *v299;
  unsigned int v300;
  const void **v301;
  const char *v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t *v307;
  unint64_t v308;
  const char *v309;
  uint64_t v310;
  void *v311;
  uint64_t v312;
  _BYTE v313[16];
  __int16 v314;
  uint64_t *v315;
  unsigned int v316;
  void *v317;
  unsigned int v318;
  unsigned int v319;
  _BYTE v320[96];
  void *v321;
  _QWORD *v322;
  void *__p;
  _QWORD *v324;
  char v325;
  uint64_t v326;

  v326 = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned __int8 *)(*(_QWORD *)this + 47);
  v3 = *(_QWORD *)(*(_QWORD *)this + 72);
  v4 = *(_QWORD *)(v3 + 24);
  v5 = *(_QWORD *)(v3 + 56);
  v307 = *(uint64_t **)this;
  v6 = v307 + 10;
  if (!v2)
    v6 = 0;
  v7 = v6[4];
  v9 = v6[1];
  v8 = v6[2];
  v305 = v9;
  v306 = v7;
  v304 = v8;
  if (v7 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v306) == 3)
  {
    v288 = v4;
    v291 = v5;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v294, v306, 0);
    v1 = v306;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v306);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v301, v1, NumElements);
    while (1)
    {
      v11 = v294 == v301 && v295 == v302;
      if (v11 && v296 == v303)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v294, (llvm::APInt *)&v299);
      if (v300 > 0x40)
      {
        v12 = *v299;
        if (*v299 > 0)
        {
LABEL_18:
          if (v300 < 0x41)
            goto LABEL_48;
LABEL_46:
          if (v299)
            MEMORY[0x20BD002D4](v299, 0x1000C8000313F17);
          goto LABEL_48;
        }
      }
      else
      {
        v12 = (uint64_t)((_QWORD)v299 << -(char)v300) >> -(char)v300;
        if (v12 > 0)
          goto LABEL_18;
      }
      v314 = 259;
      mlir::OpState::emitOpError(&v307, (const void ***)&v311, (uint64_t)&v315);
      if (v300 > 0x40)
      {
        v13 = *v299;
        if (!v315)
          goto LABEL_27;
      }
      else
      {
        v13 = (uint64_t)((_QWORD)v299 << -(char)v300) >> -(char)v300;
        if (!v315)
          goto LABEL_27;
      }
      LODWORD(v308) = 2;
      v309 = (const char *)v13;
      v14 = (char *)v317;
      if (v318 >= v319)
      {
        v31 = v318 + 1;
        if (v317 <= &v308 && (char *)v317 + 24 * v318 > (char *)&v308)
        {
          v34 = (char *)&v308 - (_BYTE *)v317;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v31, 24);
          v14 = (char *)v317;
          v15 = (unint64_t *)((char *)v317 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v31, 24);
          v15 = &v308;
          v14 = (char *)v317;
        }
      }
      else
      {
        v15 = &v308;
      }
      v16 = &v14[24 * v318];
      v17 = *(_OWORD *)v15;
      *((_QWORD *)v16 + 2) = v15[2];
      *(_OWORD *)v16 = v17;
      v18 = ++v318;
      if (v315)
      {
        LODWORD(v308) = 3;
        v309 = ", all values should be positive.";
        v310 = 32;
        v19 = (char *)v317;
        if (v18 >= v319)
        {
          v32 = v18 + 1;
          v33 = (char *)v317 + 24 * v18 > (char *)&v308;
          if (v317 <= &v308 && v33)
          {
            v35 = (char *)&v308 - (_BYTE *)v317;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v32, 24);
            v19 = (char *)v317;
            v20 = (unint64_t *)((char *)v317 + v35);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v32, 24);
            v20 = &v308;
            v19 = (char *)v317;
          }
        }
        else
        {
          v20 = &v308;
        }
        v21 = &v19[24 * v318];
        v22 = *(_OWORD *)v20;
        *((_QWORD *)v21 + 2) = v20[2];
        *(_OWORD *)v21 = v22;
        ++v318;
      }
LABEL_27:
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
      if (v315)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
      if (v325)
      {
        v23 = __p;
        if (__p)
        {
          v24 = v324;
          v25 = __p;
          if (v324 != __p)
          {
            do
              v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
            while (v24 != v23);
            v25 = __p;
          }
          v324 = v23;
          operator delete(v25);
        }
        v26 = v321;
        if (v321)
        {
          v27 = v322;
          v28 = v321;
          if (v322 != v321)
          {
            do
            {
              v30 = *--v27;
              v29 = v30;
              *v27 = 0;
              if (v30)
                MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
            }
            while (v27 != v26);
            v28 = v321;
          }
          v322 = v26;
          operator delete(v28);
        }
        if (v317 != v320)
          free(v317);
      }
      if (v300 >= 0x41)
        goto LABEL_46;
LABEL_48:
      if (v12 < 1)
        return v1;
      ++v296;
    }
    v4 = v288;
    v5 = v291;
    if (!v305)
      goto LABEL_116;
LABEL_59:
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v305) == 3)
    {
      v289 = v4;
      v292 = v5;
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v294, v305, 0);
      v36 = v305;
      v37 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v305);
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v301, v36, v37);
      while (1)
      {
        v38 = v294 == v301 && v295 == v302;
        if (v38 && v296 == v303)
        {
          v4 = v289;
          v5 = v292;
          break;
        }
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v294, (llvm::APInt *)&v299);
        if (v300 > 0x40)
        {
          v39 = *v299;
          if (*v299 > 0)
          {
LABEL_73:
            if (v300 < 0x41)
              goto LABEL_103;
LABEL_101:
            if (v299)
              MEMORY[0x20BD002D4](v299, 0x1000C8000313F17);
            goto LABEL_103;
          }
        }
        else
        {
          v39 = (uint64_t)((_QWORD)v299 << -(char)v300) >> -(char)v300;
          if (v39 > 0)
            goto LABEL_73;
        }
        v314 = 259;
        mlir::OpState::emitOpError(&v307, (const void ***)&v311, (uint64_t)&v315);
        if (v300 > 0x40)
        {
          v40 = *v299;
          if (!v315)
            goto LABEL_82;
        }
        else
        {
          v40 = (uint64_t)((_QWORD)v299 << -(char)v300) >> -(char)v300;
          if (!v315)
            goto LABEL_82;
        }
        LODWORD(v308) = 2;
        v309 = (const char *)v40;
        v41 = (char *)v317;
        if (v318 >= v319)
        {
          v58 = v318 + 1;
          if (v317 <= &v308 && (char *)v317 + 24 * v318 > (char *)&v308)
          {
            v61 = (char *)&v308 - (_BYTE *)v317;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v58, 24);
            v41 = (char *)v317;
            v42 = (unint64_t *)((char *)v317 + v61);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v58, 24);
            v42 = &v308;
            v41 = (char *)v317;
          }
        }
        else
        {
          v42 = &v308;
        }
        v43 = &v41[24 * v318];
        v44 = *(_OWORD *)v42;
        *((_QWORD *)v43 + 2) = v42[2];
        *(_OWORD *)v43 = v44;
        v45 = ++v318;
        if (v315)
        {
          LODWORD(v308) = 3;
          v309 = ", all values should be positive.";
          v310 = 32;
          v46 = (char *)v317;
          if (v45 >= v319)
          {
            v59 = v45 + 1;
            v60 = (char *)v317 + 24 * v45 > (char *)&v308;
            if (v317 <= &v308 && v60)
            {
              v62 = (char *)&v308 - (_BYTE *)v317;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v59, 24);
              v46 = (char *)v317;
              v47 = (unint64_t *)((char *)v317 + v62);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v59, 24);
              v47 = &v308;
              v46 = (char *)v317;
            }
          }
          else
          {
            v47 = &v308;
          }
          v48 = &v46[24 * v318];
          v49 = *(_OWORD *)v47;
          *((_QWORD *)v48 + 2) = v47[2];
          *(_OWORD *)v48 = v49;
          ++v318;
        }
LABEL_82:
        v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
        if (v315)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
        if (v325)
        {
          v50 = __p;
          if (__p)
          {
            v51 = v324;
            v52 = __p;
            if (v324 != __p)
            {
              do
                v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
              while (v51 != v50);
              v52 = __p;
            }
            v324 = v50;
            operator delete(v52);
          }
          v53 = v321;
          if (v321)
          {
            v54 = v322;
            v55 = v321;
            if (v322 != v321)
            {
              do
              {
                v57 = *--v54;
                v56 = v57;
                *v54 = 0;
                if (v57)
                  MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
              }
              while (v54 != v53);
              v55 = v321;
            }
            v322 = v53;
            operator delete(v55);
          }
          if (v317 != v320)
            free(v317);
        }
        if (v300 >= 0x41)
          goto LABEL_101;
LABEL_103:
        if (v39 < 1)
          return v1;
        ++v296;
      }
    }
  }
  else if (v305)
  {
    goto LABEL_59;
  }
LABEL_116:
  if (v304 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v304) == 6)
  {
    v290 = v4;
    v293 = v5;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v294, v304, 0);
    v63 = v304;
    v64 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v304);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v301, v63, v64);
    while (1)
    {
      v65 = v294 == v301 && v295 == v302;
      if (v65 && v296 == v303)
      {
        v4 = v290;
        v5 = v293;
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v294, (llvm::APInt *)&v299);
      if (v300 > 0x40)
      {
        v66 = *v299;
        if ((*v299 & 0x8000000000000000) == 0)
        {
LABEL_131:
          if (v300 < 0x41)
            goto LABEL_161;
LABEL_159:
          if (v299)
            MEMORY[0x20BD002D4](v299, 0x1000C8000313F17);
          goto LABEL_161;
        }
      }
      else
      {
        v66 = (uint64_t)((_QWORD)v299 << -(char)v300) >> -(char)v300;
        if ((v66 & 0x8000000000000000) == 0)
          goto LABEL_131;
      }
      v314 = 259;
      mlir::OpState::emitOpError(&v307, (const void ***)&v311, (uint64_t)&v315);
      if (v300 > 0x40)
      {
        v67 = *v299;
        if (!v315)
          goto LABEL_140;
      }
      else
      {
        v67 = (uint64_t)((_QWORD)v299 << -(char)v300) >> -(char)v300;
        if (!v315)
          goto LABEL_140;
      }
      LODWORD(v308) = 2;
      v309 = (const char *)v67;
      v68 = (char *)v317;
      if (v318 >= v319)
      {
        v85 = v318 + 1;
        if (v317 <= &v308 && (char *)v317 + 24 * v318 > (char *)&v308)
        {
          v88 = (char *)&v308 - (_BYTE *)v317;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v85, 24);
          v68 = (char *)v317;
          v69 = (unint64_t *)((char *)v317 + v88);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v85, 24);
          v69 = &v308;
          v68 = (char *)v317;
        }
      }
      else
      {
        v69 = &v308;
      }
      v70 = &v68[24 * v318];
      v71 = *(_OWORD *)v69;
      *((_QWORD *)v70 + 2) = v69[2];
      *(_OWORD *)v70 = v71;
      v72 = ++v318;
      if (v315)
      {
        LODWORD(v308) = 3;
        v309 = ", all values should be non-negative.";
        v310 = 36;
        v73 = (char *)v317;
        if (v72 >= v319)
        {
          v86 = v72 + 1;
          v87 = (char *)v317 + 24 * v72 > (char *)&v308;
          if (v317 <= &v308 && v87)
          {
            v89 = (char *)&v308 - (_BYTE *)v317;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v86, 24);
            v73 = (char *)v317;
            v74 = (unint64_t *)((char *)v317 + v89);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v86, 24);
            v74 = &v308;
            v73 = (char *)v317;
          }
        }
        else
        {
          v74 = &v308;
        }
        v75 = &v73[24 * v318];
        v76 = *(_OWORD *)v74;
        *((_QWORD *)v75 + 2) = v74[2];
        *(_OWORD *)v75 = v76;
        ++v318;
      }
LABEL_140:
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
      if (v315)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
      if (v325)
      {
        v77 = __p;
        if (__p)
        {
          v78 = v324;
          v79 = __p;
          if (v324 != __p)
          {
            do
              v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
            while (v78 != v77);
            v79 = __p;
          }
          v324 = v77;
          operator delete(v79);
        }
        v80 = v321;
        if (v321)
        {
          v81 = v322;
          v82 = v321;
          if (v322 != v321)
          {
            do
            {
              v84 = *--v81;
              v83 = v84;
              *v81 = 0;
              if (v84)
                MEMORY[0x20BD002D4](v83, 0x1000C8077774924);
            }
            while (v81 != v80);
            v82 = v321;
          }
          v322 = v80;
          operator delete(v82);
        }
        if (v317 != v320)
          free(v317);
      }
      if (v300 >= 0x41)
        goto LABEL_159;
LABEL_161:
      if (v66 < 0)
        return v1;
      ++v296;
    }
  }
  v311 = (void *)v307[2 * (((unint64_t)*((unsigned int *)v307 + 11) >> 23) & 1) + 8];
  mlir::IntegerAttr::getValue(&v311, (llvm::APInt *)&v315);
  if (v316 > 0x40)
  {
    v90 = *v315;
    MEMORY[0x20BD002D4]();
    if (!v4)
    {
LABEL_197:
      v308 = 0;
      goto LABEL_198;
    }
  }
  else
  {
    v90 = (uint64_t)((_QWORD)v315 << -(uint64_t)v316) >> -(uint64_t)v316;
    if (!v4)
      goto LABEL_197;
  }
  v91 = *(_QWORD *)(v4 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v91)
    goto LABEL_197;
  v92 = *(void **)(*(_QWORD *)v91 + 136);
  if (v92 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v91 = 0;
  v308 = v91;
  if (v92 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v308);
    v94 = (const char *)v93;
    if (v93 <= 3)
    {
      v314 = 259;
      mlir::OpState::emitOpError(&v307, (const void ***)&v311, (uint64_t)&v315);
      if (v315)
      {
        LODWORD(v294) = 2;
        v295 = v94;
        v95 = &v294;
        v96 = (char *)v317;
        if (v318 >= v319)
        {
          v239 = v318 + 1;
          if (v317 <= &v294 && (char *)v317 + 24 * v318 > (char *)&v294)
          {
            v271 = (char *)&v294 - (_BYTE *)v317;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v239, 24);
            v96 = (char *)v317;
            v95 = (const void ***)((char *)v317 + v271);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v239, 24);
            v95 = &v294;
            v96 = (char *)v317;
          }
        }
        v97 = &v96[24 * v318];
        v98 = *(_OWORD *)v95;
        *((_QWORD *)v97 + 2) = v95[2];
        *(_OWORD *)v97 = v98;
        v99 = ++v318;
        if (v315)
        {
          LODWORD(v294) = 3;
          v295 = ".";
          v296 = 1;
          v100 = &v294;
          v101 = (char *)v317;
          if (v99 >= v319)
          {
            v246 = v99 + 1;
            v247 = (char *)v317 + 24 * v99 > (char *)&v294;
            if (v317 <= &v294 && v247)
            {
              v276 = (char *)&v294 - (_BYTE *)v317;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v246, 24);
              v101 = (char *)v317;
              v100 = (const void ***)((char *)v317 + v276);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v246, 24);
              v100 = &v294;
              v101 = (char *)v317;
            }
          }
          v102 = &v101[24 * v318];
          v103 = *(_OWORD *)v100;
          *((_QWORD *)v102 + 2) = v100[2];
          *(_OWORD *)v102 = v103;
          ++v318;
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
      if (v315)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
      if (!v325)
        return v1;
      v104 = __p;
      if (__p)
      {
        v105 = v324;
        v106 = __p;
        if (v324 != __p)
        {
          do
            v105 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v105 - 1);
          while (v105 != v104);
          v106 = __p;
        }
        v324 = v104;
        operator delete(v106);
      }
      v107 = v321;
      if (!v321)
        goto LABEL_338;
      v108 = v322;
      v109 = v321;
      if (v322 == v321)
        goto LABEL_337;
      do
      {
        v128 = *--v108;
        v127 = v128;
        *v108 = 0;
        if (v128)
          MEMORY[0x20BD002D4](v127, 0x1000C8077774924);
      }
      while (v108 != v107);
      goto LABEL_336;
    }
    if ((v90 & 0x80000000) != 0)
      v211 = 0;
    else
      v211 = v93;
    if ((unint64_t)((int)v90 - v211) <= 0xFFFFFFFFFFFFFFFBLL)
    {
      v314 = 259;
      mlir::OpState::emitOpError(&v307, (const void ***)&v311, (uint64_t)&v315);
      if (v315)
      {
        LODWORD(v294) = 2;
        v295 = (const char *)(int)v90;
        v212 = &v294;
        v213 = (char *)v317;
        if (v318 >= v319)
        {
          v256 = v318 + 1;
          if (v317 <= &v294 && (char *)v317 + 24 * v318 > (char *)&v294)
          {
            v281 = (char *)&v294 - (_BYTE *)v317;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v256, 24);
            v213 = (char *)v317;
            v212 = (const void ***)((char *)v317 + v281);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v256, 24);
            v212 = &v294;
            v213 = (char *)v317;
          }
        }
        v214 = &v213[24 * v318];
        v215 = *(_OWORD *)v212;
        *((_QWORD *)v214 + 2) = v212[2];
        *(_OWORD *)v214 = v215;
        v216 = ++v318;
        if (v315)
        {
          LODWORD(v294) = 3;
          v295 = " for input rank ";
          v296 = 16;
          v217 = &v294;
          v218 = (char *)v317;
          if (v216 >= v319)
          {
            v261 = v216 + 1;
            v262 = (char *)v317 + 24 * v216 > (char *)&v294;
            if (v317 <= &v294 && v262)
            {
              v284 = (char *)&v294 - (_BYTE *)v317;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v261, 24);
              v218 = (char *)v317;
              v217 = (const void ***)((char *)v317 + v284);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v261, 24);
              v217 = &v294;
              v218 = (char *)v317;
            }
          }
          v219 = &v218[24 * v318];
          v220 = *(_OWORD *)v217;
          *((_QWORD *)v219 + 2) = v217[2];
          *(_OWORD *)v219 = v220;
          v221 = ++v318;
          if (v315)
          {
            LODWORD(v294) = 2;
            v295 = v94;
            v222 = &v294;
            v223 = (char *)v317;
            if (v221 >= v319)
            {
              v265 = v221 + 1;
              v266 = (char *)v317 + 24 * v221 > (char *)&v294;
              if (v317 <= &v294 && v266)
              {
                v286 = (char *)&v294 - (_BYTE *)v317;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v265, 24);
                v223 = (char *)v317;
                v222 = (const void ***)((char *)v317 + v286);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v265, 24);
                v222 = &v294;
                v223 = (char *)v317;
              }
            }
            v224 = &v223[24 * v318];
            v225 = *(_OWORD *)v222;
            *((_QWORD *)v224 + 2) = v222[2];
            *(_OWORD *)v224 = v225;
            v226 = ++v318;
            if (v315)
            {
              LODWORD(v294) = 3;
              v295 = ".";
              v296 = 1;
              v227 = &v294;
              v228 = (char *)v317;
              if (v226 >= v319)
              {
                v267 = v226 + 1;
                v268 = (char *)v317 + 24 * v226 > (char *)&v294;
                if (v317 <= &v294 && v268)
                {
                  v287 = (char *)&v294 - (_BYTE *)v317;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v267, 24);
                  v228 = (char *)v317;
                  v227 = (const void ***)((char *)v317 + v287);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v267, 24);
                  v227 = &v294;
                  v228 = (char *)v317;
                }
              }
              v229 = &v228[24 * v318];
              v230 = *(_OWORD *)v227;
              *((_QWORD *)v229 + 2) = v227[2];
              *(_OWORD *)v229 = v230;
              ++v318;
            }
          }
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
      if (v315)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
      if (!v325)
        return v1;
      v231 = __p;
      if (__p)
      {
        v232 = v324;
        v233 = __p;
        if (v324 != __p)
        {
          do
            v232 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v232 - 1);
          while (v232 != v231);
          v233 = __p;
        }
        v324 = v231;
        operator delete(v233);
      }
      v107 = v321;
      if (!v321)
        goto LABEL_338;
      v234 = v322;
      v109 = v321;
      if (v322 == v321)
        goto LABEL_337;
      do
      {
        v236 = *--v234;
        v235 = v236;
        *v234 = 0;
        if (v236)
          MEMORY[0x20BD002D4](v235, 0x1000C8077774924);
      }
      while (v234 != v107);
LABEL_336:
      v109 = v321;
LABEL_337:
      v322 = v107;
      operator delete(v109);
      goto LABEL_338;
    }
  }
LABEL_198:
  v299 = 0;
  if (!v5 || (v110 = *(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    v298 = 0;
    goto LABEL_224;
  }
  v111 = *(void **)(*(_QWORD *)v110 + 136);
  if (v111 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v110 = 0;
  v298 = v110;
  if (v111 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || (mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v298), v112 == 4))
  {
LABEL_224:
    v311 = v313;
    v312 = 0x500000000;
    if (mlir::matchConstantWithIntVector<long long>(0, (uint64_t)&v311))
    {
      if (v5)
      {
        if (v308)
        {
          v129 = v312;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v308);
          if (v130 != v129)
          {
            v297 = 259;
            mlir::OpState::emitOpError(&v307, &v294, (uint64_t)&v315);
            mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v308);
            if (v315)
            {
              LODWORD(v301) = 5;
              v302 = v165;
              v166 = &v301;
              v167 = (char *)v317;
              if (v318 >= v319)
              {
                v237 = v318 + 1;
                if (v317 <= &v301 && (char *)v317 + 24 * v318 > (char *)&v301)
                {
                  v269 = (char *)&v301 - (_BYTE *)v317;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v237, 24);
                  v167 = (char *)v317;
                  v166 = (const void ***)((char *)v317 + v269);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v237, 24);
                  v166 = &v301;
                  v167 = (char *)v317;
                }
              }
              v168 = &v167[24 * v318];
              v169 = *(_OWORD *)v166;
              *((_QWORD *)v168 + 2) = v166[2];
              *(_OWORD *)v168 = v169;
              v170 = ++v318;
              if (v315)
              {
                LODWORD(v301) = 3;
                v303 = 35;
                v171 = &v301;
                v172 = (char *)v317;
                if (v170 >= v319)
                {
                  v242 = v170 + 1;
                  v243 = (char *)v317 + 24 * v170 > (char *)&v301;
                  if (v317 <= &v301 && v243)
                  {
                    v274 = (char *)&v301 - (_BYTE *)v317;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v242, 24);
                    v172 = (char *)v317;
                    v171 = (const void ***)((char *)v317 + v274);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v242, 24);
                    v171 = &v301;
                    v172 = (char *)v317;
                  }
                }
                v173 = &v172[24 * v318];
                v174 = *(_OWORD *)v171;
                *((_QWORD *)v173 + 2) = v171[2];
                *(_OWORD *)v173 = v174;
                v175 = ++v318;
                if (v315)
                {
                  LODWORD(v301) = 5;
                  v302 = (const char *)v312;
                  v176 = &v301;
                  v177 = (char *)v317;
                  if (v175 >= v319)
                  {
                    v252 = v175 + 1;
                    v253 = (char *)v317 + 24 * v175 > (char *)&v301;
                    if (v317 <= &v301 && v253)
                    {
                      v279 = (char *)&v301 - (_BYTE *)v317;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v252, 24);
                      v177 = (char *)v317;
                      v176 = (const void ***)((char *)v317 + v279);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v252, 24);
                      v176 = &v301;
                      v177 = (char *)v317;
                    }
                  }
                  v178 = &v177[24 * v318];
                  v179 = *(_OWORD *)v176;
                  *((_QWORD *)v178 + 2) = v176[2];
                  *(_OWORD *)v178 = v179;
                  v180 = ++v318;
                  if (v315)
                  {
                    LODWORD(v301) = 3;
                    v302 = " values.";
                    v303 = 8;
                    v181 = &v301;
                    v182 = (char *)v317;
                    if (v180 >= v319)
                    {
                      v259 = v180 + 1;
                      v260 = (char *)v317 + 24 * v180 > (char *)&v301;
                      if (v317 <= &v301 && v260)
                      {
                        v283 = (char *)&v301 - (_BYTE *)v317;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v259, 24);
                        v182 = (char *)v317;
                        v181 = (const void ***)((char *)v317 + v283);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v259, 24);
                        v181 = &v301;
                        v182 = (char *)v317;
                      }
                    }
                    v183 = &v182[24 * v318];
                    v184 = *(_OWORD *)v181;
                    *((_QWORD *)v183 + 2) = v181[2];
                    *(_OWORD *)v183 = v184;
                    ++v318;
                  }
                }
              }
            }
            v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
            if (v315)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
            if (v325)
            {
              v185 = __p;
              if (__p)
              {
                v186 = v324;
                v187 = __p;
                if (v324 != __p)
                {
                  do
                    v186 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v186 - 1);
                  while (v186 != v185);
                  v187 = __p;
                }
                v324 = v185;
                operator delete(v187);
              }
              v156 = v321;
              if (!v321)
                goto LABEL_334;
              v188 = v322;
              v158 = v321;
              if (v322 == v321)
                goto LABEL_333;
              do
              {
                v190 = *--v188;
                v189 = v190;
                *v188 = 0;
                if (v190)
                  MEMORY[0x20BD002D4](v189, 0x1000C8077774924);
              }
              while (v188 != v156);
              goto LABEL_332;
            }
LABEL_258:
            v163 = v311;
            if (v311 != v313)
            {
LABEL_259:
              free(v163);
              return v1;
            }
            return v1;
          }
        }
        if (v299)
        {
          v131 = v312;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v299);
          if (v132 != v131)
          {
            v297 = 259;
            mlir::OpState::emitOpError(&v307, &v294, (uint64_t)&v315);
            mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v299);
            if (v315)
            {
              LODWORD(v301) = 5;
              v302 = v133;
              v134 = &v301;
              v135 = (char *)v317;
              if (v318 >= v319)
              {
                v240 = v318 + 1;
                if (v317 <= &v301 && (char *)v317 + 24 * v318 > (char *)&v301)
                {
                  v272 = (char *)&v301 - (_BYTE *)v317;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v240, 24);
                  v135 = (char *)v317;
                  v134 = (const void ***)((char *)v317 + v272);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v240, 24);
                  v134 = &v301;
                  v135 = (char *)v317;
                }
              }
              v136 = &v135[24 * v318];
              v137 = *(_OWORD *)v134;
              *((_QWORD *)v136 + 2) = v134[2];
              *(_OWORD *)v136 = v137;
              v138 = ++v318;
              if (v315)
              {
                LODWORD(v301) = 3;
                v303 = 38;
                v139 = &v301;
                v140 = (char *)v317;
                if (v138 >= v319)
                {
                  v248 = v138 + 1;
                  v249 = (char *)v317 + 24 * v138 > (char *)&v301;
                  if (v317 <= &v301 && v249)
                  {
                    v277 = (char *)&v301 - (_BYTE *)v317;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v248, 24);
                    v140 = (char *)v317;
                    v139 = (const void ***)((char *)v317 + v277);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v248, 24);
                    v139 = &v301;
                    v140 = (char *)v317;
                  }
                }
                v141 = &v140[24 * v318];
                v142 = *(_OWORD *)v139;
                *((_QWORD *)v141 + 2) = v139[2];
                *(_OWORD *)v141 = v142;
                v143 = ++v318;
                if (v315)
                {
                  LODWORD(v301) = 5;
                  v302 = (const char *)v312;
                  v144 = &v301;
                  v145 = (char *)v317;
                  if (v143 >= v319)
                  {
                    v257 = v143 + 1;
                    v258 = (char *)v317 + 24 * v143 > (char *)&v301;
                    if (v317 <= &v301 && v258)
                    {
                      v282 = (char *)&v301 - (_BYTE *)v317;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v257, 24);
                      v145 = (char *)v317;
                      v144 = (const void ***)((char *)v317 + v282);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v257, 24);
                      v144 = &v301;
                      v145 = (char *)v317;
                    }
                  }
                  v146 = &v145[24 * v318];
                  v147 = *(_OWORD *)v144;
                  *((_QWORD *)v146 + 2) = v144[2];
                  *(_OWORD *)v146 = v147;
                  v148 = ++v318;
                  if (v315)
                  {
                    LODWORD(v301) = 3;
                    v302 = " values.";
                    v303 = 8;
                    v149 = &v301;
                    v150 = (char *)v317;
                    if (v148 >= v319)
                    {
                      v263 = v148 + 1;
                      v264 = (char *)v317 + 24 * v148 > (char *)&v301;
                      if (v317 <= &v301 && v264)
                      {
                        v285 = (char *)&v301 - (_BYTE *)v317;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v263, 24);
                        v150 = (char *)v317;
                        v149 = (const void ***)((char *)v317 + v285);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v263, 24);
                        v149 = &v301;
                        v150 = (char *)v317;
                      }
                    }
                    v151 = &v150[24 * v318];
                    v152 = *(_OWORD *)v149;
                    *((_QWORD *)v151 + 2) = v149[2];
                    *(_OWORD *)v151 = v152;
                    ++v318;
                  }
                }
              }
            }
            v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
            if (v315)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
            if (v325)
            {
              v153 = __p;
              if (__p)
              {
                v154 = v324;
                v155 = __p;
                if (v324 != __p)
                {
                  do
                    v154 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v154 - 1);
                  while (v154 != v153);
                  v155 = __p;
                }
                v324 = v153;
                operator delete(v155);
              }
              v156 = v321;
              if (!v321)
                goto LABEL_334;
              v157 = v322;
              v158 = v321;
              if (v322 == v321)
              {
LABEL_333:
                v322 = v156;
                operator delete(v158);
LABEL_334:
                if (v317 != v320)
                  free(v317);
                goto LABEL_258;
              }
              do
              {
                v160 = *--v157;
                v159 = v160;
                *v157 = 0;
                if (v160)
                  MEMORY[0x20BD002D4](v159, 0x1000C8077774924);
              }
              while (v157 != v156);
LABEL_332:
              v158 = v321;
              goto LABEL_333;
            }
            goto LABEL_258;
          }
        }
      }
      else if ((_DWORD)v312 != 4)
      {
        v297 = 259;
        mlir::OpState::emitOpError(&v307, &v294, (uint64_t)&v315);
        if (v315)
        {
          LODWORD(v301) = 3;
          v303 = 21;
          v191 = &v301;
          v192 = (char *)v317;
          if (v318 >= v319)
          {
            v238 = v318 + 1;
            if (v317 <= &v301 && (char *)v317 + 24 * v318 > (char *)&v301)
            {
              v270 = (char *)&v301 - (_BYTE *)v317;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v238, 24);
              v192 = (char *)v317;
              v191 = (const void ***)((char *)v317 + v270);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v238, 24);
              v191 = &v301;
              v192 = (char *)v317;
            }
          }
          v193 = &v192[24 * v318];
          v194 = *(_OWORD *)v191;
          *((_QWORD *)v193 + 2) = v191[2];
          *(_OWORD *)v193 = v194;
          v195 = ++v318;
          if (v315)
          {
            LODWORD(v301) = 5;
            v302 = (const char *)v312;
            v196 = &v301;
            v197 = (char *)v317;
            if (v195 >= v319)
            {
              v244 = v195 + 1;
              v245 = (char *)v317 + 24 * v195 > (char *)&v301;
              if (v317 <= &v301 && v245)
              {
                v275 = (char *)&v301 - (_BYTE *)v317;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v244, 24);
                v197 = (char *)v317;
                v196 = (const void ***)((char *)v317 + v275);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v244, 24);
                v196 = &v301;
                v197 = (char *)v317;
              }
            }
            v198 = &v197[24 * v318];
            v199 = *(_OWORD *)v196;
            *((_QWORD *)v198 + 2) = v196[2];
            *(_OWORD *)v198 = v199;
            v200 = ++v318;
            if (v315)
            {
              LODWORD(v301) = 3;
              v302 = " values.";
              v303 = 8;
              v201 = &v301;
              v202 = (char *)v317;
              if (v200 >= v319)
              {
                v254 = v200 + 1;
                v255 = (char *)v317 + 24 * v200 > (char *)&v301;
                if (v317 <= &v301 && v255)
                {
                  v280 = (char *)&v301 - (_BYTE *)v317;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v254, 24);
                  v202 = (char *)v317;
                  v201 = (const void ***)((char *)v317 + v280);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v254, 24);
                  v201 = &v301;
                  v202 = (char *)v317;
                }
              }
              v203 = &v202[24 * v318];
              v204 = *(_OWORD *)v201;
              *((_QWORD *)v203 + 2) = v201[2];
              *(_OWORD *)v203 = v204;
              ++v318;
            }
          }
        }
        v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
        if (v315)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
        if (v325)
        {
          v205 = __p;
          if (__p)
          {
            v206 = v324;
            v207 = __p;
            if (v324 != __p)
            {
              do
                v206 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v206 - 1);
              while (v206 != v205);
              v207 = __p;
            }
            v324 = v205;
            operator delete(v207);
          }
          v156 = v321;
          if (!v321)
            goto LABEL_334;
          v208 = v322;
          v158 = v321;
          if (v322 == v321)
            goto LABEL_333;
          do
          {
            v210 = *--v208;
            v209 = v210;
            *v208 = 0;
            if (v210)
              MEMORY[0x20BD002D4](v209, 0x1000C8077774924);
          }
          while (v208 != v156);
          goto LABEL_332;
        }
        goto LABEL_258;
      }
    }
    v1 = 1;
    goto LABEL_258;
  }
  v314 = 259;
  mlir::OpState::emitOpError(&v307, (const void ***)&v311, (uint64_t)&v315);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v298);
  if (v315)
  {
    LODWORD(v294) = 5;
    v295 = v113;
    v114 = &v294;
    v115 = (char *)v317;
    if (v318 >= v319)
    {
      v241 = v318 + 1;
      if (v317 <= &v294 && (char *)v317 + 24 * v318 > (char *)&v294)
      {
        v273 = (char *)&v294 - (_BYTE *)v317;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v241, 24);
        v115 = (char *)v317;
        v114 = (const void ***)((char *)v317 + v273);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v241, 24);
        v114 = &v294;
        v115 = (char *)v317;
      }
    }
    v116 = &v115[24 * v318];
    v117 = *(_OWORD *)v114;
    *((_QWORD *)v116 + 2) = v114[2];
    *(_OWORD *)v116 = v117;
    v118 = ++v318;
    if (v315)
    {
      LODWORD(v294) = 3;
      v295 = ".";
      v296 = 1;
      v119 = &v294;
      v120 = (char *)v317;
      if (v118 >= v319)
      {
        v250 = v118 + 1;
        v251 = (char *)v317 + 24 * v118 > (char *)&v294;
        if (v317 <= &v294 && v251)
        {
          v278 = (char *)&v294 - (_BYTE *)v317;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v250, 24);
          v120 = (char *)v317;
          v119 = (const void ***)((char *)v317 + v278);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v317, v320, v250, 24);
          v119 = &v294;
          v120 = (char *)v317;
        }
      }
      v121 = &v120[24 * v318];
      v122 = *(_OWORD *)v119;
      *((_QWORD *)v121 + 2) = v119[2];
      *(_OWORD *)v121 = v122;
      ++v318;
    }
  }
  v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v315);
  if (v315)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v315);
  if (v325)
  {
    v123 = __p;
    if (__p)
    {
      v124 = v324;
      v125 = __p;
      if (v324 != __p)
      {
        do
          v124 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v124 - 1);
        while (v124 != v123);
        v125 = __p;
      }
      v324 = v123;
      operator delete(v125);
    }
    v107 = v321;
    if (v321)
    {
      v126 = v322;
      v109 = v321;
      if (v322 == v321)
        goto LABEL_337;
      do
      {
        v162 = *--v126;
        v161 = v162;
        *v126 = 0;
        if (v162)
          MEMORY[0x20BD002D4](v161, 0x1000C8077774924);
      }
      while (v126 != v107);
      goto LABEL_336;
    }
LABEL_338:
    v163 = v317;
    if (v317 == v320)
      return v1;
    goto LABEL_259;
  }
  return v1;
}

uint64_t mlir::mps::DepthwiseConv3DOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t Context;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t *Shape;
  int64_t v33;
  int64_t v34;
  uint64_t Int;
  unsigned int v36;
  BOOL v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  unsigned int v44;
  BOOL v45;
  unsigned int v46;
  BOOL v47;
  int64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  int64_t v55;
  int64_t v57;
  uint64_t v58;
  _QWORD *v59;
  int64_t v60;
  int64x2_t v61;
  int64x2_t v62;
  int64x2_t v63;
  int8x16_t *v64;
  int64x2_t v65;
  int64x2_t v66;
  int64x2_t v67;
  int64x2_t v68;
  unint64_t v69;
  int64x2_t v70;
  int64_t v71;
  uint64_t v73;
  uint64_t *v74;
  _QWORD *v75;
  int64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t NumElements;
  BOOL v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  BOOL v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  int64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  char *v104;
  unint64_t v105;
  _BYTE *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  __int128 v110;
  char *v111;
  unint64_t v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  _QWORD *v124;
  uint64_t v125;
  _QWORD *v126;
  uint64_t v127;
  uint64_t v128;
  BOOL v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  unsigned int v157;
  uint64_t *v158;
  _QWORD *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  _QWORD *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char v171[8];
  char v172;
  __int128 v173;
  __int128 v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  void *v182;
  uint64_t v183;
  _QWORD v184[5];
  void *v185;
  uint64_t v186;
  __int128 v187;
  __int128 v188;
  void *v189;
  uint64_t v190;
  _BYTE v191[24];
  void *v192;
  uint64_t v193;
  _BYTE v194[24];
  void *v195;
  uint64_t v196;
  _BYTE v197[48];
  void *v198;
  uint64_t v199;
  _BYTE v200[40];
  void *v201;
  uint64_t v202;
  _BYTE v203[40];
  unint64_t v204[2];
  _QWORD *v205;
  uint64_t v206;
  _QWORD v207[10];

  v207[8] = *MEMORY[0x24BDAC8D0];
  v180 = a4;
  v181 = a5;
  if (a7)
  {
    v14 = *a7;
    v15 = a7[1];
    v16 = *((_QWORD *)a7 + 4);
  }
  else
  {
    v16 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
  }
  v170 = a6;
  v171[0] = 0;
  v172 = 0;
  v173 = v14;
  v174 = v15;
  v175 = v16;
  v176 = a9;
  v17 = a5;
  v177 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v170);
    if (v172)
      v172 = 0;
    mlir::OperationName::OperationName(v171, "mps.depthwise_conv_3d", 21, Context);
    v172 = 1;
    v17 = v181;
  }
  v178 = a4;
  v179 = a5;
  if (v17 < 2
    || (v19 = mlir::UnknownLoc::get(this, a2), !mlir::mps::DepthwiseConv3DOpAdaptor::verify(&v170, v19)))
  {
    v31 = mlir::Float32Type::get(this, a2);
LABEL_24:
    v38 = mlir::UnrankedTensorType::get(v31);
    goto LABEL_25;
  }
  v20 = mlir::ValueRange::dereference_iterator(&v180, 0);
  v22 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v180, 1) + 8) & 0xFFFFFFFFFFFFFFF8;
  v23 = v173;
  v24 = v174;
  v25 = v175;
  v205 = (_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8);
  v21 = v205;
  v206 = v22;
  mlir::ValueRange::ValueRange(v204, (uint64_t)&v205, 2uLL);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8))
  {
    v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
    v164 = v21;
    v165 = v27;
    v28 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v22 + 8);
    if (v28)
      goto LABEL_12;
  }
  else
  {
    v164 = 0;
    v165 = 0;
    v28 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v22 + 8);
    if (v28)
    {
LABEL_12:
      v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v22 + 8);
      v162 = v22;
      v163 = v29;
      v30 = v164;
      if (!v164)
        goto LABEL_23;
      goto LABEL_17;
    }
  }
  v22 = 0;
  v162 = 0;
  v163 = v28;
  v30 = v164;
  if (!v164)
  {
LABEL_23:
    v31 = v26;
    goto LABEL_24;
  }
LABEL_17:
  if (*(_UNKNOWN **)(*v30 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || !v22
    || *(_UNKNOWN **)(*(_QWORD *)v22 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_23;
  }
  v201 = v203;
  v202 = 0x500000000;
  v198 = v200;
  v199 = 0x500000000;
  v195 = v197;
  v196 = 0x600000000;
  v192 = v194;
  v193 = 0x300000000;
  v189 = v191;
  v190 = 0x300000000;
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v164);
  v34 = v33;
  v168 = *((_QWORD *)&v23 + 1);
  v169 = v25;
  v166 = v23;
  v167 = v24;
  if ((_QWORD)v23)
  {
    Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v166);
    v36 = v196;
    v37 = v196 > 6;
    if ((_DWORD)v196 == 6)
      goto LABEL_34;
  }
  else
  {
    Int = -4;
    v36 = v196;
    v37 = v196 > 6;
    if ((_DWORD)v196 == 6)
      goto LABEL_34;
  }
  if (!v37)
  {
    if (HIDWORD(v196) > 5
      || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v195, v197, 6uLL, 8), v36 = v196, (_DWORD)v196 != 6))
    {
      bzero((char *)v195 + 8 * v36, 48 - 8 * v36);
    }
  }
  LODWORD(v196) = 6;
LABEL_34:
  v41 = v193;
  if ((_DWORD)v193 == 3)
  {
    v42 = v190;
    v43 = v190 > 3;
    if ((_DWORD)v190 == 3)
      goto LABEL_36;
  }
  else
  {
    if (v193 <= 3)
    {
      v50 = v193;
      v51 = v193;
      if (HIDWORD(v193) <= 2)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v192, v194, 3uLL, 8);
        v50 = v193;
        v51 = v193;
      }
      memset_pattern16((char *)v192 + 8 * v50, &unk_207A80400, 24 - 8 * v41);
      v49 = v51 - v41 + 3;
    }
    else
    {
      v49 = 3;
    }
    LODWORD(v193) = v49;
    v42 = v190;
    v43 = v190 > 3;
    if ((_DWORD)v190 == 3)
    {
LABEL_36:
      v44 = v202;
      v45 = v202 > 5;
      if ((_DWORD)v202 == 5)
        goto LABEL_37;
      goto LABEL_53;
    }
  }
  if (v43)
  {
    v52 = 3;
  }
  else
  {
    v53 = v42;
    v54 = v42;
    if (HIDWORD(v190) <= 2)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v191, 3uLL, 8);
      v53 = v190;
      v54 = v190;
    }
    memset_pattern16((char *)v189 + 8 * v53, &unk_207A80400, 24 - 8 * v42);
    v52 = v54 - v42 + 3;
  }
  LODWORD(v190) = v52;
  v44 = v202;
  v45 = v202 > 5;
  if ((_DWORD)v202 == 5)
  {
LABEL_37:
    v46 = v199;
    v47 = v199 > 5;
    if ((_DWORD)v199 == 5)
      goto LABEL_38;
    goto LABEL_58;
  }
LABEL_53:
  if (!v45)
  {
    if (HIDWORD(v202) > 4
      || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v201, v203, 5uLL, 8), v44 = v202, (_DWORD)v202 != 5))
    {
      bzero((char *)v201 + 8 * v44, 40 - 8 * v44);
    }
  }
  LODWORD(v202) = 5;
  v46 = v199;
  v47 = v199 > 5;
  if ((_DWORD)v199 == 5)
  {
LABEL_38:
    v48 = v34 - 4;
    if (v34 < 4)
      goto LABEL_98;
    goto LABEL_63;
  }
LABEL_58:
  if (!v47)
  {
    if (HIDWORD(v199) > 4
      || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v200, 5uLL, 8), v46 = v199, (_DWORD)v199 != 5))
    {
      bzero((char *)v198 + 8 * v46, 40 - 8 * v46);
    }
  }
  LODWORD(v199) = 5;
  v48 = v34 - 4;
  if (v34 >= 4)
  {
LABEL_63:
    v55 = (v34 & (Int >> 63)) + Int;
    if (v55 >= v34 || v55 < v48)
      v57 = v48;
    else
      v57 = (v34 & (Int >> 63)) + Int;
    if (v34 != 5)
    {
      if ((unint64_t)v34 >= 5)
      {
        if (v34 <= (unint64_t)HIDWORD(v199))
        {
          v58 = 5;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v200, v34, 8);
          v58 = v199;
        }
        if (v34 != v58)
          bzero((char *)v198 + 8 * v58, 8 * (v34 - v58));
      }
      LODWORD(v199) = v34;
    }
    v59 = v198;
    v60 = v34 & 0xFFFFFFFFFFFFFFFCLL;
    v61 = vdupq_n_s64(v57);
    v62 = vdupq_n_s64(v48);
    v63 = (int64x2_t)xmmword_207A80930;
    v64 = (int8x16_t *)((char *)v198 + 16);
    v65 = vdupq_n_s64(2uLL);
    v66 = vdupq_n_s64(1uLL);
    v67 = vdupq_n_s64(3uLL);
    v68 = vdupq_n_s64(4uLL);
    v69 = v34 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v70 = vaddq_s64(v63, v65);
      v64[-1] = vbslq_s8(vorrq_s8((int8x16_t)vcgtq_s64(v63, v61), (int8x16_t)vcgtq_s64(v62, v63)), (int8x16_t)v63, vbslq_s8((int8x16_t)vcgtq_s64(v61, v63), (int8x16_t)vaddq_s64(v63, v66), (int8x16_t)v62));
      *v64 = vbslq_s8(vorrq_s8((int8x16_t)vcgtq_s64(v70, v61), (int8x16_t)vcgtq_s64(v62, v70)), (int8x16_t)v70, vbslq_s8((int8x16_t)vcgtq_s64(v61, v70), (int8x16_t)vaddq_s64(v63, v67), (int8x16_t)v62));
      v63 = vaddq_s64(v63, v68);
      v64 += 2;
      v69 -= 4;
    }
    while (v69);
    for (; v34 != v60; ++v60)
    {
      if (v60 < v57)
        v71 = v60 + 1;
      else
        v71 = v48;
      if (v60 < v48 || v60 > v57)
        v71 = v60;
      v59[v60] = v71;
    }
    v73 = v202;
    if (v34 != v202)
    {
      if (v34 >= (unint64_t)v202)
      {
        if (v34 > (unint64_t)HIDWORD(v202))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v201, v203, v34, 8);
          v73 = v202;
        }
        if (v34 != v73)
          bzero((char *)v201 + 8 * v73, 8 * (v34 - v73));
      }
      LODWORD(v202) = v34;
    }
    v74 = (uint64_t *)v198;
    v75 = v201;
    v76 = v34;
    do
    {
      v78 = *Shape++;
      v77 = v78;
      v79 = *v74++;
      v75[v79] = v77;
      --v76;
    }
    while (v76);
  }
LABEL_98:
  if (v169 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v169) == 3)
  {
    LODWORD(v193) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v205, v169, 0);
    v80 = v169;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v169);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v182, v80, NumElements);
    while (1)
    {
      v82 = v205 == v182 && v206 == v183;
      if (v82 && v207[0] == v184[0])
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v205, (llvm::APInt *)&v185);
      if (v186 > 0x40)
        v83 = *(_QWORD *)v185;
      else
        v83 = (uint64_t)((_QWORD)v185 << -(uint64_t)v186) >> -(uint64_t)v186;
      v84 = v193;
      if (v193 >= (unint64_t)HIDWORD(v193))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v192, v194, v193 + 1, 8);
        v84 = v193;
      }
      *((_QWORD *)v192 + v84) = v83;
      LODWORD(v193) = v193 + 1;
      if (v186 >= 0x41 && v185)
        MEMORY[0x20BD002D4](v185, 0x1000C8000313F17);
      ++v207[0];
    }
  }
  if (*((_QWORD *)&v23 + 1) && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v168) == 3)
  {
    LODWORD(v190) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v205, v168, 0);
    v85 = v168;
    v86 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v168);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v182, v85, v86);
    while (1)
    {
      v87 = v205 == v182 && v206 == v183;
      if (v87 && v207[0] == v184[0])
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v205, (llvm::APInt *)&v185);
      if (v186 > 0x40)
        v88 = *(_QWORD *)v185;
      else
        v88 = (uint64_t)((_QWORD)v185 << -(uint64_t)v186) >> -(uint64_t)v186;
      v89 = v190;
      if (v190 >= (unint64_t)HIDWORD(v190))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v191, v190 + 1, 8);
        v89 = v190;
      }
      *((_QWORD *)v189 + v89) = v88;
      LODWORD(v190) = v190 + 1;
      if (v186 >= 0x41 && v185)
        MEMORY[0x20BD002D4](v185, 0x1000C8000313F17);
      ++v207[0];
    }
  }
  if ((_QWORD)v24 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v167) == 6)
  {
    LODWORD(v196) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v205, v167, 0);
    v90 = v167;
    v91 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v167);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v182, v90, v91);
    while (1)
    {
      v92 = v205 == v182 && v206 == v183;
      if (v92 && v207[0] == v184[0])
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v205, (llvm::APInt *)&v185);
      if (v186 > 0x40)
        v93 = *(_QWORD *)v185;
      else
        v93 = (uint64_t)((_QWORD)v185 << -(uint64_t)v186) >> -(uint64_t)v186;
      v94 = v196;
      if (v196 >= (unint64_t)HIDWORD(v196))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v195, v197, v196 + 1, 8);
        v94 = v196;
      }
      *((_QWORD *)v195 + v94) = v93;
      LODWORD(v196) = v196 + 1;
      if (v186 >= 0x41 && v185)
        MEMORY[0x20BD002D4](v185, 0x1000C8000313F17);
      ++v207[0];
    }
  }
  if (*((_QWORD *)&v24 + 1))
    v95 = *(_DWORD *)(*((_QWORD *)&v24 + 1) + 8);
  else
    v95 = 2;
  v96 = mlir::ShapedType::getShape((mlir::ShapedType *)&v162);
  v185 = &v187;
  v187 = 0u;
  v188 = 0u;
  v186 = 0x400000004;
  if (Int >= 0)
    v98 = v34;
  else
    v98 = 0;
  if (v97 == 4)
  {
    v99 = Int - v98 + 4;
    if (v99 <= 3)
    {
      *(_QWORD *)&v187 = *(_QWORD *)(v96 + 8 * v99);
      *((_QWORD *)&v187 + 1) = *(_QWORD *)(v96 + 8 * (v99 == 0));
      v100 = 8;
      if (v99 <= 1)
        v100 = 16;
      *(_QWORD *)&v188 = *(_QWORD *)(v96 + v100);
      v37 = v99 > 2;
      v101 = 24;
      if (v37)
        v101 = 16;
      *((_QWORD *)&v188 + 1) = *(_QWORD *)(v96 + v101);
    }
  }
  v182 = v184;
  v183 = 0x500000000;
  v102 = v202;
  v205 = v207;
  v206 = 0x800000000;
  if (!(_DWORD)v202)
  {
    v105 = -4;
    v106 = v201;
    v104 = (char *)v207;
LABEL_173:
    v107 = 0;
    if (v105 < 4 || (unint64_t)(v104 - v106) < 0x20)
      goto LABEL_178;
    v108 = 0;
    v107 = v105 & 0xFFFFFFFFFFFFFFFCLL;
    v109 = v105 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v110 = *(_OWORD *)&v106[v108 + 16];
      v111 = &v104[v108];
      *(_OWORD *)v111 = *(_OWORD *)&v106[v108];
      *((_OWORD *)v111 + 1) = v110;
      v108 += 32;
      v109 -= 4;
    }
    while (v109);
    while (v105 != v107)
    {
LABEL_178:
      *(_QWORD *)&v104[8 * v107] = *(_QWORD *)&v106[8 * v107];
      ++v107;
    }
    goto LABEL_179;
  }
  if (v202 < 9)
  {
    v103 = 0;
    v104 = (char *)v207;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v205, v207, v202, 8);
    v103 = v206;
    v104 = (char *)v205;
  }
  if (v102 != v103)
    bzero(&v104[8 * v103], 8 * (v102 - v103));
  LODWORD(v206) = v102;
  v106 = v201;
  v105 = v102 - 4;
  if (v102 != 4)
    goto LABEL_173;
LABEL_179:
  v112 = v102 - 3;
  v113 = v185;
  *(_QWORD *)&v104[8 * v105] = *(_QWORD *)v185;
  v114 = v192;
  if (v95 == 2 || v95 == 4)
  {
    v115 = *(_QWORD *)&v106[8 * v112];
    if (*(uint64_t *)v192 <= 1)
      v116 = 1;
    else
      v116 = *(_QWORD *)v192;
    v117 = *(_QWORD *)&v106[8 * v112];
    if ((unint64_t)v116 >= 2)
    {
      v117 = 0x8000000000000000;
      if (v115 != 0x8000000000000000)
      {
        v117 = v115 / v116;
        if (v115 / v116 * v116 != v115)
          v117 += v115 >= 0;
      }
    }
    *(_QWORD *)&v104[8 * v112] = v117;
    v118 = *(_QWORD *)&v106[8 * v102 - 16];
    if ((uint64_t)v114[1] <= 1)
      v119 = 1;
    else
      v119 = v114[1];
    v120 = *(_QWORD *)&v106[8 * v102 - 16];
    if ((unint64_t)v119 >= 2)
    {
      v120 = 0x8000000000000000;
      if (v118 != 0x8000000000000000)
      {
        v120 = v118 / v119;
        if (v118 / v119 * v119 != v118)
          v120 += v118 >= 0;
      }
    }
    *(_QWORD *)&v104[8 * v102 - 16] = v120;
    v121 = v102 - 1;
    v122 = *(_QWORD *)&v106[8 * v102 - 8];
    v123 = v114[2];
    if (v123 <= 1)
      v123 = 1;
    if ((unint64_t)v123 >= 2)
    {
      if (v122 == 0x8000000000000000)
      {
        v122 = 0x8000000000000000;
      }
      else if (v122 / v123 * v123 == v122)
      {
        v122 /= v123;
      }
      else
      {
        v122 = v122 / v123 + (v122 >= 0);
      }
    }
  }
  else
  {
    v124 = v189;
    v125 = *(_QWORD *)&v106[8 * v112];
    v126 = v195;
    v127 = v113[1];
    v128 = 0x8000000000000000;
    v129 = v127 == 0x8000000000000000 || v125 == 0x8000000000000000;
    v130 = 0x8000000000000000;
    if (!v129)
    {
      v131 = *((_QWORD *)v195 + 1) & ~(*((uint64_t *)v195 + 1) >> 63);
      v132 = *(_QWORD *)v195 & ~(*(uint64_t *)v195 >> 63);
      v133 = *(_QWORD *)v189;
      if (*(uint64_t *)v189 <= 1)
        v133 = 1;
      v134 = *(_QWORD *)v192;
      if (*(uint64_t *)v192 <= 1)
        v134 = 1;
      if (v95 == 1)
      {
        v131 = 0;
        v132 = 0;
      }
      v135 = v131 + v125 + v132 + v134 + ~(v133 * (v127 - 1));
      v136 = v135 / v134;
      if (v135 / v134 * v134 == v135)
        v137 = 0;
      else
        v137 = v135 >> 63;
      v130 = (v137 + v136) & ~((v137 + v136) >> 63);
    }
    *(_QWORD *)&v104[8 * v112] = v130;
    v138 = *(_QWORD *)&v106[8 * v102 - 16];
    v139 = v113[2];
    if (v139 != 0x8000000000000000 && v138 != 0x8000000000000000)
    {
      v141 = v126[3] & ~((uint64_t)v126[3] >> 63);
      v142 = v126[2] & ~((uint64_t)v126[2] >> 63);
      v143 = v124[1];
      if (v143 <= 1)
        v143 = 1;
      v144 = v114[1];
      if (v144 <= 1)
        v144 = 1;
      if (v95 == 1)
      {
        v141 = 0;
        v142 = 0;
      }
      v145 = v141 + v138 + v142 + v144 + ~(v143 * (v139 - 1));
      v146 = v145 / v144;
      if (v145 / v144 * v144 == v145)
        v147 = 0;
      else
        v147 = v145 >> 63;
      v128 = (v147 + v146) & ~((v147 + v146) >> 63);
    }
    *(_QWORD *)&v104[8 * v102 - 16] = v128;
    v121 = v102 - 1;
    v148 = v113[3];
    v122 = 0x8000000000000000;
    if (v148 != 0x8000000000000000)
    {
      v149 = *(_QWORD *)&v106[8 * v121];
      if (v149 != 0x8000000000000000)
      {
        v150 = v126[5] & ~((uint64_t)v126[5] >> 63);
        v151 = v126[4] & ~((uint64_t)v126[4] >> 63);
        v152 = v124[2];
        if (v152 <= 1)
          v152 = 1;
        v153 = v114[2];
        if (v153 <= 1)
          v153 = 1;
        if (v95 == 1)
        {
          v150 = 0;
          v151 = 0;
        }
        v154 = v150 + v149 + v151 + v153 + ~(v152 * (v148 - 1));
        v155 = v154 / v153;
        if (v154 / v153 * v153 == v154)
          v156 = 0;
        else
          v156 = v154 >> 63;
        v122 = (v156 + v155) & ~((v156 + v155) >> 63);
      }
    }
  }
  *(_QWORD *)&v104[8 * v121] = v122;
  v157 = v183;
  if ((_DWORD)v183 != (_DWORD)v102)
  {
    if (v183 <= v102)
    {
      if (HIDWORD(v183) < v102)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v182, v184, v102, 8);
        v157 = v183;
      }
      if (v157 != (_DWORD)v102)
        bzero((char *)v182 + 8 * v157, 8 * (v102 - v157));
    }
    LODWORD(v183) = v102;
    v104 = (char *)v205;
  }
  if ((_DWORD)v102)
  {
    v158 = (uint64_t *)v198;
    v159 = v182;
    v160 = v102;
    do
    {
      v161 = *v158++;
      *v159++ = *(_QWORD *)&v104[8 * v161];
      --v160;
    }
    while (v160);
  }
  if (v104 != (char *)v207)
  {
    free(v104);
    v102 = v183;
  }
  v38 = mlir::RankedTensorType::get((uint64_t)v182, v102, v26, 0);
  if (v182 != v184)
    free(v182);
  if (v185 != &v187)
    free(v185);
  if (v189 != v191)
    free(v189);
  if (v192 != v194)
    free(v192);
  if (v195 != v197)
    free(v195);
  if (v198 != v200)
    free(v198);
  if (v201 != v203)
    free(v201);
LABEL_25:
  v39 = *(_DWORD *)(a11 + 8);
  if (v39 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v39 + 1, 8);
    v39 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v39) = v38;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::DepthwiseConv3DOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  _QWORD *Type;
  _QWORD *v9;
  _QWORD *Shape;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  const char *v62;
  uint64_t Value;
  uint64_t v64;
  uint64_t OperandRange;
  const char *v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  void *v72;
  _BYTE v73[96];
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD *v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v3 = (const char *)a1[4];
  if (v3)
  {
    v4 = (const char *)a1[5];
    if (v4)
    {
      if (a1[6])
      {
        v5 = (const char *)a1[7];
        if (v5)
        {
          v6 = (const char *)a1[3];
          v7 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
          v66 = v5;
          v67 = v7;
          Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
          v9 = Type;
          if (Type)
            Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
          v70 = (uint64_t)v9;
          v71 = Type;
          Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v70);
          v69 = 3;
          if (v11 == 1 && *Shape == v69)
          {
            v62 = v5;
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62);
            v64 = v12;
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
            {
              v13 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
              v66 = v3;
              v67 = v13;
              v14 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
              v15 = v14;
              if (v14)
                v14 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v14 + 8);
              v70 = (uint64_t)v15;
              v71 = v14;
              v16 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v70);
              v69 = 3;
              if (v17 == 1
                && *v16 == v69
                && (v62 = v3,
                    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                    v64 = v18,
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
              {
                v19 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                v66 = v4;
                v67 = v19;
                v20 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
                v21 = v20;
                if (v20)
                  v20 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
                v70 = (uint64_t)v21;
                v71 = v20;
                v22 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v70);
                v69 = 6;
                if (v23 == 1
                  && *v22 == v69
                  && (v62 = v4,
                      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                      v64 = v24,
                      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                {
                  if (!v6)
                    return 1;
                  v66 = v6;
                  v70 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v66);
                  if (mlir::Type::isSignedInteger((mlir::Type *)&v70, 32))
                    return 1;
                  v61 = "'mps.depthwise_conv_3d' op attribute 'channelAxis' failed to satisfy constraint: 32-bit signed i"
                        "nteger attribute";
                }
                else
                {
                  v61 = "'mps.depthwise_conv_3d' op attribute 'explicit_padding' failed to satisfy constraint: ui64 eleme"
                        "nts attribute of shape {6}";
                }
              }
              else
              {
                v61 = "'mps.depthwise_conv_3d' op attribute 'dilation_rates' failed to satisfy constraint: ui64 elements "
                      "attribute of shape {3}";
              }
              v66 = v61;
              v68 = 259;
              mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
              v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v70);
              return v25;
            }
          }
          v66 = "'mps.depthwise_conv_3d' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {3}";
          v68 = 259;
          mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
          if (v70)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
          if (v78)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v77;
              v48 = __p;
              if (v77 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v77 = v46;
              operator delete(v48);
            }
            v29 = v74;
            if (!v74)
              goto LABEL_81;
            v49 = v75;
            v31 = v74;
            if (v75 == v74)
            {
LABEL_80:
              v75 = v29;
              operator delete(v31);
LABEL_81:
              if (v72 != v73)
                free(v72);
              return v25;
            }
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
LABEL_79:
            v31 = v74;
            goto LABEL_80;
          }
        }
        else
        {
          v66 = "'mps.depthwise_conv_3d' op requires attribute 'strides'";
          v68 = 259;
          mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
          if (v70)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
          if (v78)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v77;
              v54 = __p;
              if (v77 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v77 = v52;
              operator delete(v54);
            }
            v55 = v74;
            if (v74)
            {
              v56 = v75;
              v57 = v74;
              if (v75 != v74)
              {
                do
                {
                  v59 = *--v56;
                  v58 = v59;
                  *v56 = 0;
                  if (v59)
                    MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
                }
                while (v56 != v55);
                v57 = v74;
              }
              v75 = v55;
              operator delete(v57);
            }
            if (v72 != v73)
              free(v72);
          }
        }
      }
      else
      {
        v66 = "'mps.depthwise_conv_3d' op requires attribute 'padding_style'";
        v68 = 259;
        mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
        if (v70)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
        if (v78)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v77;
            v42 = __p;
            if (v77 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v77 = v40;
            operator delete(v42);
          }
          v29 = v74;
          if (!v74)
            goto LABEL_81;
          v43 = v75;
          v31 = v74;
          if (v75 == v74)
            goto LABEL_80;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_79;
        }
      }
    }
    else
    {
      v66 = "'mps.depthwise_conv_3d' op requires attribute 'explicit_padding'";
      v68 = 259;
      mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
      if (v70)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
      if (v78)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v77;
          v36 = __p;
          if (v77 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v77 = v34;
          operator delete(v36);
        }
        v29 = v74;
        if (!v74)
          goto LABEL_81;
        v37 = v75;
        v31 = v74;
        if (v75 == v74)
          goto LABEL_80;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_79;
      }
    }
  }
  else
  {
    v66 = "'mps.depthwise_conv_3d' op requires attribute 'dilation_rates'";
    v68 = 259;
    mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
    if (v70)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
    if (v78)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v77;
        v28 = __p;
        if (v77 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v77 = v26;
        operator delete(v28);
      }
      v29 = v74;
      if (!v74)
        goto LABEL_81;
      v30 = v75;
      v31 = v74;
      if (v75 == v74)
        goto LABEL_80;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_79;
    }
  }
  return v25;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::verify(mlir::mps::DepthwiseConv3DDataGradientOp *this)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t NumElements;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  int64_t v36;
  int64_t v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  __int128 v46;
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  __int128 v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  BOOL v62;
  int64_t v63;
  int64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  __int128 v73;
  uint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  __int128 v78;
  _QWORD *v79;
  _QWORD *v80;
  void *v81;
  _QWORD *v82;
  _QWORD *v83;
  void *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  BOOL v89;
  int64_t v90;
  int64_t v91;
  uint64_t v92;
  unint64_t v93;
  void *v94;
  uint64_t v95;
  const char *v96;
  const void ***v97;
  char *v98;
  char *v99;
  __int128 v100;
  uint64_t v101;
  const void ***v102;
  char *v103;
  char *v104;
  __int128 v105;
  _QWORD *v106;
  _QWORD *v107;
  void *v108;
  _QWORD *v109;
  _QWORD *v110;
  void *v111;
  unint64_t v112;
  void *v113;
  uint64_t v114;
  const char *v115;
  const void ***v116;
  char *v117;
  char *v118;
  __int128 v119;
  uint64_t v120;
  const void ***v121;
  char *v122;
  char *v123;
  __int128 v124;
  _QWORD *v125;
  _QWORD *v126;
  void *v127;
  _QWORD *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  const char *v135;
  const void ***v136;
  char *v137;
  char *v138;
  __int128 v139;
  uint64_t v140;
  const void ***v141;
  char *v142;
  char *v143;
  __int128 v144;
  uint64_t v145;
  const void ***v146;
  char *v147;
  char *v148;
  __int128 v149;
  uint64_t v150;
  const void ***v151;
  char *v152;
  char *v153;
  __int128 v154;
  _QWORD *v155;
  _QWORD *v156;
  void *v157;
  _QWORD *v158;
  _QWORD *v159;
  void *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  void *v165;
  const char *v167;
  const void ***v168;
  char *v169;
  char *v170;
  __int128 v171;
  uint64_t v172;
  const void ***v173;
  char *v174;
  char *v175;
  __int128 v176;
  uint64_t v177;
  const void ***v178;
  char *v179;
  char *v180;
  __int128 v181;
  uint64_t v182;
  const void ***v183;
  char *v184;
  char *v185;
  __int128 v186;
  _QWORD *v187;
  _QWORD *v188;
  void *v189;
  _QWORD *v190;
  uint64_t v191;
  uint64_t v192;
  const void ***v193;
  char *v194;
  char *v195;
  __int128 v196;
  uint64_t v197;
  const void ***v198;
  char *v199;
  char *v200;
  __int128 v201;
  uint64_t v202;
  const void ***v203;
  char *v204;
  char *v205;
  __int128 v206;
  _QWORD *v207;
  _QWORD *v208;
  void *v209;
  _QWORD *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  const void ***v214;
  char *v215;
  char *v216;
  __int128 v217;
  uint64_t v218;
  const void ***v219;
  char *v220;
  char *v221;
  __int128 v222;
  uint64_t v223;
  const void ***v224;
  char *v225;
  char *v226;
  __int128 v227;
  uint64_t v228;
  const void ***v229;
  char *v230;
  char *v231;
  __int128 v232;
  _QWORD *v233;
  _QWORD *v234;
  void *v235;
  _QWORD *v236;
  uint64_t v237;
  uint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  unint64_t v244;
  BOOL v245;
  unint64_t v246;
  BOOL v247;
  unint64_t v248;
  BOOL v249;
  unint64_t v250;
  BOOL v251;
  unint64_t v252;
  BOOL v253;
  unint64_t v254;
  BOOL v255;
  unint64_t v256;
  BOOL v257;
  unint64_t v258;
  unint64_t v259;
  BOOL v260;
  unint64_t v261;
  BOOL v262;
  unint64_t v263;
  BOOL v264;
  unint64_t v265;
  BOOL v266;
  unint64_t v267;
  BOOL v268;
  unint64_t v269;
  BOOL v270;
  int64_t v271;
  int64_t v272;
  int64_t v273;
  int64_t v274;
  int64_t v275;
  int64_t v276;
  int64_t v277;
  int64_t v278;
  int64_t v279;
  int64_t v280;
  int64_t v281;
  int64_t v282;
  int64_t v283;
  int64_t v284;
  int64_t v285;
  int64_t v286;
  int64_t v287;
  int64_t v288;
  int64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  const void **v296;
  const char *v297;
  uint64_t v298;
  __int16 v299;
  unint64_t v300;
  unint64_t v301;
  unsigned int v302;
  const void **v303;
  const char *v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t *v309;
  uint64_t v310;
  const char *v311;
  uint64_t v312;
  void *v313;
  uint64_t v314;
  _BYTE v315[16];
  __int16 v316;
  uint64_t *v317;
  unsigned int v318;
  void *v319;
  unsigned int v320;
  unsigned int v321;
  _BYTE v322[96];
  void *v323;
  _QWORD *v324;
  void *__p;
  _QWORD *v326;
  char v327;
  uint64_t v328;

  v328 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)this;
  v3 = *(_DWORD *)(*(_QWORD *)this + 44);
  v4 = *(_QWORD **)(*(_QWORD *)this + 72);
  v5 = v4[3];
  v6 = v4[7];
  if (*(_DWORD *)(*(_QWORD *)this + 68) == 2)
    v7 = 0;
  else
    v7 = v4[11];
  v309 = *(uint64_t **)this;
  v8 = (_QWORD *)(v2 + 80);
  if (!HIBYTE(v3))
    v8 = 0;
  v9 = v8[4];
  v11 = v8[1];
  v10 = v8[2];
  v307 = v11;
  v308 = v9;
  v306 = v10;
  if (v9 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v308) == 3)
  {
    v290 = v5;
    v293 = v7;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v296, v308, 0);
    v1 = v308;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v308);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v303, v1, NumElements);
    while (1)
    {
      v13 = v296 == v303 && v297 == v304;
      if (v13 && v298 == v305)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v296, (llvm::APInt *)&v301);
      if (v302 > 0x40)
      {
        v14 = *(_QWORD *)v301;
        if (*(uint64_t *)v301 > 0)
        {
LABEL_21:
          if (v302 < 0x41)
            goto LABEL_51;
LABEL_49:
          if (v301)
            MEMORY[0x20BD002D4](v301, 0x1000C8000313F17);
          goto LABEL_51;
        }
      }
      else
      {
        v14 = (uint64_t)(v301 << -(char)v302) >> -(char)v302;
        if (v14 > 0)
          goto LABEL_21;
      }
      v316 = 259;
      mlir::OpState::emitOpError(&v309, (const void ***)&v313, (uint64_t)&v317);
      if (v302 > 0x40)
      {
        v15 = *(_QWORD *)v301;
        if (!v317)
          goto LABEL_30;
      }
      else
      {
        v15 = (uint64_t)(v301 << -(char)v302) >> -(char)v302;
        if (!v317)
          goto LABEL_30;
      }
      LODWORD(v310) = 2;
      v311 = (const char *)v15;
      v16 = (char *)v319;
      if (v320 >= v321)
      {
        v33 = v320 + 1;
        if (v319 <= &v310 && (char *)v319 + 24 * v320 > (char *)&v310)
        {
          v36 = (char *)&v310 - (_BYTE *)v319;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v33, 24);
          v16 = (char *)v319;
          v17 = (char *)v319 + v36;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v33, 24);
          v17 = (char *)&v310;
          v16 = (char *)v319;
        }
      }
      else
      {
        v17 = (char *)&v310;
      }
      v18 = &v16[24 * v320];
      v19 = *(_OWORD *)v17;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v17 + 2);
      *(_OWORD *)v18 = v19;
      v20 = ++v320;
      if (v317)
      {
        LODWORD(v310) = 3;
        v311 = ", all values should be positive.";
        v312 = 32;
        v21 = (char *)v319;
        if (v20 >= v321)
        {
          v34 = v20 + 1;
          v35 = (char *)v319 + 24 * v20 > (char *)&v310;
          if (v319 <= &v310 && v35)
          {
            v37 = (char *)&v310 - (_BYTE *)v319;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v34, 24);
            v21 = (char *)v319;
            v22 = (char *)v319 + v37;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v34, 24);
            v22 = (char *)&v310;
            v21 = (char *)v319;
          }
        }
        else
        {
          v22 = (char *)&v310;
        }
        v23 = &v21[24 * v320];
        v24 = *(_OWORD *)v22;
        *((_QWORD *)v23 + 2) = *((_QWORD *)v22 + 2);
        *(_OWORD *)v23 = v24;
        ++v320;
      }
LABEL_30:
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
      if (v317)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
      if (v327)
      {
        v25 = __p;
        if (__p)
        {
          v26 = v326;
          v27 = __p;
          if (v326 != __p)
          {
            do
              v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
            while (v26 != v25);
            v27 = __p;
          }
          v326 = v25;
          operator delete(v27);
        }
        v28 = v323;
        if (v323)
        {
          v29 = v324;
          v30 = v323;
          if (v324 != v323)
          {
            do
            {
              v32 = *--v29;
              v31 = v32;
              *v29 = 0;
              if (v32)
                MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
            }
            while (v29 != v28);
            v30 = v323;
          }
          v324 = v28;
          operator delete(v30);
        }
        if (v319 != v322)
          free(v319);
      }
      if (v302 >= 0x41)
        goto LABEL_49;
LABEL_51:
      if (v14 < 1)
        return v1;
      ++v298;
    }
    v7 = v293;
    v5 = v290;
    if (!v307)
      goto LABEL_119;
LABEL_62:
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v307) == 3)
    {
      v291 = v5;
      v294 = v7;
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v296, v307, 0);
      v38 = v307;
      v39 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v307);
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v303, v38, v39);
      while (1)
      {
        v40 = v296 == v303 && v297 == v304;
        if (v40 && v298 == v305)
        {
          v7 = v294;
          v5 = v291;
          break;
        }
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v296, (llvm::APInt *)&v301);
        if (v302 > 0x40)
        {
          v41 = *(_QWORD *)v301;
          if (*(uint64_t *)v301 > 0)
          {
LABEL_76:
            if (v302 < 0x41)
              goto LABEL_106;
LABEL_104:
            if (v301)
              MEMORY[0x20BD002D4](v301, 0x1000C8000313F17);
            goto LABEL_106;
          }
        }
        else
        {
          v41 = (uint64_t)(v301 << -(char)v302) >> -(char)v302;
          if (v41 > 0)
            goto LABEL_76;
        }
        v316 = 259;
        mlir::OpState::emitOpError(&v309, (const void ***)&v313, (uint64_t)&v317);
        if (v302 > 0x40)
        {
          v42 = *(_QWORD *)v301;
          if (!v317)
            goto LABEL_85;
        }
        else
        {
          v42 = (uint64_t)(v301 << -(char)v302) >> -(char)v302;
          if (!v317)
            goto LABEL_85;
        }
        LODWORD(v310) = 2;
        v311 = (const char *)v42;
        v43 = (char *)v319;
        if (v320 >= v321)
        {
          v60 = v320 + 1;
          if (v319 <= &v310 && (char *)v319 + 24 * v320 > (char *)&v310)
          {
            v63 = (char *)&v310 - (_BYTE *)v319;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v60, 24);
            v43 = (char *)v319;
            v44 = (char *)v319 + v63;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v60, 24);
            v44 = (char *)&v310;
            v43 = (char *)v319;
          }
        }
        else
        {
          v44 = (char *)&v310;
        }
        v45 = &v43[24 * v320];
        v46 = *(_OWORD *)v44;
        *((_QWORD *)v45 + 2) = *((_QWORD *)v44 + 2);
        *(_OWORD *)v45 = v46;
        v47 = ++v320;
        if (v317)
        {
          LODWORD(v310) = 3;
          v311 = ", all values should be positive.";
          v312 = 32;
          v48 = (char *)v319;
          if (v47 >= v321)
          {
            v61 = v47 + 1;
            v62 = (char *)v319 + 24 * v47 > (char *)&v310;
            if (v319 <= &v310 && v62)
            {
              v64 = (char *)&v310 - (_BYTE *)v319;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v61, 24);
              v48 = (char *)v319;
              v49 = (char *)v319 + v64;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v61, 24);
              v49 = (char *)&v310;
              v48 = (char *)v319;
            }
          }
          else
          {
            v49 = (char *)&v310;
          }
          v50 = &v48[24 * v320];
          v51 = *(_OWORD *)v49;
          *((_QWORD *)v50 + 2) = *((_QWORD *)v49 + 2);
          *(_OWORD *)v50 = v51;
          ++v320;
        }
LABEL_85:
        v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
        if (v317)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
        if (v327)
        {
          v52 = __p;
          if (__p)
          {
            v53 = v326;
            v54 = __p;
            if (v326 != __p)
            {
              do
                v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
              while (v53 != v52);
              v54 = __p;
            }
            v326 = v52;
            operator delete(v54);
          }
          v55 = v323;
          if (v323)
          {
            v56 = v324;
            v57 = v323;
            if (v324 != v323)
            {
              do
              {
                v59 = *--v56;
                v58 = v59;
                *v56 = 0;
                if (v59)
                  MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
              }
              while (v56 != v55);
              v57 = v323;
            }
            v324 = v55;
            operator delete(v57);
          }
          if (v319 != v322)
            free(v319);
        }
        if (v302 >= 0x41)
          goto LABEL_104;
LABEL_106:
        if (v41 < 1)
          return v1;
        ++v298;
      }
    }
  }
  else if (v307)
  {
    goto LABEL_62;
  }
LABEL_119:
  if (v306 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v306) == 6)
  {
    v292 = v5;
    v295 = v7;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v296, v306, 0);
    v65 = v306;
    v66 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v306);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v303, v65, v66);
    while (1)
    {
      v67 = v296 == v303 && v297 == v304;
      if (v67 && v298 == v305)
      {
        v7 = v295;
        v5 = v292;
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v296, (llvm::APInt *)&v301);
      if (v302 > 0x40)
      {
        v68 = *(_QWORD *)v301;
        if ((*(_QWORD *)v301 & 0x8000000000000000) == 0)
        {
LABEL_134:
          if (v302 < 0x41)
            goto LABEL_164;
LABEL_162:
          if (v301)
            MEMORY[0x20BD002D4](v301, 0x1000C8000313F17);
          goto LABEL_164;
        }
      }
      else
      {
        v68 = (uint64_t)(v301 << -(char)v302) >> -(char)v302;
        if ((v68 & 0x8000000000000000) == 0)
          goto LABEL_134;
      }
      v316 = 259;
      mlir::OpState::emitOpError(&v309, (const void ***)&v313, (uint64_t)&v317);
      if (v302 > 0x40)
      {
        v69 = *(_QWORD *)v301;
        if (!v317)
          goto LABEL_143;
      }
      else
      {
        v69 = (uint64_t)(v301 << -(char)v302) >> -(char)v302;
        if (!v317)
          goto LABEL_143;
      }
      LODWORD(v310) = 2;
      v311 = (const char *)v69;
      v70 = (char *)v319;
      if (v320 >= v321)
      {
        v87 = v320 + 1;
        if (v319 <= &v310 && (char *)v319 + 24 * v320 > (char *)&v310)
        {
          v90 = (char *)&v310 - (_BYTE *)v319;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v87, 24);
          v70 = (char *)v319;
          v71 = (char *)v319 + v90;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v87, 24);
          v71 = (char *)&v310;
          v70 = (char *)v319;
        }
      }
      else
      {
        v71 = (char *)&v310;
      }
      v72 = &v70[24 * v320];
      v73 = *(_OWORD *)v71;
      *((_QWORD *)v72 + 2) = *((_QWORD *)v71 + 2);
      *(_OWORD *)v72 = v73;
      v74 = ++v320;
      if (v317)
      {
        LODWORD(v310) = 3;
        v311 = ", all values should be non-negative.";
        v312 = 36;
        v75 = (char *)v319;
        if (v74 >= v321)
        {
          v88 = v74 + 1;
          v89 = (char *)v319 + 24 * v74 > (char *)&v310;
          if (v319 <= &v310 && v89)
          {
            v91 = (char *)&v310 - (_BYTE *)v319;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v88, 24);
            v75 = (char *)v319;
            v76 = (char *)v319 + v91;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v88, 24);
            v76 = (char *)&v310;
            v75 = (char *)v319;
          }
        }
        else
        {
          v76 = (char *)&v310;
        }
        v77 = &v75[24 * v320];
        v78 = *(_OWORD *)v76;
        *((_QWORD *)v77 + 2) = *((_QWORD *)v76 + 2);
        *(_OWORD *)v77 = v78;
        ++v320;
      }
LABEL_143:
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
      if (v317)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
      if (v327)
      {
        v79 = __p;
        if (__p)
        {
          v80 = v326;
          v81 = __p;
          if (v326 != __p)
          {
            do
              v80 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v80 - 1);
            while (v80 != v79);
            v81 = __p;
          }
          v326 = v79;
          operator delete(v81);
        }
        v82 = v323;
        if (v323)
        {
          v83 = v324;
          v84 = v323;
          if (v324 != v323)
          {
            do
            {
              v86 = *--v83;
              v85 = v86;
              *v83 = 0;
              if (v86)
                MEMORY[0x20BD002D4](v85, 0x1000C8077774924);
            }
            while (v83 != v82);
            v84 = v323;
          }
          v324 = v82;
          operator delete(v84);
        }
        if (v319 != v322)
          free(v319);
      }
      if (v302 >= 0x41)
        goto LABEL_162;
LABEL_164:
      if (v68 < 0)
        return v1;
      ++v298;
    }
  }
  v313 = (void *)v309[2 * (((unint64_t)*((unsigned int *)v309 + 11) >> 23) & 1) + 8];
  mlir::IntegerAttr::getValue(&v313, (llvm::APInt *)&v317);
  if (v318 > 0x40)
  {
    v92 = *v317;
    MEMORY[0x20BD002D4]();
    v310 = 0;
    if (!v5)
    {
LABEL_200:
      v301 = 0;
      goto LABEL_201;
    }
  }
  else
  {
    v92 = (uint64_t)((_QWORD)v317 << -(uint64_t)v318) >> -(uint64_t)v318;
    v310 = 0;
    if (!v5)
      goto LABEL_200;
  }
  v93 = *(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v93)
    goto LABEL_200;
  v94 = *(void **)(*(_QWORD *)v93 + 136);
  if (v94 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v93 = 0;
  v301 = v93;
  if (v94 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v301);
    v96 = (const char *)v95;
    if (v95 <= 3)
    {
      v316 = 259;
      mlir::OpState::emitOpError(&v309, (const void ***)&v313, (uint64_t)&v317);
      if (v317)
      {
        LODWORD(v296) = 2;
        v297 = v96;
        v97 = &v296;
        v98 = (char *)v319;
        if (v320 >= v321)
        {
          v241 = v320 + 1;
          if (v319 <= &v296 && (char *)v319 + 24 * v320 > (char *)&v296)
          {
            v273 = (char *)&v296 - (_BYTE *)v319;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v241, 24);
            v98 = (char *)v319;
            v97 = (const void ***)((char *)v319 + v273);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v241, 24);
            v97 = &v296;
            v98 = (char *)v319;
          }
        }
        v99 = &v98[24 * v320];
        v100 = *(_OWORD *)v97;
        *((_QWORD *)v99 + 2) = v97[2];
        *(_OWORD *)v99 = v100;
        v101 = ++v320;
        if (v317)
        {
          LODWORD(v296) = 3;
          v297 = ".";
          v298 = 1;
          v102 = &v296;
          v103 = (char *)v319;
          if (v101 >= v321)
          {
            v248 = v101 + 1;
            v249 = (char *)v319 + 24 * v101 > (char *)&v296;
            if (v319 <= &v296 && v249)
            {
              v278 = (char *)&v296 - (_BYTE *)v319;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v248, 24);
              v103 = (char *)v319;
              v102 = (const void ***)((char *)v319 + v278);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v248, 24);
              v102 = &v296;
              v103 = (char *)v319;
            }
          }
          v104 = &v103[24 * v320];
          v105 = *(_OWORD *)v102;
          *((_QWORD *)v104 + 2) = v102[2];
          *(_OWORD *)v104 = v105;
          ++v320;
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
      if (v317)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
      if (!v327)
        return v1;
      v106 = __p;
      if (__p)
      {
        v107 = v326;
        v108 = __p;
        if (v326 != __p)
        {
          do
            v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          v108 = __p;
        }
        v326 = v106;
        operator delete(v108);
      }
      v109 = v323;
      if (!v323)
        goto LABEL_341;
      v110 = v324;
      v111 = v323;
      if (v324 == v323)
        goto LABEL_340;
      do
      {
        v130 = *--v110;
        v129 = v130;
        *v110 = 0;
        if (v130)
          MEMORY[0x20BD002D4](v129, 0x1000C8077774924);
      }
      while (v110 != v109);
      goto LABEL_339;
    }
    if ((v92 & 0x80000000) != 0)
      v213 = 0;
    else
      v213 = v95;
    if ((unint64_t)((int)v92 - v213) <= 0xFFFFFFFFFFFFFFFBLL)
    {
      v316 = 259;
      mlir::OpState::emitOpError(&v309, (const void ***)&v313, (uint64_t)&v317);
      if (v317)
      {
        LODWORD(v296) = 2;
        v297 = (const char *)(int)v92;
        v214 = &v296;
        v215 = (char *)v319;
        if (v320 >= v321)
        {
          v258 = v320 + 1;
          if (v319 <= &v296 && (char *)v319 + 24 * v320 > (char *)&v296)
          {
            v283 = (char *)&v296 - (_BYTE *)v319;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v258, 24);
            v215 = (char *)v319;
            v214 = (const void ***)((char *)v319 + v283);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v258, 24);
            v214 = &v296;
            v215 = (char *)v319;
          }
        }
        v216 = &v215[24 * v320];
        v217 = *(_OWORD *)v214;
        *((_QWORD *)v216 + 2) = v214[2];
        *(_OWORD *)v216 = v217;
        v218 = ++v320;
        if (v317)
        {
          LODWORD(v296) = 3;
          v297 = " for input gradient rank ";
          v298 = 25;
          v219 = &v296;
          v220 = (char *)v319;
          if (v218 >= v321)
          {
            v263 = v218 + 1;
            v264 = (char *)v319 + 24 * v218 > (char *)&v296;
            if (v319 <= &v296 && v264)
            {
              v286 = (char *)&v296 - (_BYTE *)v319;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v263, 24);
              v220 = (char *)v319;
              v219 = (const void ***)((char *)v319 + v286);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v263, 24);
              v219 = &v296;
              v220 = (char *)v319;
            }
          }
          v221 = &v220[24 * v320];
          v222 = *(_OWORD *)v219;
          *((_QWORD *)v221 + 2) = v219[2];
          *(_OWORD *)v221 = v222;
          v223 = ++v320;
          if (v317)
          {
            LODWORD(v296) = 2;
            v297 = v96;
            v224 = &v296;
            v225 = (char *)v319;
            if (v223 >= v321)
            {
              v267 = v223 + 1;
              v268 = (char *)v319 + 24 * v223 > (char *)&v296;
              if (v319 <= &v296 && v268)
              {
                v288 = (char *)&v296 - (_BYTE *)v319;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v267, 24);
                v225 = (char *)v319;
                v224 = (const void ***)((char *)v319 + v288);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v267, 24);
                v224 = &v296;
                v225 = (char *)v319;
              }
            }
            v226 = &v225[24 * v320];
            v227 = *(_OWORD *)v224;
            *((_QWORD *)v226 + 2) = v224[2];
            *(_OWORD *)v226 = v227;
            v228 = ++v320;
            if (v317)
            {
              LODWORD(v296) = 3;
              v297 = ".";
              v298 = 1;
              v229 = &v296;
              v230 = (char *)v319;
              if (v228 >= v321)
              {
                v269 = v228 + 1;
                v270 = (char *)v319 + 24 * v228 > (char *)&v296;
                if (v319 <= &v296 && v270)
                {
                  v289 = (char *)&v296 - (_BYTE *)v319;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v269, 24);
                  v230 = (char *)v319;
                  v229 = (const void ***)((char *)v319 + v289);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v269, 24);
                  v229 = &v296;
                  v230 = (char *)v319;
                }
              }
              v231 = &v230[24 * v320];
              v232 = *(_OWORD *)v229;
              *((_QWORD *)v231 + 2) = v229[2];
              *(_OWORD *)v231 = v232;
              ++v320;
            }
          }
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
      if (v317)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
      if (!v327)
        return v1;
      v233 = __p;
      if (__p)
      {
        v234 = v326;
        v235 = __p;
        if (v326 != __p)
        {
          do
            v234 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v234 - 1);
          while (v234 != v233);
          v235 = __p;
        }
        v326 = v233;
        operator delete(v235);
      }
      v109 = v323;
      if (!v323)
        goto LABEL_341;
      v236 = v324;
      v111 = v323;
      if (v324 == v323)
        goto LABEL_340;
      do
      {
        v238 = *--v236;
        v237 = v238;
        *v236 = 0;
        if (v238)
          MEMORY[0x20BD002D4](v237, 0x1000C8077774924);
      }
      while (v236 != v109);
LABEL_339:
      v111 = v323;
LABEL_340:
      v324 = v109;
      operator delete(v111);
      goto LABEL_341;
    }
  }
LABEL_201:
  if (!v6 || (v112 = *(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    v300 = 0;
    goto LABEL_227;
  }
  v113 = *(void **)(*(_QWORD *)v112 + 136);
  if (v113 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v112 = 0;
  v300 = v112;
  if (v113 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || (mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v300), v114 == 4))
  {
LABEL_227:
    v313 = v315;
    v314 = 0x500000000;
    if (mlir::matchConstantWithIntVector<long long>(v7, (uint64_t)&v313))
    {
      if (v6)
      {
        if (v310)
        {
          v131 = v314;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v310);
          if (v132 != v131)
          {
            v299 = 259;
            mlir::OpState::emitOpError(&v309, &v296, (uint64_t)&v317);
            mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v310);
            if (v317)
            {
              LODWORD(v303) = 5;
              v304 = v167;
              v168 = &v303;
              v169 = (char *)v319;
              if (v320 >= v321)
              {
                v239 = v320 + 1;
                if (v319 <= &v303 && (char *)v319 + 24 * v320 > (char *)&v303)
                {
                  v271 = (char *)&v303 - (_BYTE *)v319;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v239, 24);
                  v169 = (char *)v319;
                  v168 = (const void ***)((char *)v319 + v271);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v239, 24);
                  v168 = &v303;
                  v169 = (char *)v319;
                }
              }
              v170 = &v169[24 * v320];
              v171 = *(_OWORD *)v168;
              *((_QWORD *)v170 + 2) = v168[2];
              *(_OWORD *)v170 = v171;
              v172 = ++v320;
              if (v317)
              {
                LODWORD(v303) = 3;
                v305 = 35;
                v173 = &v303;
                v174 = (char *)v319;
                if (v172 >= v321)
                {
                  v244 = v172 + 1;
                  v245 = (char *)v319 + 24 * v172 > (char *)&v303;
                  if (v319 <= &v303 && v245)
                  {
                    v276 = (char *)&v303 - (_BYTE *)v319;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v244, 24);
                    v174 = (char *)v319;
                    v173 = (const void ***)((char *)v319 + v276);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v244, 24);
                    v173 = &v303;
                    v174 = (char *)v319;
                  }
                }
                v175 = &v174[24 * v320];
                v176 = *(_OWORD *)v173;
                *((_QWORD *)v175 + 2) = v173[2];
                *(_OWORD *)v175 = v176;
                v177 = ++v320;
                if (v317)
                {
                  LODWORD(v303) = 5;
                  v304 = (const char *)v314;
                  v178 = &v303;
                  v179 = (char *)v319;
                  if (v177 >= v321)
                  {
                    v254 = v177 + 1;
                    v255 = (char *)v319 + 24 * v177 > (char *)&v303;
                    if (v319 <= &v303 && v255)
                    {
                      v281 = (char *)&v303 - (_BYTE *)v319;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v254, 24);
                      v179 = (char *)v319;
                      v178 = (const void ***)((char *)v319 + v281);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v254, 24);
                      v178 = &v303;
                      v179 = (char *)v319;
                    }
                  }
                  v180 = &v179[24 * v320];
                  v181 = *(_OWORD *)v178;
                  *((_QWORD *)v180 + 2) = v178[2];
                  *(_OWORD *)v180 = v181;
                  v182 = ++v320;
                  if (v317)
                  {
                    LODWORD(v303) = 3;
                    v304 = " values.";
                    v305 = 8;
                    v183 = &v303;
                    v184 = (char *)v319;
                    if (v182 >= v321)
                    {
                      v261 = v182 + 1;
                      v262 = (char *)v319 + 24 * v182 > (char *)&v303;
                      if (v319 <= &v303 && v262)
                      {
                        v285 = (char *)&v303 - (_BYTE *)v319;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v261, 24);
                        v184 = (char *)v319;
                        v183 = (const void ***)((char *)v319 + v285);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v261, 24);
                        v183 = &v303;
                        v184 = (char *)v319;
                      }
                    }
                    v185 = &v184[24 * v320];
                    v186 = *(_OWORD *)v183;
                    *((_QWORD *)v185 + 2) = v183[2];
                    *(_OWORD *)v185 = v186;
                    ++v320;
                  }
                }
              }
            }
            v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
            if (v317)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
            if (v327)
            {
              v187 = __p;
              if (__p)
              {
                v188 = v326;
                v189 = __p;
                if (v326 != __p)
                {
                  do
                    v188 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v188 - 1);
                  while (v188 != v187);
                  v189 = __p;
                }
                v326 = v187;
                operator delete(v189);
              }
              v158 = v323;
              if (!v323)
                goto LABEL_337;
              v190 = v324;
              v160 = v323;
              if (v324 == v323)
                goto LABEL_336;
              do
              {
                v192 = *--v190;
                v191 = v192;
                *v190 = 0;
                if (v192)
                  MEMORY[0x20BD002D4](v191, 0x1000C8077774924);
              }
              while (v190 != v158);
              goto LABEL_335;
            }
LABEL_261:
            v165 = v313;
            if (v313 != v315)
            {
LABEL_262:
              free(v165);
              return v1;
            }
            return v1;
          }
        }
        if (v301)
        {
          v133 = v314;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v301);
          if (v134 != v133)
          {
            v299 = 259;
            mlir::OpState::emitOpError(&v309, &v296, (uint64_t)&v317);
            mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v301);
            if (v317)
            {
              LODWORD(v303) = 5;
              v304 = v135;
              v136 = &v303;
              v137 = (char *)v319;
              if (v320 >= v321)
              {
                v242 = v320 + 1;
                if (v319 <= &v303 && (char *)v319 + 24 * v320 > (char *)&v303)
                {
                  v274 = (char *)&v303 - (_BYTE *)v319;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v242, 24);
                  v137 = (char *)v319;
                  v136 = (const void ***)((char *)v319 + v274);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v242, 24);
                  v136 = &v303;
                  v137 = (char *)v319;
                }
              }
              v138 = &v137[24 * v320];
              v139 = *(_OWORD *)v136;
              *((_QWORD *)v138 + 2) = v136[2];
              *(_OWORD *)v138 = v139;
              v140 = ++v320;
              if (v317)
              {
                LODWORD(v303) = 3;
                v305 = 38;
                v141 = &v303;
                v142 = (char *)v319;
                if (v140 >= v321)
                {
                  v250 = v140 + 1;
                  v251 = (char *)v319 + 24 * v140 > (char *)&v303;
                  if (v319 <= &v303 && v251)
                  {
                    v279 = (char *)&v303 - (_BYTE *)v319;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v250, 24);
                    v142 = (char *)v319;
                    v141 = (const void ***)((char *)v319 + v279);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v250, 24);
                    v141 = &v303;
                    v142 = (char *)v319;
                  }
                }
                v143 = &v142[24 * v320];
                v144 = *(_OWORD *)v141;
                *((_QWORD *)v143 + 2) = v141[2];
                *(_OWORD *)v143 = v144;
                v145 = ++v320;
                if (v317)
                {
                  LODWORD(v303) = 5;
                  v304 = (const char *)v314;
                  v146 = &v303;
                  v147 = (char *)v319;
                  if (v145 >= v321)
                  {
                    v259 = v145 + 1;
                    v260 = (char *)v319 + 24 * v145 > (char *)&v303;
                    if (v319 <= &v303 && v260)
                    {
                      v284 = (char *)&v303 - (_BYTE *)v319;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v259, 24);
                      v147 = (char *)v319;
                      v146 = (const void ***)((char *)v319 + v284);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v259, 24);
                      v146 = &v303;
                      v147 = (char *)v319;
                    }
                  }
                  v148 = &v147[24 * v320];
                  v149 = *(_OWORD *)v146;
                  *((_QWORD *)v148 + 2) = v146[2];
                  *(_OWORD *)v148 = v149;
                  v150 = ++v320;
                  if (v317)
                  {
                    LODWORD(v303) = 3;
                    v304 = " values.";
                    v305 = 8;
                    v151 = &v303;
                    v152 = (char *)v319;
                    if (v150 >= v321)
                    {
                      v265 = v150 + 1;
                      v266 = (char *)v319 + 24 * v150 > (char *)&v303;
                      if (v319 <= &v303 && v266)
                      {
                        v287 = (char *)&v303 - (_BYTE *)v319;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v265, 24);
                        v152 = (char *)v319;
                        v151 = (const void ***)((char *)v319 + v287);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v265, 24);
                        v151 = &v303;
                        v152 = (char *)v319;
                      }
                    }
                    v153 = &v152[24 * v320];
                    v154 = *(_OWORD *)v151;
                    *((_QWORD *)v153 + 2) = v151[2];
                    *(_OWORD *)v153 = v154;
                    ++v320;
                  }
                }
              }
            }
            v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
            if (v317)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
            if (v327)
            {
              v155 = __p;
              if (__p)
              {
                v156 = v326;
                v157 = __p;
                if (v326 != __p)
                {
                  do
                    v156 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v156 - 1);
                  while (v156 != v155);
                  v157 = __p;
                }
                v326 = v155;
                operator delete(v157);
              }
              v158 = v323;
              if (!v323)
                goto LABEL_337;
              v159 = v324;
              v160 = v323;
              if (v324 == v323)
              {
LABEL_336:
                v324 = v158;
                operator delete(v160);
LABEL_337:
                if (v319 != v322)
                  free(v319);
                goto LABEL_261;
              }
              do
              {
                v162 = *--v159;
                v161 = v162;
                *v159 = 0;
                if (v162)
                  MEMORY[0x20BD002D4](v161, 0x1000C8077774924);
              }
              while (v159 != v158);
LABEL_335:
              v160 = v323;
              goto LABEL_336;
            }
            goto LABEL_261;
          }
        }
      }
      else if ((_DWORD)v314 != 4)
      {
        v299 = 259;
        mlir::OpState::emitOpError(&v309, &v296, (uint64_t)&v317);
        if (v317)
        {
          LODWORD(v303) = 3;
          v305 = 21;
          v193 = &v303;
          v194 = (char *)v319;
          if (v320 >= v321)
          {
            v240 = v320 + 1;
            if (v319 <= &v303 && (char *)v319 + 24 * v320 > (char *)&v303)
            {
              v272 = (char *)&v303 - (_BYTE *)v319;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v240, 24);
              v194 = (char *)v319;
              v193 = (const void ***)((char *)v319 + v272);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v240, 24);
              v193 = &v303;
              v194 = (char *)v319;
            }
          }
          v195 = &v194[24 * v320];
          v196 = *(_OWORD *)v193;
          *((_QWORD *)v195 + 2) = v193[2];
          *(_OWORD *)v195 = v196;
          v197 = ++v320;
          if (v317)
          {
            LODWORD(v303) = 5;
            v304 = (const char *)v314;
            v198 = &v303;
            v199 = (char *)v319;
            if (v197 >= v321)
            {
              v246 = v197 + 1;
              v247 = (char *)v319 + 24 * v197 > (char *)&v303;
              if (v319 <= &v303 && v247)
              {
                v277 = (char *)&v303 - (_BYTE *)v319;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v246, 24);
                v199 = (char *)v319;
                v198 = (const void ***)((char *)v319 + v277);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v246, 24);
                v198 = &v303;
                v199 = (char *)v319;
              }
            }
            v200 = &v199[24 * v320];
            v201 = *(_OWORD *)v198;
            *((_QWORD *)v200 + 2) = v198[2];
            *(_OWORD *)v200 = v201;
            v202 = ++v320;
            if (v317)
            {
              LODWORD(v303) = 3;
              v304 = " values.";
              v305 = 8;
              v203 = &v303;
              v204 = (char *)v319;
              if (v202 >= v321)
              {
                v256 = v202 + 1;
                v257 = (char *)v319 + 24 * v202 > (char *)&v303;
                if (v319 <= &v303 && v257)
                {
                  v282 = (char *)&v303 - (_BYTE *)v319;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v256, 24);
                  v204 = (char *)v319;
                  v203 = (const void ***)((char *)v319 + v282);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v256, 24);
                  v203 = &v303;
                  v204 = (char *)v319;
                }
              }
              v205 = &v204[24 * v320];
              v206 = *(_OWORD *)v203;
              *((_QWORD *)v205 + 2) = v203[2];
              *(_OWORD *)v205 = v206;
              ++v320;
            }
          }
        }
        v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
        if (v317)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
        if (v327)
        {
          v207 = __p;
          if (__p)
          {
            v208 = v326;
            v209 = __p;
            if (v326 != __p)
            {
              do
                v208 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v208 - 1);
              while (v208 != v207);
              v209 = __p;
            }
            v326 = v207;
            operator delete(v209);
          }
          v158 = v323;
          if (!v323)
            goto LABEL_337;
          v210 = v324;
          v160 = v323;
          if (v324 == v323)
            goto LABEL_336;
          do
          {
            v212 = *--v210;
            v211 = v212;
            *v210 = 0;
            if (v212)
              MEMORY[0x20BD002D4](v211, 0x1000C8077774924);
          }
          while (v210 != v158);
          goto LABEL_335;
        }
        goto LABEL_261;
      }
    }
    v1 = 1;
    goto LABEL_261;
  }
  v316 = 259;
  mlir::OpState::emitOpError(&v309, (const void ***)&v313, (uint64_t)&v317);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v300);
  if (v317)
  {
    LODWORD(v296) = 5;
    v297 = v115;
    v116 = &v296;
    v117 = (char *)v319;
    if (v320 >= v321)
    {
      v243 = v320 + 1;
      if (v319 <= &v296 && (char *)v319 + 24 * v320 > (char *)&v296)
      {
        v275 = (char *)&v296 - (_BYTE *)v319;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v243, 24);
        v117 = (char *)v319;
        v116 = (const void ***)((char *)v319 + v275);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v243, 24);
        v116 = &v296;
        v117 = (char *)v319;
      }
    }
    v118 = &v117[24 * v320];
    v119 = *(_OWORD *)v116;
    *((_QWORD *)v118 + 2) = v116[2];
    *(_OWORD *)v118 = v119;
    v120 = ++v320;
    if (v317)
    {
      LODWORD(v296) = 3;
      v297 = ".";
      v298 = 1;
      v121 = &v296;
      v122 = (char *)v319;
      if (v120 >= v321)
      {
        v252 = v120 + 1;
        v253 = (char *)v319 + 24 * v120 > (char *)&v296;
        if (v319 <= &v296 && v253)
        {
          v280 = (char *)&v296 - (_BYTE *)v319;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v252, 24);
          v122 = (char *)v319;
          v121 = (const void ***)((char *)v319 + v280);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v319, v322, v252, 24);
          v121 = &v296;
          v122 = (char *)v319;
        }
      }
      v123 = &v122[24 * v320];
      v124 = *(_OWORD *)v121;
      *((_QWORD *)v123 + 2) = v121[2];
      *(_OWORD *)v123 = v124;
      ++v320;
    }
  }
  v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v317);
  if (v317)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v317);
  if (v327)
  {
    v125 = __p;
    if (__p)
    {
      v126 = v326;
      v127 = __p;
      if (v326 != __p)
      {
        do
          v126 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v126 - 1);
        while (v126 != v125);
        v127 = __p;
      }
      v326 = v125;
      operator delete(v127);
    }
    v109 = v323;
    if (v323)
    {
      v128 = v324;
      v111 = v323;
      if (v324 == v323)
        goto LABEL_340;
      do
      {
        v164 = *--v128;
        v163 = v164;
        *v128 = 0;
        if (v164)
          MEMORY[0x20BD002D4](v163, 0x1000C8077774924);
      }
      while (v128 != v109);
      goto LABEL_339;
    }
LABEL_341:
    v165 = v319;
    if (v319 == v322)
      return v1;
    goto LABEL_262;
  }
  return v1;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t Context;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  char *v35;
  unint64_t v36;
  char *v37;
  unint64_t v38;
  int64x2_t *v39;
  int64x2_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int32x2_t v45;
  int32x2_t v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t *Value;
  int64_t v50;
  int64_t v51;
  uint64_t Int;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  BOOL v65;
  int64_t v66;
  int v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  int64_t v73;
  int64_t v75;
  uint64_t v76;
  _QWORD *v77;
  int64_t v78;
  int64x2_t v79;
  int64x2_t v80;
  int64x2_t v81;
  int8x16_t *v82;
  int64x2_t v83;
  int64x2_t v84;
  int64x2_t v85;
  int64x2_t v86;
  unint64_t v87;
  int64x2_t v88;
  int64_t v89;
  uint64_t v91;
  uint64_t *v92;
  _QWORD *v93;
  int64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t NumElements;
  BOOL v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  BOOL v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  BOOL v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  int64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  _QWORD *v122;
  unint64_t v123;
  _QWORD *v124;
  unint64_t v125;
  unint64_t v126;
  __int128 *v127;
  _OWORD *v128;
  unint64_t v129;
  __int128 v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD *v133;
  uint64_t *v134;
  uint64_t v135;
  _QWORD *v136;
  _QWORD *v137;
  _QWORD *v138;
  _QWORD *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unsigned int v155;
  uint64_t *v156;
  _QWORD *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  _QWORD *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  char v169[8];
  char v170;
  __int128 v171;
  __int128 v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  unint64_t v177;
  uint64_t v178;
  unint64_t v179;
  void *v180;
  uint64_t v181;
  _QWORD v182[5];
  void *v183;
  uint64_t v184;
  __int128 v185;
  __int128 v186;
  void *v187;
  uint64_t v188;
  _BYTE v189[24];
  void *v190;
  uint64_t v191;
  _BYTE v192[24];
  void *v193;
  uint64_t v194;
  _BYTE v195[48];
  void *v196;
  uint64_t v197;
  _BYTE v198[40];
  void *v199;
  uint64_t v200;
  _BYTE v201[40];
  void *v202;
  uint64_t v203;
  _BYTE v204[40];
  unint64_t v205[2];
  _QWORD *v206;
  uint64_t v207;
  _QWORD v208[10];

  v208[8] = *MEMORY[0x24BDAC8D0];
  v178 = a4;
  v179 = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = *((_QWORD *)a7 + 4);
  }
  else
  {
    v18 = 0;
    v16 = 0uLL;
    v17 = 0uLL;
  }
  v168 = a6;
  v169[0] = 0;
  v170 = 0;
  v171 = v16;
  v172 = v17;
  v173 = v18;
  v174 = a9;
  v19 = a5;
  v175 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v168);
    if (v170)
      v170 = 0;
    mlir::OperationName::OperationName(v169, "mps.depthwise_conv_3d_data_gradient", 35, Context);
    v170 = 1;
    v19 = v179;
  }
  v176 = a4;
  v177 = a5;
  if (v19 < 2
    || (v21 = mlir::UnknownLoc::get(this, a2),
        !mlir::mps::DepthwiseConv3DDataGradientOpAdaptor::verify(&v168, v21)))
  {
    v32 = mlir::Float32Type::get(this, a2);
LABEL_28:
    v42 = mlir::UnrankedTensorType::get(v32);
    goto LABEL_29;
  }
  v22 = mlir::ValueRange::dereference_iterator(&v178, 0);
  v23 = mlir::ValueRange::dereference_iterator(&v178, 1);
  v24 = 0;
  if (v179 == 3)
    v24 = mlir::ValueRange::dereference_iterator(&v178, 2);
  v25 = v171;
  v160 = v172;
  v161 = *((_QWORD *)&v171 + 1);
  v26 = v173;
  v159 = *((_QWORD *)&v172 + 1);
  v28 = *(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8;
  v206 = (_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8);
  v27 = v206;
  v207 = v28;
  mlir::ValueRange::ValueRange(v205, (uint64_t)&v206, 2uLL);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8))
  {
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
    v30 = v27;
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v28 + 8))
      goto LABEL_14;
  }
  else
  {
    v30 = 0;
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v28 + 8))
    {
LABEL_14:
      mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v28 + 8);
      v31 = v28;
      if (!v30)
        goto LABEL_27;
      goto LABEL_19;
    }
  }
  v31 = 0;
  if (!v30)
  {
LABEL_27:
    v32 = v29;
    goto LABEL_28;
  }
LABEL_19:
  v33 = *(void **)(*v30 + 136);
  if (v33 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || !v31
    || *(_UNKNOWN **)(*(_QWORD *)v31 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_27;
  }
  v202 = v204;
  v203 = 0x500000000;
  if (!v24)
  {
    if (v33 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      v47 = v30;
    else
      v47 = 0;
    v163 = v47;
    if (*(_UNKNOWN **)(*(_QWORD *)v28 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      v48 = v28;
    else
      v48 = 0;
    v162 = v48;
    Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v163);
    v51 = v50;
    v199 = v201;
    v200 = 0x500000000;
    v196 = v198;
    v197 = 0x500000000;
    v193 = v195;
    v194 = 0x600000000;
    v190 = v192;
    v191 = 0x300000000;
    v187 = v189;
    v188 = 0x300000000;
    v166 = v161;
    v167 = v26;
    v164 = v25;
    v165 = v160;
    if (v25)
    {
      Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v164);
      v53 = v194;
      if ((_DWORD)v194 == 6)
      {
        v54 = v159;
        goto LABEL_68;
      }
      v54 = v159;
      if (v194 > 6
        || HIDWORD(v194) <= 5
        && (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v193, v195, 6uLL, 8), v53 = v194,
                                                                                            (_DWORD)v194 == 6))
      {
LABEL_67:
        LODWORD(v194) = 6;
LABEL_68:
        v59 = v191;
        if ((_DWORD)v191 == 3)
        {
          v60 = v188;
          v61 = v188 > 3;
          if ((_DWORD)v188 == 3)
            goto LABEL_70;
        }
        else
        {
          if (v191 <= 3)
          {
            v68 = v191;
            v69 = v191;
            if (HIDWORD(v191) <= 2)
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v190, v192, 3uLL, 8);
              v68 = v191;
              v69 = v191;
            }
            memset_pattern16((char *)v190 + 8 * v68, &unk_207A80400, 24 - 8 * v59);
            v67 = v69 - v59 + 3;
          }
          else
          {
            v67 = 3;
          }
          LODWORD(v191) = v67;
          v60 = v188;
          v61 = v188 > 3;
          if ((_DWORD)v188 == 3)
          {
LABEL_70:
            v62 = v200;
            v63 = v200 > 5;
            if ((_DWORD)v200 == 5)
              goto LABEL_71;
            goto LABEL_87;
          }
        }
        if (v61)
        {
          v70 = 3;
        }
        else
        {
          v71 = v60;
          v72 = v60;
          if (HIDWORD(v188) <= 2)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v187, v189, 3uLL, 8);
            v71 = v188;
            v72 = v188;
          }
          memset_pattern16((char *)v187 + 8 * v71, &unk_207A80400, 24 - 8 * v60);
          v70 = v72 - v60 + 3;
        }
        LODWORD(v188) = v70;
        v62 = v200;
        v63 = v200 > 5;
        if ((_DWORD)v200 == 5)
        {
LABEL_71:
          v64 = v197;
          v65 = v197 > 5;
          if ((_DWORD)v197 == 5)
            goto LABEL_72;
          goto LABEL_92;
        }
LABEL_87:
        if (!v63)
        {
          if (HIDWORD(v200) > 4
            || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v199, v201, 5uLL, 8),
                v62 = v200,
                (_DWORD)v200 != 5))
          {
            bzero((char *)v199 + 8 * v62, 40 - 8 * v62);
          }
        }
        LODWORD(v200) = 5;
        v64 = v197;
        v65 = v197 > 5;
        if ((_DWORD)v197 == 5)
        {
LABEL_72:
          v66 = v51 - 4;
          if (v51 < 4)
          {
LABEL_132:
            if (v167 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v167) == 3)
            {
              LODWORD(v191) = 0;
              mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v206, v167, 0);
              v98 = v167;
              NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v167);
              mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v180, v98, NumElements);
              while (1)
              {
                v100 = v206 == v180 && v207 == v181;
                if (v100 && v208[0] == v182[0])
                  break;
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v206, (llvm::APInt *)&v183);
                if (v184 > 0x40)
                  v101 = *(_QWORD *)v183;
                else
                  v101 = (uint64_t)((_QWORD)v183 << -(uint64_t)v184) >> -(uint64_t)v184;
                v102 = v191;
                if (v191 >= (unint64_t)HIDWORD(v191))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v190, v192, v191 + 1, 8);
                  v102 = v191;
                }
                *((_QWORD *)v190 + v102) = v101;
                LODWORD(v191) = v191 + 1;
                if (v184 >= 0x41 && v183)
                  MEMORY[0x20BD002D4](v183, 0x1000C8000313F17);
                ++v208[0];
              }
            }
            if (v161 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v166) == 3)
            {
              LODWORD(v188) = 0;
              mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v206, v166, 0);
              v103 = v166;
              v104 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v166);
              mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v180, v103, v104);
              while (1)
              {
                v105 = v206 == v180 && v207 == v181;
                if (v105 && v208[0] == v182[0])
                  break;
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v206, (llvm::APInt *)&v183);
                if (v184 > 0x40)
                  v106 = *(_QWORD *)v183;
                else
                  v106 = (uint64_t)((_QWORD)v183 << -(uint64_t)v184) >> -(uint64_t)v184;
                v107 = v188;
                if (v188 >= (unint64_t)HIDWORD(v188))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v187, v189, v188 + 1, 8);
                  v107 = v188;
                }
                *((_QWORD *)v187 + v107) = v106;
                LODWORD(v188) = v188 + 1;
                if (v184 >= 0x41 && v183)
                  MEMORY[0x20BD002D4](v183, 0x1000C8000313F17);
                ++v208[0];
              }
            }
            if (v160 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v165) == 6)
            {
              LODWORD(v194) = 0;
              mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v206, v165, 0);
              v108 = v165;
              v109 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v165);
              mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v180, v108, v109);
              while (1)
              {
                v110 = v206 == v180 && v207 == v181;
                if (v110 && v208[0] == v182[0])
                  break;
                mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v206, (llvm::APInt *)&v183);
                if (v184 > 0x40)
                  v111 = *(_QWORD *)v183;
                else
                  v111 = (uint64_t)((_QWORD)v183 << -(uint64_t)v184) >> -(uint64_t)v184;
                v112 = v194;
                if (v194 >= (unint64_t)HIDWORD(v194))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v193, v195, v194 + 1, 8);
                  v112 = v194;
                }
                *((_QWORD *)v193 + v112) = v111;
                LODWORD(v194) = v194 + 1;
                if (v184 >= 0x41 && v183)
                  MEMORY[0x20BD002D4](v183, 0x1000C8000313F17);
                ++v208[0];
              }
            }
            if (v54)
              v113 = *(_DWORD *)(v54 + 8);
            else
              v113 = 2;
            v114 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v162);
            v183 = &v185;
            v185 = xmmword_207AD0298;
            v186 = unk_207AD02A8;
            v184 = 0x400000004;
            if (Int >= 0)
              v116 = v51;
            else
              v116 = 0;
            if (v115 == 4)
            {
              v117 = Int - v116 + 4;
              if (v117 <= 3)
              {
                *(_QWORD *)&v185 = *(_QWORD *)(v114 + 8 * v117);
                *((_QWORD *)&v185 + 1) = *(_QWORD *)(v114 + 8 * (v117 == 0));
                v118 = 8;
                if (v117 <= 1)
                  v118 = 16;
                *(_QWORD *)&v186 = *(_QWORD *)(v114 + v118);
                v61 = v117 > 2;
                v119 = 24;
                if (v61)
                  v119 = 16;
                *((_QWORD *)&v186 + 1) = *(_QWORD *)(v114 + v119);
              }
            }
            v180 = v182;
            v181 = 0x500000000;
            v120 = v200;
            v206 = v208;
            v207 = 0x800000000;
            if ((_DWORD)v200)
            {
              if (v200 < 9)
              {
                v121 = 0;
                v122 = v208;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v206, v208, v200, 8);
                v121 = v207;
                v122 = v206;
              }
              if (v120 != v121)
                bzero(&v122[v121], 8 * (v120 - v121));
              LODWORD(v207) = v120;
              if (v120 >= 4)
              {
                v123 = v120 - 3;
                v124 = v199;
                v125 = v120 - 4;
                if (v120 != 4)
                {
                  v126 = 0;
                  if (v125 < 4)
                    goto LABEL_212;
                  if ((unint64_t)((char *)v122 - (_BYTE *)v199) < 0x20)
                    goto LABEL_212;
                  v126 = v125 & 0xFFFFFFFFFFFFFFFCLL;
                  v127 = (__int128 *)((char *)v199 + 16);
                  v128 = v122 + 2;
                  v129 = v125 & 0xFFFFFFFFFFFFFFFCLL;
                  do
                  {
                    v130 = *v127;
                    *(v128 - 1) = *(v127 - 1);
                    *v128 = v130;
                    v127 += 2;
                    v128 += 2;
                    v129 -= 4;
                  }
                  while (v129);
                  if (v125 != v126)
                  {
LABEL_212:
                    v131 = v120 - v126 - 4;
                    v132 = v126;
                    v133 = &v122[v126];
                    v134 = &v124[v132];
                    do
                    {
                      v135 = *v134++;
                      *v133++ = v135;
                      --v131;
                    }
                    while (v131);
                  }
                }
                v136 = v183;
                v122[v125] = *(_QWORD *)v183;
                v137 = v190;
                v138 = v187;
                v139 = v193;
                v140 = v124[v123];
                v141 = 0x8000000000000000;
                v142 = 0x8000000000000000;
                if (v140 != 0x8000000000000000)
                {
                  v143 = v136[1];
                  v144 = *(_QWORD *)v190;
                  v145 = *(_QWORD *)v187 * (v143 - 1) + 1;
                  switch(v113)
                  {
                    case 0:
                      v142 = 0x8000000000000000;
                      if (v143 != 0x8000000000000000)
                      {
                        v140 = v145 + v144 * (v140 - 1) - (*(_QWORD *)v193 + *((_QWORD *)v193 + 1));
                        goto LABEL_222;
                      }
                      break;
                    case 1:
                      v140 = v145 + v144 * (v140 - 1);
                      if (v143 == 0x8000000000000000)
                        v140 = 0x8000000000000000;
                      goto LABEL_221;
                    case 2:
                    case 4:
                      v140 *= v144;
                      goto LABEL_221;
                    default:
LABEL_221:
                      v142 = v140;
                      if (v143 != 0x8000000000000000)
LABEL_222:
                        v142 = v140 & ~(v140 >> 63);
                      break;
                  }
                }
                v122[v123] = v142;
                v146 = v124[v120 - 2];
                if (v146 != 0x8000000000000000)
                {
                  v147 = v136[2];
                  v148 = v137[1];
                  v149 = v138[1] * (v147 - 1) + 1;
                  switch(v113)
                  {
                    case 0:
                      v141 = 0x8000000000000000;
                      if (v147 != 0x8000000000000000)
                      {
                        v146 = v149 + v148 * (v146 - 1) - (v139[2] + v139[3]);
                        goto LABEL_232;
                      }
                      break;
                    case 1:
                      if (v147 == 0x8000000000000000)
                        v146 = 0x8000000000000000;
                      else
                        v146 = v149 + v148 * (v146 - 1);
                      goto LABEL_231;
                    case 2:
                    case 4:
                      v146 *= v148;
                      goto LABEL_231;
                    default:
LABEL_231:
                      v141 = v146;
                      if (v147 != 0x8000000000000000)
LABEL_232:
                        v141 = v146 & ~(v146 >> 63);
                      break;
                  }
                }
                v122[v120 - 2] = v141;
                v150 = v124[v120 - 1];
                v151 = 0x8000000000000000;
                if (v150 != 0x8000000000000000)
                {
                  v152 = v136[3];
                  v153 = v137[2];
                  v154 = v138[2] * (v152 - 1) + 1;
                  switch(v113)
                  {
                    case 0:
                      v151 = 0x8000000000000000;
                      if (v152 != 0x8000000000000000)
                      {
                        v150 = v154 + v153 * (v150 - 1) - (v139[4] + v139[5]);
                        goto LABEL_241;
                      }
                      break;
                    case 1:
                      v150 = v154 + v153 * (v150 - 1);
                      if (v152 == 0x8000000000000000)
                        v150 = 0x8000000000000000;
                      goto LABEL_240;
                    case 2:
                    case 4:
                      v150 *= v153;
                      goto LABEL_240;
                    default:
LABEL_240:
                      v151 = v150;
                      if (v152 != 0x8000000000000000)
LABEL_241:
                        v151 = v150 & ~(v150 >> 63);
                      break;
                  }
                }
                v122[v120 - 1] = v151;
                v155 = v181;
                if ((_DWORD)v181 != (_DWORD)v120)
                {
                  if (v181 <= v120)
                  {
                    if (HIDWORD(v181) < v120)
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v180, v182, v120, 8);
                      v155 = v181;
                    }
                    if (v155 != (_DWORD)v120)
                      bzero((char *)v180 + 8 * v155, 8 * (v120 - v155));
                  }
                  LODWORD(v181) = v120;
                  v122 = v206;
                }
                v156 = (uint64_t *)v196;
                v157 = v180;
                do
                {
                  v158 = *v156++;
                  *v157++ = v122[v158];
                  --v120;
                }
                while (v120);
              }
              if (v122 != v208)
                free(v122);
            }
            v42 = mlir::RankedTensorType::get((uint64_t)v180, v181, v29, 0);
            if (v180 != v182)
              free(v180);
            if (v183 != &v185)
              free(v183);
            if (v187 != v189)
              free(v187);
            if (v190 != v192)
              free(v190);
            if (v193 != v195)
              free(v193);
            if (v196 != v198)
              free(v196);
            if (v199 != v201)
              free(v199);
            v55 = 1;
            goto LABEL_268;
          }
LABEL_97:
          v73 = (v51 & (Int >> 63)) + Int;
          if (v73 >= v51 || v73 < v66)
            v75 = v66;
          else
            v75 = (v51 & (Int >> 63)) + Int;
          if (v51 != 5)
          {
            if ((unint64_t)v51 >= 5)
            {
              if (v51 <= (unint64_t)HIDWORD(v197))
              {
                v76 = 5;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v196, v198, v51, 8);
                v76 = v197;
              }
              if (v51 != v76)
                bzero((char *)v196 + 8 * v76, 8 * (v51 - v76));
            }
            LODWORD(v197) = v51;
          }
          v77 = v196;
          v78 = v51 & 0xFFFFFFFFFFFFFFFCLL;
          v79 = vdupq_n_s64(v75);
          v80 = vdupq_n_s64(v66);
          v81 = (int64x2_t)xmmword_207A80930;
          v82 = (int8x16_t *)((char *)v196 + 16);
          v83 = vdupq_n_s64(2uLL);
          v84 = vdupq_n_s64(1uLL);
          v85 = vdupq_n_s64(3uLL);
          v86 = vdupq_n_s64(4uLL);
          v87 = v51 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            v88 = vaddq_s64(v81, v83);
            v82[-1] = vbslq_s8(vorrq_s8((int8x16_t)vcgtq_s64(v81, v79), (int8x16_t)vcgtq_s64(v80, v81)), (int8x16_t)v81, vbslq_s8((int8x16_t)vcgtq_s64(v79, v81), (int8x16_t)vaddq_s64(v81, v84), (int8x16_t)v80));
            *v82 = vbslq_s8(vorrq_s8((int8x16_t)vcgtq_s64(v88, v79), (int8x16_t)vcgtq_s64(v80, v88)), (int8x16_t)v88, vbslq_s8((int8x16_t)vcgtq_s64(v79, v88), (int8x16_t)vaddq_s64(v81, v85), (int8x16_t)v80));
            v81 = vaddq_s64(v81, v86);
            v82 += 2;
            v87 -= 4;
          }
          while (v87);
          for (; v51 != v78; ++v78)
          {
            if (v78 < v75)
              v89 = v78 + 1;
            else
              v89 = v66;
            if (v78 < v66 || v78 > v75)
              v89 = v78;
            v77[v78] = v89;
          }
          v91 = v200;
          if (v51 != v200)
          {
            if (v51 >= (unint64_t)v200)
            {
              if (v51 > (unint64_t)HIDWORD(v200))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v199, v201, v51, 8);
                v91 = v200;
              }
              if (v51 != v91)
                bzero((char *)v199 + 8 * v91, 8 * (v51 - v91));
            }
            LODWORD(v200) = v51;
          }
          v92 = (uint64_t *)v196;
          v93 = v199;
          v94 = v51;
          do
          {
            v96 = *Value++;
            v95 = v96;
            v97 = *v92++;
            v93[v97] = v95;
            --v94;
          }
          while (v94);
          goto LABEL_132;
        }
LABEL_92:
        if (!v65)
        {
          if (HIDWORD(v197) > 4
            || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v196, v198, 5uLL, 8),
                v64 = v197,
                (_DWORD)v197 != 5))
          {
            bzero((char *)v196 + 8 * v64, 40 - 8 * v64);
          }
        }
        LODWORD(v197) = 5;
        v66 = v51 - 4;
        if (v51 < 4)
          goto LABEL_132;
        goto LABEL_97;
      }
    }
    else
    {
      v53 = 0;
      Int = -4;
      v54 = v159;
    }
    bzero((char *)v193 + 8 * v53, 48 - 8 * v53);
    goto LABEL_67;
  }
  if (!mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)&v202))
  {
    v42 = mlir::UnrankedTensorType::get(v29);
    v55 = 1;
    goto LABEL_268;
  }
  v34 = v203;
  if (!(_DWORD)v203)
    goto LABEL_55;
  v35 = (char *)v202;
  v36 = (v203 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  v37 = (char *)v202;
  if (v36 < 3)
    goto LABEL_57;
  v38 = v36 + 1;
  v37 = (char *)v202 + 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
  v39 = (int64x2_t *)((char *)v202 + 16);
  v40.i64[0] = -1;
  v40.i64[1] = -1;
  v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v45 = vmovn_s64(vceqq_s64(v39[-1], v40));
    if ((v45.i8[0] & 1) != 0)
    {
      v39[-1].i64[0] = 0x8000000000000000;
      if ((v45.i8[4] & 1) == 0)
      {
LABEL_35:
        v46 = vmovn_s64(vceqq_s64(*v39, v40));
        if ((v46.i8[0] & 1) != 0)
          goto LABEL_40;
        goto LABEL_36;
      }
    }
    else if ((v45.i8[4] & 1) == 0)
    {
      goto LABEL_35;
    }
    v39[-1].i64[1] = 0x8000000000000000;
    v46 = vmovn_s64(vceqq_s64(*v39, v40));
    if ((v46.i8[0] & 1) != 0)
    {
LABEL_40:
      v39->i64[0] = 0x8000000000000000;
      if ((v46.i8[4] & 1) == 0)
        goto LABEL_32;
      goto LABEL_41;
    }
LABEL_36:
    if ((v46.i8[4] & 1) == 0)
      goto LABEL_32;
LABEL_41:
    v39->i64[1] = 0x8000000000000000;
LABEL_32:
    v39 += 2;
    v41 -= 4;
  }
  while (v41);
  if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL))
    goto LABEL_55;
LABEL_57:
  v58 = &v35[8 * v34];
  do
  {
    if (*(_QWORD *)v37 == -1)
      *(_QWORD *)v37 = 0x8000000000000000;
    v37 += 8;
  }
  while (v37 != v58);
LABEL_55:
  v206 = v27;
  v56 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v206);
  v206 = v208;
  v207 = 0x500000000;
  {
    v42 = mlir::RankedTensorType::get((uint64_t)v206, v207, v29, 0);
    v55 = 1;
  }
  else
  {
    v42 = 0;
    v55 = 0;
  }
  if (v206 != v208)
    free(v206);
LABEL_268:
  if (v202 != v204)
    free(v202);
  if (!v55)
    return 0;
LABEL_29:
  v43 = *(_DWORD *)(a11 + 8);
  if (v43 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v43 + 1, 8);
    v43 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v43) = v42;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  _QWORD *Type;
  _QWORD *v9;
  _QWORD *Shape;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  const char *v62;
  uint64_t Value;
  uint64_t v64;
  uint64_t OperandRange;
  const char *v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  void *v72;
  _BYTE v73[96];
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD *v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v3 = (const char *)a1[4];
  if (v3)
  {
    v4 = (const char *)a1[5];
    if (v4)
    {
      if (a1[6])
      {
        v5 = (const char *)a1[7];
        if (v5)
        {
          v6 = (const char *)a1[3];
          v7 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
          v66 = v5;
          v67 = v7;
          Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
          v9 = Type;
          if (Type)
            Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
          v70 = (uint64_t)v9;
          v71 = Type;
          Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v70);
          v69 = 3;
          if (v11 == 1 && *Shape == v69)
          {
            v62 = v5;
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62);
            v64 = v12;
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
            {
              v13 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
              v66 = v3;
              v67 = v13;
              v14 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
              v15 = v14;
              if (v14)
                v14 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v14 + 8);
              v70 = (uint64_t)v15;
              v71 = v14;
              v16 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v70);
              v69 = 3;
              if (v17 == 1
                && *v16 == v69
                && (v62 = v3,
                    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                    v64 = v18,
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
              {
                v19 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                v66 = v4;
                v67 = v19;
                v20 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
                v21 = v20;
                if (v20)
                  v20 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
                v70 = (uint64_t)v21;
                v71 = v20;
                v22 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v70);
                v69 = 6;
                if (v23 == 1
                  && *v22 == v69
                  && (v62 = v4,
                      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
                      v64 = v24,
                      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
                {
                  if (!v6)
                    return 1;
                  v66 = v6;
                  v70 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v66);
                  if (mlir::Type::isSignedInteger((mlir::Type *)&v70, 32))
                    return 1;
                  v61 = "'mps.depthwise_conv_3d_data_gradient' op attribute 'channelAxis' failed to satisfy constraint: 3"
                        "2-bit signed integer attribute";
                }
                else
                {
                  v61 = "'mps.depthwise_conv_3d_data_gradient' op attribute 'explicit_padding' failed to satisfy constrai"
                        "nt: ui64 elements attribute of shape {6}";
                }
              }
              else
              {
                v61 = "'mps.depthwise_conv_3d_data_gradient' op attribute 'dilation_rates' failed to satisfy constraint: "
                      "ui64 elements attribute of shape {3}";
              }
              v66 = v61;
              v68 = 259;
              mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
              v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v70);
              return v25;
            }
          }
          v66 = "'mps.depthwise_conv_3d_data_gradient' op attribute 'strides' failed to satisfy constraint: ui64 elements"
                " attribute of shape {3}";
          v68 = 259;
          mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
          if (v70)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
          if (v78)
          {
            v46 = __p;
            if (__p)
            {
              v47 = v77;
              v48 = __p;
              if (v77 != __p)
              {
                do
                  v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
                while (v47 != v46);
                v48 = __p;
              }
              v77 = v46;
              operator delete(v48);
            }
            v29 = v74;
            if (!v74)
              goto LABEL_81;
            v49 = v75;
            v31 = v74;
            if (v75 == v74)
            {
LABEL_80:
              v75 = v29;
              operator delete(v31);
LABEL_81:
              if (v72 != v73)
                free(v72);
              return v25;
            }
            do
            {
              v51 = *--v49;
              v50 = v51;
              *v49 = 0;
              if (v51)
                MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
            }
            while (v49 != v29);
LABEL_79:
            v31 = v74;
            goto LABEL_80;
          }
        }
        else
        {
          v66 = "'mps.depthwise_conv_3d_data_gradient' op requires attribute 'strides'";
          v68 = 259;
          mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
          v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
          if (v70)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
          if (v78)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v77;
              v54 = __p;
              if (v77 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v77 = v52;
              operator delete(v54);
            }
            v55 = v74;
            if (v74)
            {
              v56 = v75;
              v57 = v74;
              if (v75 != v74)
              {
                do
                {
                  v59 = *--v56;
                  v58 = v59;
                  *v56 = 0;
                  if (v59)
                    MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
                }
                while (v56 != v55);
                v57 = v74;
              }
              v75 = v55;
              operator delete(v57);
            }
            if (v72 != v73)
              free(v72);
          }
        }
      }
      else
      {
        v66 = "'mps.depthwise_conv_3d_data_gradient' op requires attribute 'padding_style'";
        v68 = 259;
        mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
        v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
        if (v70)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
        if (v78)
        {
          v40 = __p;
          if (__p)
          {
            v41 = v77;
            v42 = __p;
            if (v77 != __p)
            {
              do
                v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
              while (v41 != v40);
              v42 = __p;
            }
            v77 = v40;
            operator delete(v42);
          }
          v29 = v74;
          if (!v74)
            goto LABEL_81;
          v43 = v75;
          v31 = v74;
          if (v75 == v74)
            goto LABEL_80;
          do
          {
            v45 = *--v43;
            v44 = v45;
            *v43 = 0;
            if (v45)
              MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
          }
          while (v43 != v29);
          goto LABEL_79;
        }
      }
    }
    else
    {
      v66 = "'mps.depthwise_conv_3d_data_gradient' op requires attribute 'explicit_padding'";
      v68 = 259;
      mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
      if (v70)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
      if (v78)
      {
        v34 = __p;
        if (__p)
        {
          v35 = v77;
          v36 = __p;
          if (v77 != __p)
          {
            do
              v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
            while (v35 != v34);
            v36 = __p;
          }
          v77 = v34;
          operator delete(v36);
        }
        v29 = v74;
        if (!v74)
          goto LABEL_81;
        v37 = v75;
        v31 = v74;
        if (v75 == v74)
          goto LABEL_80;
        do
        {
          v39 = *--v37;
          v38 = v39;
          *v37 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v37 != v29);
        goto LABEL_79;
      }
    }
  }
  else
  {
    v66 = "'mps.depthwise_conv_3d_data_gradient' op requires attribute 'dilation_rates'";
    v68 = 259;
    mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&v70);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v70);
    if (v70)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v70);
    if (v78)
    {
      v26 = __p;
      if (__p)
      {
        v27 = v77;
        v28 = __p;
        if (v77 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v77 = v26;
        operator delete(v28);
      }
      v29 = v74;
      if (!v74)
        goto LABEL_81;
      v30 = v75;
      v31 = v74;
      if (v75 == v74)
        goto LABEL_80;
      do
      {
        v33 = *--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v30 != v29);
      goto LABEL_79;
    }
  }
  return v25;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::verify(mlir::mps::DepthwiseConv3DWeightsGradientOp *this)
{
  uint64_t v1;
  int v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t NumElements;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  unint64_t *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  char *v20;
  unint64_t *v21;
  char *v22;
  __int128 v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  BOOL v34;
  int64_t v35;
  int64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  unint64_t *v43;
  char *v44;
  __int128 v45;
  uint64_t v46;
  char *v47;
  unint64_t *v48;
  char *v49;
  __int128 v50;
  _QWORD *v51;
  _QWORD *v52;
  void *v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  BOOL v61;
  int64_t v62;
  int64_t v63;
  uint64_t v64;
  uint64_t v65;
  BOOL v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  unint64_t *v70;
  char *v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  unint64_t *v75;
  char *v76;
  __int128 v77;
  _QWORD *v78;
  _QWORD *v79;
  void *v80;
  _QWORD *v81;
  _QWORD *v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  BOOL v88;
  int64_t v89;
  int64_t v90;
  uint64_t v91;
  uint64_t v92;
  const char *v93;
  uint64_t v94;
  unint64_t v95;
  void *v96;
  uint64_t v97;
  const char *v98;
  const void ***v99;
  char *v100;
  char *v101;
  __int128 v102;
  uint64_t v103;
  const void ***v104;
  char *v105;
  char *v106;
  __int128 v107;
  _QWORD *v108;
  _QWORD *v109;
  void *v110;
  _QWORD *v111;
  _QWORD *v112;
  void *v113;
  unint64_t v114;
  void *v115;
  uint64_t v116;
  const char *v117;
  const void ***v118;
  char *v119;
  char *v120;
  __int128 v121;
  uint64_t v122;
  const void ***v123;
  char *v124;
  char *v125;
  __int128 v126;
  _QWORD *v127;
  _QWORD *v128;
  void *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  const void ***v133;
  char *v134;
  char *v135;
  __int128 v136;
  uint64_t v137;
  const void ***v138;
  char *v139;
  char *v140;
  __int128 v141;
  uint64_t v142;
  const void ***v143;
  char *v144;
  char *v145;
  __int128 v146;
  _QWORD *v147;
  _QWORD *v148;
  void *v149;
  _QWORD *v150;
  _QWORD *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *v157;
  uint64_t v159;
  const void ***v160;
  char *v161;
  char *v162;
  __int128 v163;
  uint64_t v164;
  const void ***v165;
  char *v166;
  char *v167;
  __int128 v168;
  uint64_t v169;
  const void ***v170;
  char *v171;
  char *v172;
  __int128 v173;
  uint64_t v174;
  const void ***v175;
  char *v176;
  char *v177;
  __int128 v178;
  _QWORD *v179;
  _QWORD *v180;
  void *v181;
  _QWORD *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  const void ***v186;
  char *v187;
  char *v188;
  __int128 v189;
  uint64_t v190;
  const void ***v191;
  char *v192;
  char *v193;
  __int128 v194;
  uint64_t v195;
  const void ***v196;
  char *v197;
  char *v198;
  __int128 v199;
  uint64_t v200;
  const void ***v201;
  char *v202;
  char *v203;
  __int128 v204;
  _QWORD *v205;
  _QWORD *v206;
  void *v207;
  _QWORD *v208;
  uint64_t v209;
  uint64_t v210;
  unint64_t v211;
  unint64_t v212;
  BOOL v213;
  unint64_t v214;
  BOOL v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  BOOL v219;
  unint64_t v220;
  BOOL v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  BOOL v225;
  unint64_t v226;
  BOOL v227;
  unint64_t v228;
  BOOL v229;
  unint64_t v230;
  BOOL v231;
  unint64_t v232;
  BOOL v233;
  unint64_t v234;
  BOOL v235;
  int64_t v236;
  int64_t v237;
  int64_t v238;
  int64_t v239;
  int64_t v240;
  int64_t v241;
  int64_t v242;
  int64_t v243;
  int64_t v244;
  int64_t v245;
  int64_t v246;
  int64_t v247;
  int64_t v248;
  int64_t v249;
  int64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  const void **v254;
  const char *v255;
  uint64_t v256;
  __int16 v257;
  unint64_t v258;
  unsigned int v259;
  const void **v260;
  const char *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t *v266;
  unint64_t v267;
  const char *v268;
  uint64_t v269;
  void *v270;
  uint64_t v271;
  _BYTE v272[16];
  __int16 v273;
  uint64_t *v274;
  unsigned int v275;
  void *v276;
  unsigned int v277;
  unsigned int v278;
  _BYTE v279[96];
  void *v280;
  _QWORD *v281;
  void *__p;
  _QWORD *v283;
  char v284;
  uint64_t v285;

  v285 = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned __int8 *)(*(_QWORD *)this + 47);
  v3 = *(_QWORD **)(*(_QWORD *)this + 72);
  v4 = v3[7];
  v5 = v3[3];
  v6 = v3[11];
  v266 = *(uint64_t **)this;
  v7 = v266 + 10;
  if (!v2)
    v7 = 0;
  v8 = v7[4];
  v10 = v7[1];
  v9 = v7[2];
  v264 = v10;
  v265 = v8;
  v263 = v9;
  if (v8 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v265) == 3)
  {
    v251 = v4;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v254, v265, 0);
    v1 = v265;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v265);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v260, v1, NumElements);
    while (1)
    {
      v12 = v254 == v260 && v255 == v261;
      if (v12 && v256 == v262)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v254, (llvm::APInt *)&v258);
      if (v259 > 0x40)
      {
        v13 = *(_QWORD *)v258;
        if (*(uint64_t *)v258 > 0)
        {
LABEL_14:
          if (v259 < 0x41)
            goto LABEL_48;
LABEL_46:
          if (v258)
            MEMORY[0x20BD002D4](v258, 0x1000C8000313F17);
          goto LABEL_48;
        }
      }
      else
      {
        v13 = (uint64_t)(v258 << -(char)v259) >> -(char)v259;
        if (v13 > 0)
          goto LABEL_14;
      }
      v273 = 259;
      mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
      if (v259 > 0x40)
      {
        v14 = *(_QWORD *)v258;
        if (!v274)
          goto LABEL_27;
      }
      else
      {
        v14 = (uint64_t)(v258 << -(char)v259) >> -(char)v259;
        if (!v274)
          goto LABEL_27;
      }
      LODWORD(v267) = 2;
      v268 = (const char *)v14;
      v15 = (char *)v276;
      if (v277 >= v278)
      {
        v32 = v277 + 1;
        if (v276 <= &v267 && (char *)v276 + 24 * v277 > (char *)&v267)
        {
          v35 = (char *)&v267 - (_BYTE *)v276;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v32, 24);
          v15 = (char *)v276;
          v16 = (unint64_t *)((char *)v276 + v35);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v32, 24);
          v16 = &v267;
          v15 = (char *)v276;
        }
      }
      else
      {
        v16 = &v267;
      }
      v17 = &v15[24 * v277];
      v18 = *(_OWORD *)v16;
      *((_QWORD *)v17 + 2) = v16[2];
      *(_OWORD *)v17 = v18;
      v19 = ++v277;
      if (v274)
      {
        LODWORD(v267) = 3;
        v268 = ", all values should be positive.";
        v269 = 32;
        v20 = (char *)v276;
        if (v19 >= v278)
        {
          v33 = v19 + 1;
          v34 = (char *)v276 + 24 * v19 > (char *)&v267;
          if (v276 <= &v267 && v34)
          {
            v36 = (char *)&v267 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v33, 24);
            v20 = (char *)v276;
            v21 = (unint64_t *)((char *)v276 + v36);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v33, 24);
            v21 = &v267;
            v20 = (char *)v276;
          }
        }
        else
        {
          v21 = &v267;
        }
        v22 = &v20[24 * v277];
        v23 = *(_OWORD *)v21;
        *((_QWORD *)v22 + 2) = v21[2];
        *(_OWORD *)v22 = v23;
        ++v277;
      }
LABEL_27:
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
      if (v274)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
      if (v284)
      {
        v24 = __p;
        if (__p)
        {
          v25 = v283;
          v26 = __p;
          if (v283 != __p)
          {
            do
              v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            v26 = __p;
          }
          v283 = v24;
          operator delete(v26);
        }
        v27 = v280;
        if (v280)
        {
          v28 = v281;
          v29 = v280;
          if (v281 != v280)
          {
            do
            {
              v31 = *--v28;
              v30 = v31;
              *v28 = 0;
              if (v31)
                MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
            }
            while (v28 != v27);
            v29 = v280;
          }
          v281 = v27;
          operator delete(v29);
        }
        if (v276 != v279)
          free(v276);
      }
      if (v259 >= 0x41)
        goto LABEL_46;
LABEL_48:
      if (v13 < 1)
        return v1;
      ++v256;
    }
    v4 = v251;
    if (!v264)
      goto LABEL_116;
LABEL_59:
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v264) == 3)
    {
      v252 = v4;
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v254, v264, 0);
      v37 = v264;
      v38 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v264);
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v260, v37, v38);
      while (1)
      {
        v39 = v254 == v260 && v255 == v261;
        if (v39 && v256 == v262)
        {
          v4 = v252;
          break;
        }
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v254, (llvm::APInt *)&v258);
        if (v259 > 0x40)
        {
          v40 = *(_QWORD *)v258;
          if (*(uint64_t *)v258 > 0)
          {
LABEL_69:
            if (v259 < 0x41)
              goto LABEL_103;
LABEL_101:
            if (v258)
              MEMORY[0x20BD002D4](v258, 0x1000C8000313F17);
            goto LABEL_103;
          }
        }
        else
        {
          v40 = (uint64_t)(v258 << -(char)v259) >> -(char)v259;
          if (v40 > 0)
            goto LABEL_69;
        }
        v273 = 259;
        mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
        if (v259 > 0x40)
        {
          v41 = *(_QWORD *)v258;
          if (!v274)
            goto LABEL_82;
        }
        else
        {
          v41 = (uint64_t)(v258 << -(char)v259) >> -(char)v259;
          if (!v274)
            goto LABEL_82;
        }
        LODWORD(v267) = 2;
        v268 = (const char *)v41;
        v42 = (char *)v276;
        if (v277 >= v278)
        {
          v59 = v277 + 1;
          if (v276 <= &v267 && (char *)v276 + 24 * v277 > (char *)&v267)
          {
            v62 = (char *)&v267 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v59, 24);
            v42 = (char *)v276;
            v43 = (unint64_t *)((char *)v276 + v62);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v59, 24);
            v43 = &v267;
            v42 = (char *)v276;
          }
        }
        else
        {
          v43 = &v267;
        }
        v44 = &v42[24 * v277];
        v45 = *(_OWORD *)v43;
        *((_QWORD *)v44 + 2) = v43[2];
        *(_OWORD *)v44 = v45;
        v46 = ++v277;
        if (v274)
        {
          LODWORD(v267) = 3;
          v268 = ", all values should be positive.";
          v269 = 32;
          v47 = (char *)v276;
          if (v46 >= v278)
          {
            v60 = v46 + 1;
            v61 = (char *)v276 + 24 * v46 > (char *)&v267;
            if (v276 <= &v267 && v61)
            {
              v63 = (char *)&v267 - (_BYTE *)v276;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v60, 24);
              v47 = (char *)v276;
              v48 = (unint64_t *)((char *)v276 + v63);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v60, 24);
              v48 = &v267;
              v47 = (char *)v276;
            }
          }
          else
          {
            v48 = &v267;
          }
          v49 = &v47[24 * v277];
          v50 = *(_OWORD *)v48;
          *((_QWORD *)v49 + 2) = v48[2];
          *(_OWORD *)v49 = v50;
          ++v277;
        }
LABEL_82:
        v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
        if (v274)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
        if (v284)
        {
          v51 = __p;
          if (__p)
          {
            v52 = v283;
            v53 = __p;
            if (v283 != __p)
            {
              do
                v52 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v52 - 1);
              while (v52 != v51);
              v53 = __p;
            }
            v283 = v51;
            operator delete(v53);
          }
          v54 = v280;
          if (v280)
          {
            v55 = v281;
            v56 = v280;
            if (v281 != v280)
            {
              do
              {
                v58 = *--v55;
                v57 = v58;
                *v55 = 0;
                if (v58)
                  MEMORY[0x20BD002D4](v57, 0x1000C8077774924);
              }
              while (v55 != v54);
              v56 = v280;
            }
            v281 = v54;
            operator delete(v56);
          }
          if (v276 != v279)
            free(v276);
        }
        if (v259 >= 0x41)
          goto LABEL_101;
LABEL_103:
        if (v40 < 1)
          return v1;
        ++v256;
      }
    }
  }
  else if (v264)
  {
    goto LABEL_59;
  }
LABEL_116:
  if (v263 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v263) == 6)
  {
    v253 = v4;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v254, v263, 0);
    v64 = v263;
    v65 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v263);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v260, v64, v65);
    while (1)
    {
      v66 = v254 == v260 && v255 == v261;
      if (v66 && v256 == v262)
      {
        v4 = v253;
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v254, (llvm::APInt *)&v258);
      if (v259 > 0x40)
      {
        v67 = *(_QWORD *)v258;
        if ((*(_QWORD *)v258 & 0x8000000000000000) == 0)
        {
LABEL_127:
          if (v259 < 0x41)
            goto LABEL_161;
LABEL_159:
          if (v258)
            MEMORY[0x20BD002D4](v258, 0x1000C8000313F17);
          goto LABEL_161;
        }
      }
      else
      {
        v67 = (uint64_t)(v258 << -(char)v259) >> -(char)v259;
        if ((v67 & 0x8000000000000000) == 0)
          goto LABEL_127;
      }
      v273 = 259;
      mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
      if (v259 > 0x40)
      {
        v68 = *(_QWORD *)v258;
        if (!v274)
          goto LABEL_140;
      }
      else
      {
        v68 = (uint64_t)(v258 << -(char)v259) >> -(char)v259;
        if (!v274)
          goto LABEL_140;
      }
      LODWORD(v267) = 2;
      v268 = (const char *)v68;
      v69 = (char *)v276;
      if (v277 >= v278)
      {
        v86 = v277 + 1;
        if (v276 <= &v267 && (char *)v276 + 24 * v277 > (char *)&v267)
        {
          v89 = (char *)&v267 - (_BYTE *)v276;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v86, 24);
          v69 = (char *)v276;
          v70 = (unint64_t *)((char *)v276 + v89);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v86, 24);
          v70 = &v267;
          v69 = (char *)v276;
        }
      }
      else
      {
        v70 = &v267;
      }
      v71 = &v69[24 * v277];
      v72 = *(_OWORD *)v70;
      *((_QWORD *)v71 + 2) = v70[2];
      *(_OWORD *)v71 = v72;
      v73 = ++v277;
      if (v274)
      {
        LODWORD(v267) = 3;
        v268 = ", all values should be non-negative.";
        v269 = 36;
        v74 = (char *)v276;
        if (v73 >= v278)
        {
          v87 = v73 + 1;
          v88 = (char *)v276 + 24 * v73 > (char *)&v267;
          if (v276 <= &v267 && v88)
          {
            v90 = (char *)&v267 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v87, 24);
            v74 = (char *)v276;
            v75 = (unint64_t *)((char *)v276 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v87, 24);
            v75 = &v267;
            v74 = (char *)v276;
          }
        }
        else
        {
          v75 = &v267;
        }
        v76 = &v74[24 * v277];
        v77 = *(_OWORD *)v75;
        *((_QWORD *)v76 + 2) = v75[2];
        *(_OWORD *)v76 = v77;
        ++v277;
      }
LABEL_140:
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
      if (v274)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
      if (v284)
      {
        v78 = __p;
        if (__p)
        {
          v79 = v283;
          v80 = __p;
          if (v283 != __p)
          {
            do
              v79 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v79 - 1);
            while (v79 != v78);
            v80 = __p;
          }
          v283 = v78;
          operator delete(v80);
        }
        v81 = v280;
        if (v280)
        {
          v82 = v281;
          v83 = v280;
          if (v281 != v280)
          {
            do
            {
              v85 = *--v82;
              v84 = v85;
              *v82 = 0;
              if (v85)
                MEMORY[0x20BD002D4](v84, 0x1000C8077774924);
            }
            while (v82 != v81);
            v83 = v280;
          }
          v281 = v81;
          operator delete(v83);
        }
        if (v276 != v279)
          free(v276);
      }
      if (v259 >= 0x41)
        goto LABEL_159;
LABEL_161:
      if (v67 < 0)
        return v1;
      ++v256;
    }
  }
  v270 = (void *)v266[2 * (((unint64_t)*((unsigned int *)v266 + 11) >> 23) & 1) + 8];
  mlir::IntegerAttr::getValue(&v270, (llvm::APInt *)&v274);
  if (v275 > 0x40)
  {
    v94 = *v274;
    MEMORY[0x20BD002D4]();
    v92 = v94 << 32;
    v93 = (const char *)(int)v94;
    if (!v4)
    {
LABEL_197:
      v267 = 0;
      goto LABEL_198;
    }
  }
  else
  {
    v91 = (uint64_t)((_QWORD)v274 << -(uint64_t)v275) >> -(uint64_t)v275;
    v92 = v91 << 32;
    v93 = (const char *)(int)v91;
    if (!v4)
      goto LABEL_197;
  }
  v95 = *(_QWORD *)(v4 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v95)
    goto LABEL_197;
  v96 = *(void **)(*(_QWORD *)v95 + 136);
  if (v96 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v95 = 0;
  v267 = v95;
  if (v96 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v267);
    v98 = (const char *)v97;
    if (v97 <= 3)
    {
      v273 = 259;
      mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
      if (v274)
      {
        LODWORD(v254) = 2;
        v255 = v98;
        v99 = &v254;
        v100 = (char *)v276;
        if (v277 >= v278)
        {
          v216 = v277 + 1;
          if (v276 <= &v254 && (char *)v276 + 24 * v277 > (char *)&v254)
          {
            v239 = (char *)&v254 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v216, 24);
            v100 = (char *)v276;
            v99 = (const void ***)((char *)v276 + v239);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v216, 24);
            v99 = &v254;
            v100 = (char *)v276;
          }
        }
        v101 = &v100[24 * v277];
        v102 = *(_OWORD *)v99;
        *((_QWORD *)v101 + 2) = v99[2];
        *(_OWORD *)v101 = v102;
        v103 = ++v277;
        if (v274)
        {
          LODWORD(v254) = 3;
          v255 = ".";
          v256 = 1;
          v104 = &v254;
          v105 = (char *)v276;
          if (v103 >= v278)
          {
            v218 = v103 + 1;
            v219 = (char *)v276 + 24 * v103 > (char *)&v254;
            if (v276 <= &v254 && v219)
            {
              v241 = (char *)&v254 - (_BYTE *)v276;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v218, 24);
              v105 = (char *)v276;
              v104 = (const void ***)((char *)v276 + v241);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v218, 24);
              v104 = &v254;
              v105 = (char *)v276;
            }
          }
          v106 = &v105[24 * v277];
          v107 = *(_OWORD *)v104;
          *((_QWORD *)v106 + 2) = v104[2];
          *(_OWORD *)v106 = v107;
          ++v277;
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
      if (v274)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
      if (!v284)
        return v1;
      v108 = __p;
      if (__p)
      {
        v109 = v283;
        v110 = __p;
        if (v283 != __p)
        {
          do
            v109 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v109 - 1);
          while (v109 != v108);
          v110 = __p;
        }
        v283 = v108;
        operator delete(v110);
      }
      v111 = v280;
      if (!v280)
        goto LABEL_313;
      v112 = v281;
      v113 = v280;
      if (v281 == v280)
        goto LABEL_312;
      do
      {
        v132 = *--v112;
        v131 = v132;
        *v112 = 0;
        if (v132)
          MEMORY[0x20BD002D4](v131, 0x1000C8077774924);
      }
      while (v112 != v111);
      goto LABEL_311;
    }
    if (v92 >= 0)
      v159 = v97;
    else
      v159 = 0;
    if ((unint64_t)&v93[-v159] <= 0xFFFFFFFFFFFFFFFBLL)
    {
      v273 = 259;
      mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
      if (v274)
      {
        LODWORD(v254) = 2;
        v255 = v93;
        v160 = &v254;
        v161 = (char *)v276;
        if (v277 >= v278)
        {
          v222 = v277 + 1;
          if (v276 <= &v254 && (char *)v276 + 24 * v277 > (char *)&v254)
          {
            v243 = (char *)&v254 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v222, 24);
            v161 = (char *)v276;
            v160 = (const void ***)((char *)v276 + v243);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v222, 24);
            v160 = &v254;
            v161 = (char *)v276;
          }
        }
        v162 = &v161[24 * v277];
        v163 = *(_OWORD *)v160;
        *((_QWORD *)v162 + 2) = v160[2];
        *(_OWORD *)v162 = v163;
        v164 = ++v277;
        if (v274)
        {
          LODWORD(v254) = 3;
          v255 = " for input rank ";
          v256 = 16;
          v165 = &v254;
          v166 = (char *)v276;
          if (v164 >= v278)
          {
            v224 = v164 + 1;
            v225 = (char *)v276 + 24 * v164 > (char *)&v254;
            if (v276 <= &v254 && v225)
            {
              v245 = (char *)&v254 - (_BYTE *)v276;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v224, 24);
              v166 = (char *)v276;
              v165 = (const void ***)((char *)v276 + v245);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v224, 24);
              v165 = &v254;
              v166 = (char *)v276;
            }
          }
          v167 = &v166[24 * v277];
          v168 = *(_OWORD *)v165;
          *((_QWORD *)v167 + 2) = v165[2];
          *(_OWORD *)v167 = v168;
          v169 = ++v277;
          if (v274)
          {
            LODWORD(v254) = 2;
            v255 = v98;
            v170 = &v254;
            v171 = (char *)v276;
            if (v169 >= v278)
            {
              v228 = v169 + 1;
              v229 = (char *)v276 + 24 * v169 > (char *)&v254;
              if (v276 <= &v254 && v229)
              {
                v247 = (char *)&v254 - (_BYTE *)v276;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v228, 24);
                v171 = (char *)v276;
                v170 = (const void ***)((char *)v276 + v247);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v228, 24);
                v170 = &v254;
                v171 = (char *)v276;
              }
            }
            v172 = &v171[24 * v277];
            v173 = *(_OWORD *)v170;
            *((_QWORD *)v172 + 2) = v170[2];
            *(_OWORD *)v172 = v173;
            v174 = ++v277;
            if (v274)
            {
              LODWORD(v254) = 3;
              v255 = ".";
              v256 = 1;
              v175 = &v254;
              v176 = (char *)v276;
              if (v174 >= v278)
              {
                v232 = v174 + 1;
                v233 = (char *)v276 + 24 * v174 > (char *)&v254;
                if (v276 <= &v254 && v233)
                {
                  v249 = (char *)&v254 - (_BYTE *)v276;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v232, 24);
                  v176 = (char *)v276;
                  v175 = (const void ***)((char *)v276 + v249);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v232, 24);
                  v175 = &v254;
                  v176 = (char *)v276;
                }
              }
              v177 = &v176[24 * v277];
              v178 = *(_OWORD *)v175;
              *((_QWORD *)v177 + 2) = v175[2];
              *(_OWORD *)v177 = v178;
              ++v277;
            }
          }
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
      if (v274)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
      if (!v284)
        return v1;
      v179 = __p;
      if (__p)
      {
        v180 = v283;
        v181 = __p;
        if (v283 != __p)
        {
          do
            v180 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v180 - 1);
          while (v180 != v179);
          v181 = __p;
        }
        v283 = v179;
        operator delete(v181);
      }
      v111 = v280;
      if (!v280)
        goto LABEL_313;
      v182 = v281;
      v113 = v280;
      if (v281 == v280)
        goto LABEL_312;
      do
      {
        v184 = *--v182;
        v183 = v184;
        *v182 = 0;
        if (v184)
          MEMORY[0x20BD002D4](v183, 0x1000C8077774924);
      }
      while (v182 != v111);
LABEL_311:
      v113 = v280;
LABEL_312:
      v281 = v111;
      operator delete(v113);
      goto LABEL_313;
    }
  }
LABEL_198:
  if (!v5 || (v114 = *(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    v258 = 0;
    goto LABEL_224;
  }
  v115 = *(void **)(*(_QWORD *)v114 + 136);
  if (v115 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v114 = 0;
  v258 = v114;
  if (v115 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_224:
    v270 = v272;
    v271 = 0x500000000;
    v1 = 1;
    if (mlir::matchConstantWithIntVector<long long>(v6, (uint64_t)&v270) && (_DWORD)v271 != 4)
    {
      v257 = 259;
      mlir::OpState::emitOpError(&v266, &v254, (uint64_t)&v274);
      if (v274)
      {
        LODWORD(v260) = 3;
        v262 = 21;
        v133 = &v260;
        v134 = (char *)v276;
        if (v277 >= v278)
        {
          v211 = v277 + 1;
          if (v276 <= &v260 && (char *)v276 + 24 * v277 > (char *)&v260)
          {
            v236 = (char *)&v260 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v211, 24);
            v134 = (char *)v276;
            v133 = (const void ***)((char *)v276 + v236);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v211, 24);
            v133 = &v260;
            v134 = (char *)v276;
          }
        }
        v135 = &v134[24 * v277];
        v136 = *(_OWORD *)v133;
        *((_QWORD *)v135 + 2) = v133[2];
        *(_OWORD *)v135 = v136;
        v137 = ++v277;
        if (v274)
        {
          LODWORD(v260) = 5;
          v261 = (const char *)v271;
          v138 = &v260;
          v139 = (char *)v276;
          if (v137 >= v278)
          {
            v212 = v137 + 1;
            v213 = (char *)v276 + 24 * v137 > (char *)&v260;
            if (v276 <= &v260 && v213)
            {
              v237 = (char *)&v260 - (_BYTE *)v276;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v212, 24);
              v139 = (char *)v276;
              v138 = (const void ***)((char *)v276 + v237);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v212, 24);
              v138 = &v260;
              v139 = (char *)v276;
            }
          }
          v140 = &v139[24 * v277];
          v141 = *(_OWORD *)v138;
          *((_QWORD *)v140 + 2) = v138[2];
          *(_OWORD *)v140 = v141;
          v142 = ++v277;
          if (v274)
          {
            LODWORD(v260) = 3;
            v261 = " values.";
            v262 = 8;
            v143 = &v260;
            v144 = (char *)v276;
            if (v142 >= v278)
            {
              v214 = v142 + 1;
              v215 = (char *)v276 + 24 * v142 > (char *)&v260;
              if (v276 <= &v260 && v215)
              {
                v238 = (char *)&v260 - (_BYTE *)v276;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v214, 24);
                v144 = (char *)v276;
                v143 = (const void ***)((char *)v276 + v238);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v214, 24);
                v143 = &v260;
                v144 = (char *)v276;
              }
            }
            v145 = &v144[24 * v277];
            v146 = *(_OWORD *)v143;
            *((_QWORD *)v145 + 2) = v143[2];
            *(_OWORD *)v145 = v146;
            ++v277;
          }
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
      if (v274)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
      if (v284)
      {
        v147 = __p;
        if (__p)
        {
          v148 = v283;
          v149 = __p;
          if (v283 != __p)
          {
            do
              v148 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v148 - 1);
            while (v148 != v147);
            v149 = __p;
          }
          v283 = v147;
          operator delete(v149);
        }
        v150 = v280;
        if (v280)
        {
          v151 = v281;
          v152 = v280;
          if (v281 != v280)
          {
            do
            {
              v154 = *--v151;
              v153 = v154;
              *v151 = 0;
              if (v154)
                MEMORY[0x20BD002D4](v153, 0x1000C8077774924);
            }
            while (v151 != v150);
            v152 = v280;
          }
          v281 = v150;
          operator delete(v152);
        }
        if (v276 != v279)
          free(v276);
      }
    }
    v157 = v270;
    if (v270 != v272)
    {
LABEL_255:
      free(v157);
      return v1;
    }
    return v1;
  }
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v258);
  v117 = (const char *)v116;
  if (v116 > 3)
  {
    if (v92 >= 0)
      v185 = v116;
    else
      v185 = 0;
    if ((unint64_t)&v93[-v185] <= 0xFFFFFFFFFFFFFFFBLL)
    {
      v273 = 259;
      mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
      if (v274)
      {
        LODWORD(v254) = 2;
        v255 = v93;
        v186 = &v254;
        v187 = (char *)v276;
        if (v277 >= v278)
        {
          v223 = v277 + 1;
          if (v276 <= &v254 && (char *)v276 + 24 * v277 > (char *)&v254)
          {
            v244 = (char *)&v254 - (_BYTE *)v276;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v223, 24);
            v187 = (char *)v276;
            v186 = (const void ***)((char *)v276 + v244);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v223, 24);
            v186 = &v254;
            v187 = (char *)v276;
          }
        }
        v188 = &v187[24 * v277];
        v189 = *(_OWORD *)v186;
        *((_QWORD *)v188 + 2) = v186[2];
        *(_OWORD *)v188 = v189;
        v190 = ++v277;
        if (v274)
        {
          LODWORD(v254) = 3;
          v255 = " for input gradient rank ";
          v256 = 25;
          v191 = &v254;
          v192 = (char *)v276;
          if (v190 >= v278)
          {
            v226 = v190 + 1;
            v227 = (char *)v276 + 24 * v190 > (char *)&v254;
            if (v276 <= &v254 && v227)
            {
              v246 = (char *)&v254 - (_BYTE *)v276;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v226, 24);
              v192 = (char *)v276;
              v191 = (const void ***)((char *)v276 + v246);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v226, 24);
              v191 = &v254;
              v192 = (char *)v276;
            }
          }
          v193 = &v192[24 * v277];
          v194 = *(_OWORD *)v191;
          *((_QWORD *)v193 + 2) = v191[2];
          *(_OWORD *)v193 = v194;
          v195 = ++v277;
          if (v274)
          {
            LODWORD(v254) = 2;
            v255 = v117;
            v196 = &v254;
            v197 = (char *)v276;
            if (v195 >= v278)
            {
              v230 = v195 + 1;
              v231 = (char *)v276 + 24 * v195 > (char *)&v254;
              if (v276 <= &v254 && v231)
              {
                v248 = (char *)&v254 - (_BYTE *)v276;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v230, 24);
                v197 = (char *)v276;
                v196 = (const void ***)((char *)v276 + v248);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v230, 24);
                v196 = &v254;
                v197 = (char *)v276;
              }
            }
            v198 = &v197[24 * v277];
            v199 = *(_OWORD *)v196;
            *((_QWORD *)v198 + 2) = v196[2];
            *(_OWORD *)v198 = v199;
            v200 = ++v277;
            if (v274)
            {
              LODWORD(v254) = 3;
              v255 = ".";
              v256 = 1;
              v201 = &v254;
              v202 = (char *)v276;
              if (v200 >= v278)
              {
                v234 = v200 + 1;
                v235 = (char *)v276 + 24 * v200 > (char *)&v254;
                if (v276 <= &v254 && v235)
                {
                  v250 = (char *)&v254 - (_BYTE *)v276;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v234, 24);
                  v202 = (char *)v276;
                  v201 = (const void ***)((char *)v276 + v250);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v234, 24);
                  v201 = &v254;
                  v202 = (char *)v276;
                }
              }
              v203 = &v202[24 * v277];
              v204 = *(_OWORD *)v201;
              *((_QWORD *)v203 + 2) = v201[2];
              *(_OWORD *)v203 = v204;
              ++v277;
            }
          }
        }
      }
      v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
      if (v274)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
      if (!v284)
        return v1;
      v205 = __p;
      if (__p)
      {
        v206 = v283;
        v207 = __p;
        if (v283 != __p)
        {
          do
            v206 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v206 - 1);
          while (v206 != v205);
          v207 = __p;
        }
        v283 = v205;
        operator delete(v207);
      }
      v111 = v280;
      if (!v280)
        goto LABEL_313;
      v208 = v281;
      v113 = v280;
      if (v281 == v280)
        goto LABEL_312;
      do
      {
        v210 = *--v208;
        v209 = v210;
        *v208 = 0;
        if (v210)
          MEMORY[0x20BD002D4](v209, 0x1000C8077774924);
      }
      while (v208 != v111);
      goto LABEL_311;
    }
    goto LABEL_224;
  }
  v273 = 259;
  mlir::OpState::emitOpError(&v266, (const void ***)&v270, (uint64_t)&v274);
  if (v274)
  {
    LODWORD(v254) = 2;
    v255 = v117;
    v118 = &v254;
    v119 = (char *)v276;
    if (v277 >= v278)
    {
      v217 = v277 + 1;
      if (v276 <= &v254 && (char *)v276 + 24 * v277 > (char *)&v254)
      {
        v240 = (char *)&v254 - (_BYTE *)v276;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v217, 24);
        v119 = (char *)v276;
        v118 = (const void ***)((char *)v276 + v240);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v217, 24);
        v118 = &v254;
        v119 = (char *)v276;
      }
    }
    v120 = &v119[24 * v277];
    v121 = *(_OWORD *)v118;
    *((_QWORD *)v120 + 2) = v118[2];
    *(_OWORD *)v120 = v121;
    v122 = ++v277;
    if (v274)
    {
      LODWORD(v254) = 3;
      v255 = ".";
      v256 = 1;
      v123 = &v254;
      v124 = (char *)v276;
      if (v122 >= v278)
      {
        v220 = v122 + 1;
        v221 = (char *)v276 + 24 * v122 > (char *)&v254;
        if (v276 <= &v254 && v221)
        {
          v242 = (char *)&v254 - (_BYTE *)v276;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v220, 24);
          v124 = (char *)v276;
          v123 = (const void ***)((char *)v276 + v242);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v276, v279, v220, 24);
          v123 = &v254;
          v124 = (char *)v276;
        }
      }
      v125 = &v124[24 * v277];
      v126 = *(_OWORD *)v123;
      *((_QWORD *)v125 + 2) = v123[2];
      *(_OWORD *)v125 = v126;
      ++v277;
    }
  }
  v1 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v274);
  if (v274)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v274);
  if (v284)
  {
    v127 = __p;
    if (__p)
    {
      v128 = v283;
      v129 = __p;
      if (v283 != __p)
      {
        do
          v128 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v128 - 1);
        while (v128 != v127);
        v129 = __p;
      }
      v283 = v127;
      operator delete(v129);
    }
    v111 = v280;
    if (v280)
    {
      v130 = v281;
      v113 = v280;
      if (v281 == v280)
        goto LABEL_312;
      do
      {
        v156 = *--v130;
        v155 = v156;
        *v130 = 0;
        if (v156)
          MEMORY[0x20BD002D4](v155, 0x1000C8077774924);
      }
      while (v130 != v111);
      goto LABEL_311;
    }
LABEL_313:
    v157 = v276;
    if (v276 == v279)
      return v1;
    goto LABEL_255;
  }
  return v1;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  unint64_t v26[3];

  v26[2] = *MEMORY[0x24BDAC8D0];
  v22[0] = a4;
  v22[1] = a5;
  if (a5 != 3)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = mlir::ValueRange::dereference_iterator(v22, 0);
  v12 = mlir::ValueRange::dereference_iterator(v22, 1);
  v13 = mlir::ValueRange::dereference_iterator(v22, 2);
  v14 = (void *)(*(_QWORD *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8);
  v15 = *(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8;
  v23 = v14;
  v24 = v15;
  mlir::ValueRange::ValueRange(v26, (uint64_t)&v23, 2uLL);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v15 + 8))
  {
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v15 + 8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v14 + 8))
      goto LABEL_4;
LABEL_8:
    v14 = 0;
    if (!v15)
      goto LABEL_20;
    goto LABEL_9;
  }
  v15 = 0;
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v14 + 8))
    goto LABEL_8;
LABEL_4:
  mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v14 + 8);
  if (!v15)
    goto LABEL_20;
LABEL_9:
  if (*(_UNKNOWN **)(*(_QWORD *)v15 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && v14
    && *(_UNKNOWN **)(*(_QWORD *)v14 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v23 = v25;
    v24 = 0x400000000;
    if (mlir::matchConstantWithIntVector<long long>(v13, (uint64_t)&v23))
    {
      v18 = v24;
      if (v24 <= 3)
      {
        if (HIDWORD(v24) > 3
          || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v25, 4uLL, 8), v18 = v24, (_DWORD)v24 != 4))
        {
          bzero((char *)v23 + 8 * v18, 32 - 8 * v18);
        }
        v18 = 4;
        LODWORD(v24) = 4;
      }
      v19 = mlir::RankedTensorType::get((uint64_t)v23, v18, v16, 0);
      v20 = v23;
      if (v23 == v25)
        goto LABEL_21;
    }
    else
    {
      v19 = mlir::UnrankedTensorType::get(v16);
      v20 = v23;
      if (v23 == v25)
        goto LABEL_21;
    }
    free(v20);
    goto LABEL_21;
  }
LABEL_20:
  v19 = mlir::UnrankedTensorType::get(v16);
LABEL_21:
  v21 = *(unsigned int *)(a11 + 8);
  if (v21 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v21 + 1, 8);
    LODWORD(v21) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v21) = v19;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::checkInputTensors<mlir::mps::PoolMaxGradientOp>(uint64_t a1)
{
  unint64_t v1;
  unsigned int *v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  const void **v24;
  __int16 v25;
  uint64_t *v26;
  _QWORD v27[3];
  void *v28;
  uint64_t v29;
  void *v30;
  _QWORD *v31;
  void *__p;
  _QWORD *v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v26 = (uint64_t *)a1;
  v1 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v2 = (unsigned int *)(a1 + 16 * ((v1 >> 23) & 1) + 64);
  else
    v2 = 0;
  v3 = v2[18];
  v4 = v2[19];
  if ((v1 & 0x800000) != 0)
  {
    v5 = *(_QWORD *)(a1 + 72);
    if (v4)
      goto LABEL_6;
  }
  else
  {
    v5 = 0;
    if (v4)
    {
LABEL_6:
      v6 = *(_QWORD *)(v5 + 32 * v3 + 24);
      v7 = v4 + v3;
      v8 = v2[20];
      if ((v1 & 0x800000) != 0)
        goto LABEL_7;
      goto LABEL_16;
    }
  }
  v6 = 0;
  v7 = v4 + v3;
  v8 = v2[20];
  if ((v1 & 0x800000) != 0)
  {
LABEL_7:
    v9 = *(_QWORD *)(a1 + 72);
    if (v8)
      goto LABEL_8;
    goto LABEL_17;
  }
LABEL_16:
  v9 = 0;
  if (v8)
  {
LABEL_8:
    v10 = *(_QWORD *)(v9 + 32 * v7 + 24);
    v11 = v2[21];
    if ((v1 & 0x800000) != 0)
      goto LABEL_9;
    goto LABEL_18;
  }
LABEL_17:
  v10 = 0;
  v11 = v2[21];
  if ((v1 & 0x800000) != 0)
  {
LABEL_9:
    v12 = *(_QWORD *)(a1 + 72);
    if (v11)
      goto LABEL_10;
LABEL_19:
    v13 = 0;
    if (v10)
      goto LABEL_11;
LABEL_20:
    if (!v6 || v13)
      goto LABEL_23;
    return 1;
  }
LABEL_18:
  v12 = 0;
  if (!v11)
    goto LABEL_19;
LABEL_10:
  v13 = *(_QWORD *)(v12 + 32 * (v8 + v7) + 24);
  if (!v10)
    goto LABEL_20;
LABEL_11:
  if (v13 && !v6)
    return 1;
LABEL_23:
  v24 = (const void **)"op supports only (gradient && input) || (gradient && indices && ouput_shape) as parameters";
  v25 = 259;
  mlir::OpState::emitOpError(&v26, &v24, (uint64_t)v27);
  v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v27);
  if (v27[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v27);
  if (v34)
  {
    v15 = __p;
    if (__p)
    {
      v16 = v33;
      v17 = __p;
      if (v33 != __p)
      {
        do
          v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v16 - 1);
        while (v16 != v15);
        v17 = __p;
      }
      v33 = v15;
      operator delete(v17);
    }
    v18 = v30;
    if (v30)
    {
      v19 = v31;
      v20 = v30;
      if (v31 != v30)
      {
        do
        {
          v22 = *--v19;
          v21 = v22;
          *v19 = 0;
          if (v22)
            MEMORY[0x20BD002D4](v21, 0x1000C8077774924);
        }
        while (v19 != v18);
        v20 = v30;
      }
      v31 = v18;
      operator delete(v20);
    }
    if (v28 != &v29)
      free(v28);
  }
  return v14;
}

uint64_t mlir::mps::inferPool4DShape(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4, uint64_t *a5, _QWORD *a6, _QWORD *a7, int a8, unsigned __int8 a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 *v24;
  _OWORD *v25;
  unint64_t v26;
  __int128 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v109;
  _QWORD *v110;
  _QWORD *v111;

  v12 = *((unsigned int *)a4 + 2);
  if (v12 >= 4)
    v13 = 4;
  else
    v13 = *((unsigned int *)a4 + 2);
  if (v12 <= 3)
    v14 = 0;
  else
    v14 = v12 - v13;
  v15 = *(unsigned int *)(a10 + 8);
  v16 = v12 - v15;
  if ((_DWORD)v12 != (_DWORD)v15)
  {
    if (v12 >= v15)
    {
      v110 = a3;
      v111 = a6;
      v17 = a7;
      v18 = a8;
      v19 = *(unsigned int *)(a10 + 8);
      v20 = *(_DWORD *)(a10 + 8);
      if (*(_DWORD *)(a10 + 12) < v12)
      {
        v109 = *((unsigned int *)a4 + 2);
        llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v12, 8);
        v12 = v109;
        v19 = *(unsigned int *)(a10 + 8);
        v20 = *(_DWORD *)(a10 + 8);
      }
      bzero((void *)(*(_QWORD *)a10 + 8 * v19), 8 * (v12 - v15));
      LODWORD(v12) = v20 + v16;
      a8 = v18;
      a7 = v17;
      a3 = v110;
      a6 = v111;
    }
    *(_DWORD *)(a10 + 8) = v12;
  }
  if (v14)
  {
    v21 = 0;
    v22 = *a4;
    v23 = *(_QWORD *)a10;
    if (v14 < 4)
      goto LABEL_19;
    if ((unint64_t)(v23 - v22) < 0x20)
      goto LABEL_19;
    v21 = v14 & 0xFFFFFFFFFFFFFFFCLL;
    v24 = (__int128 *)(v22 + 16);
    v25 = (_OWORD *)(v23 + 16);
    v26 = v14 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v27 = *v24;
      *(v25 - 1) = *(v24 - 1);
      *v25 = v27;
      v24 += 2;
      v25 += 2;
      v26 -= 4;
    }
    while (v26);
    if (v14 != v21)
    {
LABEL_19:
      v28 = v14 - v21;
      v29 = 8 * v21;
      v30 = (uint64_t *)(v22 + v29);
      v31 = (_QWORD *)(v23 + v29);
      do
      {
        v32 = *v30++;
        *v31++ = v32;
        --v28;
      }
      while (v28);
    }
  }
  if (v13)
  {
    v33 = *a4;
    v34 = *a5;
    v35 = *(_QWORD *)a10;
    if (a8 == 4 || a8 == 2)
    {
      v36 = -v13;
      v37 = v34 + 32;
      v38 = (uint64_t *)(v35 + 8 * v14);
      v39 = (uint64_t *)(v33 + 8 * v14);
      do
      {
        v42 = *v39++;
        v41 = v42;
        if (*(uint64_t *)(v37 + 8 * v36) <= 1)
          v43 = 1;
        else
          v43 = *(_QWORD *)(v37 + 8 * v36);
        v44 = v41;
        if ((unint64_t)v43 >= 2)
        {
          v44 = 0x8000000000000000;
          if (v41 != 0x8000000000000000)
          {
            v44 = v41 / v43;
            if (v41 / v43 * v43 != v41)
              v44 += v41 >= 0;
          }
        }
        *v38++ = v44;
      }
      while (!__CFADD__(v36++, 1));
    }
    else
    {
      v45 = a9;
      v46 = *a3;
      v47 = *a6;
      v48 = *a7;
      v49 = *(_QWORD *)(v33 + 8 * v14);
      v50 = 4 - v13;
      v51 = *(_QWORD *)(*a3 + 8 * (4 - v13));
      v52 = 0x8000000000000000;
      if (v51 != 0x8000000000000000 && v49 != 0x8000000000000000)
      {
        v54 = *(_QWORD *)(v48 + 16 * v50 + 8) & ~(*(uint64_t *)(v48 + 16 * v50 + 8) >> 63);
        v55 = *(_QWORD *)(v48 + 16 * v50) & ~(*(uint64_t *)(v48 + 16 * v50) >> 63);
        v56 = 8 * v50;
        v57 = *(_QWORD *)(v47 + v56);
        if (v57 <= 1)
          v57 = 1;
        v58 = *(_QWORD *)(v34 + v56);
        if (v58 <= 1)
          v58 = 1;
        if (a8 == 1)
        {
          v54 = 0;
          v55 = 0;
        }
        v59 = v58 + v49 + v55 + v54 + ~(v57 * (v51 - 1));
        v60 = v59 / v58;
        v61 = v59 / v58 * v58;
        if (v59 >= 0)
          v62 = a9;
        else
          v62 = a9 - 1;
        if (v61 == v59)
          v63 = 0;
        else
          v63 = v62;
        v52 = (v60 + v63) & ~((v60 + v63) >> 63);
      }
      *(_QWORD *)(v35 + 8 * v14) = v52;
      if (v13 != 1)
      {
        v64 = v14 + 1;
        v65 = 5 - v13;
        v66 = *(_QWORD *)(v46 + 8 * (5 - v13));
        v67 = 0x8000000000000000;
        if (v66 != 0x8000000000000000)
        {
          v68 = *(_QWORD *)(v33 + 8 * v64);
          if (v68 != 0x8000000000000000)
          {
            v69 = *(_QWORD *)(v48 + 16 * v65 + 8) & ~(*(uint64_t *)(v48 + 16 * v65 + 8) >> 63);
            v70 = *(_QWORD *)(v48 + 16 * v65) & ~(*(uint64_t *)(v48 + 16 * v65) >> 63);
            v71 = 8 * v65;
            v72 = *(_QWORD *)(v47 + v71);
            if (v72 <= 1)
              v72 = 1;
            v73 = *(_QWORD *)(v34 + v71);
            if (v73 <= 1)
              v73 = 1;
            if (a8 == 1)
            {
              v69 = 0;
              v70 = 0;
            }
            v74 = v73 + v68 + v70 + v69 + ~(v72 * (v66 - 1));
            v75 = v74 / v73;
            v76 = v74 / v73 * v73;
            if (v74 >= 0)
              v77 = a9;
            else
              v77 = a9 - 1;
            if (v76 == v74)
              v78 = 0;
            else
              v78 = v77;
            v67 = (v75 + v78) & ~((v75 + v78) >> 63);
          }
        }
        *(_QWORD *)(v35 + 8 * v64) = v67;
        if (v13 != 2)
        {
          v79 = v14 + 2;
          v80 = 6 - v13;
          v81 = *(_QWORD *)(v46 + 8 * (6 - v13));
          v82 = 0x8000000000000000;
          if (v81 != 0x8000000000000000)
          {
            v83 = *(_QWORD *)(v33 + 8 * v79);
            if (v83 != 0x8000000000000000)
            {
              v84 = *(_QWORD *)(v48 + 16 * v80 + 8) & ~(*(uint64_t *)(v48 + 16 * v80 + 8) >> 63);
              v85 = *(_QWORD *)(v48 + 16 * v80) & ~(*(uint64_t *)(v48 + 16 * v80) >> 63);
              v86 = 8 * v80;
              v87 = *(_QWORD *)(v47 + v86);
              if (v87 <= 1)
                v87 = 1;
              v88 = *(_QWORD *)(v34 + v86);
              if (v88 <= 1)
                v88 = 1;
              if (a8 == 1)
              {
                v84 = 0;
                v85 = 0;
              }
              v89 = v88 + v83 + v85 + v84 + ~(v87 * (v81 - 1));
              v90 = v89 / v88;
              v91 = v89 / v88 * v88;
              if (v89 >= 0)
                v92 = a9;
              else
                v92 = a9 - 1;
              if (v91 == v89)
                v93 = 0;
              else
                v93 = v92;
              v82 = (v90 + v93) & ~((v90 + v93) >> 63);
            }
          }
          *(_QWORD *)(v35 + 8 * v79) = v82;
          if (v13 != 3)
          {
            v94 = v14 + 3;
            v95 = v13 ^ 7;
            v96 = *(_QWORD *)(v46 + 8 * (v13 ^ 7));
            v97 = 0x8000000000000000;
            if (v96 != 0x8000000000000000)
            {
              v98 = *(_QWORD *)(v33 + 8 * v94);
              if (v98 != 0x8000000000000000)
              {
                v99 = *(_QWORD *)(v48 + 16 * v95 + 8) & ~(*(uint64_t *)(v48 + 16 * v95 + 8) >> 63);
                v100 = *(_QWORD *)(v48 + 16 * v95) & ~(*(uint64_t *)(v48 + 16 * v95) >> 63);
                v101 = 8 * v95;
                v102 = *(_QWORD *)(v47 + v101);
                if (v102 <= 1)
                  v102 = 1;
                v103 = *(_QWORD *)(v34 + v101);
                if (v103 <= 1)
                  v103 = 1;
                if (a8 == 1)
                  v104 = 0;
                else
                  v104 = v99;
                if (a8 == 1)
                  v100 = 0;
                v105 = v103 + v98 + v100 + v104 + ~(v102 * (v96 - 1));
                v106 = v105 / v103;
                v107 = v105 / v103 * v103;
                if (v105 < 0)
                  v45 = a9 - 1;
                if (v107 == v105)
                  v45 = 0;
                v97 = (v106 + v45) & ~((v106 + v45) >> 63);
              }
            }
            *(_QWORD *)(v35 + 8 * v94) = v97;
          }
        }
      }
    }
  }
  return 1;
}

uint64_t mlir::mps::inferPool4DGradientOpReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int64x2_t *v12;
  int v13;
  __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int64x2_t *v18;
  int64x2_t v19;
  uint64_t v20;
  int32x2_t v21;
  int32x2_t v22;
  uint64_t v23;
  uint64_t ElementTypeOrSelf;
  uint64_t v26;
  uint64_t OperandRange;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  _BYTE v34[32];
  _QWORD v35[3];

  v35[2] = *MEMORY[0x24BDAC8D0];
  v35[0] = a3;
  v35[1] = a4;
  v7 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v35, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
  {
    v30 = 0;
    v31 = 0;
    if (a4 == 3)
      goto LABEL_3;
LABEL_21:
    v23 = mlir::ValueRange::dereference_iterator(v35, 1);
  }
  v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
  v30 = v7;
  v31 = v8;
  if (a4 != 3)
    goto LABEL_21;
LABEL_3:
  v32 = v34;
  v33 = 0x400000000;
  v9 = mlir::ValueRange::dereference_iterator(v35, 2);
  if (mlir::matchConstantWithIntVector<long long>(v9, (uint64_t)&v32))
  {
    v10 = v33;
    if (v33 >= 4)
    {
      v12 = (int64x2_t *)v32;
      v14 = (char *)v32 + 8 * v33;
      v15 = 8 * v33 - 8;
      if (v15 >= 0x18)
      {
LABEL_9:
        v16 = (v15 >> 3) + 1;
        v17 = &v12->i64[v16 & 0x3FFFFFFFFFFFFFFCLL];
        v18 = v12 + 1;
        v19.i64[0] = -1;
        v19.i64[1] = -1;
        v20 = v16 & 0x3FFFFFFFFFFFFFFCLL;
        while (1)
        {
          v21 = vmovn_s64(vceqq_s64(v18[-1], v19));
          if ((v21.i8[0] & 1) != 0)
          {
            v18[-1].i64[0] = 0x8000000000000000;
            if ((v21.i8[4] & 1) == 0)
            {
LABEL_13:
              v22 = vmovn_s64(vceqq_s64(*v18, v19));
              if ((v22.i8[0] & 1) == 0)
                goto LABEL_14;
              goto LABEL_18;
            }
          }
          else if ((v21.i8[4] & 1) == 0)
          {
            goto LABEL_13;
          }
          v18[-1].i64[1] = 0x8000000000000000;
          v22 = vmovn_s64(vceqq_s64(*v18, v19));
          if ((v22.i8[0] & 1) == 0)
          {
LABEL_14:
            if ((v22.i8[4] & 1) != 0)
              goto LABEL_19;
            goto LABEL_10;
          }
LABEL_18:
          v18->i64[0] = 0x8000000000000000;
          if ((v22.i8[4] & 1) != 0)
LABEL_19:
            v18->i64[1] = 0x8000000000000000;
LABEL_10:
          v18 += 2;
          v20 -= 4;
          if (!v20)
          {
            if (v16 != (v16 & 0x3FFFFFFFFFFFFFFCLL))
              goto LABEL_28;
            goto LABEL_31;
          }
        }
      }
    }
    else
    {
      if (HIDWORD(v33) <= 3)
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, 4uLL, 8);
      v11 = v33;
      v12 = (int64x2_t *)v32;
      memset_pattern16((char *)v32 + 8 * v33, &unk_207A80400, 32 - 8 * v10);
      v13 = v11 - v10;
      v10 = (v11 - v10 + 4);
      LODWORD(v33) = v13 + 4;
      if (v13 == -4)
      {
        v10 = 0;
        goto LABEL_31;
      }
      v14 = &v12->i8[8 * v10];
      v15 = 8 * v10 - 8;
      if (v15 >= 0x18)
        goto LABEL_9;
    }
    v17 = (uint64_t *)v12;
    do
    {
LABEL_28:
      if (*v17 == -1)
        *v17 = 0x8000000000000000;
      ++v17;
    }
    while (v17 != (uint64_t *)v14);
LABEL_31:
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    v26 = mlir::RankedTensorType::get((uint64_t)v12, v10, OperandRange, 0);
  }
  else
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(v7);
    v26 = mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  v28 = v26;
  v29 = *(unsigned int *)(a5 + 8);
  if (v29 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v29 + 1, 8);
    LODWORD(v29) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v29) = v28;
  ++*(_DWORD *)(a5 + 8);
  if (v32 != v34)
    free(v32);
  return 1;
}

uint64_t mlir::mps::PoolAvgOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, __int128 a9, uint64_t a10)
{
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD v25[7];
  __int128 v26;
  _BYTE v27[64];
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (a7)
  {
    v15 = *a7;
    v16 = a7[1];
    v17 = a7[2];
    v18 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v18 = 0;
    v15 = 0uLL;
    v16 = 0uLL;
    v17 = 0uLL;
  }
  *(_QWORD *)&v26 = a6;
  BYTE8(v26) = 0;
  v27[0] = 0;
  *(_OWORD *)&v27[8] = v15;
  *(_OWORD *)&v27[24] = v16;
  *(_OWORD *)&v27[40] = v17;
  *(_QWORD *)&v27[56] = v18;
  v28 = a9;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v27[0])
      v27[0] = 0;
    mlir::OperationName::OperationName((char *)&v26 + 8, "mps.pooling_average", 19, Context);
    v27[0] = 1;
  }
  *(_QWORD *)&v29 = a4;
  *((_QWORD *)&v29 + 1) = a5;
  if (a5 && (v20 = mlir::UnknownLoc::get(this, a2), mlir::mps::PoolAvgOpAdaptor::verify(&v26, v20)))
  {
    v25[4] = *(_OWORD *)&v27[48];
    v25[5] = v28;
    v25[6] = v29;
    v25[0] = v26;
    v25[1] = *(_OWORD *)v27;
    v25[2] = *(_OWORD *)&v27[16];
    v25[3] = *(_OWORD *)&v27[32];
    return mlir::mps::inferPooling4DOpReturnTypes<mlir::mps::PoolAvgOpAdaptor>((uint64_t)a2, a3, v25, a10);
  }
  else
  {
    v22 = mlir::Float32Type::get(this, a2);
    v23 = mlir::UnrankedTensorType::get(v22);
    v24 = *(unsigned int *)(a10 + 8);
    if (v24 >= *(_DWORD *)(a10 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v24 + 1, 8);
      LODWORD(v24) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v24) = v23;
    ++*(_DWORD *)(a10 + 8);
    return 1;
  }
}

uint64_t mlir::mps::PoolAvgOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  _QWORD *Type;
  _QWORD *v9;
  _QWORD *Shape;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  const char *v65;
  uint64_t Value;
  uint64_t v67;
  uint64_t OperandRange;
  const char *v69;
  uint64_t v70;
  __int16 v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  uint64_t v76;
  void *v77;
  _QWORD *v78;
  void *__p;
  _QWORD *v80;
  char v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v3 = (const char *)a1[9];
  if (v3)
  {
    v5 = (const char *)a1[4];
    v4 = (const char *)a1[5];
    v6 = (const char *)a1[8];
    v7 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
    v69 = v3;
    v70 = v7;
    Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
    v9 = Type;
    if (Type)
      Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
    v73 = v9;
    v74 = Type;
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
    v72 = 4;
    if (v11 == 1
      && *Shape == v72
      && (v65 = v3,
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65),
          v67 = v12,
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
      if (!v6)
        goto LABEL_103;
      v13 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
      v69 = v6;
      v70 = v13;
      v14 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
      v15 = v14;
      if (v14)
        v14 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v14 + 8);
      v73 = v15;
      v74 = v14;
      v16 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
      v72 = 4;
      if (v17 != 1)
        goto LABEL_54;
      if (*v16 == v72
        && (v65 = v6,
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65),
            v67 = v18,
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
            mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
      {
LABEL_103:
        if (!v5)
          goto LABEL_104;
        v19 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
        v69 = v5;
        v70 = v19;
        v20 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
        v21 = v20;
        if (v20)
          v20 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
        v73 = v21;
        v74 = v20;
        v22 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
        v72 = 4;
        if (v23 != 1)
          goto LABEL_68;
        if (*v22 == v72
          && (v65 = v5,
              Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65),
              v67 = v24,
              OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
              mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
        {
LABEL_104:
          if (!v4)
            return 1;
          v25 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
          v69 = v4;
          v70 = v25;
          v26 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
          v27 = v26;
          if (v26)
            v26 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v26 + 8);
          v73 = v27;
          v74 = v26;
          v28 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
          v72 = 8;
          if (v29 == 1 && *v28 == v72)
          {
            v65 = v4;
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65);
            v67 = v30;
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
              return 1;
          }
          v69 = "'mps.pooling_average' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements attrib"
                "ute of shape {8}";
          v71 = 259;
          mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
          v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
          if (v73)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
          if (v81)
          {
            v58 = __p;
            if (__p)
            {
              v59 = v80;
              v60 = __p;
              if (v80 != __p)
              {
                do
                  v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
                while (v59 != v58);
                v60 = __p;
              }
              v80 = v58;
              operator delete(v60);
            }
            v35 = v77;
            if (!v77)
              goto LABEL_98;
            v61 = v78;
            v37 = v77;
            if (v78 == v77)
            {
LABEL_97:
              v78 = v35;
              operator delete(v37);
LABEL_98:
              if (v75 != &v76)
                free(v75);
              return v31;
            }
            do
            {
              v63 = *--v61;
              v62 = v63;
              *v61 = 0;
              if (v63)
                MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
            }
            while (v61 != v35);
LABEL_96:
            v37 = v77;
            goto LABEL_97;
          }
        }
        else
        {
LABEL_68:
          v69 = "'mps.pooling_average' op attribute 'dilation_rates' failed to satisfy constraint: ui64 elements attribute of shape {4}";
          v71 = 259;
          mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
          v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
          if (v73)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
          if (v81)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v80;
              v54 = __p;
              if (v80 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v80 = v52;
              operator delete(v54);
            }
            v35 = v77;
            if (!v77)
              goto LABEL_98;
            v55 = v78;
            v37 = v77;
            if (v78 == v77)
              goto LABEL_97;
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v35);
            goto LABEL_96;
          }
        }
      }
      else
      {
LABEL_54:
        v69 = "'mps.pooling_average' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        v71 = 259;
        mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
        v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
        if (v73)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
        if (v81)
        {
          v46 = __p;
          if (__p)
          {
            v47 = v80;
            v48 = __p;
            if (v80 != __p)
            {
              do
                v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
              while (v47 != v46);
              v48 = __p;
            }
            v80 = v46;
            operator delete(v48);
          }
          v35 = v77;
          if (!v77)
            goto LABEL_98;
          v49 = v78;
          v37 = v77;
          if (v78 == v77)
            goto LABEL_97;
          do
          {
            v51 = *--v49;
            v50 = v51;
            *v49 = 0;
            if (v51)
              MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
          }
          while (v49 != v35);
          goto LABEL_96;
        }
      }
    }
    else
    {
      v69 = "'mps.pooling_average' op attribute 'window_sizes' failed to satisfy constraint: ui64 elements attribute of shape {4}";
      v71 = 259;
      mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
      v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
      if (v73)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
      if (v81)
      {
        v32 = __p;
        if (__p)
        {
          v33 = v80;
          v34 = __p;
          if (v80 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v80 = v32;
          operator delete(v34);
        }
        v35 = v77;
        if (!v77)
          goto LABEL_98;
        v36 = v78;
        v37 = v77;
        if (v78 == v77)
          goto LABEL_97;
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        goto LABEL_96;
      }
    }
  }
  else
  {
    v69 = "'mps.pooling_average' op requires attribute 'window_sizes'";
    v71 = 259;
    mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    if (v81)
    {
      v40 = __p;
      if (__p)
      {
        v41 = v80;
        v42 = __p;
        if (v80 != __p)
        {
          do
            v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
          while (v41 != v40);
          v42 = __p;
        }
        v80 = v40;
        operator delete(v42);
      }
      v35 = v77;
      if (!v77)
        goto LABEL_98;
      v43 = v78;
      v37 = v77;
      if (v78 == v77)
        goto LABEL_97;
      do
      {
        v45 = *--v43;
        v44 = v45;
        *v43 = 0;
        if (v45)
          MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
      }
      while (v43 != v35);
      goto LABEL_96;
    }
  }
  return v31;
}

uint64_t mlir::mps::inferPooling4DOpReturnTypes<mlir::mps::PoolAvgOpAdaptor>(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  _QWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  unint64_t v17;
  _OWORD v18[7];
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v19 = a3[6];
  v16 = 0;
  v8 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v19, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v9 = a3[1];
  v18[0] = *a3;
  v18[1] = v9;
  v10 = a3[6];
  v11 = a3[4];
  v18[5] = a3[5];
  v18[6] = v10;
  v12 = a3[3];
  v18[2] = a3[2];
  v18[3] = v12;
  v18[4] = v11;
  v17 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v19, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::Attribute::getContext((mlir::Attribute *)&v17);
  if (!mlir::mps::inferPool4DReturnType<mlir::mps::PoolAvgOpAdaptor>(a1, a2, v8, v18, &v16))
    return 0;
  v13 = v16;
  v14 = *(unsigned int *)(a4 + 8);
  if (v14 >= *(_DWORD *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v14 + 1, 8);
    LODWORD(v14) = *(_DWORD *)(a4 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a4 + 8 * v14) = v13;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

uint64_t mlir::mps::verifyPooling4D<mlir::mps::PoolAvgOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t NumElements;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  int64_t v43;
  int64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t *v51;
  char *v52;
  __int128 v53;
  uint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  __int128 v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  int64_t v70;
  int64_t v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t *v78;
  char *v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t *v83;
  char *v84;
  __int128 v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  int64_t v97;
  int64_t v98;
  uint64_t v99;
  uint64_t v100;
  BOOL v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  uint64_t *v105;
  char *v106;
  __int128 v107;
  uint64_t v108;
  char *v109;
  uint64_t *v110;
  char *v111;
  __int128 v112;
  _QWORD *v113;
  _QWORD *v114;
  void *v115;
  _QWORD *v116;
  _QWORD *v117;
  void *v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  BOOL v123;
  int64_t v124;
  int64_t v125;
  uint64_t *v126;
  int v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  char *v143;
  char *v144;
  __int128 v145;
  _QWORD *v146;
  _QWORD *v147;
  void *v148;
  _QWORD *v149;
  _QWORD *v150;
  void *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t *v154;
  char *v155;
  char *v156;
  __int128 v157;
  uint64_t v158;
  uint64_t *v159;
  char *v160;
  char *v161;
  __int128 v162;
  _QWORD *v163;
  _QWORD *v164;
  void *v165;
  _QWORD *v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  BOOL v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  const void **v179[4];
  __int16 v180;
  uint64_t v181;
  unsigned int v182;
  unint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186;
  const char *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t *v193;
  uint64_t v194;
  const char *v195;
  uint64_t v196;
  _QWORD v197[3];
  void *v198;
  unsigned int v199;
  unsigned int v200;
  _BYTE v201[96];
  void *v202;
  _QWORD *v203;
  void *__p;
  _QWORD *v205;
  char v206;
  uint64_t v207;

  v207 = *MEMORY[0x24BDAC8D0];
  v193 = (uint64_t *)a1;
  v4 = *(unsigned int *)(a1 + 44);
  v5 = a1 + 64;
  v6 = (v4 >> 23) & 1;
  v7 = a1 + 64 + 16 * v6;
  if (!HIBYTE(*(_DWORD *)(a1 + 44)))
    v7 = 0;
  v8 = *(_QWORD *)(v7 + 40);
  if (v8)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v7 + 40)))
      v9 = v8;
    else
      v9 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v9 = 0;
  }
  v192 = v9;
  v10 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v10 = 0;
  v11 = *(_QWORD *)(v10 + 8);
  if (v11)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v10 + 8)))
      v12 = v11;
    else
      v12 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v12 = 0;
  }
  v191 = v12;
  v13 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v13 = 0;
  v14 = *(_QWORD *)(v13 + 48);
  if (v14)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v13 + 48)))
      v15 = v14;
    else
      v15 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v15 = 0;
  }
  v189 = 0;
  v190 = v15;
  v16 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v16 = 0;
  v17 = *(_QWORD *)(v16 + 16);
  if (v17)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v16 + 16)))
      v18 = v17;
    else
      v18 = 0;
    v189 = v18;
  }
  if (v15 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v190) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v190, 0);
    v17 = v190;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v190);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v17, NumElements);
    while (1)
    {
      v20 = v186 == v183 && v187 == v184;
      if (v20 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v21 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_47:
          if (v182 < 0x41)
            goto LABEL_77;
LABEL_75:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_77;
        }
      }
      else
      {
        v21 = v181 << -(char)v182 >> -(char)v182;
        if (v21 > 0)
          goto LABEL_47;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v22 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_56;
      }
      else
      {
        v22 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_56;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v22;
      v23 = (char *)v198;
      if (v199 >= v200)
      {
        v40 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v43 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v40, 24);
          v23 = (char *)v198;
          v24 = (uint64_t *)((char *)v198 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v40, 24);
          v24 = &v194;
          v23 = (char *)v198;
        }
      }
      else
      {
        v24 = &v194;
      }
      v25 = &v23[24 * v199];
      v26 = *(_OWORD *)v24;
      *((_QWORD *)v25 + 2) = v24[2];
      *(_OWORD *)v25 = v26;
      v27 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v28 = (char *)v198;
        if (v27 >= v200)
        {
          v41 = v27 + 1;
          v42 = (char *)v198 + 24 * v27 > (char *)&v194;
          if (v198 <= &v194 && v42)
          {
            v44 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v41, 24);
            v28 = (char *)v198;
            v29 = (uint64_t *)((char *)v198 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v41, 24);
            v29 = &v194;
            v28 = (char *)v198;
          }
        }
        else
        {
          v29 = &v194;
        }
        v30 = &v28[24 * v199];
        v31 = *(_OWORD *)v29;
        *((_QWORD *)v30 + 2) = v29[2];
        *(_OWORD *)v30 = v31;
        ++v199;
      }
LABEL_56:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v32 = __p;
        if (__p)
        {
          v33 = v205;
          v34 = __p;
          if (v205 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v205 = v32;
          operator delete(v34);
        }
        v35 = v202;
        if (v202)
        {
          v36 = v203;
          v37 = v202;
          if (v203 != v202)
          {
            do
            {
              v39 = *--v36;
              v38 = v39;
              *v36 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v36 != v35);
            v37 = v202;
          }
          v203 = v35;
          operator delete(v37);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_75;
LABEL_77:
      if (v21 < 1)
        return v17;
      ++v188;
    }
  }
  if (v192 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v192) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v192, 0);
    v45 = v192;
    v46 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v192);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v45, v46);
    while (1)
    {
      v47 = v186 == v183 && v187 == v184;
      if (v47 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v48 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_102:
          if (v182 < 0x41)
            goto LABEL_132;
LABEL_130:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_132;
        }
      }
      else
      {
        v48 = v181 << -(char)v182 >> -(char)v182;
        if (v48 > 0)
          goto LABEL_102;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v49 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_111;
      }
      else
      {
        v49 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_111;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v49;
      v50 = (char *)v198;
      if (v199 >= v200)
      {
        v67 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v70 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v67, 24);
          v50 = (char *)v198;
          v51 = (uint64_t *)((char *)v198 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v67, 24);
          v51 = &v194;
          v50 = (char *)v198;
        }
      }
      else
      {
        v51 = &v194;
      }
      v52 = &v50[24 * v199];
      v53 = *(_OWORD *)v51;
      *((_QWORD *)v52 + 2) = v51[2];
      *(_OWORD *)v52 = v53;
      v54 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v55 = (char *)v198;
        if (v54 >= v200)
        {
          v68 = v54 + 1;
          v69 = (char *)v198 + 24 * v54 > (char *)&v194;
          if (v198 <= &v194 && v69)
          {
            v71 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v68, 24);
            v55 = (char *)v198;
            v56 = (uint64_t *)((char *)v198 + v71);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v68, 24);
            v56 = &v194;
            v55 = (char *)v198;
          }
        }
        else
        {
          v56 = &v194;
        }
        v57 = &v55[24 * v199];
        v58 = *(_OWORD *)v56;
        *((_QWORD *)v57 + 2) = v56[2];
        *(_OWORD *)v57 = v58;
        ++v199;
      }
LABEL_111:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v59 = __p;
        if (__p)
        {
          v60 = v205;
          v61 = __p;
          if (v205 != __p)
          {
            do
              v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
            while (v60 != v59);
            v61 = __p;
          }
          v205 = v59;
          operator delete(v61);
        }
        v62 = v202;
        if (v202)
        {
          v63 = v203;
          v64 = v202;
          if (v203 != v202)
          {
            do
            {
              v66 = *--v63;
              v65 = v66;
              *v63 = 0;
              if (v66)
                MEMORY[0x20BD002D4](v65, 0x1000C8077774924);
            }
            while (v63 != v62);
            v64 = v202;
          }
          v203 = v62;
          operator delete(v64);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_130;
LABEL_132:
      if (v48 < 1)
        return v17;
      ++v188;
    }
  }
  if (v191 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v191) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v191, 0);
    v72 = v191;
    v73 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v191);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v72, v73);
    while (1)
    {
      v74 = v186 == v183 && v187 == v184;
      if (v74 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v75 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_157:
          if (v182 < 0x41)
            goto LABEL_187;
LABEL_185:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_187;
        }
      }
      else
      {
        v75 = v181 << -(char)v182 >> -(char)v182;
        if (v75 > 0)
          goto LABEL_157;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v76 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_166;
      }
      else
      {
        v76 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_166;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v76;
      v77 = (char *)v198;
      if (v199 >= v200)
      {
        v94 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v97 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v94, 24);
          v77 = (char *)v198;
          v78 = (uint64_t *)((char *)v198 + v97);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v94, 24);
          v78 = &v194;
          v77 = (char *)v198;
        }
      }
      else
      {
        v78 = &v194;
      }
      v79 = &v77[24 * v199];
      v80 = *(_OWORD *)v78;
      *((_QWORD *)v79 + 2) = v78[2];
      *(_OWORD *)v79 = v80;
      v81 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v82 = (char *)v198;
        if (v81 >= v200)
        {
          v95 = v81 + 1;
          v96 = (char *)v198 + 24 * v81 > (char *)&v194;
          if (v198 <= &v194 && v96)
          {
            v98 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v95, 24);
            v82 = (char *)v198;
            v83 = (uint64_t *)((char *)v198 + v98);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v95, 24);
            v83 = &v194;
            v82 = (char *)v198;
          }
        }
        else
        {
          v83 = &v194;
        }
        v84 = &v82[24 * v199];
        v85 = *(_OWORD *)v83;
        *((_QWORD *)v84 + 2) = v83[2];
        *(_OWORD *)v84 = v85;
        ++v199;
      }
LABEL_166:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v86 = __p;
        if (__p)
        {
          v87 = v205;
          v88 = __p;
          if (v205 != __p)
          {
            do
              v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
            while (v87 != v86);
            v88 = __p;
          }
          v205 = v86;
          operator delete(v88);
        }
        v89 = v202;
        if (v202)
        {
          v90 = v203;
          v91 = v202;
          if (v203 != v202)
          {
            do
            {
              v93 = *--v90;
              v92 = v93;
              *v90 = 0;
              if (v93)
                MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
            }
            while (v90 != v89);
            v91 = v202;
          }
          v203 = v89;
          operator delete(v91);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_185;
LABEL_187:
      if (v75 < 1)
        return v17;
      ++v188;
    }
  }
  if (v189 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v189) == 8)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v189, 0);
    v99 = v189;
    v100 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v189);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v99, v100);
    while (1)
    {
      v101 = v186 == v183 && v187 == v184;
      if (v101 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v102 = *(_QWORD *)v181;
        if ((*(_QWORD *)v181 & 0x8000000000000000) == 0)
        {
LABEL_212:
          if (v182 < 0x41)
            goto LABEL_242;
LABEL_240:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_242;
        }
      }
      else
      {
        v102 = v181 << -(char)v182 >> -(char)v182;
        if ((v102 & 0x8000000000000000) == 0)
          goto LABEL_212;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v103 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_221;
      }
      else
      {
        v103 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_221;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v103;
      v104 = (char *)v198;
      if (v199 >= v200)
      {
        v121 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v124 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v121, 24);
          v104 = (char *)v198;
          v105 = (uint64_t *)((char *)v198 + v124);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v121, 24);
          v105 = &v194;
          v104 = (char *)v198;
        }
      }
      else
      {
        v105 = &v194;
      }
      v106 = &v104[24 * v199];
      v107 = *(_OWORD *)v105;
      *((_QWORD *)v106 + 2) = v105[2];
      *(_OWORD *)v106 = v107;
      v108 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be non-negative.";
        v196 = 36;
        v109 = (char *)v198;
        if (v108 >= v200)
        {
          v122 = v108 + 1;
          v123 = (char *)v198 + 24 * v108 > (char *)&v194;
          if (v198 <= &v194 && v123)
          {
            v125 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v122, 24);
            v109 = (char *)v198;
            v110 = (uint64_t *)((char *)v198 + v125);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v122, 24);
            v110 = &v194;
            v109 = (char *)v198;
          }
        }
        else
        {
          v110 = &v194;
        }
        v111 = &v109[24 * v199];
        v112 = *(_OWORD *)v110;
        *((_QWORD *)v111 + 2) = v110[2];
        *(_OWORD *)v111 = v112;
        ++v199;
      }
LABEL_221:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v113 = __p;
        if (__p)
        {
          v114 = v205;
          v115 = __p;
          if (v205 != __p)
          {
            do
              v114 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v114 - 1);
            while (v114 != v113);
            v115 = __p;
          }
          v205 = v113;
          operator delete(v115);
        }
        v116 = v202;
        if (v202)
        {
          v117 = v203;
          v118 = v202;
          if (v203 != v202)
          {
            do
            {
              v120 = *--v117;
              v119 = v120;
              *v117 = 0;
              if (v120)
                MEMORY[0x20BD002D4](v119, 0x1000C8077774924);
            }
            while (v117 != v116);
            v118 = v202;
          }
          v203 = v116;
          operator delete(v118);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_240;
LABEL_242:
      if (v102 < 0)
        return v17;
      ++v188;
    }
  }
  v126 = &v193[2 * (((unint64_t)*((unsigned int *)v193 + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)v193 + 11)))
    v126 = 0;
  v127 = *(_DWORD *)(v126[4] + 8);
  if (v127 == 3)
  {
    v180 = 259;
    mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
    if (v197[0])
    {
      LODWORD(v186) = 3;
      v187 = "not supported by this op.";
      v188 = 25;
      v142 = (uint64_t *)&v186;
      v143 = (char *)v198;
      if (v199 >= v200)
      {
        v170 = v199 + 1;
        if (v198 <= &v186 && (char *)v198 + 24 * v199 > (char *)&v186)
        {
          v174 = (char *)&v186 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v170, 24);
          v143 = (char *)v198;
          v142 = (uint64_t *)((char *)v198 + v174);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v170, 24);
          v142 = (uint64_t *)&v186;
          v143 = (char *)v198;
        }
      }
      v144 = &v143[24 * v199];
      v145 = *(_OWORD *)v142;
      *((_QWORD *)v144 + 2) = v142[2];
      *(_OWORD *)v144 = v145;
      ++v199;
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
    if (v197[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
    if (v206)
    {
      v146 = __p;
      if (__p)
      {
        v147 = v205;
        v148 = __p;
        if (v205 != __p)
        {
          do
            v147 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v147 - 1);
          while (v147 != v146);
          v148 = __p;
        }
        v205 = v146;
        operator delete(v148);
      }
      v149 = v202;
      if (!v202)
        goto LABEL_312;
      v150 = v203;
      v151 = v202;
      if (v203 == v202)
        goto LABEL_311;
      do
      {
        v153 = *--v150;
        v152 = v153;
        *v150 = 0;
        if (v153)
          MEMORY[0x20BD002D4](v152, 0x1000C8077774924);
      }
      while (v150 != v149);
      goto LABEL_310;
    }
  }
  else
  {
    if (v127 || v189)
    {
      if (a2)
      {
        v128 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
        if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v128 + 8))
        {
          v129 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v128 + 8);
          v130 = a3;
          v186 = v128;
          v187 = (const char *)v129;
          if (a3)
            goto LABEL_260;
LABEL_285:
          v131 = 0;
          v183 = 0;
          v184 = 0;
          if (v128)
            goto LABEL_262;
          return 1;
        }
        v128 = 0;
        v130 = a3;
        v186 = 0;
        v187 = 0;
        if (!a3)
          goto LABEL_285;
      }
      else
      {
        v128 = 0;
        v186 = 0;
        v187 = 0;
        v130 = a3;
        if (!a3)
          goto LABEL_285;
      }
LABEL_260:
      v131 = *(_QWORD *)(v130 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v131 + 8))
      {
        v132 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v131 + 8);
        v183 = v131;
        v184 = v132;
        if (v128)
        {
LABEL_262:
          v17 = 1;
          if (*(_UNKNOWN **)(*(_QWORD *)v128 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
          {
            if (v131)
            {
              if (*(_UNKNOWN **)(*(_QWORD *)v131 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
              {
                mlir::ShapedType::getShape((mlir::ShapedType *)&v186);
                v134 = v133;
                mlir::ShapedType::getShape((mlir::ShapedType *)&v183);
                if (v134 != v135)
                {
                  v180 = 259;
                  mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v186);
                  v194 = v136;
                  v137 = mlir::InFlightDiagnostic::operator<<<unsigned long>((uint64_t)v197, &v194);
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v183);
                  v181 = v139;
                  v140 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v138, &v181);
                  v141 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v140, ".");
                  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v141);
                  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v197);
                }
              }
            }
          }
          return v17;
        }
      }
      else
      {
        v131 = 0;
        v183 = 0;
        v184 = 0;
        if (v128)
          goto LABEL_262;
      }
      return 1;
    }
    v180 = 259;
    mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
    if (v197[0])
    {
      LODWORD(v186) = 3;
      v187 = "invalid type. Must be specified when ";
      v188 = 37;
      v154 = (uint64_t *)&v186;
      v155 = (char *)v198;
      if (v199 >= v200)
      {
        v171 = v199 + 1;
        if (v198 <= &v186 && (char *)v198 + 24 * v199 > (char *)&v186)
        {
          v175 = (char *)&v186 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v171, 24);
          v155 = (char *)v198;
          v154 = (uint64_t *)((char *)v198 + v175);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v171, 24);
          v154 = (uint64_t *)&v186;
          v155 = (char *)v198;
        }
      }
      v156 = &v155[24 * v199];
      v157 = *(_OWORD *)v154;
      *((_QWORD *)v156 + 2) = v154[2];
      *(_OWORD *)v156 = v157;
      v158 = ++v199;
      if (v197[0])
      {
        LODWORD(v186) = 3;
        v188 = 31;
        v159 = (uint64_t *)&v186;
        v160 = (char *)v198;
        if (v158 >= v200)
        {
          v172 = v158 + 1;
          v173 = (char *)v198 + 24 * v158 > (char *)&v186;
          if (v198 <= &v186 && v173)
          {
            v176 = (char *)&v186 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v172, 24);
            v160 = (char *)v198;
            v159 = (uint64_t *)((char *)v198 + v176);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v172, 24);
            v159 = (uint64_t *)&v186;
            v160 = (char *)v198;
          }
        }
        v161 = &v160[24 * v199];
        v162 = *(_OWORD *)v159;
        *((_QWORD *)v161 + 2) = v159[2];
        *(_OWORD *)v161 = v162;
        ++v199;
      }
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
    if (v197[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
    if (v206)
    {
      v163 = __p;
      if (__p)
      {
        v164 = v205;
        v165 = __p;
        if (v205 != __p)
        {
          do
            v164 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v164 - 1);
          while (v164 != v163);
          v165 = __p;
        }
        v205 = v163;
        operator delete(v165);
      }
      v149 = v202;
      if (!v202)
        goto LABEL_312;
      v166 = v203;
      v151 = v202;
      if (v203 == v202)
      {
LABEL_311:
        v203 = v149;
        operator delete(v151);
LABEL_312:
        if (v198 != v201)
          free(v198);
        return v17;
      }
      do
      {
        v168 = *--v166;
        v167 = v168;
        *v166 = 0;
        if (v168)
          MEMORY[0x20BD002D4](v167, 0x1000C8077774924);
      }
      while (v166 != v149);
LABEL_310:
      v151 = v202;
      goto LABEL_311;
    }
  }
  return v17;
}

uint64_t mlir::mps::PoolL2NormOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, __int128 a9, uint64_t a10)
{
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD v25[7];
  __int128 v26;
  _BYTE v27[64];
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (a7)
  {
    v15 = *a7;
    v16 = a7[1];
    v17 = a7[2];
    v18 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v18 = 0;
    v15 = 0uLL;
    v16 = 0uLL;
    v17 = 0uLL;
  }
  *(_QWORD *)&v26 = a6;
  BYTE8(v26) = 0;
  v27[0] = 0;
  *(_OWORD *)&v27[8] = v15;
  *(_OWORD *)&v27[24] = v16;
  *(_OWORD *)&v27[40] = v17;
  *(_QWORD *)&v27[56] = v18;
  v28 = a9;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v27[0])
      v27[0] = 0;
    mlir::OperationName::OperationName((char *)&v26 + 8, "mps.pooling_l2_norm", 19, Context);
    v27[0] = 1;
  }
  *(_QWORD *)&v29 = a4;
  *((_QWORD *)&v29 + 1) = a5;
  if (a5 && (v20 = mlir::UnknownLoc::get(this, a2), mlir::mps::PoolL2NormOpAdaptor::verify(&v26, v20)))
  {
    v25[4] = *(_OWORD *)&v27[48];
    v25[5] = v28;
    v25[6] = v29;
    v25[0] = v26;
    v25[1] = *(_OWORD *)v27;
    v25[2] = *(_OWORD *)&v27[16];
    v25[3] = *(_OWORD *)&v27[32];
    return mlir::mps::inferPooling4DOpReturnTypes<mlir::mps::PoolAvgOpAdaptor>((uint64_t)a2, a3, v25, a10);
  }
  else
  {
    v22 = mlir::Float32Type::get(this, a2);
    v23 = mlir::UnrankedTensorType::get(v22);
    v24 = *(unsigned int *)(a10 + 8);
    if (v24 >= *(_DWORD *)(a10 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v24 + 1, 8);
      LODWORD(v24) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v24) = v23;
    ++*(_DWORD *)(a10 + 8);
    return 1;
  }
}

uint64_t mlir::mps::PoolL2NormOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  _QWORD *Type;
  _QWORD *v9;
  _QWORD *Shape;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  const char *v65;
  uint64_t Value;
  uint64_t v67;
  uint64_t OperandRange;
  const char *v69;
  uint64_t v70;
  __int16 v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  uint64_t v76;
  void *v77;
  _QWORD *v78;
  void *__p;
  _QWORD *v80;
  char v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v3 = (const char *)a1[9];
  if (v3)
  {
    v5 = (const char *)a1[4];
    v4 = (const char *)a1[5];
    v6 = (const char *)a1[8];
    v7 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
    v69 = v3;
    v70 = v7;
    Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
    v9 = Type;
    if (Type)
      Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
    v73 = v9;
    v74 = Type;
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
    v72 = 4;
    if (v11 == 1
      && *Shape == v72
      && (v65 = v3,
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65),
          v67 = v12,
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
      if (!v6)
        goto LABEL_103;
      v13 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
      v69 = v6;
      v70 = v13;
      v14 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
      v15 = v14;
      if (v14)
        v14 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v14 + 8);
      v73 = v15;
      v74 = v14;
      v16 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
      v72 = 4;
      if (v17 != 1)
        goto LABEL_54;
      if (*v16 == v72
        && (v65 = v6,
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65),
            v67 = v18,
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
            mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
      {
LABEL_103:
        if (!v5)
          goto LABEL_104;
        v19 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
        v69 = v5;
        v70 = v19;
        v20 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
        v21 = v20;
        if (v20)
          v20 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
        v73 = v21;
        v74 = v20;
        v22 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
        v72 = 4;
        if (v23 != 1)
          goto LABEL_68;
        if (*v22 == v72
          && (v65 = v5,
              Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65),
              v67 = v24,
              OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
              mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
        {
LABEL_104:
          if (!v4)
            return 1;
          v25 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
          v69 = v4;
          v70 = v25;
          v26 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v69);
          v27 = v26;
          if (v26)
            v26 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v26 + 8);
          v73 = v27;
          v74 = v26;
          v28 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v73);
          v72 = 8;
          if (v29 == 1 && *v28 == v72)
          {
            v65 = v4;
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v65);
            v67 = v30;
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
              return 1;
          }
          v69 = "'mps.pooling_l2_norm' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements attrib"
                "ute of shape {8}";
          v71 = 259;
          mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
          v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
          if (v73)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
          if (v81)
          {
            v58 = __p;
            if (__p)
            {
              v59 = v80;
              v60 = __p;
              if (v80 != __p)
              {
                do
                  v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
                while (v59 != v58);
                v60 = __p;
              }
              v80 = v58;
              operator delete(v60);
            }
            v35 = v77;
            if (!v77)
              goto LABEL_98;
            v61 = v78;
            v37 = v77;
            if (v78 == v77)
            {
LABEL_97:
              v78 = v35;
              operator delete(v37);
LABEL_98:
              if (v75 != &v76)
                free(v75);
              return v31;
            }
            do
            {
              v63 = *--v61;
              v62 = v63;
              *v61 = 0;
              if (v63)
                MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
            }
            while (v61 != v35);
LABEL_96:
            v37 = v77;
            goto LABEL_97;
          }
        }
        else
        {
LABEL_68:
          v69 = "'mps.pooling_l2_norm' op attribute 'dilation_rates' failed to satisfy constraint: ui64 elements attribute of shape {4}";
          v71 = 259;
          mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
          v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
          if (v73)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
          if (v81)
          {
            v52 = __p;
            if (__p)
            {
              v53 = v80;
              v54 = __p;
              if (v80 != __p)
              {
                do
                  v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
                while (v53 != v52);
                v54 = __p;
              }
              v80 = v52;
              operator delete(v54);
            }
            v35 = v77;
            if (!v77)
              goto LABEL_98;
            v55 = v78;
            v37 = v77;
            if (v78 == v77)
              goto LABEL_97;
            do
            {
              v57 = *--v55;
              v56 = v57;
              *v55 = 0;
              if (v57)
                MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
            }
            while (v55 != v35);
            goto LABEL_96;
          }
        }
      }
      else
      {
LABEL_54:
        v69 = "'mps.pooling_l2_norm' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        v71 = 259;
        mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
        v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
        if (v73)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
        if (v81)
        {
          v46 = __p;
          if (__p)
          {
            v47 = v80;
            v48 = __p;
            if (v80 != __p)
            {
              do
                v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
              while (v47 != v46);
              v48 = __p;
            }
            v80 = v46;
            operator delete(v48);
          }
          v35 = v77;
          if (!v77)
            goto LABEL_98;
          v49 = v78;
          v37 = v77;
          if (v78 == v77)
            goto LABEL_97;
          do
          {
            v51 = *--v49;
            v50 = v51;
            *v49 = 0;
            if (v51)
              MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
          }
          while (v49 != v35);
          goto LABEL_96;
        }
      }
    }
    else
    {
      v69 = "'mps.pooling_l2_norm' op attribute 'window_sizes' failed to satisfy constraint: ui64 elements attribute of shape {4}";
      v71 = 259;
      mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
      v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
      if (v73)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
      if (v81)
      {
        v32 = __p;
        if (__p)
        {
          v33 = v80;
          v34 = __p;
          if (v80 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v80 = v32;
          operator delete(v34);
        }
        v35 = v77;
        if (!v77)
          goto LABEL_98;
        v36 = v78;
        v37 = v77;
        if (v78 == v77)
          goto LABEL_97;
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        goto LABEL_96;
      }
    }
  }
  else
  {
    v69 = "'mps.pooling_l2_norm' op requires attribute 'window_sizes'";
    v71 = 259;
    mlir::emitError(a2, (uint64_t)&v69, (uint64_t)&v73);
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v73);
    if (v73)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v73);
    if (v81)
    {
      v40 = __p;
      if (__p)
      {
        v41 = v80;
        v42 = __p;
        if (v80 != __p)
        {
          do
            v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
          while (v41 != v40);
          v42 = __p;
        }
        v80 = v40;
        operator delete(v42);
      }
      v35 = v77;
      if (!v77)
        goto LABEL_98;
      v43 = v78;
      v37 = v77;
      if (v78 == v77)
        goto LABEL_97;
      do
      {
        v45 = *--v43;
        v44 = v45;
        *v43 = 0;
        if (v45)
          MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
      }
      while (v43 != v35);
      goto LABEL_96;
    }
  }
  return v31;
}

uint64_t mlir::mps::verifyPooling4D<mlir::mps::PoolMaxGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t NumElements;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  int64_t v43;
  int64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t *v51;
  char *v52;
  __int128 v53;
  uint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  __int128 v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  int64_t v70;
  int64_t v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t *v78;
  char *v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t *v83;
  char *v84;
  __int128 v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  int64_t v97;
  int64_t v98;
  uint64_t v99;
  uint64_t v100;
  BOOL v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  uint64_t *v105;
  char *v106;
  __int128 v107;
  uint64_t v108;
  char *v109;
  uint64_t *v110;
  char *v111;
  __int128 v112;
  _QWORD *v113;
  _QWORD *v114;
  void *v115;
  _QWORD *v116;
  _QWORD *v117;
  void *v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  BOOL v123;
  int64_t v124;
  int64_t v125;
  uint64_t *v126;
  int v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  char *v143;
  char *v144;
  __int128 v145;
  _QWORD *v146;
  _QWORD *v147;
  void *v148;
  _QWORD *v149;
  _QWORD *v150;
  void *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t *v154;
  char *v155;
  char *v156;
  __int128 v157;
  uint64_t v158;
  uint64_t *v159;
  char *v160;
  char *v161;
  __int128 v162;
  _QWORD *v163;
  _QWORD *v164;
  void *v165;
  _QWORD *v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  BOOL v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  const void **v179[4];
  __int16 v180;
  uint64_t v181;
  unsigned int v182;
  unint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186;
  const char *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t *v193;
  uint64_t v194;
  const char *v195;
  uint64_t v196;
  _QWORD v197[3];
  void *v198;
  unsigned int v199;
  unsigned int v200;
  _BYTE v201[96];
  void *v202;
  _QWORD *v203;
  void *__p;
  _QWORD *v205;
  char v206;
  uint64_t v207;

  v207 = *MEMORY[0x24BDAC8D0];
  v193 = (uint64_t *)a1;
  v4 = *(unsigned int *)(a1 + 44);
  v5 = a1 + 64;
  v6 = (v4 >> 23) & 1;
  v7 = a1 + 64 + 16 * v6;
  if (!HIBYTE(*(_DWORD *)(a1 + 44)))
    v7 = 0;
  v8 = *(_QWORD *)(v7 + 56);
  if (v8)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v7 + 56)))
      v9 = v8;
    else
      v9 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v9 = 0;
  }
  v192 = v9;
  v10 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v10 = 0;
  v11 = *(_QWORD *)(v10 + 8);
  if (v11)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v10 + 8)))
      v12 = v11;
    else
      v12 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v12 = 0;
  }
  v191 = v12;
  v13 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v13 = 0;
  v14 = *(_QWORD *)(v13 + 64);
  if (v14)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v13 + 64)))
      v15 = v14;
    else
      v15 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v15 = 0;
  }
  v189 = 0;
  v190 = v15;
  v16 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v16 = 0;
  v17 = *(_QWORD *)(v16 + 16);
  if (v17)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v16 + 16)))
      v18 = v17;
    else
      v18 = 0;
    v189 = v18;
  }
  if (v15 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v190) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v190, 0);
    v17 = v190;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v190);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v17, NumElements);
    while (1)
    {
      v20 = v186 == v183 && v187 == v184;
      if (v20 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v21 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_47:
          if (v182 < 0x41)
            goto LABEL_77;
LABEL_75:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_77;
        }
      }
      else
      {
        v21 = v181 << -(char)v182 >> -(char)v182;
        if (v21 > 0)
          goto LABEL_47;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v22 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_56;
      }
      else
      {
        v22 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_56;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v22;
      v23 = (char *)v198;
      if (v199 >= v200)
      {
        v40 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v43 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v40, 24);
          v23 = (char *)v198;
          v24 = (uint64_t *)((char *)v198 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v40, 24);
          v24 = &v194;
          v23 = (char *)v198;
        }
      }
      else
      {
        v24 = &v194;
      }
      v25 = &v23[24 * v199];
      v26 = *(_OWORD *)v24;
      *((_QWORD *)v25 + 2) = v24[2];
      *(_OWORD *)v25 = v26;
      v27 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v28 = (char *)v198;
        if (v27 >= v200)
        {
          v41 = v27 + 1;
          v42 = (char *)v198 + 24 * v27 > (char *)&v194;
          if (v198 <= &v194 && v42)
          {
            v44 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v41, 24);
            v28 = (char *)v198;
            v29 = (uint64_t *)((char *)v198 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v41, 24);
            v29 = &v194;
            v28 = (char *)v198;
          }
        }
        else
        {
          v29 = &v194;
        }
        v30 = &v28[24 * v199];
        v31 = *(_OWORD *)v29;
        *((_QWORD *)v30 + 2) = v29[2];
        *(_OWORD *)v30 = v31;
        ++v199;
      }
LABEL_56:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v32 = __p;
        if (__p)
        {
          v33 = v205;
          v34 = __p;
          if (v205 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v205 = v32;
          operator delete(v34);
        }
        v35 = v202;
        if (v202)
        {
          v36 = v203;
          v37 = v202;
          if (v203 != v202)
          {
            do
            {
              v39 = *--v36;
              v38 = v39;
              *v36 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v36 != v35);
            v37 = v202;
          }
          v203 = v35;
          operator delete(v37);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_75;
LABEL_77:
      if (v21 < 1)
        return v17;
      ++v188;
    }
  }
  if (v192 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v192) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v192, 0);
    v45 = v192;
    v46 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v192);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v45, v46);
    while (1)
    {
      v47 = v186 == v183 && v187 == v184;
      if (v47 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v48 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_102:
          if (v182 < 0x41)
            goto LABEL_132;
LABEL_130:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_132;
        }
      }
      else
      {
        v48 = v181 << -(char)v182 >> -(char)v182;
        if (v48 > 0)
          goto LABEL_102;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v49 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_111;
      }
      else
      {
        v49 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_111;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v49;
      v50 = (char *)v198;
      if (v199 >= v200)
      {
        v67 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v70 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v67, 24);
          v50 = (char *)v198;
          v51 = (uint64_t *)((char *)v198 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v67, 24);
          v51 = &v194;
          v50 = (char *)v198;
        }
      }
      else
      {
        v51 = &v194;
      }
      v52 = &v50[24 * v199];
      v53 = *(_OWORD *)v51;
      *((_QWORD *)v52 + 2) = v51[2];
      *(_OWORD *)v52 = v53;
      v54 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v55 = (char *)v198;
        if (v54 >= v200)
        {
          v68 = v54 + 1;
          v69 = (char *)v198 + 24 * v54 > (char *)&v194;
          if (v198 <= &v194 && v69)
          {
            v71 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v68, 24);
            v55 = (char *)v198;
            v56 = (uint64_t *)((char *)v198 + v71);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v68, 24);
            v56 = &v194;
            v55 = (char *)v198;
          }
        }
        else
        {
          v56 = &v194;
        }
        v57 = &v55[24 * v199];
        v58 = *(_OWORD *)v56;
        *((_QWORD *)v57 + 2) = v56[2];
        *(_OWORD *)v57 = v58;
        ++v199;
      }
LABEL_111:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v59 = __p;
        if (__p)
        {
          v60 = v205;
          v61 = __p;
          if (v205 != __p)
          {
            do
              v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
            while (v60 != v59);
            v61 = __p;
          }
          v205 = v59;
          operator delete(v61);
        }
        v62 = v202;
        if (v202)
        {
          v63 = v203;
          v64 = v202;
          if (v203 != v202)
          {
            do
            {
              v66 = *--v63;
              v65 = v66;
              *v63 = 0;
              if (v66)
                MEMORY[0x20BD002D4](v65, 0x1000C8077774924);
            }
            while (v63 != v62);
            v64 = v202;
          }
          v203 = v62;
          operator delete(v64);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_130;
LABEL_132:
      if (v48 < 1)
        return v17;
      ++v188;
    }
  }
  if (v191 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v191) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v191, 0);
    v72 = v191;
    v73 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v191);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v72, v73);
    while (1)
    {
      v74 = v186 == v183 && v187 == v184;
      if (v74 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v75 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_157:
          if (v182 < 0x41)
            goto LABEL_187;
LABEL_185:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_187;
        }
      }
      else
      {
        v75 = v181 << -(char)v182 >> -(char)v182;
        if (v75 > 0)
          goto LABEL_157;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v76 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_166;
      }
      else
      {
        v76 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_166;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v76;
      v77 = (char *)v198;
      if (v199 >= v200)
      {
        v94 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v97 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v94, 24);
          v77 = (char *)v198;
          v78 = (uint64_t *)((char *)v198 + v97);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v94, 24);
          v78 = &v194;
          v77 = (char *)v198;
        }
      }
      else
      {
        v78 = &v194;
      }
      v79 = &v77[24 * v199];
      v80 = *(_OWORD *)v78;
      *((_QWORD *)v79 + 2) = v78[2];
      *(_OWORD *)v79 = v80;
      v81 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v82 = (char *)v198;
        if (v81 >= v200)
        {
          v95 = v81 + 1;
          v96 = (char *)v198 + 24 * v81 > (char *)&v194;
          if (v198 <= &v194 && v96)
          {
            v98 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v95, 24);
            v82 = (char *)v198;
            v83 = (uint64_t *)((char *)v198 + v98);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v95, 24);
            v83 = &v194;
            v82 = (char *)v198;
          }
        }
        else
        {
          v83 = &v194;
        }
        v84 = &v82[24 * v199];
        v85 = *(_OWORD *)v83;
        *((_QWORD *)v84 + 2) = v83[2];
        *(_OWORD *)v84 = v85;
        ++v199;
      }
LABEL_166:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v86 = __p;
        if (__p)
        {
          v87 = v205;
          v88 = __p;
          if (v205 != __p)
          {
            do
              v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
            while (v87 != v86);
            v88 = __p;
          }
          v205 = v86;
          operator delete(v88);
        }
        v89 = v202;
        if (v202)
        {
          v90 = v203;
          v91 = v202;
          if (v203 != v202)
          {
            do
            {
              v93 = *--v90;
              v92 = v93;
              *v90 = 0;
              if (v93)
                MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
            }
            while (v90 != v89);
            v91 = v202;
          }
          v203 = v89;
          operator delete(v91);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_185;
LABEL_187:
      if (v75 < 1)
        return v17;
      ++v188;
    }
  }
  if (v189 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v189) == 8)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v189, 0);
    v99 = v189;
    v100 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v189);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v99, v100);
    while (1)
    {
      v101 = v186 == v183 && v187 == v184;
      if (v101 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v102 = *(_QWORD *)v181;
        if ((*(_QWORD *)v181 & 0x8000000000000000) == 0)
        {
LABEL_212:
          if (v182 < 0x41)
            goto LABEL_242;
LABEL_240:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_242;
        }
      }
      else
      {
        v102 = v181 << -(char)v182 >> -(char)v182;
        if ((v102 & 0x8000000000000000) == 0)
          goto LABEL_212;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v103 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_221;
      }
      else
      {
        v103 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_221;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v103;
      v104 = (char *)v198;
      if (v199 >= v200)
      {
        v121 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v124 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v121, 24);
          v104 = (char *)v198;
          v105 = (uint64_t *)((char *)v198 + v124);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v121, 24);
          v105 = &v194;
          v104 = (char *)v198;
        }
      }
      else
      {
        v105 = &v194;
      }
      v106 = &v104[24 * v199];
      v107 = *(_OWORD *)v105;
      *((_QWORD *)v106 + 2) = v105[2];
      *(_OWORD *)v106 = v107;
      v108 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be non-negative.";
        v196 = 36;
        v109 = (char *)v198;
        if (v108 >= v200)
        {
          v122 = v108 + 1;
          v123 = (char *)v198 + 24 * v108 > (char *)&v194;
          if (v198 <= &v194 && v123)
          {
            v125 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v122, 24);
            v109 = (char *)v198;
            v110 = (uint64_t *)((char *)v198 + v125);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v122, 24);
            v110 = &v194;
            v109 = (char *)v198;
          }
        }
        else
        {
          v110 = &v194;
        }
        v111 = &v109[24 * v199];
        v112 = *(_OWORD *)v110;
        *((_QWORD *)v111 + 2) = v110[2];
        *(_OWORD *)v111 = v112;
        ++v199;
      }
LABEL_221:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v113 = __p;
        if (__p)
        {
          v114 = v205;
          v115 = __p;
          if (v205 != __p)
          {
            do
              v114 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v114 - 1);
            while (v114 != v113);
            v115 = __p;
          }
          v205 = v113;
          operator delete(v115);
        }
        v116 = v202;
        if (v202)
        {
          v117 = v203;
          v118 = v202;
          if (v203 != v202)
          {
            do
            {
              v120 = *--v117;
              v119 = v120;
              *v117 = 0;
              if (v120)
                MEMORY[0x20BD002D4](v119, 0x1000C8077774924);
            }
            while (v117 != v116);
            v118 = v202;
          }
          v203 = v116;
          operator delete(v118);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_240;
LABEL_242:
      if (v102 < 0)
        return v17;
      ++v188;
    }
  }
  if (HIBYTE(*((_DWORD *)v193 + 11)))
    v126 = &v193[2 * (((unint64_t)*((unsigned int *)v193 + 11) >> 23) & 1) + 8];
  else
    v126 = 0;
  v127 = *(_DWORD *)(v126[6] + 8);
  if (v127 == 3)
  {
    v180 = 259;
    mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
    if (v197[0])
    {
      LODWORD(v186) = 3;
      v187 = "not supported by this op.";
      v188 = 25;
      v142 = (uint64_t *)&v186;
      v143 = (char *)v198;
      if (v199 >= v200)
      {
        v170 = v199 + 1;
        if (v198 <= &v186 && (char *)v198 + 24 * v199 > (char *)&v186)
        {
          v174 = (char *)&v186 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v170, 24);
          v143 = (char *)v198;
          v142 = (uint64_t *)((char *)v198 + v174);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v170, 24);
          v142 = (uint64_t *)&v186;
          v143 = (char *)v198;
        }
      }
      v144 = &v143[24 * v199];
      v145 = *(_OWORD *)v142;
      *((_QWORD *)v144 + 2) = v142[2];
      *(_OWORD *)v144 = v145;
      ++v199;
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
    if (v197[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
    if (v206)
    {
      v146 = __p;
      if (__p)
      {
        v147 = v205;
        v148 = __p;
        if (v205 != __p)
        {
          do
            v147 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v147 - 1);
          while (v147 != v146);
          v148 = __p;
        }
        v205 = v146;
        operator delete(v148);
      }
      v149 = v202;
      if (!v202)
        goto LABEL_311;
      v150 = v203;
      v151 = v202;
      if (v203 == v202)
        goto LABEL_310;
      do
      {
        v153 = *--v150;
        v152 = v153;
        *v150 = 0;
        if (v153)
          MEMORY[0x20BD002D4](v152, 0x1000C8077774924);
      }
      while (v150 != v149);
      goto LABEL_309;
    }
  }
  else
  {
    if (v127 || v189)
    {
      if (!mlir::mps::checkInputTensors<mlir::mps::PoolMaxGradientOp>((uint64_t)v193))
        return 0;
      if (a2)
      {
        v128 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
        if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v128 + 8))
        {
          v129 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v128 + 8);
          v130 = a3;
          v186 = v128;
          v187 = (const char *)v129;
          if (a3)
            goto LABEL_262;
LABEL_288:
          v131 = 0;
          v183 = 0;
          v184 = 0;
          if (v128)
            goto LABEL_264;
          return 1;
        }
        v128 = 0;
        v130 = a3;
        v186 = 0;
        v187 = 0;
        if (!a3)
          goto LABEL_288;
      }
      else
      {
        v128 = 0;
        v186 = 0;
        v187 = 0;
        v130 = a3;
        if (!a3)
          goto LABEL_288;
      }
LABEL_262:
      v131 = *(_QWORD *)(v130 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v131 + 8))
      {
        v132 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v131 + 8);
        v183 = v131;
        v184 = v132;
        if (v128)
        {
LABEL_264:
          v17 = 1;
          if (*(_UNKNOWN **)(*(_QWORD *)v128 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
          {
            if (v131)
            {
              if (*(_UNKNOWN **)(*(_QWORD *)v131 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
              {
                mlir::ShapedType::getShape((mlir::ShapedType *)&v186);
                v134 = v133;
                mlir::ShapedType::getShape((mlir::ShapedType *)&v183);
                if (v134 != v135)
                {
                  v180 = 259;
                  mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v186);
                  v194 = v136;
                  v137 = mlir::InFlightDiagnostic::operator<<<unsigned long>((uint64_t)v197, &v194);
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v183);
                  v181 = v139;
                  v140 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v138, &v181);
                  v141 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v140, ".");
                  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v141);
                  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v197);
                }
              }
            }
          }
          return v17;
        }
      }
      else
      {
        v131 = 0;
        v183 = 0;
        v184 = 0;
        if (v128)
          goto LABEL_264;
      }
      return 1;
    }
    v180 = 259;
    mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
    if (v197[0])
    {
      LODWORD(v186) = 3;
      v187 = "invalid type. Must be specified when ";
      v188 = 37;
      v154 = (uint64_t *)&v186;
      v155 = (char *)v198;
      if (v199 >= v200)
      {
        v171 = v199 + 1;
        if (v198 <= &v186 && (char *)v198 + 24 * v199 > (char *)&v186)
        {
          v175 = (char *)&v186 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v171, 24);
          v155 = (char *)v198;
          v154 = (uint64_t *)((char *)v198 + v175);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v171, 24);
          v154 = (uint64_t *)&v186;
          v155 = (char *)v198;
        }
      }
      v156 = &v155[24 * v199];
      v157 = *(_OWORD *)v154;
      *((_QWORD *)v156 + 2) = v154[2];
      *(_OWORD *)v156 = v157;
      v158 = ++v199;
      if (v197[0])
      {
        LODWORD(v186) = 3;
        v188 = 31;
        v159 = (uint64_t *)&v186;
        v160 = (char *)v198;
        if (v158 >= v200)
        {
          v172 = v158 + 1;
          v173 = (char *)v198 + 24 * v158 > (char *)&v186;
          if (v198 <= &v186 && v173)
          {
            v176 = (char *)&v186 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v172, 24);
            v160 = (char *)v198;
            v159 = (uint64_t *)((char *)v198 + v176);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v172, 24);
            v159 = (uint64_t *)&v186;
            v160 = (char *)v198;
          }
        }
        v161 = &v160[24 * v199];
        v162 = *(_OWORD *)v159;
        *((_QWORD *)v161 + 2) = v159[2];
        *(_OWORD *)v161 = v162;
        ++v199;
      }
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
    if (v197[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
    if (v206)
    {
      v163 = __p;
      if (__p)
      {
        v164 = v205;
        v165 = __p;
        if (v205 != __p)
        {
          do
            v164 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v164 - 1);
          while (v164 != v163);
          v165 = __p;
        }
        v205 = v163;
        operator delete(v165);
      }
      v149 = v202;
      if (!v202)
        goto LABEL_311;
      v166 = v203;
      v151 = v202;
      if (v203 == v202)
      {
LABEL_310:
        v203 = v149;
        operator delete(v151);
LABEL_311:
        if (v198 != v201)
          free(v198);
        return v17;
      }
      do
      {
        v168 = *--v166;
        v167 = v168;
        *v166 = 0;
        if (v168)
          MEMORY[0x20BD002D4](v167, 0x1000C8077774924);
      }
      while (v166 != v149);
LABEL_309:
      v151 = v202;
      goto LABEL_310;
    }
  }
  return v17;
}

uint64_t mlir::mps::PoolMaxOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, __int128 a9, uint64_t a10)
{
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t Context;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  mlir::MLIRContext *v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t ElementTypeOrSelf;
  uint64_t v30;
  uint64_t *Shape;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  int v48;
  __int16 v49;
  uint64_t v50;
  _QWORD v51[2];
  void *v52;
  uint64_t v53;
  _BYTE v54[32];
  _OWORD v55[8];
  void *v56[2];
  _BYTE v57[32];
  void *v58[2];
  _BYTE v59[32];
  void *Value;
  uint64_t v61;
  _BYTE v62[64];
  void *v63[2];
  _BYTE v64[32];
  void *v65[2];
  _BYTE v66[32];
  __int128 v67;
  _BYTE v68[80];
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  if (a7)
  {
    v13 = *a7;
    v14 = a7[1];
    v15 = a7[2];
    v16 = a7[3];
    v17 = *((_QWORD *)a7 + 8);
  }
  else
  {
    v17 = 0;
    v13 = 0uLL;
    v14 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
  }
  *(_QWORD *)&v67 = a6;
  BYTE8(v67) = 0;
  v68[0] = 0;
  *(_OWORD *)&v68[8] = v13;
  *(_OWORD *)&v68[24] = v14;
  *(_OWORD *)&v68[40] = v15;
  *(_OWORD *)&v68[56] = v16;
  *(_QWORD *)&v68[72] = v17;
  v69 = a9;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v67);
    if (v68[0])
      v68[0] = 0;
    mlir::OperationName::OperationName((char *)&v67 + 8, "mps.pooling_max", 15, Context);
    v68[0] = 1;
  }
  *(_QWORD *)&v70 = a4;
  *((_QWORD *)&v70 + 1) = a5;
  if (!a5 || (v19 = mlir::UnknownLoc::get(this, a2), !mlir::mps::PoolMaxOpAdaptor::verify(&v67, v19)))
  {
    v22 = mlir::Float32Type::get(this, a2);
    v23 = mlir::UnrankedTensorType::get(v22);
    v24 = *(unsigned int *)(a10 + 8);
    if (v24 >= *(_DWORD *)(a10 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v24 + 1, 8);
      LODWORD(v24) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v24) = v23;
    ++*(_DWORD *)(a10 + 8);
    v25 = mlir::IntegerType::get((uint64_t)this, 0x20u, 1u);
    if (!v25)
      v25 = mlir::Float32Type::get(this, v26);
    v27 = mlir::UnrankedTensorType::get(v25);
    v28 = *(_DWORD *)(a10 + 8);
    if (v28 >= *(_DWORD *)(a10 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v28 + 1, 8);
      v28 = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v28) = v27;
    goto LABEL_48;
  }
  Value = (void *)v70;
  v61 = 0;
  v20 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&Value, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  if (v21)
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  else
    v20 = 0;
  v51[0] = v20;
  v51[1] = v21;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v20);
  v30 = mlir::IntegerType::get((uint64_t)this, 0x20u, 1u);
  v50 = *(_QWORD *)&v68[48];
  if (*(_QWORD *)&v68[48])
  {
    Value = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v50);
    if (mlir::Type::isSignedInteger((mlir::Type *)&Value, 32) || mlir::Type::isSignedInteger((mlir::Type *)&Value, 64))
      v30 = (uint64_t)Value;
  }
  if (!v20 || (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v51) & 1) == 0)
  {
    v42 = mlir::UnrankedTensorType::get(ElementTypeOrSelf);
    v43 = mlir::UnrankedTensorType::get(v30);
    v44 = *(unsigned int *)(a10 + 8);
    if (v44 >= *(_DWORD *)(a10 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v44 + 1, 8);
      LODWORD(v44) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v44) = v42;
    v45 = *(_DWORD *)(a10 + 12);
    v46 = (*(_DWORD *)(a10 + 8) + 1);
    *(_DWORD *)(a10 + 8) = v46;
    if (v46 >= v45)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v46 + 1, 8);
      LODWORD(v46) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v46) = v43;
LABEL_48:
    ++*(_DWORD *)(a10 + 8);
    return 1;
  }
  v65[0] = v66;
  v65[1] = (void *)0x400000000;
  v63[0] = v64;
  v63[1] = (void *)0x400000000;
  Value = v62;
  v61 = 0x800000000;
  v58[0] = v59;
  v58[1] = (void *)0x400000000;
  v56[0] = v57;
  v56[1] = (void *)0x400000000;
  v49 = 0;
  v48 = 2;
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v51);
  v55[4] = *(_OWORD *)&v68[48];
  v55[5] = *(_OWORD *)&v68[64];
  v55[6] = v69;
  v55[7] = v70;
  v55[0] = v67;
  v55[1] = *(_OWORD *)v68;
  v55[2] = *(_OWORD *)&v68[16];
  v55[3] = *(_OWORD *)&v68[32];
  mlir::mps::getPool4dParams<mlir::mps::PoolMaxOpAdaptor>(Shape, v32, v55, (uint64_t)v65, (uint64_t)v63, (uint64_t)&Value, (uint64_t)v58, (uint64_t)v56, &v48, (BOOL *)&v49 + 1, (BOOL *)&v49);
  v52 = v54;
  v53 = 0x400000000;
  if (mlir::mps::inferPool4DShape(v33, v34, v63, (uint64_t *)v65, (uint64_t *)v58, v56, &Value, v48, HIBYTE(v49), (uint64_t)&v52))
  {
    v35 = mlir::RankedTensorType::get((uint64_t)v52, v53, ElementTypeOrSelf, 0);
    v36 = mlir::RankedTensorType::get((uint64_t)v52, v53, v30, 0);
    v37 = *(unsigned int *)(a10 + 8);
    if (v37 >= *(_DWORD *)(a10 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v37 + 1, 8);
      LODWORD(v37) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v37) = v35;
    v38 = *(_DWORD *)(a10 + 12);
    v39 = (*(_DWORD *)(a10 + 8) + 1);
    *(_DWORD *)(a10 + 8) = v39;
    if (v39 >= v38)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a10, (void *)(a10 + 16), v39 + 1, 8);
      LODWORD(v39) = *(_DWORD *)(a10 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a10 + 8 * v39) = v36;
    ++*(_DWORD *)(a10 + 8);
    v40 = 1;
    v41 = v52;
    if (v52 == v54)
      goto LABEL_33;
  }
  else
  {
    v40 = 0;
    v41 = v52;
    if (v52 == v54)
      goto LABEL_33;
  }
  free(v41);
LABEL_33:
  if (v56[0] != v57)
    free(v56[0]);
  if (v58[0] != v59)
    free(v58[0]);
  if (Value != v62)
    free(Value);
  if (v63[0] != v64)
    free(v63[0]);
  if (v65[0] != v66)
    free(v65[0]);
  return v40;
}

uint64_t mlir::mps::PoolMaxOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  _QWORD *v6;
  const char *v7;
  uint64_t v8;
  _QWORD *Type;
  _QWORD *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  void *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  const char *v66;
  uint64_t Value;
  uint64_t v68;
  uint64_t OperandRange;
  const char *v70;
  uint64_t v71;
  __int16 v72;
  uint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  void *v76;
  uint64_t v77;
  void *v78;
  _QWORD *v79;
  void *__p;
  _QWORD *v81;
  char v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v3 = (const char *)a1[11];
  if (v3)
  {
    v5 = (const char *)a1[4];
    v4 = (const char *)a1[5];
    v6 = (_QWORD *)a1[8];
    v7 = (const char *)a1[10];
    v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
    v70 = v3;
    v71 = v8;
    Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
    v10 = Type;
    if (Type)
      Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
    v74 = v10;
    v75 = Type;
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v74);
    v73 = 4;
    if (v12 == 1
      && *Shape == v73
      && (v66 = v3,
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66),
          v68 = v13,
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
      if (!v7)
        goto LABEL_105;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v7 + 8);
      v70 = v7;
      v71 = v14;
      v15 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
      v16 = v15;
      if (v15)
        v15 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
      v74 = v16;
      v75 = v15;
      v17 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v74);
      v73 = 4;
      if (v18 != 1)
        goto LABEL_56;
      if (*v17 == v73
        && (v66 = v7,
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66),
            v68 = v19,
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
            mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
      {
LABEL_105:
        if (!v5)
          goto LABEL_106;
        v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
        v70 = v5;
        v71 = v20;
        v21 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
        v22 = v21;
        if (v21)
          v21 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
        v74 = v22;
        v75 = v21;
        v23 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v74);
        v73 = 4;
        if (v24 != 1)
          goto LABEL_70;
        if (*v23 == v73
          && (v66 = v5,
              Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66),
              v68 = v25,
              OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
              mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
        {
LABEL_106:
          if (!v4)
            goto LABEL_25;
          v26 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
          v70 = v4;
          v71 = v26;
          v27 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v70);
          v28 = v27;
          if (v27)
            v27 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
          v74 = v28;
          v75 = v27;
          v29 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v74);
          v73 = 8;
          if (v30 == 1 && *v29 == v73)
          {
            v66 = v4;
            Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66);
            v68 = v31;
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
            {
LABEL_25:
              if (v6)
              {
                v74 = v6;
                mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v74);
              }
              return 1;
            }
          }
          v70 = "'mps.pooling_max' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements attribute of shape {8}";
          v72 = 259;
          mlir::emitError(a2, (uint64_t)&v70, (uint64_t)&v74);
          v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v74);
          if (v74)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v74);
          if (v82)
          {
            v59 = __p;
            if (__p)
            {
              v60 = v81;
              v61 = __p;
              if (v81 != __p)
              {
                do
                  v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
                while (v60 != v59);
                v61 = __p;
              }
              v81 = v59;
              operator delete(v61);
            }
            v36 = v78;
            if (!v78)
              goto LABEL_100;
            v62 = v79;
            v38 = v78;
            if (v79 == v78)
            {
LABEL_99:
              v79 = v36;
              operator delete(v38);
LABEL_100:
              if (v76 != &v77)
                free(v76);
              return v32;
            }
            do
            {
              v64 = *--v62;
              v63 = v64;
              *v62 = 0;
              if (v64)
                MEMORY[0x20BD002D4](v63, 0x1000C8077774924);
            }
            while (v62 != v36);
LABEL_98:
            v38 = v78;
            goto LABEL_99;
          }
        }
        else
        {
LABEL_70:
          v70 = "'mps.pooling_max' op attribute 'dilation_rates' failed to satisfy constraint: ui64 elements attribute of shape {4}";
          v72 = 259;
          mlir::emitError(a2, (uint64_t)&v70, (uint64_t)&v74);
          v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v74);
          if (v74)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v74);
          if (v82)
          {
            v53 = __p;
            if (__p)
            {
              v54 = v81;
              v55 = __p;
              if (v81 != __p)
              {
                do
                  v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v54 - 1);
                while (v54 != v53);
                v55 = __p;
              }
              v81 = v53;
              operator delete(v55);
            }
            v36 = v78;
            if (!v78)
              goto LABEL_100;
            v56 = v79;
            v38 = v78;
            if (v79 == v78)
              goto LABEL_99;
            do
            {
              v58 = *--v56;
              v57 = v58;
              *v56 = 0;
              if (v58)
                MEMORY[0x20BD002D4](v57, 0x1000C8077774924);
            }
            while (v56 != v36);
            goto LABEL_98;
          }
        }
      }
      else
      {
LABEL_56:
        v70 = "'mps.pooling_max' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        v72 = 259;
        mlir::emitError(a2, (uint64_t)&v70, (uint64_t)&v74);
        v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v74);
        if (v74)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v74);
        if (v82)
        {
          v47 = __p;
          if (__p)
          {
            v48 = v81;
            v49 = __p;
            if (v81 != __p)
            {
              do
                v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v48 - 1);
              while (v48 != v47);
              v49 = __p;
            }
            v81 = v47;
            operator delete(v49);
          }
          v36 = v78;
          if (!v78)
            goto LABEL_100;
          v50 = v79;
          v38 = v78;
          if (v79 == v78)
            goto LABEL_99;
          do
          {
            v52 = *--v50;
            v51 = v52;
            *v50 = 0;
            if (v52)
              MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
          }
          while (v50 != v36);
          goto LABEL_98;
        }
      }
    }
    else
    {
      v70 = "'mps.pooling_max' op attribute 'window_sizes' failed to satisfy constraint: ui64 elements attribute of shape {4}";
      v72 = 259;
      mlir::emitError(a2, (uint64_t)&v70, (uint64_t)&v74);
      v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v74);
      if (v74)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v74);
      if (v82)
      {
        v33 = __p;
        if (__p)
        {
          v34 = v81;
          v35 = __p;
          if (v81 != __p)
          {
            do
              v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            v35 = __p;
          }
          v81 = v33;
          operator delete(v35);
        }
        v36 = v78;
        if (!v78)
          goto LABEL_100;
        v37 = v79;
        v38 = v78;
        if (v79 == v78)
          goto LABEL_99;
        do
        {
          v40 = *--v37;
          v39 = v40;
          *v37 = 0;
          if (v40)
            MEMORY[0x20BD002D4](v39, 0x1000C8077774924);
        }
        while (v37 != v36);
        goto LABEL_98;
      }
    }
  }
  else
  {
    v70 = "'mps.pooling_max' op requires attribute 'window_sizes'";
    v72 = 259;
    mlir::emitError(a2, (uint64_t)&v70, (uint64_t)&v74);
    v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v74);
    if (v74)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v74);
    if (v82)
    {
      v41 = __p;
      if (__p)
      {
        v42 = v81;
        v43 = __p;
        if (v81 != __p)
        {
          do
            v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
          while (v42 != v41);
          v43 = __p;
        }
        v81 = v41;
        operator delete(v43);
      }
      v36 = v78;
      if (!v78)
        goto LABEL_100;
      v44 = v79;
      v38 = v78;
      if (v79 == v78)
        goto LABEL_99;
      do
      {
        v46 = *--v44;
        v45 = v46;
        *v44 = 0;
        if (v46)
          MEMORY[0x20BD002D4](v45, 0x1000C8077774924);
      }
      while (v44 != v36);
      goto LABEL_98;
    }
  }
  return v32;
}

void mlir::mps::getPool4dParams<mlir::mps::PoolMaxOpAdaptor>(uint64_t *a1, unint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, BOOL *a10, BOOL *a11)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t NumElements;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  unsigned int v61;
  uint64_t v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;

  v18 = a3[11];
  v70 = a3[10];
  v71 = v18;
  v58 = a3[4];
  v59 = a3[5];
  v68 = v59;
  v69 = v58;
  *a9 = 2;
  v19 = a3[9];
  if (v19)
    *a9 = *(_DWORD *)(v19 + 8);
  *a10 = a3[3] != 0;
  *a11 = a3[6] != 0;
  v20 = *(unsigned int *)(a6 + 8);
  if ((_DWORD)v20 == 8)
  {
    v21 = *(unsigned int *)(a7 + 8);
    v22 = v21 > 4;
    if ((_DWORD)v21 == 4)
      goto LABEL_5;
LABEL_15:
    if (v22)
    {
      *(_DWORD *)(a7 + 8) = 4;
      v23 = *(unsigned int *)(a8 + 8);
      v24 = v23 > 4;
      if ((_DWORD)v23 != 4)
        goto LABEL_22;
    }
    else
    {
      v29 = v21;
      v30 = v21;
      if (*(_DWORD *)(a7 + 12) <= 3u)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a7, (void *)(a7 + 16), 4uLL, 8);
        v29 = *(unsigned int *)(a7 + 8);
        v30 = *(_DWORD *)(a7 + 8);
      }
      memset_pattern16((void *)(*(_QWORD *)a7 + 8 * v29), &unk_207A80400, 32 - 8 * v21);
      *(_DWORD *)(a7 + 8) = v30 - v21 + 4;
      v23 = *(unsigned int *)(a8 + 8);
      v24 = v23 > 4;
      if ((_DWORD)v23 != 4)
        goto LABEL_22;
    }
LABEL_6:
    v25 = *(unsigned int *)(a5 + 8);
    v26 = v25 > 4;
    if ((_DWORD)v25 == 4)
      goto LABEL_7;
LABEL_29:
    if (v26)
    {
      *(_DWORD *)(a5 + 8) = 4;
      if (a2 > *(unsigned int *)(a4 + 12))
        goto LABEL_8;
    }
    else
    {
      v33 = v25;
      v34 = v25;
      if (*(_DWORD *)(a5 + 12) <= 3u)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), 4uLL, 8);
        v33 = *(unsigned int *)(a5 + 8);
        v34 = *(_DWORD *)(a5 + 8);
      }
      memset_pattern16((void *)(*(_QWORD *)a5 + 8 * v33), &unk_207A80400, 32 - 8 * v25);
      *(_DWORD *)(a5 + 8) = v34 - v25 + 4;
      if (a2 > *(unsigned int *)(a4 + 12))
        goto LABEL_8;
    }
LABEL_36:
    if (!a2)
      goto LABEL_42;
    goto LABEL_37;
  }
  if (v20 <= 8)
  {
    v27 = *(unsigned int *)(a6 + 8);
    v28 = *(_DWORD *)(a6 + 8);
    if (*(_DWORD *)(a6 + 12) <= 7u)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a6, (void *)(a6 + 16), 8uLL, 8);
      v27 = *(unsigned int *)(a6 + 8);
      v28 = *(_DWORD *)(a6 + 8);
    }
    bzero((void *)(*(_QWORD *)a6 + 8 * v27), 64 - 8 * v20);
    *(_DWORD *)(a6 + 8) = v28 - v20 + 8;
    v21 = *(unsigned int *)(a7 + 8);
    v22 = v21 > 4;
    if ((_DWORD)v21 != 4)
      goto LABEL_15;
  }
  else
  {
    *(_DWORD *)(a6 + 8) = 8;
    v21 = *(unsigned int *)(a7 + 8);
    v22 = v21 > 4;
    if ((_DWORD)v21 != 4)
      goto LABEL_15;
  }
LABEL_5:
  v23 = *(unsigned int *)(a8 + 8);
  v24 = v23 > 4;
  if ((_DWORD)v23 == 4)
    goto LABEL_6;
LABEL_22:
  if (v24)
  {
    *(_DWORD *)(a8 + 8) = 4;
    v25 = *(unsigned int *)(a5 + 8);
    v26 = v25 > 4;
    if ((_DWORD)v25 != 4)
      goto LABEL_29;
  }
  else
  {
    v31 = v23;
    v32 = v23;
    if (*(_DWORD *)(a8 + 12) <= 3u)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a8, (void *)(a8 + 16), 4uLL, 8);
      v31 = *(unsigned int *)(a8 + 8);
      v32 = *(_DWORD *)(a8 + 8);
    }
    memset_pattern16((void *)(*(_QWORD *)a8 + 8 * v31), &unk_207A80400, 32 - 8 * v23);
    *(_DWORD *)(a8 + 8) = v32 - v23 + 4;
    v25 = *(unsigned int *)(a5 + 8);
    v26 = v25 > 4;
    if ((_DWORD)v25 != 4)
      goto LABEL_29;
  }
LABEL_7:
  if (a2 <= *(unsigned int *)(a4 + 12))
    goto LABEL_36;
LABEL_8:
  llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), a2, 8);
LABEL_37:
  v35 = *(_DWORD *)(a4 + 8);
  v36 = 8 * a2;
  do
  {
    v37 = *a1;
    if (v35 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v35 + 1, 8);
      v35 = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v35) = v37;
    v35 = *(_DWORD *)(a4 + 8) + 1;
    *(_DWORD *)(a4 + 8) = v35;
    ++a1;
    v36 -= 8;
  }
  while (v36);
  v18 = v71;
LABEL_42:
  if (v18 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v71) == 4)
  {
    *(_DWORD *)(a5 + 8) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v65, v71, 0);
    v38 = v71;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v71);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v62, v38, NumElements);
    while (1)
    {
      v40 = v65 == v62 && v66 == v63;
      if (v40 && v67 == v64)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*(&v65, (llvm::APInt *)&v60);
      if (v61 > 0x40)
        v41 = *v60;
      else
        v41 = (uint64_t)((_QWORD)v60 << -(uint64_t)v61) >> -(uint64_t)v61;
      v42 = *(unsigned int *)(a5 + 8);
      if (v42 >= *(unsigned int *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v42 + 1, 8);
        v42 = *(unsigned int *)(a5 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a5 + 8 * v42) = v41;
      ++*(_DWORD *)(a5 + 8);
      if (v61 >= 0x41)
      {
        if (v60)
          MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
      }
      ++v67;
    }
  }
  if (v70 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v70) == 4)
  {
    *(_DWORD *)(a7 + 8) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v65, v70, 0);
    v43 = v70;
    v44 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v70);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v62, v43, v44);
    while (1)
    {
      v45 = v65 == v62 && v66 == v63;
      if (v45 && v67 == v64)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*(&v65, (llvm::APInt *)&v60);
      if (v61 > 0x40)
        v46 = *v60;
      else
        v46 = (uint64_t)((_QWORD)v60 << -(uint64_t)v61) >> -(uint64_t)v61;
      v47 = *(unsigned int *)(a7 + 8);
      if (v47 >= *(unsigned int *)(a7 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a7, (void *)(a7 + 16), v47 + 1, 8);
        v47 = *(unsigned int *)(a7 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a7 + 8 * v47) = v46;
      ++*(_DWORD *)(a7 + 8);
      if (v61 >= 0x41 && v60)
        MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
      ++v67;
    }
  }
  if (v58 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v69) == 4)
  {
    *(_DWORD *)(a8 + 8) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v65, v69, 0);
    v48 = v69;
    v49 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v69);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v62, v48, v49);
    while (1)
    {
      v50 = v65 == v62 && v66 == v63;
      if (v50 && v67 == v64)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*(&v65, (llvm::APInt *)&v60);
      if (v61 > 0x40)
        v51 = *v60;
      else
        v51 = (uint64_t)((_QWORD)v60 << -(uint64_t)v61) >> -(uint64_t)v61;
      v52 = *(unsigned int *)(a8 + 8);
      if (v52 >= *(unsigned int *)(a8 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a8, (void *)(a8 + 16), v52 + 1, 8);
        v52 = *(unsigned int *)(a8 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a8 + 8 * v52) = v51;
      ++*(_DWORD *)(a8 + 8);
      if (v61 >= 0x41 && v60)
        MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
      ++v67;
    }
  }
  if (v59 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v68) == 8)
  {
    *(_DWORD *)(a6 + 8) = 0;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v65, v68, 0);
    v53 = v68;
    v54 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v68);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v62, v53, v54);
    while (1)
    {
      v55 = v65 == v62 && v66 == v63;
      if (v55 && v67 == v64)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*(&v65, (llvm::APInt *)&v60);
      if (v61 > 0x40)
        v56 = *v60;
      else
        v56 = (uint64_t)((_QWORD)v60 << -(uint64_t)v61) >> -(uint64_t)v61;
      v57 = *(unsigned int *)(a6 + 8);
      if (v57 >= *(unsigned int *)(a6 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a6, (void *)(a6 + 16), v57 + 1, 8);
        v57 = *(unsigned int *)(a6 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a6 + 8 * v57) = v56;
      ++*(_DWORD *)(a6 + 8);
      if (v61 >= 0x41 && v60)
        MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
      ++v67;
    }
  }
}

uint64_t mlir::mps::verifyPooling4D<mlir::mps::PoolMaxOp>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t NumElements;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  int64_t v43;
  int64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t *v51;
  char *v52;
  __int128 v53;
  uint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  __int128 v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  int64_t v70;
  int64_t v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t *v78;
  char *v79;
  __int128 v80;
  uint64_t v81;
  char *v82;
  uint64_t *v83;
  char *v84;
  __int128 v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  int64_t v97;
  int64_t v98;
  uint64_t v99;
  uint64_t v100;
  BOOL v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  uint64_t *v105;
  char *v106;
  __int128 v107;
  uint64_t v108;
  char *v109;
  uint64_t *v110;
  char *v111;
  __int128 v112;
  _QWORD *v113;
  _QWORD *v114;
  void *v115;
  _QWORD *v116;
  _QWORD *v117;
  void *v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  BOOL v123;
  int64_t v124;
  int64_t v125;
  uint64_t *v126;
  int v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  char *v143;
  char *v144;
  __int128 v145;
  _QWORD *v146;
  _QWORD *v147;
  void *v148;
  _QWORD *v149;
  _QWORD *v150;
  void *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t *v154;
  char *v155;
  char *v156;
  __int128 v157;
  uint64_t v158;
  uint64_t *v159;
  char *v160;
  char *v161;
  __int128 v162;
  _QWORD *v163;
  _QWORD *v164;
  void *v165;
  _QWORD *v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  BOOL v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  const void **v179[4];
  __int16 v180;
  uint64_t v181;
  unsigned int v182;
  unint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186;
  const char *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t *v193;
  uint64_t v194;
  const char *v195;
  uint64_t v196;
  _QWORD v197[3];
  void *v198;
  unsigned int v199;
  unsigned int v200;
  _BYTE v201[96];
  void *v202;
  _QWORD *v203;
  void *__p;
  _QWORD *v205;
  char v206;
  uint64_t v207;

  v207 = *MEMORY[0x24BDAC8D0];
  v193 = (uint64_t *)a1;
  v4 = *(unsigned int *)(a1 + 44);
  v5 = a1 + 64;
  v6 = (v4 >> 23) & 1;
  v7 = a1 + 64 + 16 * v6;
  if (!HIBYTE(*(_DWORD *)(a1 + 44)))
    v7 = 0;
  v8 = *(_QWORD *)(v7 + 56);
  if (v8)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v7 + 56)))
      v9 = v8;
    else
      v9 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v9 = 0;
  }
  v192 = v9;
  v10 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v10 = 0;
  v11 = *(_QWORD *)(v10 + 8);
  if (v11)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v10 + 8)))
      v12 = v11;
    else
      v12 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v12 = 0;
  }
  v191 = v12;
  v13 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v13 = 0;
  v14 = *(_QWORD *)(v13 + 64);
  if (v14)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v13 + 64)))
      v15 = v14;
    else
      v15 = 0;
    v4 = *(unsigned int *)(a1 + 44);
    v6 = (v4 >> 23) & 1;
  }
  else
  {
    v15 = 0;
  }
  v189 = 0;
  v190 = v15;
  v16 = v5 + 16 * v6;
  if (!BYTE3(v4))
    v16 = 0;
  v17 = *(_QWORD *)(v16 + 16);
  if (v17)
  {
    if (mlir::DenseIntElementsAttr::classof(*(_QWORD *)(v16 + 16)))
      v18 = v17;
    else
      v18 = 0;
    v189 = v18;
  }
  if (v15 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v190) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v190, 0);
    v17 = v190;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v190);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v17, NumElements);
    while (1)
    {
      v20 = v186 == v183 && v187 == v184;
      if (v20 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v21 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_47:
          if (v182 < 0x41)
            goto LABEL_77;
LABEL_75:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_77;
        }
      }
      else
      {
        v21 = v181 << -(char)v182 >> -(char)v182;
        if (v21 > 0)
          goto LABEL_47;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v22 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_56;
      }
      else
      {
        v22 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_56;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v22;
      v23 = (char *)v198;
      if (v199 >= v200)
      {
        v40 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v43 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v40, 24);
          v23 = (char *)v198;
          v24 = (uint64_t *)((char *)v198 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v40, 24);
          v24 = &v194;
          v23 = (char *)v198;
        }
      }
      else
      {
        v24 = &v194;
      }
      v25 = &v23[24 * v199];
      v26 = *(_OWORD *)v24;
      *((_QWORD *)v25 + 2) = v24[2];
      *(_OWORD *)v25 = v26;
      v27 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v28 = (char *)v198;
        if (v27 >= v200)
        {
          v41 = v27 + 1;
          v42 = (char *)v198 + 24 * v27 > (char *)&v194;
          if (v198 <= &v194 && v42)
          {
            v44 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v41, 24);
            v28 = (char *)v198;
            v29 = (uint64_t *)((char *)v198 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v41, 24);
            v29 = &v194;
            v28 = (char *)v198;
          }
        }
        else
        {
          v29 = &v194;
        }
        v30 = &v28[24 * v199];
        v31 = *(_OWORD *)v29;
        *((_QWORD *)v30 + 2) = v29[2];
        *(_OWORD *)v30 = v31;
        ++v199;
      }
LABEL_56:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v32 = __p;
        if (__p)
        {
          v33 = v205;
          v34 = __p;
          if (v205 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v205 = v32;
          operator delete(v34);
        }
        v35 = v202;
        if (v202)
        {
          v36 = v203;
          v37 = v202;
          if (v203 != v202)
          {
            do
            {
              v39 = *--v36;
              v38 = v39;
              *v36 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v36 != v35);
            v37 = v202;
          }
          v203 = v35;
          operator delete(v37);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_75;
LABEL_77:
      if (v21 < 1)
        return v17;
      ++v188;
    }
  }
  if (v192 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v192) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v192, 0);
    v45 = v192;
    v46 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v192);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v45, v46);
    while (1)
    {
      v47 = v186 == v183 && v187 == v184;
      if (v47 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v48 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_102:
          if (v182 < 0x41)
            goto LABEL_132;
LABEL_130:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_132;
        }
      }
      else
      {
        v48 = v181 << -(char)v182 >> -(char)v182;
        if (v48 > 0)
          goto LABEL_102;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v49 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_111;
      }
      else
      {
        v49 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_111;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v49;
      v50 = (char *)v198;
      if (v199 >= v200)
      {
        v67 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v70 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v67, 24);
          v50 = (char *)v198;
          v51 = (uint64_t *)((char *)v198 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v67, 24);
          v51 = &v194;
          v50 = (char *)v198;
        }
      }
      else
      {
        v51 = &v194;
      }
      v52 = &v50[24 * v199];
      v53 = *(_OWORD *)v51;
      *((_QWORD *)v52 + 2) = v51[2];
      *(_OWORD *)v52 = v53;
      v54 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v55 = (char *)v198;
        if (v54 >= v200)
        {
          v68 = v54 + 1;
          v69 = (char *)v198 + 24 * v54 > (char *)&v194;
          if (v198 <= &v194 && v69)
          {
            v71 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v68, 24);
            v55 = (char *)v198;
            v56 = (uint64_t *)((char *)v198 + v71);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v68, 24);
            v56 = &v194;
            v55 = (char *)v198;
          }
        }
        else
        {
          v56 = &v194;
        }
        v57 = &v55[24 * v199];
        v58 = *(_OWORD *)v56;
        *((_QWORD *)v57 + 2) = v56[2];
        *(_OWORD *)v57 = v58;
        ++v199;
      }
LABEL_111:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v59 = __p;
        if (__p)
        {
          v60 = v205;
          v61 = __p;
          if (v205 != __p)
          {
            do
              v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
            while (v60 != v59);
            v61 = __p;
          }
          v205 = v59;
          operator delete(v61);
        }
        v62 = v202;
        if (v202)
        {
          v63 = v203;
          v64 = v202;
          if (v203 != v202)
          {
            do
            {
              v66 = *--v63;
              v65 = v66;
              *v63 = 0;
              if (v66)
                MEMORY[0x20BD002D4](v65, 0x1000C8077774924);
            }
            while (v63 != v62);
            v64 = v202;
          }
          v203 = v62;
          operator delete(v64);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_130;
LABEL_132:
      if (v48 < 1)
        return v17;
      ++v188;
    }
  }
  if (v191 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v191) == 4)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v191, 0);
    v72 = v191;
    v73 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v191);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v72, v73);
    while (1)
    {
      v74 = v186 == v183 && v187 == v184;
      if (v74 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v75 = *(_QWORD *)v181;
        if (*(uint64_t *)v181 > 0)
        {
LABEL_157:
          if (v182 < 0x41)
            goto LABEL_187;
LABEL_185:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_187;
        }
      }
      else
      {
        v75 = v181 << -(char)v182 >> -(char)v182;
        if (v75 > 0)
          goto LABEL_157;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v76 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_166;
      }
      else
      {
        v76 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_166;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v76;
      v77 = (char *)v198;
      if (v199 >= v200)
      {
        v94 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v97 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v94, 24);
          v77 = (char *)v198;
          v78 = (uint64_t *)((char *)v198 + v97);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v94, 24);
          v78 = &v194;
          v77 = (char *)v198;
        }
      }
      else
      {
        v78 = &v194;
      }
      v79 = &v77[24 * v199];
      v80 = *(_OWORD *)v78;
      *((_QWORD *)v79 + 2) = v78[2];
      *(_OWORD *)v79 = v80;
      v81 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be positive.";
        v196 = 32;
        v82 = (char *)v198;
        if (v81 >= v200)
        {
          v95 = v81 + 1;
          v96 = (char *)v198 + 24 * v81 > (char *)&v194;
          if (v198 <= &v194 && v96)
          {
            v98 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v95, 24);
            v82 = (char *)v198;
            v83 = (uint64_t *)((char *)v198 + v98);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v95, 24);
            v83 = &v194;
            v82 = (char *)v198;
          }
        }
        else
        {
          v83 = &v194;
        }
        v84 = &v82[24 * v199];
        v85 = *(_OWORD *)v83;
        *((_QWORD *)v84 + 2) = v83[2];
        *(_OWORD *)v84 = v85;
        ++v199;
      }
LABEL_166:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v86 = __p;
        if (__p)
        {
          v87 = v205;
          v88 = __p;
          if (v205 != __p)
          {
            do
              v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
            while (v87 != v86);
            v88 = __p;
          }
          v205 = v86;
          operator delete(v88);
        }
        v89 = v202;
        if (v202)
        {
          v90 = v203;
          v91 = v202;
          if (v203 != v202)
          {
            do
            {
              v93 = *--v90;
              v92 = v93;
              *v90 = 0;
              if (v93)
                MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
            }
            while (v90 != v89);
            v91 = v202;
          }
          v203 = v89;
          operator delete(v91);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_185;
LABEL_187:
      if (v75 < 1)
        return v17;
      ++v188;
    }
  }
  if (v189 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v189) == 8)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v186, v189, 0);
    v99 = v189;
    v100 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v189);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v183, v99, v100);
    while (1)
    {
      v101 = v186 == v183 && v187 == v184;
      if (v101 && v188 == v185)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v186, (llvm::APInt *)&v181);
      if (v182 > 0x40)
      {
        v102 = *(_QWORD *)v181;
        if ((*(_QWORD *)v181 & 0x8000000000000000) == 0)
        {
LABEL_212:
          if (v182 < 0x41)
            goto LABEL_242;
LABEL_240:
          if (v181)
            MEMORY[0x20BD002D4](v181, 0x1000C8000313F17);
          goto LABEL_242;
        }
      }
      else
      {
        v102 = v181 << -(char)v182 >> -(char)v182;
        if ((v102 & 0x8000000000000000) == 0)
          goto LABEL_212;
      }
      v180 = 259;
      mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
      if (v182 > 0x40)
      {
        v103 = *(_QWORD *)v181;
        if (!v197[0])
          goto LABEL_221;
      }
      else
      {
        v103 = v181 << -(char)v182 >> -(char)v182;
        if (!v197[0])
          goto LABEL_221;
      }
      LODWORD(v194) = 2;
      v195 = (const char *)v103;
      v104 = (char *)v198;
      if (v199 >= v200)
      {
        v121 = v199 + 1;
        if (v198 <= &v194 && (char *)v198 + 24 * v199 > (char *)&v194)
        {
          v124 = (char *)&v194 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v121, 24);
          v104 = (char *)v198;
          v105 = (uint64_t *)((char *)v198 + v124);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v121, 24);
          v105 = &v194;
          v104 = (char *)v198;
        }
      }
      else
      {
        v105 = &v194;
      }
      v106 = &v104[24 * v199];
      v107 = *(_OWORD *)v105;
      *((_QWORD *)v106 + 2) = v105[2];
      *(_OWORD *)v106 = v107;
      v108 = ++v199;
      if (v197[0])
      {
        LODWORD(v194) = 3;
        v195 = ", all values should be non-negative.";
        v196 = 36;
        v109 = (char *)v198;
        if (v108 >= v200)
        {
          v122 = v108 + 1;
          v123 = (char *)v198 + 24 * v108 > (char *)&v194;
          if (v198 <= &v194 && v123)
          {
            v125 = (char *)&v194 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v122, 24);
            v109 = (char *)v198;
            v110 = (uint64_t *)((char *)v198 + v125);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v122, 24);
            v110 = &v194;
            v109 = (char *)v198;
          }
        }
        else
        {
          v110 = &v194;
        }
        v111 = &v109[24 * v199];
        v112 = *(_OWORD *)v110;
        *((_QWORD *)v111 + 2) = v110[2];
        *(_OWORD *)v111 = v112;
        ++v199;
      }
LABEL_221:
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
      if (v197[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
      if (v206)
      {
        v113 = __p;
        if (__p)
        {
          v114 = v205;
          v115 = __p;
          if (v205 != __p)
          {
            do
              v114 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v114 - 1);
            while (v114 != v113);
            v115 = __p;
          }
          v205 = v113;
          operator delete(v115);
        }
        v116 = v202;
        if (v202)
        {
          v117 = v203;
          v118 = v202;
          if (v203 != v202)
          {
            do
            {
              v120 = *--v117;
              v119 = v120;
              *v117 = 0;
              if (v120)
                MEMORY[0x20BD002D4](v119, 0x1000C8077774924);
            }
            while (v117 != v116);
            v118 = v202;
          }
          v203 = v116;
          operator delete(v118);
        }
        if (v198 != v201)
          free(v198);
      }
      if (v182 >= 0x41)
        goto LABEL_240;
LABEL_242:
      if (v102 < 0)
        return v17;
      ++v188;
    }
  }
  v126 = &v193[2 * (((unint64_t)*((unsigned int *)v193 + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)v193 + 11)))
    v126 = 0;
  v127 = *(_DWORD *)(v126[6] + 8);
  if (v127 == 3)
  {
    v180 = 259;
    mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
    if (v197[0])
    {
      LODWORD(v186) = 3;
      v187 = "not supported by this op.";
      v188 = 25;
      v142 = (uint64_t *)&v186;
      v143 = (char *)v198;
      if (v199 >= v200)
      {
        v170 = v199 + 1;
        if (v198 <= &v186 && (char *)v198 + 24 * v199 > (char *)&v186)
        {
          v174 = (char *)&v186 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v170, 24);
          v143 = (char *)v198;
          v142 = (uint64_t *)((char *)v198 + v174);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v170, 24);
          v142 = (uint64_t *)&v186;
          v143 = (char *)v198;
        }
      }
      v144 = &v143[24 * v199];
      v145 = *(_OWORD *)v142;
      *((_QWORD *)v144 + 2) = v142[2];
      *(_OWORD *)v144 = v145;
      ++v199;
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
    if (v197[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
    if (v206)
    {
      v146 = __p;
      if (__p)
      {
        v147 = v205;
        v148 = __p;
        if (v205 != __p)
        {
          do
            v147 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v147 - 1);
          while (v147 != v146);
          v148 = __p;
        }
        v205 = v146;
        operator delete(v148);
      }
      v149 = v202;
      if (!v202)
        goto LABEL_312;
      v150 = v203;
      v151 = v202;
      if (v203 == v202)
        goto LABEL_311;
      do
      {
        v153 = *--v150;
        v152 = v153;
        *v150 = 0;
        if (v153)
          MEMORY[0x20BD002D4](v152, 0x1000C8077774924);
      }
      while (v150 != v149);
      goto LABEL_310;
    }
  }
  else
  {
    if (v127 || v189)
    {
      if (a2)
      {
        v128 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
        if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v128 + 8))
        {
          v129 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v128 + 8);
          v130 = a3;
          v186 = v128;
          v187 = (const char *)v129;
          if (a3)
            goto LABEL_260;
LABEL_285:
          v131 = 0;
          v183 = 0;
          v184 = 0;
          if (v128)
            goto LABEL_262;
          return 1;
        }
        v128 = 0;
        v130 = a3;
        v186 = 0;
        v187 = 0;
        if (!a3)
          goto LABEL_285;
      }
      else
      {
        v128 = 0;
        v186 = 0;
        v187 = 0;
        v130 = a3;
        if (!a3)
          goto LABEL_285;
      }
LABEL_260:
      v131 = *(_QWORD *)(v130 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v131 + 8))
      {
        v132 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v131 + 8);
        v183 = v131;
        v184 = v132;
        if (v128)
        {
LABEL_262:
          v17 = 1;
          if (*(_UNKNOWN **)(*(_QWORD *)v128 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
          {
            if (v131)
            {
              if (*(_UNKNOWN **)(*(_QWORD *)v131 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
              {
                mlir::ShapedType::getShape((mlir::ShapedType *)&v186);
                v134 = v133;
                mlir::ShapedType::getShape((mlir::ShapedType *)&v183);
                if (v134 != v135)
                {
                  v180 = 259;
                  mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v186);
                  v194 = v136;
                  v137 = mlir::InFlightDiagnostic::operator<<<unsigned long>((uint64_t)v197, &v194);
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v183);
                  v181 = v139;
                  v140 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v138, &v181);
                  v141 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v140, ".");
                  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v141);
                  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v197);
                }
              }
            }
          }
          return v17;
        }
      }
      else
      {
        v131 = 0;
        v183 = 0;
        v184 = 0;
        if (v128)
          goto LABEL_262;
      }
      return 1;
    }
    v180 = 259;
    mlir::OpState::emitOpError(&v193, v179, (uint64_t)v197);
    if (v197[0])
    {
      LODWORD(v186) = 3;
      v187 = "invalid type. Must be specified when ";
      v188 = 37;
      v154 = (uint64_t *)&v186;
      v155 = (char *)v198;
      if (v199 >= v200)
      {
        v171 = v199 + 1;
        if (v198 <= &v186 && (char *)v198 + 24 * v199 > (char *)&v186)
        {
          v175 = (char *)&v186 - (_BYTE *)v198;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v171, 24);
          v155 = (char *)v198;
          v154 = (uint64_t *)((char *)v198 + v175);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v171, 24);
          v154 = (uint64_t *)&v186;
          v155 = (char *)v198;
        }
      }
      v156 = &v155[24 * v199];
      v157 = *(_OWORD *)v154;
      *((_QWORD *)v156 + 2) = v154[2];
      *(_OWORD *)v156 = v157;
      v158 = ++v199;
      if (v197[0])
      {
        LODWORD(v186) = 3;
        v188 = 31;
        v159 = (uint64_t *)&v186;
        v160 = (char *)v198;
        if (v158 >= v200)
        {
          v172 = v158 + 1;
          v173 = (char *)v198 + 24 * v158 > (char *)&v186;
          if (v198 <= &v186 && v173)
          {
            v176 = (char *)&v186 - (_BYTE *)v198;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v172, 24);
            v160 = (char *)v198;
            v159 = (uint64_t *)((char *)v198 + v176);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v201, v172, 24);
            v159 = (uint64_t *)&v186;
            v160 = (char *)v198;
          }
        }
        v161 = &v160[24 * v199];
        v162 = *(_OWORD *)v159;
        *((_QWORD *)v161 + 2) = v159[2];
        *(_OWORD *)v161 = v162;
        ++v199;
      }
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v197);
    if (v197[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v197);
    if (v206)
    {
      v163 = __p;
      if (__p)
      {
        v164 = v205;
        v165 = __p;
        if (v205 != __p)
        {
          do
            v164 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v164 - 1);
          while (v164 != v163);
          v165 = __p;
        }
        v205 = v163;
        operator delete(v165);
      }
      v149 = v202;
      if (!v202)
        goto LABEL_312;
      v166 = v203;
      v151 = v202;
      if (v203 == v202)
      {
LABEL_311:
        v203 = v149;
        operator delete(v151);
LABEL_312:
        if (v198 != v201)
          free(v198);
        return v17;
      }
      do
      {
        v168 = *--v166;
        v167 = v168;
        *v166 = 0;
        if (v168)
          MEMORY[0x20BD002D4](v167, 0x1000C8077774924);
      }
      while (v166 != v149);
LABEL_310:
      v151 = v202;
      goto LABEL_311;
    }
  }
  return v17;
}

uint64_t mlir::mps::BiasAddOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  const char *v25;
  char *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  const void ***v31;
  char *v32;
  char *v33;
  __int128 v34;
  uint64_t v35;
  const void ***v36;
  char *v37;
  char *v38;
  __int128 v39;
  const char *v40;
  const void ***v41;
  char *v42;
  char *v43;
  __int128 v44;
  uint64_t v45;
  const void ***v46;
  char *v47;
  char *v48;
  __int128 v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  _QWORD *v53;
  _QWORD *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  const void ***v58;
  char *v59;
  char *v60;
  __int128 v61;
  const char *v62;
  const void ***v63;
  char *v64;
  char *v65;
  __int128 v66;
  uint64_t v67;
  const void ***v68;
  char *v69;
  char *v70;
  __int128 v71;
  _QWORD *v72;
  _QWORD *v73;
  void *v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  const void **v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  BOOL v92;
  unint64_t v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  BOOL v97;
  unint64_t v98;
  BOOL v99;
  unint64_t v100;
  BOOL v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  int64_t v108;
  int64_t v109;
  int64_t v110;
  int64_t v111;
  uint64_t v112;
  const void **v113;
  const char *v114;
  uint64_t v115;
  __int16 v116;
  _QWORD v117[2];
  _QWORD *v118;
  uint64_t v119;
  const void **v120;
  const char *v121;
  uint64_t v122;
  __int16 v123;
  uint64_t v124;
  uint64_t v125;
  void *v126;
  unsigned int v127;
  unsigned int v128;
  _BYTE v129[96];
  void *v130;
  _QWORD *v131;
  void *__p;
  _QWORD *v133;
  char v134;
  uint64_t v135;

  v135 = *MEMORY[0x24BDAC8D0];
  v2 = (*this)[9];
  v3 = *(int *)((*this)[10] + 8);
  v4 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v4)
  {
    v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8);
    v6 = (*this)[9];
    v118 = v4;
    v119 = v5;
    v7 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v6 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v7)
    {
LABEL_3:
      v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
      goto LABEL_6;
    }
  }
  else
  {
    v118 = 0;
    v119 = 0;
    v7 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v7)
      goto LABEL_3;
  }
  v8 = 0;
LABEL_6:
  v117[0] = v7;
  v117[1] = v8;
  if ((_DWORD)v3 == 1)
    v9 = 2;
  else
    v9 = 3;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v118))
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v118);
    if (v10 < v9)
    {
      v116 = 257;
      mlir::OpState::emitOpError(this, &v113, (uint64_t)&v124);
      if (v124)
      {
        LODWORD(v120) = 3;
        v121 = "requires value operand to have rank at least ";
        v122 = 45;
        v11 = &v120;
        v12 = (char *)v126;
        if (v127 >= v128)
        {
          v87 = v127 + 1;
          if (v126 <= &v120 && (char *)v126 + 24 * v127 > (char *)&v120)
          {
            v102 = (char *)&v120 - (_BYTE *)v126;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v87, 24);
            v12 = (char *)v126;
            v11 = (const void ***)((char *)v126 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v87, 24);
            v11 = &v120;
            v12 = (char *)v126;
          }
        }
        v13 = &v12[24 * v127];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        v15 = ++v127;
        if (v124)
        {
          LODWORD(v120) = 2;
          v121 = (const char *)v9;
          v16 = &v120;
          v17 = (char *)v126;
          if (v15 >= v128)
          {
            v91 = v15 + 1;
            v92 = (char *)v126 + 24 * v15 > (char *)&v120;
            if (v126 <= &v120 && v92)
            {
              v106 = (char *)&v120 - (_BYTE *)v126;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v91, 24);
              v17 = (char *)v126;
              v16 = (const void ***)((char *)v126 + v106);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v91, 24);
              v16 = &v120;
              v17 = (char *)v126;
            }
          }
          v18 = &v17[24 * v127];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = v16[2];
          *(_OWORD *)v18 = v19;
          v20 = ++v127;
          if (v124)
          {
            LODWORD(v120) = 3;
            v122 = 7;
            v21 = &v120;
            v22 = (char *)v126;
            if (v20 >= v128)
            {
              v100 = v20 + 1;
              v101 = (char *)v126 + 24 * v20 > (char *)&v120;
              if (v126 <= &v120 && v101)
              {
                v111 = (char *)&v120 - (_BYTE *)v126;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v100, 24);
                v22 = (char *)v126;
                v21 = (const void ***)((char *)v126 + v111);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v100, 24);
                v21 = &v120;
                v22 = (char *)v126;
              }
            }
            v23 = &v22[24 * v127];
            v24 = *(_OWORD *)v21;
            *((_QWORD *)v23 + 2) = v21[2];
            *(_OWORD *)v23 = v24;
            ++v127;
          }
        }
      }
      if (v3 > 0xA)
      {
        v25 = 0;
        v26 = &byte_207AF6795;
        if (!v124)
          goto LABEL_56;
      }
      else
      {
        v25 = (const char *)qword_207ADC340[v3];
        v26 = off_24C061168[v3];
        if (!v124)
          goto LABEL_56;
      }
      v123 = 261;
      v120 = (const void **)v26;
      v121 = v25;
      mlir::Diagnostic::operator<<((uint64_t)&v125, &v120);
      if (v124)
      {
        LODWORD(v120) = 3;
        v122 = 21;
        v58 = &v120;
        v59 = (char *)v126;
        if (v127 >= v128)
        {
          v93 = v127 + 1;
          if (v126 <= &v120 && (char *)v126 + 24 * v127 > (char *)&v120)
          {
            v107 = (char *)&v120 - (_BYTE *)v126;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v93, 24);
            v59 = (char *)v126;
            v58 = (const void ***)((char *)v126 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v93, 24);
            v58 = &v120;
            v59 = (char *)v126;
          }
        }
        v60 = &v59[24 * v127];
        v61 = *(_OWORD *)v58;
        *((_QWORD *)v60 + 2) = v58[2];
        *(_OWORD *)v60 = v61;
        ++v127;
      }
LABEL_56:
      mlir::ShapedType::getShape((mlir::ShapedType *)&v118);
      if (v124)
      {
        LODWORD(v120) = 2;
        v121 = v62;
        v63 = &v120;
        v64 = (char *)v126;
        if (v127 >= v128)
        {
          v88 = v127 + 1;
          if (v126 <= &v120 && (char *)v126 + 24 * v127 > (char *)&v120)
          {
            v103 = (char *)&v120 - (_BYTE *)v126;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v88, 24);
            v64 = (char *)v126;
            v63 = (const void ***)((char *)v126 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v88, 24);
            v63 = &v120;
            v64 = (char *)v126;
          }
        }
        v65 = &v64[24 * v127];
        v66 = *(_OWORD *)v63;
        *((_QWORD *)v65 + 2) = v63[2];
        *(_OWORD *)v65 = v66;
        v67 = ++v127;
        if (v124)
        {
          LODWORD(v120) = 3;
          v121 = ".";
          v122 = 1;
          v68 = &v120;
          v69 = (char *)v126;
          if (v67 >= v128)
          {
            v94 = v67 + 1;
            v95 = (char *)v126 + 24 * v67 > (char *)&v120;
            if (v126 <= &v120 && v95)
            {
              v108 = (char *)&v120 - (_BYTE *)v126;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v94, 24);
              v69 = (char *)v126;
              v68 = (const void ***)((char *)v126 + v108);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v94, 24);
              v68 = &v120;
              v69 = (char *)v126;
            }
          }
          v70 = &v69[24 * v127];
          v71 = *(_OWORD *)v68;
          *((_QWORD *)v70 + 2) = v68[2];
          *(_OWORD *)v70 = v71;
          ++v127;
        }
      }
      v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v124);
      if (v124)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v124);
      if (v134)
      {
        v72 = __p;
        if (__p)
        {
          v73 = v133;
          v74 = __p;
          if (v133 != __p)
          {
            do
              v73 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v73 - 1);
            while (v73 != v72);
            v74 = __p;
          }
          v133 = v72;
          operator delete(v74);
        }
        v53 = v130;
        if (!v130)
          goto LABEL_77;
        v75 = v131;
        v55 = v130;
        if (v131 == v130)
        {
LABEL_76:
          v131 = v53;
          operator delete(v55);
LABEL_77:
          if (v126 != v129)
            free(v126);
          return v30;
        }
        do
        {
          v77 = *--v75;
          v76 = v77;
          *v75 = 0;
          if (v77)
            MEMORY[0x20BD002D4](v76, 0x1000C8077774924);
        }
        while (v75 != v53);
LABEL_75:
        v55 = v130;
        goto LABEL_76;
      }
      return v30;
    }
  }
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v117)
    && (mlir::ShapedType::getShape((mlir::ShapedType *)v117), v27 != 1))
  {
    v123 = 257;
    mlir::OpState::emitOpError(this, &v120, (uint64_t)&v124);
    if (v124)
    {
      LODWORD(v113) = 3;
      v114 = "requires bias operand to have rank exactly one.";
      v115 = 47;
      v31 = &v113;
      v32 = (char *)v126;
      if (v127 >= v128)
      {
        v89 = v127 + 1;
        if (v126 <= &v113 && (char *)v126 + 24 * v127 > (char *)&v113)
        {
          v104 = (char *)&v113 - (_BYTE *)v126;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v89, 24);
          v32 = (char *)v126;
          v31 = (const void ***)((char *)v126 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v89, 24);
          v31 = &v113;
          v32 = (char *)v126;
        }
      }
      v33 = &v32[24 * v127];
      v34 = *(_OWORD *)v31;
      *((_QWORD *)v33 + 2) = v31[2];
      *(_OWORD *)v33 = v34;
      v35 = ++v127;
      if (v124)
      {
        LODWORD(v113) = 3;
        v114 = " Found ";
        v115 = 7;
        v36 = &v113;
        v37 = (char *)v126;
        if (v35 >= v128)
        {
          v96 = v35 + 1;
          v97 = (char *)v126 + 24 * v35 > (char *)&v113;
          if (v126 <= &v113 && v97)
          {
            v109 = (char *)&v113 - (_BYTE *)v126;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v96, 24);
            v37 = (char *)v126;
            v36 = (const void ***)((char *)v126 + v109);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v96, 24);
            v36 = &v113;
            v37 = (char *)v126;
          }
        }
        v38 = &v37[24 * v127];
        v39 = *(_OWORD *)v36;
        *((_QWORD *)v38 + 2) = v36[2];
        *(_OWORD *)v38 = v39;
        ++v127;
      }
    }
    mlir::ShapedType::getShape((mlir::ShapedType *)v117);
    if (v124)
    {
      LODWORD(v113) = 2;
      v114 = v40;
      v41 = &v113;
      v42 = (char *)v126;
      if (v127 >= v128)
      {
        v90 = v127 + 1;
        if (v126 <= &v113 && (char *)v126 + 24 * v127 > (char *)&v113)
        {
          v105 = (char *)&v113 - (_BYTE *)v126;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v90, 24);
          v42 = (char *)v126;
          v41 = (const void ***)((char *)v126 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v90, 24);
          v41 = &v113;
          v42 = (char *)v126;
        }
      }
      v43 = &v42[24 * v127];
      v44 = *(_OWORD *)v41;
      *((_QWORD *)v43 + 2) = v41[2];
      *(_OWORD *)v43 = v44;
      v45 = ++v127;
      if (v124)
      {
        LODWORD(v113) = 3;
        v114 = ".";
        v115 = 1;
        v46 = &v113;
        v47 = (char *)v126;
        if (v45 >= v128)
        {
          v98 = v45 + 1;
          v99 = (char *)v126 + 24 * v45 > (char *)&v113;
          if (v126 <= &v113 && v99)
          {
            v110 = (char *)&v113 - (_BYTE *)v126;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v98, 24);
            v47 = (char *)v126;
            v46 = (const void ***)((char *)v126 + v110);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v126, v129, v98, 24);
            v46 = &v113;
            v47 = (char *)v126;
          }
        }
        v48 = &v47[24 * v127];
        v49 = *(_OWORD *)v46;
        *((_QWORD *)v48 + 2) = v46[2];
        *(_OWORD *)v48 = v49;
        ++v127;
      }
    }
    v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v124);
    if (v124)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v124);
    if (v134)
    {
      v50 = __p;
      if (__p)
      {
        v51 = v133;
        v52 = __p;
        if (v133 != __p)
        {
          do
            v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
          while (v51 != v50);
          v52 = __p;
        }
        v133 = v50;
        operator delete(v52);
      }
      v53 = v130;
      if (!v130)
        goto LABEL_77;
      v54 = v131;
      v55 = v130;
      if (v131 == v130)
        goto LABEL_76;
      do
      {
        v57 = *--v54;
        v56 = v57;
        *v54 = 0;
        if (v57)
          MEMORY[0x20BD002D4](v56, 0x1000C8077774924);
      }
      while (v54 != v53);
      goto LABEL_75;
    }
  }
  else if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v117)
         && mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v118))
  {
    if ((_DWORD)v3 == 1)
    {
      mlir::ShapedType::getShape((mlir::ShapedType *)&v118);
      v29 = (v28 - 1);
    }
    else
    {
      v29 = 1;
    }
    v78 = *(const void ***)(mlir::ShapedType::getShape((mlir::ShapedType *)&v118) + 8 * v29);
    v113 = v78;
    v79 = *(_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)v117);
    v112 = v79;
    v30 = 1;
    if (v78 != (const void **)0x8000000000000000 && v79 != 0x8000000000000000 && v78 != (const void **)v79)
    {
      v123 = 257;
      mlir::OpState::emitOpError(this, &v120, (uint64_t)&v124);
      v80 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v124, "requires feature dimension and bias dimension to match. ");
      v81 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v80, "Found ");
      v82 = mlir::InFlightDiagnostic::operator<<<long long &>(v81, (uint64_t *)&v113);
      v83 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v82, " and ");
      v84 = mlir::InFlightDiagnostic::operator<<<long long &>(v83, &v112);
      v85 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v84, ", respectively.");
      v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v85);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v124);
    }
  }
  else
  {
    return 1;
  }
  return v30;
}

uint64_t mlir::mps::BiasAddGradOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v16;
  uint64_t Context;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t Shape;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t ElementTypeOrSelf;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v36;
  int64x2_t v37;
  int64x2_t *v38;
  int64x2_t v39;
  int64x2_t v40;
  unint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  char v44;
  void *v45;
  uint64_t v46;
  uint64_t OperandRange;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  _BYTE v55[32];
  void *v56;
  uint64_t v57;
  _BYTE v58[48];
  uint64_t v59;
  _BYTE v60[8];
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD v67[4];

  v67[2] = *MEMORY[0x24BDAC8D0];
  v67[0] = a4;
  v67[1] = a5;
  if (a7)
    v16 = *a7;
  else
    v16 = 0;
  v59 = a6;
  v60[0] = 0;
  v61 = 0;
  v62 = v16;
  v63 = a9;
  v64 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v59);
    if (v61)
      v61 = 0;
    mlir::OperationName::OperationName(v60, "mps.bias_add_grad", 17, Context);
    v61 = 1;
  }
  v65 = a4;
  v66 = a5;
  if (!a5
    || (v18 = mlir::UnknownLoc::get(this, a2),
        !mlir::mps::BiasAddGradOpAdaptor::verify((uint64_t)&v59, v18)))
  {
    ElementTypeOrSelf = mlir::Float32Type::get(this, a2);
    goto LABEL_20;
  }
  v19 = mlir::ValueRange::dereference_iterator(v67, 0);
  v20 = *(_DWORD *)(v62 + 8);
  v21 = (_QWORD *)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8))
  {
    v51 = 0;
    v52 = 0;
    goto LABEL_25;
  }
  v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  v51 = v21;
  v52 = v22;
  if (!v21)
  {
LABEL_25:
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(0);
    goto LABEL_20;
  }
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v51) & 1) != 0)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v51);
    v24 = v23;
    if (v20 == 1)
      v25 = v23 - 1;
    else
      v25 = 1;
    v56 = v58;
    v57 = 0x600000000;
    Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v51);
    v28 = v27;
    v53 = v55;
    v54 = 0x400000000;
    if (v24)
    {
      if (v24 < 5)
      {
        v29 = 0;
        v30 = (uint64_t *)v55;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v24, 8);
        v29 = v54;
        v30 = (uint64_t *)v53;
      }
      if (v24 != v29)
        bzero(&v30[v29], 8 * (v24 - v29));
      LODWORD(v54) = v24;
      if (v24 >= 4)
      {
        v36 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        v37 = (int64x2_t)xmmword_207A80930;
        v38 = (int64x2_t *)(v30 + 2);
        v39 = vdupq_n_s64(2uLL);
        v40 = vdupq_n_s64(4uLL);
        v41 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v38[-1] = v37;
          *v38 = vaddq_s64(v37, v39);
          v37 = vaddq_s64(v37, v40);
          v38 += 2;
          v41 -= 4;
        }
        while (v41);
        goto LABEL_37;
      }
      v36 = 0;
      do
      {
        v30[v36] = v36;
        ++v36;
LABEL_37:
        ;
      }
      while (v24 != v36);
    }
    else
    {
      v30 = (uint64_t *)v55;
    }
    v42 = &v30[v25];
    v43 = &v30[v24];
    if (v43 != v42 + 1)
    {
      memmove(v42, v42 + 1, (char *)v43 - (char *)(v42 + 1));
      LODWORD(v24) = v54;
      v30 = (uint64_t *)v53;
    }
    LODWORD(v54) = v24 - 1;
    if (v53 != v55)
      free(v53);
    if (v44)
    {
      v45 = v56;
      v46 = v57;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v51);
      v48 = mlir::RankedTensorType::get((uint64_t)v45, v46, OperandRange, 0);
      v49 = *(unsigned int *)(a11 + 8);
      if (v49 >= *(_DWORD *)(a11 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v49 + 1, 8);
        LODWORD(v49) = *(_DWORD *)(a11 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a11 + 8 * v49) = v48;
      ++*(_DWORD *)(a11 + 8);
      v34 = 1;
      v50 = v56;
      if (v56 == v58)
        return v34;
    }
    else
    {
      v34 = 0;
      v50 = v56;
      if (v56 == v58)
        return v34;
    }
    free(v50);
    return v34;
  }
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v51);
LABEL_20:
  v32 = mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  v33 = *(unsigned int *)(a11 + 8);
  if (v33 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v33 + 1, 8);
    LODWORD(v33) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v33) = v32;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::BiasAddGradOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  _QWORD v15[3];
  void *v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  void *__p;
  _QWORD *v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2 || *(_DWORD *)(v2 + 8) < 2u)
    return 1;
  v13 = "'mps.bias_add_grad' op attribute 'data_format' failed to satisfy constraint: valid TensorDataLayout is NHWC or NCHW";
  v14 = 259;
  mlir::emitError(a2, (uint64_t)&v13, (uint64_t)v15);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
  if (v15[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
  if (v22)
  {
    v5 = __p;
    if (__p)
    {
      v6 = v21;
      v7 = __p;
      if (v21 != __p)
      {
        do
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        v7 = __p;
      }
      v21 = v5;
      operator delete(v7);
    }
    v8 = v18;
    if (v18)
    {
      v9 = v19;
      v10 = v18;
      if (v19 != v18)
      {
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
        }
        while (v9 != v8);
        v10 = v18;
      }
      v19 = v8;
      operator delete(v10);
    }
    if (v16 != &v17)
      free(v16);
  }
  return v3;
}

uint64_t mlir::mps::`anonymous namespace'::inferReductionOpReturnShape(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, int a7, uint64_t a8)
{
  uint64_t **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD **v20;
  _QWORD *v21;
  _QWORD **v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v30;
  _BYTE v31[24];
  uint64_t *v32;
  void *v33;
  uint64_t v34;
  _BYTE v35[32];
  _QWORD **v36;
  _QWORD *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  _QWORD v41[8];

  v41[6] = *MEMORY[0x24BDAC8D0];
  v39 = v41;
  v40 = 0x600000000;
  {
    v27 = 0;
    v28 = v39;
    if (v39 == v41)
      return v27;
    goto LABEL_33;
  }
  v33 = v35;
  v34 = 0x400000000;
  v37 = 0;
  v38 = 0;
  v36 = &v37;
  if ((_DWORD)v40)
  {
    v12 = (uint64_t **)v39;
    v13 = 8 * v40;
    do
    {
      v14 = *v12++;
      v32 = v14;
      llvm::SmallSet<long long,4u,std::less<long long>>::insert((uint64_t)&v33, &v32, (uint64_t)v31);
      v13 -= 8;
    }
    while (v13);
  }
  if (a4)
  {
    v15 = 0;
    v16 = (void *)(a8 + 16);
    do
    {
      if (v38)
      {
        v19 = v37;
        if (!v37)
          goto LABEL_7;
        v20 = &v37;
        do
        {
          v21 = v19;
          v22 = v20;
          v23 = v19[4];
          v24 = v19 + 1;
          if (v23 >= v15)
          {
            v24 = v21;
            v20 = (_QWORD **)v21;
          }
          v19 = (_QWORD *)*v24;
        }
        while (v19);
        if (v20 == &v37)
          goto LABEL_7;
        if (v23 < v15)
          v21 = v22;
        if (v15 < v21[4])
          goto LABEL_7;
      }
      else
      {
        if (!(_DWORD)v34)
          goto LABEL_7;
        v25 = v33;
        v26 = 8 * v34;
        while (*v25 != v15)
        {
          ++v25;
          v26 -= 8;
          if (!v26)
            goto LABEL_7;
        }
        if (!v26)
        {
LABEL_7:
          v17 = *(_QWORD *)(a3 + 8 * v15);
          v18 = *(unsigned int *)(a8 + 8);
          if (v18 >= *(unsigned int *)(a8 + 12))
            goto LABEL_29;
          goto LABEL_8;
        }
      }
      if (!a7)
        goto LABEL_9;
      v18 = *(unsigned int *)(a8 + 8);
      v17 = 1;
      if (v18 >= *(unsigned int *)(a8 + 12))
      {
LABEL_29:
        v30 = v16;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a8, v16, v18 + 1, 8);
        v16 = v30;
        v18 = *(unsigned int *)(a8 + 8);
      }
LABEL_8:
      *(_QWORD *)(*(_QWORD *)a8 + 8 * v18) = v17;
      ++*(_DWORD *)(a8 + 8);
LABEL_9:
      ++v15;
    }
    while (v15 != a4);
  }
  std::__tree<std::__value_type<double,double>,std::__map_value_compare<double,std::__value_type<double,double>,std::less<double>,true>,std::allocator<std::__value_type<double,double>>>::destroy((uint64_t)&v36, v37);
  if (v33 != v35)
    free(v33);
  v27 = 1;
  v28 = v39;
  if (v39 != v41)
LABEL_33:
    free(v28);
  return v27;
}

uint64_t mlir::mps::BiasAddGradOp::verify(uint64_t **this)
{
  uint64_t *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  const char *v17;
  char *v18;
  uint64_t v19;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  const void ***v31;
  char *v32;
  char *v33;
  __int128 v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  BOOL v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  int64_t v55;
  const void **v56;
  __int16 v57;
  _QWORD *v58;
  uint64_t v59;
  const void **v60;
  const char *v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  unsigned int v67;
  unsigned int v68;
  _BYTE v69[96];
  void *v70;
  _QWORD *v71;
  void *__p;
  _QWORD *v73;
  char v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v1 = *this;
  v2 = *(int *)((*this)[10] + 8);
  v3 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
  {
    v58 = 0;
    v59 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v58))
      goto LABEL_5;
    return 1;
  }
  v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
  v58 = v3;
  v59 = v4;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v58))
    return 1;
LABEL_5:
  if ((_DWORD)v2 == 1)
    v5 = 2;
  else
    v5 = 3;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
  if (v6 >= v5)
    return 1;
  v7 = (const char *)v6;
  v56 = (const void **)"requires out_backprop operand to have rank at least ";
  v57 = 259;
  mlir::Operation::emitOpError(v1, &v56, (uint64_t)&v64);
  if (v64)
  {
    LODWORD(v60) = 2;
    v61 = (const char *)v5;
    v8 = &v60;
    v9 = (char *)v66;
    if (v67 >= v68)
    {
      v43 = v67 + 1;
      if (v66 <= &v60 && (char *)v66 + 24 * v67 > (char *)&v60)
      {
        v51 = (char *)&v60 - (_BYTE *)v66;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v43, 24);
        v9 = (char *)v66;
        v8 = (const void ***)((char *)v66 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v43, 24);
        v8 = &v60;
        v9 = (char *)v66;
      }
    }
    v10 = &v9[24 * v67];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    v12 = ++v67;
    if (v64)
    {
      LODWORD(v60) = 3;
      v62 = 7;
      v13 = &v60;
      v14 = (char *)v66;
      if (v12 >= v68)
      {
        v44 = v12 + 1;
        v45 = (char *)v66 + 24 * v12 > (char *)&v60;
        if (v66 <= &v60 && v45)
        {
          v52 = (char *)&v60 - (_BYTE *)v66;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v44, 24);
          v14 = (char *)v66;
          v13 = (const void ***)((char *)v66 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v44, 24);
          v13 = &v60;
          v14 = (char *)v66;
        }
      }
      v15 = &v14[24 * v67];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v67;
    }
  }
  if (v2 <= 0xA)
  {
    v17 = (const char *)qword_207ADC340[v2];
    v18 = off_24C061168[v2];
    if (!v64)
      goto LABEL_27;
LABEL_20:
    v63 = 261;
    v60 = (const void **)v18;
    v61 = v17;
    mlir::Diagnostic::operator<<((uint64_t)&v65, &v60);
    if (v64)
    {
      LODWORD(v60) = 3;
      v62 = 21;
      v21 = &v60;
      v22 = (char *)v66;
      if (v67 >= v68)
      {
        v46 = v67 + 1;
        if (v66 <= &v60 && (char *)v66 + 24 * v67 > (char *)&v60)
        {
          v53 = (char *)&v60 - (_BYTE *)v66;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v46, 24);
          v22 = (char *)v66;
          v21 = (const void ***)((char *)v66 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v46, 24);
          v21 = &v60;
          v22 = (char *)v66;
        }
      }
      v23 = &v22[24 * v67];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v67;
      if (v64)
      {
        LODWORD(v60) = 2;
        v61 = v7;
        v26 = &v60;
        v27 = (char *)v66;
        if (v25 >= v68)
        {
          v47 = v25 + 1;
          v48 = (char *)v66 + 24 * v25 > (char *)&v60;
          if (v66 <= &v60 && v48)
          {
            v54 = (char *)&v60 - (_BYTE *)v66;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v47, 24);
            v27 = (char *)v66;
            v26 = (const void ***)((char *)v66 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v47, 24);
            v26 = &v60;
            v27 = (char *)v66;
          }
        }
        v28 = &v27[24 * v67];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        v30 = ++v67;
        if (v64)
        {
          LODWORD(v60) = 3;
          v61 = ".";
          v62 = 1;
          v31 = &v60;
          v32 = (char *)v66;
          if (v30 >= v68)
          {
            v49 = v30 + 1;
            v50 = (char *)v66 + 24 * v30 > (char *)&v60;
            if (v66 <= &v60 && v50)
            {
              v55 = (char *)&v60 - (_BYTE *)v66;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v49, 24);
              v32 = (char *)v66;
              v31 = (const void ***)((char *)v66 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v49, 24);
              v31 = &v60;
              v32 = (char *)v66;
            }
          }
          v33 = &v32[24 * v67];
          v34 = *(_OWORD *)v31;
          *((_QWORD *)v33 + 2) = v31[2];
          *(_OWORD *)v33 = v34;
          ++v67;
        }
      }
    }
    goto LABEL_27;
  }
  v17 = 0;
  v18 = &byte_207AF6795;
  if (v64)
    goto LABEL_20;
LABEL_27:
  v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v64);
  if (v64)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v64);
  if (v74)
  {
    v35 = __p;
    if (__p)
    {
      v36 = v73;
      v37 = __p;
      if (v73 != __p)
      {
        do
          v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
        while (v36 != v35);
        v37 = __p;
      }
      v73 = v35;
      operator delete(v37);
    }
    v38 = v70;
    if (v70)
    {
      v39 = v71;
      v40 = v70;
      if (v71 != v70)
      {
        do
        {
          v42 = *--v39;
          v41 = v42;
          *v39 = 0;
          if (v42)
            MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
        }
        while (v39 != v38);
        v40 = v70;
      }
      v71 = v38;
      operator delete(v40);
    }
    if (v66 != v69)
      free(v66);
  }
  return v19;
}

uint64_t mlir::mps::inferStencilShape(int a1, int a2, void *__src, unint64_t a4, _QWORD *a5, int a6, unint64_t **a7, _QWORD **a8, _QWORD **a9, char a10, uint64_t a11)
{
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;

  v16 = *(unsigned int *)(a11 + 8);
  if (a4 != v16)
  {
    if (a4 >= v16)
    {
      if (a4 > *(unsigned int *)(a11 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), a4, 8);
        v16 = *(unsigned int *)(a11 + 8);
      }
      if (a4 != v16)
        bzero((void *)(*(_QWORD *)a11 + 8 * v16), 8 * (a4 - v16));
    }
    *(_DWORD *)(a11 + 8) = a4;
  }
  v17 = a4 - 4;
  if (a4)
    memmove(*(void **)a11, __src, 8 * a4);
  v18 = *a8;
  v19 = *a7;
  v20 = *(_QWORD **)a11;
  v21 = *((_QWORD *)__src + v17);
  if ((a10 & 1) == 0)
  {
    v28 = *a9;
    if (v21 == 0x8000000000000000)
    {
      v29 = a4 - 3;
      v30 = *((_QWORD *)__src + a4 - 3);
      if (v30 == 0x8000000000000000)
        goto LABEL_18;
    }
    else
    {
      v20[v17] = (*v28 + v28[1] + v21 + ~(*v18 * (*a5 - 1)) + *v19) / *v19;
      v29 = a4 - 3;
      v30 = *((_QWORD *)__src + a4 - 3);
      if (v30 == 0x8000000000000000)
      {
LABEL_18:
        v31 = a4 - 2;
        v32 = *((_QWORD *)__src + a4 - 2);
        if (v32 == 0x8000000000000000)
          goto LABEL_19;
        goto LABEL_35;
      }
    }
    v20[v29] = (v28[2] + v28[3] + v30 + ~(v18[1] * (a5[1] - 1)) + v19[1]) / v19[1];
    v31 = a4 - 2;
    v32 = *((_QWORD *)__src + a4 - 2);
    if (v32 == 0x8000000000000000)
    {
LABEL_19:
      v26 = a4 - 1;
      v33 = *((_QWORD *)__src + a4 - 1);
      if (v33 == 0x8000000000000000)
        return 1;
      goto LABEL_36;
    }
LABEL_35:
    v20[v31] = (v28[4] + v28[5] + v32 + ~(v18[2] * (a5[2] - 1)) + v19[2]) / v19[2];
    v26 = a4 - 1;
    v33 = *((_QWORD *)__src + a4 - 1);
    if (v33 == 0x8000000000000000)
      return 1;
LABEL_36:
    v42 = v19[3];
    v44 = v28[6] + v28[7] + v33 + ~(v18[3] * (a5[3] - 1)) + v42;
LABEL_37:
    v20[v26] = v44 / v42;
    return 1;
  }
  if (v21 == 0x8000000000000000)
  {
    v22 = a4 - 3;
    v23 = *((_QWORD *)__src + a4 - 3);
    if (v23 == 0x8000000000000000)
      goto LABEL_13;
LABEL_24:
    v36 = v19[1];
    v37 = v23 % v36;
    if (!(v23 % v36))
      v37 = v19[1];
    v35 = v18[1] * (a5[1] - 1);
    v20[v22] = (((v35 - v37 + 1) & ~((uint64_t)(v35 - v37 + 1) >> 63)) + ~v35 + v23 + v36) / v36;
    v24 = a4 - 2;
    v25 = *((_QWORD *)__src + a4 - 2);
    if (v25 == 0x8000000000000000)
    {
LABEL_14:
      v26 = a4 - 1;
      v27 = *((_QWORD *)__src + a4 - 1);
      if (v27 == 0x8000000000000000)
        return 1;
      goto LABEL_30;
    }
    goto LABEL_27;
  }
  v34 = v21 % *v19;
  if (!v34)
    v34 = *v19;
  v20[v17] = (((*v18 * (*a5 - 1) - v34 + 1) & ~((uint64_t)(*v18 * (*a5 - 1) - v34 + 1) >> 63))
            + ~(*v18 * (*a5 - 1))
            + v21
            + *v19)
           / *v19;
  v22 = a4 - 3;
  v23 = *((_QWORD *)__src + a4 - 3);
  if (v23 != 0x8000000000000000)
    goto LABEL_24;
LABEL_13:
  v24 = a4 - 2;
  v25 = *((_QWORD *)__src + a4 - 2);
  if (v25 == 0x8000000000000000)
    goto LABEL_14;
LABEL_27:
  v39 = v19[2];
  v40 = v25 % v39;
  if (!(v25 % v39))
    v40 = v19[2];
  v38 = v18[2] * (a5[2] - 1);
  v20[v24] = (((v38 - v40 + 1) & ~((uint64_t)(v38 - v40 + 1) >> 63)) + ~v38 + v25 + v39) / v39;
  v26 = a4 - 1;
  v27 = *((_QWORD *)__src + a4 - 1);
  if (v27 != 0x8000000000000000)
  {
LABEL_30:
    v41 = v18[3] * (a5[3] - 1);
    v42 = v19[3];
    v43 = v27 % v42;
    if (!(v27 % v42))
      v43 = v42;
    v44 = ((v41 - v43 + 1) & ~((uint64_t)(v41 - v43 + 1) >> 63)) + ~v41 + v27 + v42;
    goto LABEL_37;
  }
  return 1;
}

uint64_t mlir::mps::StencilOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  uint64_t Context;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t ElementTypeOrSelf;
  uint64_t v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  char v47;
  void *Shape;
  unint64_t v49;
  unint64_t v50;
  _QWORD *v51;
  int v52;
  void *v53;
  uint64_t v54;
  uint64_t OperandRange;
  uint64_t v56;
  _QWORD *v57[2];
  uint64_t *v58;
  uint64_t v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  _QWORD v72[4];
  void *v73;
  uint64_t v74;
  _QWORD v75[8];
  void *v76;
  uint64_t v77;
  _QWORD v78[4];
  void *v79;
  uint64_t v80;
  _BYTE v81[32];
  uint64_t v82;
  char v83[8];
  char v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  v93 = a4;
  v94 = a5;
  if (a7)
  {
    v16 = *a7;
    v17 = a7[1];
    v18 = a7[2];
    v19 = a7[3];
  }
  else
  {
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = 0uLL;
    v19 = 0uLL;
  }
  v82 = a6;
  v83[0] = 0;
  v84 = 0;
  v85 = v16;
  v86 = v17;
  v87 = v18;
  v88 = v19;
  v20 = a5;
  v89 = a9;
  v90 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v82);
    if (v84)
      v84 = 0;
    mlir::OperationName::OperationName(v83, "mps.stencil", 11, Context);
    v84 = 1;
    v20 = v94;
  }
  v91 = a4;
  v92 = a5;
  if (v20 < 2
    || (v22 = mlir::UnknownLoc::get(this, a2), !mlir::mps::StencilOpAdaptor::verify(&v82, v22)))
  {
    v34 = mlir::Float32Type::get(this, a2);
    v28 = (_QWORD *)mlir::UnrankedTensorType::get(v34);
    goto LABEL_21;
  }
  v23 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v93, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v24 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v93, 1) + 8);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8))
  {
    v68 = 0;
    v69 = 0;
    return mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "cannot stencil a non-shaped inputType");
  }
  v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8);
  v68 = v23;
  v69 = v25;
  if (!v23)
    return mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "cannot stencil a non-shaped inputType");
  v26 = v24 & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)(v24 & 0xFFFFFFFFFFFFFFF8) + 8))
  {
    v66 = 0;
    v67 = 0;
    return mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "cannot stencil with a non-shaped weightsType");
  }
  v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v26 + 8);
  v66 = v24 & 0xFFFFFFFFFFFFFFF8;
  v67 = v27;
  if (!v26)
    return mlir::emitOptionalError<char const(&)[39]>((uint64_t)a2, a3, "cannot stencil with a non-shaped weightsType");
  v28 = v68;
  if (*(_UNKNOWN **)(*v68 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && *(_UNKNOWN **)(*(_QWORD *)v26 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v68);
    v30 = v29;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v66);
    if (v30 >= 4 && v31 == 4)
    {
      v32 = *((_QWORD *)&v85 + 1);
      v64 = v85;
      v65 = *((_QWORD *)&v88 + 1);
      v63 = *((_QWORD *)&v85 + 1);
      if (*((_QWORD *)&v87 + 1))
        v33 = *(_DWORD *)(*((_QWORD *)&v87 + 1) + 8);
      else
        v33 = 2;
      v79 = v81;
      v80 = 0x400000000;
      if (*((_QWORD *)&v88 + 1) && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v65) == 4)
      {
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v73, v65, 0);
        mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&v65, &v76);
        while (1)
        {
          v40 = v73 == v76 && v74 == v77;
          if (v40 && v75[0] == v78[0])
            break;
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v73, (llvm::APInt *)&v70);
          if (v71 > 0x40)
            v41 = *(_QWORD *)v70;
          else
            v41 = (uint64_t)((_QWORD)v70 << -(uint64_t)v71) >> -(uint64_t)v71;
          v42 = v80;
          if (v80 >= (unint64_t)HIDWORD(v80))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v80 + 1, 8);
            v42 = v80;
          }
          *((_QWORD *)v79 + v42) = v41;
          LODWORD(v80) = v80 + 1;
          if (v71 >= 0x41)
          {
            if (v70)
              MEMORY[0x20BD002D4](v70, 0x1000C8000313F17);
          }
          ++v75[0];
        }
      }
      else
      {
        llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v79, 4uLL, 1uLL);
      }
      v76 = v78;
      v77 = 0x400000000;
      if (v64 && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v64) == 4)
      {
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v73, v64, 0);
        mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&v64, &v70);
        while (1)
        {
          v43 = v73 == v70 && v74 == v71;
          if (v43 && v75[0] == v72[0])
            break;
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v73, (llvm::APInt *)&v60);
          if (v61 > 0x40)
            v44 = *v60;
          else
            v44 = (uint64_t)((_QWORD)v60 << -(uint64_t)v61) >> -(uint64_t)v61;
          v45 = v77;
          if (v77 >= (unint64_t)HIDWORD(v77))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v78, v77 + 1, 8);
            v45 = v77;
          }
          *((_QWORD *)v76 + v45) = v44;
          LODWORD(v77) = v77 + 1;
          if (v61 >= 0x41 && v60)
            MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
          ++v75[0];
        }
      }
      else
      {
        llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v76, 4uLL, 1uLL);
      }
      v73 = v75;
      v74 = 0x800000000;
      switch(v33)
      {
        case 0:
        case 3:
          if (!v32 || mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v63) != 8)
            goto LABEL_87;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v70, v63, 0);
          mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&v63, &v60);
          break;
        case 1:
LABEL_87:
          llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v73, 8uLL, 0);
          goto LABEL_88;
        case 2:
        case 4:
          v47 = 1;
          goto LABEL_90;
        default:
LABEL_88:
          v47 = 0;
LABEL_90:
          v70 = v72;
          v71 = 0x400000000;
          Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v68);
          v50 = v49;
          v51 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v66);
          v60 = (unint64_t *)v79;
          v61 = v80;
          v58 = (uint64_t *)v76;
          v59 = v77;
          v57[0] = v73;
          v57[1] = (_QWORD *)v74;
          if (mlir::mps::inferStencilShape((int)v51, v52, Shape, v50, v51, v52, &v60, &v58, v57, v47, (uint64_t)&v70))
          {
            v53 = v70;
            v54 = v71;
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
            v56 = mlir::RankedTensorType::get((uint64_t)v53, v54, OperandRange, 0);
            llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v56);
            v36 = 1;
          }
          else
          {
            v36 = 0;
          }
          if (v70 != v72)
            free(v70);
          if (v73 != v75)
            free(v73);
          if (v76 != v78)
            free(v76);
          if (v79 != v81)
            free(v79);
          return v36;
      }
      while (1)
      {
        v46 = v70 == v60 && v71 == v61;
        if (v46 && v72[0] == v62)
          goto LABEL_88;
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v70, (llvm::APInt *)&v58);
        if (v59 > 0x40)
        {
          llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back((uint64_t)&v73, *v58);
          if (v59 < 0x41)
            goto LABEL_74;
        }
        else
        {
          llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back((uint64_t)&v73, (uint64_t)((_QWORD)v58 << -(uint64_t)v59) >> -(uint64_t)v59);
          if (v59 < 0x41)
            goto LABEL_74;
        }
        if (v58)
          MEMORY[0x20BD002D4](v58, 0x1000C8000313F17);
LABEL_74:
        ++v72[0];
      }
    }
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(v68);
    v39 = mlir::UnrankedTensorType::get(ElementTypeOrSelf);
    llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v39);
    return 1;
  }
LABEL_21:
  v35 = *(unsigned int *)(a11 + 8);
  if (v35 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v35 + 1, 8);
    LODWORD(v35) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v35) = v28;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::StencilOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  _QWORD *Type;
  _QWORD *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  void *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  const char *v66;
  uint64_t v67;
  __int16 v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t OperandRange;
  uint64_t Value;
  _QWORD *v74;
  void *v75;
  uint64_t v76;
  void *v77;
  _QWORD *v78;
  void *__p;
  _QWORD *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  v4 = (const char *)a1[3];
  v3 = (const char *)a1[4];
  v6 = (const char *)a1[5];
  v5 = (const char *)a1[6];
  v7 = (const char *)a1[10];
  if (!v6)
    goto LABEL_105;
  v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
  v66 = v6;
  v67 = v8;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
  v10 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  Value = (uint64_t)v10;
  v74 = Type;
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
  v82 = 4;
  if (v12 != 1)
    goto LABEL_28;
  if (*Shape == v82
    && (v69 = v6,
        v70 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69),
        v71 = v13,
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v70),
        mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)))
  {
LABEL_105:
    if (!v7)
      goto LABEL_106;
    v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v7 + 8);
    v66 = v7;
    v67 = v14;
    v15 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
    v16 = v15;
    if (v15)
      v15 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
    Value = (uint64_t)v16;
    v74 = v15;
    v17 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
    v82 = 4;
    if (v18 != 1)
      goto LABEL_42;
    if (*v17 == v82
      && (v69 = v7,
          v70 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69),
          v71 = v19,
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v70),
          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_106:
      if (!v4)
        goto LABEL_107;
      v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
      v66 = v4;
      v67 = v20;
      v21 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
      v22 = v21;
      if (v21)
        v21 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
      Value = (uint64_t)v22;
      v74 = v21;
      v23 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
      v82 = 4;
      if (v24 != 1)
        goto LABEL_56;
      if (*v23 == v82
        && (v69 = v4,
            v70 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69),
            v71 = v25,
            OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v70),
            mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
      {
LABEL_107:
        if (!v3)
          goto LABEL_108;
        v26 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v3 + 8);
        v66 = v3;
        v67 = v26;
        v27 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
        v28 = v27;
        if (v27)
          v27 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
        Value = (uint64_t)v28;
        v74 = v27;
        v29 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&Value);
        v82 = 8;
        if (v30 != 1)
          goto LABEL_70;
        if (*v29 == v82
          && (v69 = v3,
              v70 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69),
              v71 = v31,
              OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v70),
              mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
        {
LABEL_108:
          if (!v5)
            return 1;
          v66 = v5;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v66);
          if (mlir::Type::isF32((mlir::Type *)&Value))
            return 1;
          v66 = "'mps.stencil' op attribute 'paddingConstant' failed to satisfy constraint: 32-bit float attribute";
          v68 = 259;
          mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&Value);
          v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v81)
          {
            v59 = __p;
            if (__p)
            {
              v60 = v80;
              v61 = __p;
              if (v80 != __p)
              {
                do
                  v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
                while (v60 != v59);
                v61 = __p;
              }
              v80 = v59;
              operator delete(v61);
            }
            v36 = v77;
            if (!v77)
              goto LABEL_100;
            v62 = v78;
            v38 = v77;
            if (v78 == v77)
            {
LABEL_99:
              v78 = v36;
              operator delete(v38);
LABEL_100:
              if (v75 != &v76)
                free(v75);
              return v32;
            }
            do
            {
              v64 = *--v62;
              v63 = v64;
              *v62 = 0;
              if (v64)
                MEMORY[0x20BD002D4](v63, 0x1000C8077774924);
            }
            while (v62 != v36);
LABEL_98:
            v38 = v77;
            goto LABEL_99;
          }
        }
        else
        {
LABEL_70:
          v66 = "'mps.stencil' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements attribute of shape {8}";
          v68 = 259;
          mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&Value);
          v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
          if (Value)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
          if (v81)
          {
            v53 = __p;
            if (__p)
            {
              v54 = v80;
              v55 = __p;
              if (v80 != __p)
              {
                do
                  v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v54 - 1);
                while (v54 != v53);
                v55 = __p;
              }
              v80 = v53;
              operator delete(v55);
            }
            v36 = v77;
            if (!v77)
              goto LABEL_100;
            v56 = v78;
            v38 = v77;
            if (v78 == v77)
              goto LABEL_99;
            do
            {
              v58 = *--v56;
              v57 = v58;
              *v56 = 0;
              if (v58)
                MEMORY[0x20BD002D4](v57, 0x1000C8077774924);
            }
            while (v56 != v36);
            goto LABEL_98;
          }
        }
      }
      else
      {
LABEL_56:
        v66 = "'mps.stencil' op attribute 'dilation_rates' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        v68 = 259;
        mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&Value);
        v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
        if (Value)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
        if (v81)
        {
          v47 = __p;
          if (__p)
          {
            v48 = v80;
            v49 = __p;
            if (v80 != __p)
            {
              do
                v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v48 - 1);
              while (v48 != v47);
              v49 = __p;
            }
            v80 = v47;
            operator delete(v49);
          }
          v36 = v77;
          if (!v77)
            goto LABEL_100;
          v50 = v78;
          v38 = v77;
          if (v78 == v77)
            goto LABEL_99;
          do
          {
            v52 = *--v50;
            v51 = v52;
            *v50 = 0;
            if (v52)
              MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
          }
          while (v50 != v36);
          goto LABEL_98;
        }
      }
    }
    else
    {
LABEL_42:
      v66 = "'mps.stencil' op attribute 'strides' failed to satisfy constraint: ui64 elements attribute of shape {4}";
      v68 = 259;
      mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&Value);
      v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      if (v81)
      {
        v41 = __p;
        if (__p)
        {
          v42 = v80;
          v43 = __p;
          if (v80 != __p)
          {
            do
              v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
            while (v42 != v41);
            v43 = __p;
          }
          v80 = v41;
          operator delete(v43);
        }
        v36 = v77;
        if (!v77)
          goto LABEL_100;
        v44 = v78;
        v38 = v77;
        if (v78 == v77)
          goto LABEL_99;
        do
        {
          v46 = *--v44;
          v45 = v46;
          *v44 = 0;
          if (v46)
            MEMORY[0x20BD002D4](v45, 0x1000C8077774924);
        }
        while (v44 != v36);
        goto LABEL_98;
      }
    }
  }
  else
  {
LABEL_28:
    v66 = "'mps.stencil' op attribute 'offsets' failed to satisfy constraint: si64 elements attribute of shape {4}";
    v68 = 259;
    mlir::emitError(a2, (uint64_t)&v66, (uint64_t)&Value);
    v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v81)
    {
      v33 = __p;
      if (__p)
      {
        v34 = v80;
        v35 = __p;
        if (v80 != __p)
        {
          do
            v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          v35 = __p;
        }
        v80 = v33;
        operator delete(v35);
      }
      v36 = v77;
      if (!v77)
        goto LABEL_100;
      v37 = v78;
      v38 = v77;
      if (v78 == v77)
        goto LABEL_99;
      do
      {
        v40 = *--v37;
        v39 = v40;
        *v37 = 0;
        if (v40)
          MEMORY[0x20BD002D4](v39, 0x1000C8077774924);
      }
      while (v37 != v36);
      goto LABEL_98;
    }
  }
  return v32;
}

_QWORD *mlir::DenseIntElementsAttr::end@<X0>(mlir::DenseIntElementsAttr *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t NumElements;

  v3 = *(_QWORD *)this;
  NumElements = mlir::DenseElementsAttr::getNumElements(this);
  return mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(a2, v3, NumElements);
}

uint64_t mlir::mps::StencilOp::verify(uint64_t **this)
{
  uint64_t *v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v2 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v2 = 0;
  v3 = *(_DWORD *)(v2[5] + 8);
  if (v3)
  {
    if (v3 != 3)
      goto LABEL_8;
    if (!v2[2])
    {
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (!v57)
        return v13;
      v34 = __p;
      if (__p)
      {
        v35 = v56;
        v36 = __p;
        if (v56 != __p)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = __p;
        }
        v56 = v34;
        operator delete(v36);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_76;
      v37 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_75;
      do
      {
        v39 = *--v37;
        v38 = v39;
        *v37 = 0;
        if (v39)
          MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
      }
      while (v37 != v17);
LABEL_74:
      v19 = v53;
LABEL_75:
      v54 = v17;
      operator delete(v19);
      goto LABEL_76;
    }
  }
  if (!v2[1])
  {
                            " MPS_EXPLICIT or MPS_EXPLICIT_OFFSET.";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (!v57)
      return v13;
    v22 = __p;
    if (__p)
    {
      v23 = v56;
      v24 = __p;
      if (v56 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v56 = v22;
      operator delete(v24);
    }
    v17 = v53;
    if (v53)
    {
      v25 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_75;
      do
      {
        v27 = *--v25;
        v26 = v27;
        *v25 = 0;
        if (v27)
          MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
      }
      while (v25 != v17);
      goto LABEL_74;
    }
    goto LABEL_76;
  }
LABEL_8:
  v4 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v4 + 8))
  {
    v46 = 0;
    v47 = 0;
    goto LABEL_17;
  }
  v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v4 + 8);
  v46 = v4;
  v47 = v5;
  if (!v4)
  {
LABEL_17:
    v48[0] = (const void **)"invalid type for input.";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (!v57)
      return v13;
    v14 = __p;
    if (__p)
    {
      v15 = v56;
      v16 = __p;
      if (v56 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v56 = v14;
      operator delete(v16);
    }
    v17 = v53;
    if (!v53)
      goto LABEL_76;
    v18 = v54;
    v19 = v53;
    if (v54 == v53)
      goto LABEL_75;
    do
    {
      v21 = *--v18;
      v20 = v21;
      *v18 = 0;
      if (v21)
        MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
    }
    while (v18 != v17);
    goto LABEL_74;
  }
  v6 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v6 + 8))
  {
    v44 = 0;
    v45 = 0;
LABEL_46:
    v48[0] = (const void **)"invalid type for weights.";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (!v57)
      return v13;
    v28 = __p;
    if (__p)
    {
      v29 = v56;
      v30 = __p;
      if (v56 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v56 = v28;
      operator delete(v30);
    }
    v17 = v53;
    if (v53)
    {
      v31 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_75;
      do
      {
        v33 = *--v31;
        v32 = v33;
        *v31 = 0;
        if (v33)
          MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
      }
      while (v31 != v17);
      goto LABEL_74;
    }
LABEL_76:
    if (v51 != &v52)
      free(v51);
    return v13;
  }
  v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v6 + 8);
  v44 = v6;
  v45 = v7;
  if (!v6)
    goto LABEL_46;
  if (*(_UNKNOWN **)(*(_QWORD *)v4 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && *(_UNKNOWN **)(*(_QWORD *)v6 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    v9 = v8;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v44);
    v42 = v10;
    v43 = v9;
    if (v9 <= 3)
    {
      v48[0] = (const void **)"stencil input rank ";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v11 = mlir::InFlightDiagnostic::operator<<<unsigned long>((uint64_t)v50, (uint64_t *)&v43);
      v12 = " must be >= 4 ";
LABEL_82:
      v41 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v11, v12);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v41);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
      return v13;
    }
    if (v10 != 4)
    {
      v48[0] = (const void **)"stencil weights rank ";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v11 = mlir::InFlightDiagnostic::operator<<<unsigned long>((uint64_t)v50, &v42);
      v12 = " must be == 4 ";
      goto LABEL_82;
    }
  }
  return 1;
}

uint64_t mlir::mps::StencilOp::getPaddingStyle(mlir::mps::StencilOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(unsigned int *)(*(_QWORD *)(v1 + 40) + 8);
}

uint64_t mlir::mps::StencilOp::getExplicitPadding(mlir::mps::StencilOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(_QWORD *)(v1 + 8);
}

uint64_t mlir::mps::CropResizeOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  _QWORD *v24;
  uint64_t v25;
  void *v26;
  unint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v34;
  void *v35;
  unsigned int UInt;
  void *v37;
  void *v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unsigned int v49;
  _QWORD *v50;
  uint64_t ElementTypeOrSelf;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t Value;
  void *v56;
  uint64_t v57;
  _BYTE v58[64];
  uint64_t v59;
  char v60[8];
  char v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  v70 = a4;
  v71 = a5;
  if (a7)
  {
    v14 = *a7;
    v15 = a7[1];
    v16 = a7[2];
    v17 = *((_QWORD *)a7 + 6);
  }
  else
  {
    v17 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
  }
  v59 = a6;
  v60[0] = 0;
  v61 = 0;
  v62 = v14;
  v63 = v15;
  v64 = v16;
  v65 = v17;
  v66 = a9;
  v18 = a5;
  v67 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v59);
    if (v61)
      v61 = 0;
    mlir::OperationName::OperationName(v60, "mps.crop_resize", 15, Context);
    v61 = 1;
    v18 = v71;
  }
  v68 = a4;
  v69 = a5;
  if (v18 >= 2
    && (v20 = mlir::UnknownLoc::get(this, a2), mlir::mps::CropResizeOpAdaptor::verify(&v59, v20)))
  {
    v21 = mlir::ValueRange::dereference_iterator(&v70, 0);
    v22 = *(void **)(*(_QWORD *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
    if (v22 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      || v22 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v24 = (_QWORD *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
    }
    else
    {
      v24 = 0;
    }
    v25 = mlir::ValueRange::dereference_iterator(&v70, 1);
    v26 = *(void **)(*(_QWORD *)(*(_QWORD *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
    if (v26 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      || v26 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      v28 = *(_QWORD *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8;
    }
    else
    {
      v28 = 0;
    }
    if (v24)
      v29 = v28 == 0;
    else
      v29 = 1;
    if (!v29)
    {
      v34 = (void *)v64;
      if (!(_QWORD)v64)
        goto LABEL_39;
      v35 = *(void **)(*(_QWORD *)v64 + 136);
      if (v35 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v34 = 0;
      v56 = v34;
      if (v35 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
        && (Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v56),
            mlir::Type::isUnsignedInteger((mlir::Type *)&Value)))
      {
        UInt = mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&v56);
      }
      else
      {
LABEL_39:
        UInt = 1;
      }
      v37 = (void *)*((_QWORD *)&v64 + 1);
      if (!*((_QWORD *)&v64 + 1))
        goto LABEL_46;
      v38 = *(void **)(**((_QWORD **)&v64 + 1) + 136);
      if (v38 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v37 = 0;
      v56 = v37;
      if (v38 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
        && (Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v56),
            mlir::Type::isUnsignedInteger((mlir::Type *)&Value)))
      {
        v39 = mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&v56);
      }
      else
      {
LABEL_46:
        v39 = 1;
      }
      Value = (uint64_t)v24;
      v56 = v58;
      v57 = 0x800000000;
      v54 = v28;
      if (mlir::TensorType::hasRank((mlir::TensorType *)&Value)
        && (mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&Value), v40 == 4))
      {
        v41 = (unint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&Value);
        v42 = *v41;
        v43 = v41[1];
        if (!mlir::TensorType::hasRank((mlir::TensorType *)&v54))
        {
LABEL_50:
          v44 = 0x8000000000000000;
          v45 = 0x8000000000000000;
LABEL_57:
          v49 = v57;
          if ((_DWORD)v57 != 5)
          {
            if (v57 <= 5)
            {
              if (HIDWORD(v57) > 4
                || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v58, 5uLL, 8),
                    v49 = v57,
                    (_DWORD)v57 != 5))
              {
                bzero((char *)v56 + 8 * v49, 40 - 8 * v49);
              }
            }
            LODWORD(v57) = 5;
          }
          v50 = v56;
          *(_QWORD *)v56 = v44;
          v50[1] = v45;
          v50[2] = v43;
          v50[3] = UInt;
          v50[4] = v39;
          ElementTypeOrSelf = mlir::getElementTypeOrSelf(v24);
          v52 = mlir::RankedTensorType::get((uint64_t)v50, 5, ElementTypeOrSelf, 0);
          v53 = *(unsigned int *)(a11 + 8);
          if (v53 >= *(_DWORD *)(a11 + 12))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v53 + 1, 8);
            LODWORD(v53) = *(_DWORD *)(a11 + 8);
          }
          *(_QWORD *)(*(_QWORD *)a11 + 8 * v53) = v52;
          ++*(_DWORD *)(a11 + 8);
          if (v56 != v58)
            free(v56);
          return 1;
        }
      }
      else
      {
        v42 = 0x8000000000000000;
        v43 = 0x8000000000000000;
        if (!mlir::TensorType::hasRank((mlir::TensorType *)&v54))
          goto LABEL_50;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v54);
      v45 = 0x8000000000000000;
      v44 = 0x8000000000000000;
      if (v46 == 2)
      {
        v47 = (unint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v54);
        v44 = *v47;
        v48 = v47[1];
        if (v48 != 0x8000000000000000)
        {
          if (v48 == 4)
            v45 = v42;
          else
            v45 = 1;
        }
      }
      goto LABEL_57;
    }
    v30 = mlir::getElementTypeOrSelf(v24);
  }
  else
  {
    v30 = mlir::Float32Type::get(this, a2);
  }
  v31 = mlir::UnrankedTensorType::get(v30);
  v32 = *(unsigned int *)(a11 + 8);
  if (v32 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v32 + 1, 8);
    LODWORD(v32) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v32) = v31;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::CropResizeOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v27[4];
  __int16 v28;
  _QWORD v29[3];
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *v33;
  void *__p;
  _QWORD *v35;
  char v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v3 = a1[8];
  v4 = a1[9];
  if (a1[7]
    && (v27[0] = a1[7],
        v29[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v27),
        !mlir::Type::isUnsignedInteger((mlir::Type *)v29, 32)))
  {
    v27[0] = "'mps.crop_resize' op attribute 'resize_height' failed to satisfy constraint: 32-bit unsigned integer attribute";
    v28 = 259;
    mlir::emitError(a2, (uint64_t)v27, (uint64_t)v29);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v29);
    if (v29[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v29);
    if (v36)
    {
      v6 = __p;
      if (__p)
      {
        v7 = v35;
        v8 = __p;
        if (v35 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v35 = v6;
        operator delete(v8);
      }
      v9 = v32;
      if (!v32)
        goto LABEL_52;
      v10 = v33;
      v11 = v32;
      if (v33 == v32)
        goto LABEL_51;
      do
      {
        v13 = *--v10;
        v12 = v13;
        *v10 = 0;
        if (v13)
          MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
      }
      while (v10 != v9);
      goto LABEL_50;
    }
  }
  else if (v3
         && (v27[0] = v3,
             v29[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v27),
             !mlir::Type::isUnsignedInteger((mlir::Type *)v29, 32)))
  {
    v27[0] = "'mps.crop_resize' op attribute 'resize_width' failed to satisfy constraint: 32-bit unsigned integer attribute";
    v28 = 259;
    mlir::emitError(a2, (uint64_t)v27, (uint64_t)v29);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v29);
    if (v29[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v29);
    if (v36)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v35;
        v16 = __p;
        if (v35 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v35 = v14;
        operator delete(v16);
      }
      v9 = v32;
      if (!v32)
        goto LABEL_52;
      v17 = v33;
      v11 = v32;
      if (v33 == v32)
        goto LABEL_51;
      do
      {
        v19 = *--v17;
        v18 = v19;
        *v17 = 0;
        if (v19)
          MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
      }
      while (v17 != v9);
      goto LABEL_50;
    }
  }
  else
  {
    if (!v4)
      return 1;
    v27[0] = v4;
    v29[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v27);
    if (mlir::Type::isF32((mlir::Type *)v29))
      return 1;
    v27[0] = "'mps.crop_resize' op attribute 'spatial_scale' failed to satisfy constraint: 32-bit float attribute";
    v28 = 259;
    mlir::emitError(a2, (uint64_t)v27, (uint64_t)v29);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v29);
    if (v29[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v29);
    if (v36)
    {
      v20 = __p;
      if (__p)
      {
        v21 = v35;
        v22 = __p;
        if (v35 != __p)
        {
          do
            v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          v22 = __p;
        }
        v35 = v20;
        operator delete(v22);
      }
      v9 = v32;
      if (!v32)
        goto LABEL_52;
      v23 = v33;
      v11 = v32;
      if (v33 == v32)
      {
LABEL_51:
        v33 = v9;
        operator delete(v11);
LABEL_52:
        if (v30 != &v31)
          free(v30);
        return v5;
      }
      do
      {
        v25 = *--v23;
        v24 = v25;
        *v23 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v23 != v9);
LABEL_50:
      v11 = v32;
      goto LABEL_51;
    }
  }
  return v5;
}

uint64_t mlir::mps::CropResizeOp::verify(uint64_t **this)
{
  uint64_t v2;
  unint64_t v3;
  void *v4;
  unint64_t v6;
  void *v7;
  BOOL v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 hasRank;
  uint64_t v20;
  uint64_t v21;
  uint64_t Value;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v39;
  _QWORD *v40;
  void *v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  const void **v47[4];
  __int16 v48;
  unint64_t v49;
  unint64_t v50;
  _QWORD v51[3];
  void *v52;
  _BYTE v53[96];
  void *v54;
  _QWORD *v55;
  void *__p;
  _QWORD *v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v2 = (*this)[9];
  v3 = *(_QWORD *)(*(_QWORD *)(v2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v4 = *(void **)(*(_QWORD *)v3 + 136);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && v4 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v3 = 0;
  }
  v50 = v3;
  v6 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v7 = *(void **)(*(_QWORD *)v6 + 136);
  if (v7 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && v7 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v6 = 0;
  }
  v49 = v6;
  if (v3)
    v9 = v6 == 0;
  else
    v9 = 1;
  if (v9)
  {
    v47[0] = (const void **)"cannot crop_resize a non-tensor type";
    v48 = 259;
    mlir::OpState::emitOpError(this, v47, (uint64_t)v51);
    v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
    if (v51[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
    if (v58)
    {
      v11 = __p;
      if (__p)
      {
        v12 = v57;
        v13 = __p;
        if (v57 != __p)
        {
          do
            v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
          while (v12 != v11);
          v13 = __p;
        }
        v57 = v11;
        operator delete(v13);
      }
      v14 = v54;
      if (!v54)
        goto LABEL_70;
      v15 = v55;
      v16 = v54;
      if (v55 == v54)
        goto LABEL_69;
      do
      {
        v18 = *--v15;
        v17 = v18;
        *v15 = 0;
        if (v18)
          MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
      }
      while (v15 != v14);
      goto LABEL_68;
    }
  }
  else
  {
    hasRank = mlir::TensorType::hasRank((mlir::TensorType *)&v50);
    if (hasRank && (mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v50), v20 != 4))
    {
      v47[0] = (const void **)"images tensor must have shape [N, C, H, W]";
      v48 = 259;
      mlir::OpState::emitOpError(this, v47, (uint64_t)v51);
      v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
      if (v51[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
      if (v58)
      {
        v26 = __p;
        if (__p)
        {
          v27 = v57;
          v28 = __p;
          if (v57 != __p)
          {
            do
              v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
            while (v27 != v26);
            v28 = __p;
          }
          v57 = v26;
          operator delete(v28);
        }
        v14 = v54;
        if (!v54)
          goto LABEL_70;
        v29 = v55;
        v16 = v54;
        if (v55 == v54)
          goto LABEL_69;
        do
        {
          v31 = *--v29;
          v30 = v31;
          *v29 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v29 != v14);
        goto LABEL_68;
      }
    }
    else
    {
      if (!mlir::TensorType::hasRank((mlir::TensorType *)&v49))
        return 1;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v49);
      if (v21 == 2)
      {
        Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v49);
        v24 = *(_QWORD *)(Value + 8 * v23 - 8);
        if ((unint64_t)(v24 - 4) >= 2 && v24 != 0x8000000000000000)
        {
          v47[0] = (const void **)"boxes tensor must have shape [B, 4] or [B, 5]";
          v48 = 259;
          mlir::OpState::emitOpError(this, v47, (uint64_t)v51);
          v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
          if (v51[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
          if (!v58)
            return v10;
          v39 = __p;
          if (__p)
          {
            v40 = v57;
            v41 = __p;
            if (v57 != __p)
            {
              do
                v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
              while (v40 != v39);
              v41 = __p;
            }
            v57 = v39;
            operator delete(v41);
          }
          v42 = v54;
          if (v54)
          {
            v43 = v55;
            v44 = v54;
            if (v55 != v54)
            {
              do
              {
                v46 = *--v43;
                v45 = v46;
                *v43 = 0;
                if (v46)
                  MEMORY[0x20BD002D4](v45, 0x1000C8077774924);
              }
              while (v43 != v42);
              v44 = v54;
            }
            v55 = v42;
            operator delete(v44);
          }
          if (v52 != v53)
            free(v52);
          if ((unint64_t)(v24 - 4) >= 2 && v24 != 0x8000000000000000)
            return v10;
        }
        return 1;
      }
      v47[0] = (const void **)"boxes tensor must have shape [B, 4] or [B, 5]";
      v48 = 259;
      mlir::OpState::emitOpError(this, v47, (uint64_t)v51);
      v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
      if (v51[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
      if (v58)
      {
        v32 = __p;
        if (__p)
        {
          v33 = v57;
          v34 = __p;
          if (v57 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v57 = v32;
          operator delete(v34);
        }
        v14 = v54;
        if (!v54)
          goto LABEL_70;
        v35 = v55;
        v16 = v54;
        if (v55 == v54)
        {
LABEL_69:
          v55 = v14;
          operator delete(v16);
LABEL_70:
          if (v52 != v53)
            free(v52);
          return v10;
        }
        do
        {
          v37 = *--v35;
          v36 = v37;
          *v35 = 0;
          if (v37)
            MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
        }
        while (v35 != v14);
LABEL_68:
        v16 = v54;
        goto LABEL_69;
      }
    }
  }
  return v10;
}

uint64_t mlir::mps::LPNormOp::verify(uint64_t **this)
{
  void *v2;
  uint64_t DefiningOp;
  int64_t SingleInt;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char PositiveAxes;
  void *v20;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t **v31[4];
  _QWORD v32[2];
  _QWORD *v33;
  uint64_t ***v34;
  __int16 v35;
  _QWORD v36[2];
  int64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  _QWORD v41[2];
  _QWORD v42[2];
  _QWORD *v43;
  void *v44;
  uint64_t v45;
  _BYTE v46[32];
  uint64_t v47;
  uint64_t v48;
  void *v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD *v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v2 = *(void **)((*this)[9] + 56);
  v47 = 0;
  v48 = 0;
  v31[0] = (uint64_t **)&v47;
  v39 = v2;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v39);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(v31, DefiningOp))
  {
    SingleInt = mlir::getSingleIntValue<long long>(v47, v48);
    v37 = SingleInt;
    v38 = v5;
    if ((_BYTE)v5 && SingleInt <= 0)
    {
      v39 = "failed: exponent must be positive, but got {0}";
      v40 = 46;
      v41[0] = &v43;
      v41[1] = 1;
      v42[0] = &off_24C02E3D8;
      v42[1] = &v37;
      v43 = v42;
      LOWORD(v32[0]) = 263;
      v31[0] = (uint64_t **)&v39;
      mlir::OpState::emitOpError(this, (const void ***)v31, (uint64_t)&v47);
      v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v47);
      if (v47)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v47);
      if (!v55)
        return v6;
      v7 = __p;
      if (__p)
      {
        v8 = v54;
        v9 = __p;
        if (v54 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v54 = v7;
        operator delete(v9);
      }
      v10 = v51;
      if (v51)
      {
        v11 = v52;
        v12 = v51;
        if (v52 != v51)
        {
          do
          {
            v14 = *--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              MEMORY[0x20BD002D4](v13, 0x1000C8077774924);
          }
          while (v11 != v10);
          v12 = v51;
        }
        v52 = v10;
        operator delete(v12);
      }
      v20 = v49;
      if (v49 == v50)
        return v6;
LABEL_32:
      free(v20);
      return v6;
    }
  }
  else
  {
    v37 = 0;
    v38 = 0;
  }
  v15 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v15)
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
  else
    v16 = 0;
  v36[0] = v15;
  v36[1] = v16;
  v44 = v46;
  v45 = 0x400000000;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v36)
    || !mlir::matchConstantWithIntVector<long long>(*(_QWORD *)((*this)[9] + 88), (uint64_t)&v44))
  {
    goto LABEL_30;
  }
  v39 = v41;
  v40 = 0x600000000;
  v6 = (uint64_t)v44;
  v17 = v45;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  if (!PositiveAxes)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v36);
    v31[0] = (uint64_t **)"failed: found an axis out of bounds for input rank {0}";
    v31[1] = (uint64_t **)54;
    v31[2] = &v33;
    v31[3] = (uint64_t **)1;
    v32[0] = &off_24C02E498;
    v32[1] = v22;
    v33 = v32;
    v34 = v31;
    v35 = 263;
    mlir::OpState::emitOpError(this, (const void ***)&v34, (uint64_t)&v47);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v47);
    if (v47)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v47);
    if (v55)
    {
      v23 = __p;
      if (__p)
      {
        v24 = v54;
        v25 = __p;
        if (v54 != __p)
        {
          do
            v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
          while (v24 != v23);
          v25 = __p;
        }
        v54 = v23;
        operator delete(v25);
      }
      v26 = v51;
      if (v51)
      {
        v27 = v52;
        v28 = v51;
        if (v52 != v51)
        {
          do
          {
            v30 = *--v27;
            v29 = v30;
            *v27 = 0;
            if (v30)
              MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
          }
          while (v27 != v26);
          v28 = v51;
        }
        v52 = v26;
        operator delete(v28);
      }
      if (v49 != v50)
        free(v49);
    }
  }
  if (v39 != v41)
    free(v39);
  if (PositiveAxes)
LABEL_30:
    v6 = 1;
  v20 = v44;
  if (v44 != v46)
    goto LABEL_32;
  return v6;
}

uint64_t mlir::mps::MatrixDecompositionLUOp::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t Shape;
  unint64_t v20;
  unint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  unint64_t v30;
  uint64_t v31;
  size_t v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  void *v48;
  uint64_t v49;
  _BYTE v50[32];
  void *v51;
  uint64_t v52;
  _BYTE v53[32];
  _QWORD v54[4];

  v54[2] = *MEMORY[0x24BDAC8D0];
  v54[0] = a4;
  v54[1] = a5;
  if (a5 != 1)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v51 = a4;
  v52 = 1;
  v14 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v51, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v15 = *(unsigned int *)(a11 + 8);
  if (v15 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v15) = v14;
  ++*(_DWORD *)(a11 + 8);
  v16 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v54, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v16 + 8)
    || (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v16 + 8),
        *(_UNKNOWN **)(*(_QWORD *)v16 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id))
  {
    v23 = mlir::IntegerType::get(a1, 0x20u, 2u);
    v24 = mlir::UnrankedTensorType::get(v23);
    v25 = *(unsigned int *)(a11 + 8);
    if (v25 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v25 + 1, 8);
      LODWORD(v25) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v25) = v24;
    ++*(_DWORD *)(a11 + 8);
    v26 = mlir::IntegerType::get(a1, 0x20u, 1u);
    v27 = mlir::UnrankedTensorType::get(v26);
    v28 = *(unsigned int *)(a11 + 8);
    if (v28 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v28 + 1, 8);
      LODWORD(v28) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v28) = v27;
    ++*(_DWORD *)(a11 + 8);
  }
  else
  {
    v17 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v54, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8))
    {
      v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
      v51 = v17;
      v52 = v18;
      Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v51);
      v21 = v20 - 1;
      if (v20 <= 1)
        return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "input must be rank 2 or more");
    }
    else
    {
      v51 = 0;
      v52 = 0;
      Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v51);
      v21 = v20 - 1;
      if (v20 <= 1)
        return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "input must be rank 2 or more");
    }
    v29 = (const void *)Shape;
    v30 = v20 - 2;
    if (*(_QWORD *)(Shape + 8 * (v20 - 2)) >= *(_QWORD *)(Shape + 8 * v21))
      v31 = *(_QWORD *)(Shape + 8 * v21);
    else
      v31 = *(_QWORD *)(Shape + 8 * (v20 - 2));
    v32 = 8 * v20;
    v33 = v53;
    v51 = v53;
    v52 = 0x400000000;
    v47 = (uint64_t)(8 * v20) >> 3;
    if (8 * v20 < 0x21)
    {
      v34 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, (uint64_t)(8 * v20) >> 3, 8);
      v34 = v52;
      v33 = v51;
    }
    memcpy(&v33[8 * v34], v29, v32);
    LODWORD(v52) = v52 + (v32 >> 3);
    v35 = v52;
    v36 = v51;
    *((_QWORD *)v51 + v30) = 1;
    v36[v21] = v31;
    v37 = mlir::IntegerType::get(a1, 0x20u, 2u);
    v38 = mlir::RankedTensorType::get((uint64_t)v36, v35, v37, 0);
    v39 = *(unsigned int *)(a11 + 8);
    if (v39 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v39 + 1, 8);
      LODWORD(v39) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v39) = v38;
    ++*(_DWORD *)(a11 + 8);
    v48 = v50;
    v49 = 0x400000000;
    if (v32 < 0x21)
    {
      v40 = 0;
      v41 = v50;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v50, v47, 8);
      v40 = v49;
      v41 = v48;
    }
    memcpy(&v41[8 * v40], v29, v32);
    LODWORD(v49) = v49 + (v32 >> 3);
    v42 = v49;
    v43 = v48;
    *(int64x2_t *)((char *)v48 + 8 * v30) = vdupq_n_s64(1uLL);
    v44 = mlir::IntegerType::get(a1, 0x20u, 1u);
    v45 = mlir::RankedTensorType::get((uint64_t)v43, v42, v44, 0);
    v46 = *(unsigned int *)(a11 + 8);
    if (v46 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v46 + 1, 8);
      LODWORD(v46) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v46) = v45;
    ++*(_DWORD *)(a11 + 8);
    if (v48 != v50)
      free(v48);
    if (v51 != v53)
      free(v51);
  }
  return 1;
}

uint64_t mlir::mps::MatrixSolverLUOp::verify(uint64_t **this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *Shape;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  _QWORD *v23[4];
  __int16 v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v2 + 8))
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v2 + 8);
  else
    v2 = 0;
  v3 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v3 + 8))
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v3 + 8);
  else
    v3 = 0;
  v4 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v4 + 8))
  {
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v4 + 8);
    v5 = 1;
    if (!v2)
      return v5;
  }
  else
  {
    v4 = 0;
    v5 = 1;
    if (!v2)
      return v5;
  }
  if (v3
    && *(_UNKNOWN **)(*(_QWORD *)v2 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && v4
    && *(_UNKNOWN **)(*(_QWORD *)v3 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && *(_UNKNOWN **)(*(_QWORD *)v4 + 136) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v23[0] = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v25 = mlir::Type::dyn_cast<mlir::ShapedType>(v23);
    v26 = v6;
    Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v25);
    v9 = v8;
    v23[0] = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    v25 = mlir::Type::dyn_cast<mlir::ShapedType>(v23);
    v26 = v10;
    v11 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v25);
    v13 = v12;
    v23[0] = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8);
    v25 = mlir::Type::dyn_cast<mlir::ShapedType>(v23);
    v26 = v14;
    v15 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v25);
    if (v9 == v16 && v9 == v13)
    {
      v17 = v9 - 2;
      if (v9 == 2)
        return 1;
      v5 = 1;
      while (1)
      {
        v19 = *v15++;
        v18 = v19;
        v20 = *Shape++;
        if (v18 != v20 || v18 != *v11)
          break;
        ++v11;
        if (!--v17)
          return v5;
      }
      v21 = "batch dims of rhs and lu should match";
    }
    else
    {
      v21 = "rank for lu matrix and rhs should match";
    }
    v23[0] = v21;
    v24 = 259;
    mlir::OpState::emitOpError(this, (const void ***)v23, (uint64_t)&v25);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v25);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v25);
  }
  return v5;
}

uint64_t mlir::mps::MatrixSolverLUOp::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v13;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t OperandRange;
  uint64_t v21;
  uint64_t v22;
  uint64_t Shape;
  unint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _BYTE *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD v40[3];

  v40[2] = *MEMORY[0x24BDAC8D0];
  v40[0] = a4;
  v40[1] = a5;
  if (a5 != 3)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v13 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v40, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v13 + 8))
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v13 + 8);
  else
    v13 = 0;
  v15 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v40, 2) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v15 + 8))
  {
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v15 + 8);
    v35 = v15;
    v36 = v16;
    if (!v13)
      goto LABEL_17;
  }
  else
  {
    v15 = 0;
    v35 = 0;
    v36 = 0;
    if (!v13)
    {
LABEL_17:
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v35);
      v21 = mlir::UnrankedTensorType::get(OperandRange);
      v22 = *(unsigned int *)(a11 + 8);
      if (v22 >= *(_DWORD *)(a11 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
        LODWORD(v22) = *(_DWORD *)(a11 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a11 + 8 * v22) = v21;
      ++*(_DWORD *)(a11 + 8);
      return 1;
    }
  }
  v17 = *(_UNKNOWN **)(*(_QWORD *)v13 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
     || v15 == 0;
  if (v17 || *(_UNKNOWN **)(*(_QWORD *)v15 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    goto LABEL_17;
  v18 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v40, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v18 + 8);
  if (v19)
    v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v18 + 8);
  else
    v18 = 0;
  v37 = v18;
  v38 = v19;
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
  v25 = v24;
  v26 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v40, 2) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v26 + 8))
  {
    v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v26 + 8);
    v37 = v26;
    v38 = v27;
    v28 = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
    if (v25 < 2)
      return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "inputs must be rank 2 or more");
  }
  else
  {
    v37 = 0;
    v38 = 0;
    v28 = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
    if (v25 < 2)
      return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "inputs must be rank 2 or more");
  }
  if (v29 > 1)
  {
    v30 = *(_QWORD *)(Shape + 8 * v25 - 8);
    llvm::SmallVector<long long,4u>::SmallVector<long long const*,void>(&v37, v28, &v28[8 * v29]);
    v31 = v38;
    v32 = v37;
    *((_QWORD *)v37 + v38 - 2) = v30;
    v33 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v35);
    v34 = mlir::RankedTensorType::get((uint64_t)v32, v31, v33, 0);
    llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v34);
    if (v37 != &v39)
      free(v37);
    return 1;
  }
  return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "inputs must be rank 2 or more");
}

uint64_t mlir::mps::MatrixInverseOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t Shape;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  const void **v20;
  __int16 v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v2 + 8))
    return 1;
  mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v2 + 8);
  if (*(_UNKNOWN **)(*(_QWORD *)v2 + 136) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    return 1;
  v3 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
  if (v4)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
  else
    v3 = 0;
  v22[0] = v3;
  v22[1] = v4;
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v22);
  v9 = Shape + 8 * v8;
  v10 = *(_QWORD *)(v9 - 16);
  v5 = 1;
  if (v10 != 0x8000000000000000)
  {
    v11 = *(_QWORD *)(v9 - 8);
    if (v11 != 0x8000000000000000 && v11 != v10)
    {
      v20 = (const void **)"inverse op supported only for square matrix";
      v21 = 259;
      mlir::OpState::emitOpError(this, &v20, (uint64_t)v22);
      v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
      if (v22[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
      if (v29)
      {
        v12 = __p;
        if (__p)
        {
          v13 = v28;
          v14 = __p;
          if (v28 != __p)
          {
            do
              v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
            while (v13 != v12);
            v14 = __p;
          }
          v28 = v12;
          operator delete(v14);
        }
        v15 = v25;
        if (v25)
        {
          v16 = v26;
          v17 = v25;
          if (v26 != v25)
          {
            do
            {
              v19 = *--v16;
              v18 = v19;
              *v16 = 0;
              if (v19)
                MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
            }
            while (v16 != v15);
            v17 = v25;
          }
          v26 = v15;
          operator delete(v17);
        }
        if (v23 != &v24)
          free(v23);
      }
    }
  }
  return v5;
}

uint64_t mlir::mps::MatrixInverseOp::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v13;
  uint64_t v14;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x24BDAC8D0];
  v19 = a4;
  v20 = a5;
  if (a5 != 1)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v13 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v19, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v13 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v13 = 0;
  v18 = v13;
  if (v13)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v18);
    if (v14 <= 1)
      return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "input must be rank 2 or more");
  }
  v21[0] = v19;
  v21[1] = v20;
  if (!v20)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v16 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v21, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v17 = *(unsigned int *)(a11 + 8);
  if (v17 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v17 + 1, 8);
    LODWORD(v17) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v17) = v16;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::PruningOp::verify(uint64_t **this)
{
  unint64_t v2;
  float v3;
  void *v4;
  llvm::APFloatBase *v5;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const void **v18[4];
  __int16 v19;
  uint64_t v20;
  _QWORD v21[2];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v18[0] = *(const void ***)(v2 + 16);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)v18, (uint64_t)&v20);
  v3 = llvm::APFloat::convertToFloat((llvm::APFloat *)&v20);
  v4 = (void *)v21[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v5) == v4)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    if (v3 < 0.0 || v3 > 1.0)
      goto LABEL_8;
    return 1;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
  if (v3 >= 0.0 && v3 <= 1.0)
    return 1;
LABEL_8:
  v19 = 259;
  mlir::OpState::emitOpError(this, v18, (uint64_t)&v20);
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v20);
  if (v20)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v20);
  if (v28)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v27;
      v10 = __p;
      if (v27 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v27 = v8;
      operator delete(v10);
    }
    v11 = v24;
    if (v24)
    {
      v12 = v25;
      v13 = v24;
      if (v25 != v24)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v24;
      }
      v25 = v11;
      operator delete(v13);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v7;
}

uint64_t mlir::mps::CreateTextureTensorOp::verify(uint64_t **this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t Shape;
  uint64_t v6;
  uint64_t v7;
  unint64_t v9;
  unsigned int v10;
  int v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  void ***v34;
  uint64_t v35;
  void *v36;
  unsigned int *v37;
  uint64_t (**v38)(llvm::detail::format_adapter *__hidden);
  uint64_t *v39;
  void **v40;
  uint64_t (***v41)(llvm::detail::format_adapter *__hidden);
  const void **v42[4];
  __int16 v43;
  uint64_t v44;
  unsigned int v45;
  _QWORD v46[2];
  _QWORD v47[3];
  void *v48;
  uint64_t v49;
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  v3 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v3)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
  else
    v4 = 0;
  v46[0] = v3;
  v46[1] = v4;
  Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v46);
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v46))
    return 1;
  v6 = *(_QWORD *)(Shape + 24);
  if (v6 == 0x8000000000000000)
    return 1;
  v9 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v9 = 0;
  v10 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 8);
  v45 = v10;
  v44 = v6;
  if (v10 > 9)
    return 1;
  v11 = 1 << v10;
  if ((v11 & 0x24C) != 0)
  {
    if (v6 != 4)
    {
      v32 = "failed: expected a number of channels equal to 4 for pixel format {0}, but found {1}";
      v33 = 84;
      v34 = &v40;
      v35 = 2;
      v36 = &unk_24C02E588;
      v37 = &v45;
      v38 = &off_24C02E3D8;
      v39 = &v44;
      v40 = &v36;
      v41 = &v38;
      v43 = 263;
      v42[0] = (const void **)&v32;
      mlir::OpState::emitOpError(this, v42, (uint64_t)v47);
      v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      if (v54)
      {
        v20 = __p;
        if (__p)
        {
          v21 = v53;
          v22 = __p;
          if (v53 != __p)
          {
            do
              v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            v22 = __p;
          }
          v53 = v20;
          operator delete(v22);
        }
        v15 = v50;
        if (!v50)
          goto LABEL_63;
        v23 = v51;
        v17 = v50;
        if (v51 == v50)
          goto LABEL_62;
        do
        {
          v25 = *--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v23 != v15);
        goto LABEL_61;
      }
      return v7;
    }
    return 1;
  }
  if ((v11 & 0x91) != 0)
  {
    if (v6 != 1)
    {
      v32 = "failed: expected a number of channels equal to 1 for pixel format {0}, but found {1}";
      v33 = 84;
      v34 = &v40;
      v35 = 2;
      v36 = &unk_24C02E588;
      v37 = &v45;
      v38 = &off_24C02E3D8;
      v39 = &v44;
      v40 = &v36;
      v41 = &v38;
      v43 = 263;
      v42[0] = (const void **)&v32;
      mlir::OpState::emitOpError(this, v42, (uint64_t)v47);
      v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      if (v54)
      {
        v12 = __p;
        if (__p)
        {
          v13 = v53;
          v14 = __p;
          if (v53 != __p)
          {
            do
              v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
            while (v13 != v12);
            v14 = __p;
          }
          v53 = v12;
          operator delete(v14);
        }
        v15 = v50;
        if (!v50)
          goto LABEL_63;
        v16 = v51;
        v17 = v50;
        if (v51 == v50)
        {
LABEL_62:
          v51 = v15;
          operator delete(v17);
LABEL_63:
          if (v48 != &v49)
            free(v48);
          return v7;
        }
        do
        {
          v19 = *--v16;
          v18 = v19;
          *v16 = 0;
          if (v19)
            MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
        }
        while (v16 != v15);
LABEL_61:
        v17 = v50;
        goto LABEL_62;
      }
      return v7;
    }
    return 1;
  }
  if (v6 == 2)
    return 1;
  v32 = "failed: expected a number of channels equal to 2 for pixel format {0}, but found {1}";
  v33 = 84;
  v34 = &v40;
  v35 = 2;
  v36 = &unk_24C02E588;
  v37 = &v45;
  v38 = &off_24C02E3D8;
  v39 = &v44;
  v40 = &v36;
  v41 = &v38;
  v43 = 263;
  v42[0] = (const void **)&v32;
  mlir::OpState::emitOpError(this, v42, (uint64_t)v47);
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
  if (v47[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
  if (v54)
  {
    v26 = __p;
    if (__p)
    {
      v27 = v53;
      v28 = __p;
      if (v53 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v53 = v26;
      operator delete(v28);
    }
    v15 = v50;
    if (!v50)
      goto LABEL_63;
    v29 = v51;
    v17 = v50;
    if (v51 == v50)
      goto LABEL_62;
    do
    {
      v31 = *--v29;
      v30 = v31;
      *v29 = 0;
      if (v31)
        MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
    }
    while (v29 != v15);
    goto LABEL_61;
  }
  return v7;
}

BOOL mlir::mps::QuantizeOp::verify(uint64_t **this)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  const void **v30[4];
  __int16 v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t **v38;
  uint64_t *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  _QWORD *v43;
  void *__p;
  _QWORD *v45;
  char v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v37 = *(uint64_t **)(v2 + 8);
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v37) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    v31 = 259;
    mlir::OpState::emitOpError(this, v30, (uint64_t)&v37);
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v37);
    if (v37)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
    if (v46)
    {
      v4 = __p;
      if (__p)
      {
        v5 = v45;
        v6 = __p;
        if (v45 != __p)
        {
          do
            v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
          while (v5 != v4);
          v6 = __p;
        }
        v45 = v4;
        operator delete(v6);
      }
      v7 = v42;
      if (!v42)
        goto LABEL_52;
      v8 = v43;
      v9 = v42;
      if (v43 == v42)
      {
LABEL_51:
        v43 = v7;
        operator delete(v9);
LABEL_52:
        if (v40 != &v41)
          free(v40);
        return v3;
      }
      do
      {
        v11 = *--v8;
        v10 = v11;
        *v8 = 0;
        if (v11)
          MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
      }
      while (v8 != v7);
LABEL_50:
      v9 = v42;
      goto LABEL_51;
    }
    return v3;
  }
  v12 = *this;
  v36 = v12;
  v13 = *(_QWORD *)(v12[9] + 24);
  v30[0] = (const void **)v12[10];
  if (v30[0])
  {
    mlir::IntegerAttr::getValue(v30, (llvm::APInt *)&v37);
    if (v38 > 0x40)
    {
      LODWORD(v14) = *(_DWORD *)v37;
      MEMORY[0x20BD002D4]();
    }
    else
    {
      v14 = (uint64_t)((_QWORD)v37 << -(uint64_t)v38) >> -(uint64_t)v38;
    }
    v15 = v14 | 0x100000000;
  }
  else
  {
    v15 = 0;
  }
  v35 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v16 + 8))
  {
    v33 = 0;
    v34 = 0;
    return 1;
  }
  v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v16 + 8);
  v33 = v16;
  v34 = v17;
  if (!v16 || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v33))
    return 1;
  v32 = 0;
  if ((v15 & 0x100000000) == 0)
    goto LABEL_56;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v33);
  if ((int)v15 < 0)
    v19 = v18;
  else
    v19 = 0;
  v20 = v19 + v15;
  if ((v20 & 0x80000000) == 0)
  {
    v21 = v20;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v33);
    if (v21 <= v22)
    {
      v32 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)&v33) + 8 * v21);
      v12 = v36;
LABEL_56:
      v37 = &v35;
      v38 = &v36;
      v39 = &v32;
      v40 = &v33;
    }
  }
  v31 = 259;
  mlir::OpState::emitOpError(&v36, v30, (uint64_t)&v37);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v37);
  if (v37)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  if (v46)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v45;
      v25 = __p;
      if (v45 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v45 = v23;
      operator delete(v25);
    }
    v7 = v42;
    if (!v42)
      goto LABEL_52;
    v26 = v43;
    v9 = v42;
    if (v43 == v42)
      goto LABEL_51;
    do
    {
      v28 = *--v26;
      v27 = v28;
      *v26 = 0;
      if (v28)
        MEMORY[0x20BD002D4](v27, 0x1000C8077774924);
    }
    while (v26 != v7);
    goto LABEL_50;
  }
  return v3;
}

BOOL mlir::mps::DequantizeOp::verify(uint64_t **this)
{
  unint64_t v2;
  void *v3;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  const void **v42[4];
  __int16 v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t **v50;
  uint64_t *v51;
  void *v52;
  uint64_t v53;
  void *v54;
  _QWORD *v55;
  void *__p;
  _QWORD *v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v49 = *(uint64_t **)(v2 + 8);
  v3 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v49) + 136);
  if (v3 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    && v3 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    v43 = 259;
    mlir::OpState::emitOpError(this, v42, (uint64_t)&v49);
    v26 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v49);
    if (v49)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v49);
    if (v58)
    {
      v36 = __p;
      if (__p)
      {
        v37 = v57;
        v38 = __p;
        if (v57 != __p)
        {
          do
            v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
          while (v37 != v36);
          v38 = __p;
        }
        v57 = v36;
        operator delete(v38);
      }
      v30 = v54;
      if (!v54)
        goto LABEL_92;
      v39 = v55;
      v32 = v54;
      if (v55 == v54)
      {
LABEL_91:
        v55 = v30;
        operator delete(v32);
LABEL_92:
        if (v52 != &v53)
          free(v52);
        return v26;
      }
      do
      {
        v41 = *--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v39 != v30);
LABEL_90:
      v32 = v54;
      goto LABEL_91;
    }
    return v26;
  }
  v15 = *this;
  v48 = v15;
  v16 = *(_QWORD *)(v15[9] + 24);
  v42[0] = (const void **)v15[10];
  if (v42[0])
  {
    mlir::IntegerAttr::getValue(v42, (llvm::APInt *)&v49);
    if (v50 > 0x40)
    {
      LODWORD(v17) = *(_DWORD *)v49;
      MEMORY[0x20BD002D4]();
    }
    else
    {
      v17 = (uint64_t)((_QWORD)v49 << -(uint64_t)v50) >> -(uint64_t)v50;
    }
    v18 = v17 | 0x100000000;
  }
  else
  {
    v18 = 0;
  }
  v47 = v18;
  v19 = (_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8))
  {
    v45 = 0;
    v46 = 0;
    return 1;
  }
  v20 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  v45 = v19;
  v46 = v20;
  if (!v19 || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v45))
    return 1;
  v44 = 0;
  if ((v18 & 0x100000000) == 0)
  {
LABEL_72:
    v49 = &v47;
    v50 = &v48;
    v51 = &v44;
    v52 = &v45;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  if ((int)v18 < 0)
    v22 = v21;
  else
    v22 = 0;
  v23 = v22 + v18;
  if ((v23 & 0x80000000) == 0)
  {
    v24 = v23;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
    if (v24 <= v25)
    {
      v44 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)&v45) + 8 * v24);
      v15 = v48;
      goto LABEL_72;
    }
  }
  v43 = 259;
  mlir::OpState::emitOpError(&v48, v42, (uint64_t)&v49);
  v26 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v49);
  if (v49)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v49);
  if (v58)
  {
    v27 = __p;
    if (__p)
    {
      v28 = v57;
      v29 = __p;
      if (v57 != __p)
      {
        do
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        v29 = __p;
      }
      v57 = v27;
      operator delete(v29);
    }
    v30 = v54;
    if (!v54)
      goto LABEL_92;
    v31 = v55;
    v32 = v54;
    if (v55 == v54)
      goto LABEL_91;
    do
    {
      v34 = *--v31;
      v33 = v34;
      *v31 = 0;
      if (v34)
        MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
    }
    while (v31 != v30);
    goto LABEL_90;
  }
  return v26;
}

void mlir::mps::DequantizeOp::downgradeToVersion(uint64_t **a1@<X0>, _DWORD *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t *v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[4];
  _QWORD v19[2];
  _QWORD v20[2];
  _QWORD v21[2];
  const void **v22;
  __int16 v23;
  _QWORD v24[2];
  int v25;
  _QWORD v26[3];
  void *v27;
  uint64_t v28;
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v6 = *a1;
  v24[0] = &unk_24C050508;
  v24[1] = 1;
  v25 = 1;
  if (!mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)a1)
    || (v7 = a2[2]) != 0 && (v7 != 1 || a2[3] || a2[4]))
  {
    v8 = *((unsigned int *)v6 + 9);
    v9 = v6 - 2;
    if (!(_DWORD)v8)
      v9 = 0;
    *(_QWORD *)a3 = v9;
    *(_QWORD *)(a3 + 8) = v8;
    *(_BYTE *)(a3 + 16) = 1;
  }
  else
  {
    v18[0] = "failed to downgrade: requested target version is {0}, but ND Params in only supported from version {1}";
    v18[1] = 102;
    v18[2] = v21;
    v18[3] = 2;
    v19[0] = &unk_24C02E528;
    v19[1] = a2;
    v20[0] = &unk_24C02E5B8;
    v20[1] = v24;
    v21[0] = v19;
    v21[1] = v20;
    v23 = 263;
    v22 = (const void **)v18;
    mlir::OpState::emitOpError(a1, &v22, (uint64_t)v26);
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
    if (v26[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v26);
    if (v33)
    {
      v10 = __p;
      if (__p)
      {
        v11 = v32;
        v12 = __p;
        if (v32 != __p)
        {
          do
            v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          v12 = __p;
        }
        v32 = v10;
        operator delete(v12);
      }
      v13 = v29;
      if (v29)
      {
        v14 = v30;
        v15 = v29;
        if (v30 != v29)
        {
          do
          {
            v17 = *--v14;
            v16 = v17;
            *v14 = 0;
            if (v17)
              MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
          }
          while (v14 != v13);
          v15 = v29;
        }
        v30 = v13;
        operator delete(v15);
      }
      if (v27 != &v28)
        free(v27);
    }
  }
}

uint64_t mlir::mps::DequantizeOp::hasNDParams(mlir::mps::DequantizeOp *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v14;
  uint64_t v15;

  v1 = *(_QWORD **)(*(_QWORD *)this + 72);
  v2 = v1[11];
  v3 = v1[15];
  v4 = (_QWORD *)(*(_QWORD *)(v1[7] + 8) & 0xFFFFFFFFFFFFFFF8);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8))
  {
    v5 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v4 + 8);
    v14 = v4;
    v15 = v5;
    if (v4)
    {
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v14))
      {
        mlir::ShapedType::getShape((mlir::ShapedType *)&v14);
        if (v6 > 1)
          return 1;
      }
    }
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  v7 = (_QWORD *)(*(_QWORD *)(v2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8))
  {
    v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
    v14 = v7;
    v15 = v8;
    if (v7)
    {
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v14))
      {
        mlir::ShapedType::getShape((mlir::ShapedType *)&v14);
        if (v9 > 1)
          return 1;
      }
    }
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  v10 = (_QWORD *)(*(_QWORD *)(v3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v10 + 8))
  {
    v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v10 + 8);
    v14 = v10;
    v15 = v11;
    if (v10)
    {
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v14))
      {
        mlir::ShapedType::getShape((mlir::ShapedType *)&v14);
        if (v12 > 1)
          return 1;
      }
    }
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  return 0;
}

uint64_t mlir::mps::QuantizeOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  uint64_t Context;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *Value;
  uint64_t ElementTypeOrSelf;
  uint64_t v26;
  uint64_t v27[2];
  __int128 v28;
  char v29;
  uint64_t v30;
  _BYTE v31[8];
  char v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (a7)
    v14 = *a7;
  else
    v14 = 0uLL;
  v30 = a6;
  v31[0] = 0;
  v32 = 0;
  v33 = v14;
  v34 = a9;
  v35 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v30);
    if (v32)
      v32 = 0;
    mlir::OperationName::OperationName(v31, "mps.quantize", 12, Context);
    v32 = 1;
  }
  *(_QWORD *)&v36 = a4;
  *((_QWORD *)&v36 + 1) = a5;
  if (a5
    && (v16 = mlir::UnknownLoc::get(this, a2), mlir::mps::QuantizeOpAdaptor::verify((uint64_t)&v30, v16)))
  {
    v17 = *((_QWORD *)&v33 + 1);
    v37 = v36;
    v18 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v18)
      v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v18 + 8);
    else
      v19 = 0;
    v27[0] = (uint64_t)v18;
    v27[1] = v19;
    v26 = v17;
    Value = (_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v26);
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(Value);
    LOBYTE(v28) = 0;
    v29 = 0;
    v21 = mlir::ShapedType::cloneWith(v27, &v28, ElementTypeOrSelf);
    v22 = *(unsigned int *)(a11 + 8);
    if (v22 >= *(_DWORD *)(a11 + 12))
      goto LABEL_16;
  }
  else
  {
    v20 = mlir::Float32Type::get(this, a2);
    v21 = mlir::UnrankedTensorType::get(v20);
    v22 = *(unsigned int *)(a11 + 8);
    if (v22 >= *(_DWORD *)(a11 + 12))
    {
LABEL_16:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
      LODWORD(v22) = *(_DWORD *)(a11 + 8);
    }
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v22) = v21;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::QuantizeOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v20[4];
  __int16 v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 32))
  {
    v3 = *(_QWORD *)(a1 + 24);
    v22[0] = *(_QWORD *)(a1 + 32);
    mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v22);
    if (!v3)
      return 1;
    v20[0] = v3;
    v22[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v20);
    if (mlir::Type::isSignedInteger((mlir::Type *)v22, 32))
      return 1;
    v20[0] = "'mps.quantize' op attribute 'axis' failed to satisfy constraint: 32-bit signed integer attribute";
    v21 = 259;
    mlir::emitError(a2, (uint64_t)v20, (uint64_t)v22);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
    if (v22[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
    if (v29)
    {
      v13 = __p;
      if (__p)
      {
        v14 = v28;
        v15 = __p;
        if (v28 != __p)
        {
          do
            v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          v15 = __p;
        }
        v28 = v13;
        operator delete(v15);
      }
      v8 = v25;
      if (!v25)
        goto LABEL_35;
      v16 = v26;
      v10 = v25;
      if (v26 == v25)
      {
LABEL_34:
        v26 = v8;
        operator delete(v10);
LABEL_35:
        if (v23 != &v24)
          free(v23);
        return v4;
      }
      do
      {
        v18 = *--v16;
        v17 = v18;
        *v16 = 0;
        if (v18)
          MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
      }
      while (v16 != v8);
LABEL_33:
      v10 = v25;
      goto LABEL_34;
    }
  }
  else
  {
    v20[0] = "'mps.quantize' op requires attribute 'dtype'";
    v21 = 259;
    mlir::emitError(a2, (uint64_t)v20, (uint64_t)v22);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
    if (v22[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
    if (v29)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v28;
        v7 = __p;
        if (v28 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v28 = v5;
        operator delete(v7);
      }
      v8 = v25;
      if (!v25)
        goto LABEL_35;
      v9 = v26;
      v10 = v25;
      if (v26 == v25)
        goto LABEL_34;
      do
      {
        v12 = *--v9;
        v11 = v12;
        *v9 = 0;
        if (v12)
          MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
      }
      while (v9 != v8);
      goto LABEL_33;
    }
  }
  return v4;
}

uint64_t mlir::mps::DequantizeOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  uint64_t Context;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *Value;
  uint64_t ElementTypeOrSelf;
  uint64_t v26;
  uint64_t v27[2];
  __int128 v28;
  char v29;
  uint64_t v30;
  _BYTE v31[8];
  char v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (a7)
    v14 = *a7;
  else
    v14 = 0uLL;
  v30 = a6;
  v31[0] = 0;
  v32 = 0;
  v33 = v14;
  v34 = a9;
  v35 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v30);
    if (v32)
      v32 = 0;
    mlir::OperationName::OperationName(v31, "mps.dequantize", 14, Context);
    v32 = 1;
  }
  *(_QWORD *)&v36 = a4;
  *((_QWORD *)&v36 + 1) = a5;
  if (a5
    && (v16 = mlir::UnknownLoc::get(this, a2),
        mlir::mps::DequantizeOpAdaptor::verify((uint64_t)&v30, v16)))
  {
    v17 = *((_QWORD *)&v33 + 1);
    v37 = v36;
    v18 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v18)
      v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v18 + 8);
    else
      v19 = 0;
    v27[0] = (uint64_t)v18;
    v27[1] = v19;
    v26 = v17;
    Value = (_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v26);
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(Value);
    LOBYTE(v28) = 0;
    v29 = 0;
    v21 = mlir::ShapedType::cloneWith(v27, &v28, ElementTypeOrSelf);
    v22 = *(unsigned int *)(a11 + 8);
    if (v22 >= *(_DWORD *)(a11 + 12))
      goto LABEL_16;
  }
  else
  {
    v20 = mlir::Float32Type::get(this, a2);
    v21 = mlir::UnrankedTensorType::get(v20);
    v22 = *(unsigned int *)(a11 + 8);
    if (v22 >= *(_DWORD *)(a11 + 12))
    {
LABEL_16:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
      LODWORD(v22) = *(_DWORD *)(a11 + 8);
    }
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v22) = v21;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::DequantizeOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v20[4];
  __int16 v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 32))
  {
    v3 = *(_QWORD *)(a1 + 24);
    v22[0] = *(_QWORD *)(a1 + 32);
    mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v22);
    if (!v3)
      return 1;
    v20[0] = v3;
    v22[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v20);
    if (mlir::Type::isSignedInteger((mlir::Type *)v22, 32))
      return 1;
    v20[0] = "'mps.dequantize' op attribute 'axis' failed to satisfy constraint: 32-bit signed integer attribute";
    v21 = 259;
    mlir::emitError(a2, (uint64_t)v20, (uint64_t)v22);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
    if (v22[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
    if (v29)
    {
      v13 = __p;
      if (__p)
      {
        v14 = v28;
        v15 = __p;
        if (v28 != __p)
        {
          do
            v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          v15 = __p;
        }
        v28 = v13;
        operator delete(v15);
      }
      v8 = v25;
      if (!v25)
        goto LABEL_35;
      v16 = v26;
      v10 = v25;
      if (v26 == v25)
      {
LABEL_34:
        v26 = v8;
        operator delete(v10);
LABEL_35:
        if (v23 != &v24)
          free(v23);
        return v4;
      }
      do
      {
        v18 = *--v16;
        v17 = v18;
        *v16 = 0;
        if (v18)
          MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
      }
      while (v16 != v8);
LABEL_33:
      v10 = v25;
      goto LABEL_34;
    }
  }
  else
  {
    v20[0] = "'mps.dequantize' op requires attribute 'dtype'";
    v21 = 259;
    mlir::emitError(a2, (uint64_t)v20, (uint64_t)v22);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
    if (v22[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
    if (v29)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v28;
        v7 = __p;
        if (v28 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v28 = v5;
        operator delete(v7);
      }
      v8 = v25;
      if (!v25)
        goto LABEL_35;
      v9 = v26;
      v10 = v25;
      if (v26 == v25)
        goto LABEL_34;
      do
      {
        v12 = *--v9;
        v11 = v12;
        *v9 = 0;
        if (v12)
          MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
      }
      while (v9 != v8);
      goto LABEL_33;
    }
  }
  return v4;
}

uint64_t mlir::mps::DequantizeLUTOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v16;
  uint64_t Context;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *OperandRange;
  uint64_t v25;
  uint64_t v26;
  uint64_t ElementTypeOrSelf;
  uint64_t v28;
  uint64_t Axis;
  uint64_t v30;
  unint64_t PositiveAxis;
  char v32;
  unint64_t v33;
  const void *Shape;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v43[2];
  uint64_t v44[2];
  __int128 v45;
  char v46;
  uint64_t v47;
  _BYTE v48[8];
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  _QWORD v55[3];

  v55[2] = *MEMORY[0x24BDAC8D0];
  v55[0] = a4;
  v55[1] = a5;
  if (a7)
    v16 = *a7;
  else
    v16 = 0;
  v47 = a6;
  v48[0] = 0;
  v49 = 0;
  v50 = v16;
  v51 = a9;
  v52 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v47);
    if (v49)
      v49 = 0;
    mlir::OperationName::OperationName(v48, "mps.dequantize_lut", 18, Context);
    v49 = 1;
  }
  v53 = a4;
  v54 = a5;
  if (a5 < 2
    || (v18 = mlir::UnknownLoc::get(this, a2),
        !mlir::mps::DequantizeLUTOpAdaptor::verify((uint64_t)&v47, v18)))
  {
    v21 = mlir::Float32Type::get(this, a2);
LABEL_31:
    v28 = mlir::UnrankedTensorType::get(v21);
    goto LABEL_32;
  }
  v19 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v55, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v19)
    v20 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  else
    v20 = 0;
  v44[0] = (uint64_t)v19;
  v44[1] = v20;
  v22 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v55, 1) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v22)
    v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  else
    v23 = 0;
  v43[0] = v22;
  v43[1] = v23;
  OperandRange = (_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v43);
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v43) & 1) == 0)
    goto LABEL_30;
  mlir::ShapedType::getShape((mlir::ShapedType *)v43);
  if (v25 == 1
    || !v50
    || (v26 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)v43) + 8 * (v25 - 1)), v26 == 1))
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(OperandRange);
    LOBYTE(v45) = 0;
    v46 = 0;
    v28 = mlir::ShapedType::cloneWith(v44, &v45, ElementTypeOrSelf);
LABEL_32:
    v40 = v28;
    v41 = *(unsigned int *)(a11 + 8);
    if (v41 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v41 + 1, 8);
      LODWORD(v41) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v41) = v40;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44) || !v50)
  {
LABEL_30:
    v21 = (uint64_t)OperandRange;
    goto LABEL_31;
  }
  Axis = (int)mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis((mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase *)&v47);
  mlir::ShapedType::getShape((mlir::ShapedType *)v44);
  if (v32)
  {
    v33 = PositiveAxis;
    Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v44);
    llvm::SmallVector<long long,5u>::SmallVector<long long,void>(&v45, Shape, v35);
    v36 = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
    v37 = 0x8000000000000000;
    v38 = v45;
    if (v26 != 0x8000000000000000 && *(_QWORD *)(v36 + 8 * v33) != 0x8000000000000000)
      v37 = *(_QWORD *)(v45 + 8 * v33) * v26;
    *(_QWORD *)(v45 + 8 * v33) = v37;
    v39 = mlir::RankedTensorType::get(v38, DWORD2(v45), (uint64_t)OperandRange, 0);
    llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v39);
    if ((char *)v45 != &v46)
      free((void *)v45);
    return 1;
  }
  return mlir::mps::ResizeOp::inferReturnTypes(mlir::MLIRContext *,std::optional<mlir::Location>,mlir::ValueRange,mlir::DictionaryAttr,mlir::OpaqueProperties,mlir::RegionRange,llvm::SmallVectorImpl<mlir::Type> &)::$_0::operator()(a11, (uint64_t)OperandRange);
}

uint64_t mlir::mps::DequantizeLUTOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[4];
  __int16 v14;
  _QWORD v15[3];
  void *v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  void *__p;
  _QWORD *v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 24))
    return 1;
  v13[0] = *(_QWORD *)(a1 + 24);
  v15[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13);
  if (mlir::Type::isSignedInteger((mlir::Type *)v15, 32))
    return 1;
  v13[0] = "'mps.dequantize_lut' op attribute 'axis' failed to satisfy constraint: 32-bit signed integer attribute";
  v14 = 259;
  mlir::emitError(a2, (uint64_t)v13, (uint64_t)v15);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
  if (v15[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
  if (v22)
  {
    v5 = __p;
    if (__p)
    {
      v6 = v21;
      v7 = __p;
      if (v21 != __p)
      {
        do
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        v7 = __p;
      }
      v21 = v5;
      operator delete(v7);
    }
    v8 = v18;
    if (v18)
    {
      v9 = v19;
      v10 = v18;
      if (v19 != v18)
      {
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
        }
        while (v9 != v8);
        v10 = v18;
      }
      v19 = v8;
      operator delete(v10);
    }
    if (v16 != &v17)
      free(v16);
  }
  return v3;
}

unint64_t mlir::mps::`anonymous namespace'::tryGetPositiveAxis(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t *a5)
{
  const char *v7;
  int *v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  int *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  int *v34;
  char *v35;
  char *v36;
  __int128 v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v49;
  unint64_t v50;
  BOOL v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  BOOL v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  int64_t v63;
  int64_t v64;
  int64_t v65;
  const void **v66[4];
  __int16 v67;
  uint64_t v68;
  int v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72[3];
  void *v73;
  unsigned int v74;
  unsigned int v75;
  _BYTE v76[96];
  void *v77;
  _QWORD *v78;
  void *__p;
  _QWORD *v80;
  char v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v68 = a1;
  v7 = (const char *)-a2;
  if (-a2 > a1 || a2 <= a1)
  {
    if (a5)
    {
      v66[0] = (const void **)"invalid axis ";
      v67 = 259;
      mlir::Operation::emitOpError(a5, v66, (uint64_t)v72);
      if (v72[0])
      {
        v69 = 2;
        v70 = (const char *)a1;
        v9 = &v69;
        v10 = (char *)v73;
        if (v74 >= v75)
        {
          v49 = v74 + 1;
          if (v73 <= &v69 && (char *)v73 + 24 * v74 > (char *)&v69)
          {
            v60 = (char *)&v69 - (_BYTE *)v73;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v49, 24);
            v10 = (char *)v73;
            v9 = (int *)((char *)v73 + v60);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v49, 24);
            v9 = &v69;
            v10 = (char *)v73;
          }
        }
        v11 = &v10[24 * v74];
        v12 = *(_OWORD *)v9;
        *((_QWORD *)v11 + 2) = *((_QWORD *)v9 + 2);
        *(_OWORD *)v11 = v12;
        v13 = ++v74;
        if (v72[0])
        {
          v69 = 3;
          v70 = " is outside of the range [";
          v71 = 26;
          v14 = &v69;
          v15 = (char *)v73;
          if (v13 >= v75)
          {
            v50 = v13 + 1;
            v51 = (char *)v73 + 24 * v13 > (char *)&v69;
            if (v73 <= &v69 && v51)
            {
              v61 = (char *)&v69 - (_BYTE *)v73;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v50, 24);
              v15 = (char *)v73;
              v14 = (int *)((char *)v73 + v61);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v50, 24);
              v14 = &v69;
              v15 = (char *)v73;
            }
          }
          v16 = &v15[24 * v74];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          v18 = ++v74;
          if (v72[0])
          {
            v69 = 2;
            v70 = v7;
            v19 = &v69;
            v20 = (char *)v73;
            if (v18 >= v75)
            {
              v52 = v18 + 1;
              v53 = (char *)v73 + 24 * v18 > (char *)&v69;
              if (v73 <= &v69 && v53)
              {
                v62 = (char *)&v69 - (_BYTE *)v73;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v52, 24);
                v20 = (char *)v73;
                v19 = (int *)((char *)v73 + v62);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v52, 24);
                v19 = &v69;
                v20 = (char *)v73;
              }
            }
            v21 = &v20[24 * v74];
            v22 = *(_OWORD *)v19;
            *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
            *(_OWORD *)v21 = v22;
            v23 = ++v74;
            if (v72[0])
            {
              v69 = 3;
              v70 = ", ";
              v71 = 2;
              v24 = &v69;
              v25 = (char *)v73;
              if (v23 >= v75)
              {
                v54 = v23 + 1;
                v55 = (char *)v73 + 24 * v23 > (char *)&v69;
                if (v73 <= &v69 && v55)
                {
                  v63 = (char *)&v69 - (_BYTE *)v73;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v54, 24);
                  v25 = (char *)v73;
                  v24 = (int *)((char *)v73 + v63);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v54, 24);
                  v24 = &v69;
                  v25 = (char *)v73;
                }
              }
              v26 = &v25[24 * v74];
              v27 = *(_OWORD *)v24;
              *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
              *(_OWORD *)v26 = v27;
              v28 = ++v74;
              if (v72[0])
              {
                v69 = 2;
                v70 = (const char *)(a2 - 1);
                v29 = &v69;
                v30 = (char *)v73;
                if (v28 >= v75)
                {
                  v56 = v28 + 1;
                  v57 = (char *)v73 + 24 * v28 > (char *)&v69;
                  if (v73 <= &v69 && v57)
                  {
                    v64 = (char *)&v69 - (_BYTE *)v73;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v56, 24);
                    v30 = (char *)v73;
                    v29 = (int *)((char *)v73 + v64);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v56, 24);
                    v29 = &v69;
                    v30 = (char *)v73;
                  }
                }
                v31 = &v30[24 * v74];
                v32 = *(_OWORD *)v29;
                *((_QWORD *)v31 + 2) = *((_QWORD *)v29 + 2);
                *(_OWORD *)v31 = v32;
                v33 = ++v74;
                if (v72[0])
                {
                  v69 = 3;
                  v70 = "].";
                  v71 = 2;
                  v34 = &v69;
                  v35 = (char *)v73;
                  if (v33 >= v75)
                  {
                    v58 = v33 + 1;
                    v59 = (char *)v73 + 24 * v33 > (char *)&v69;
                    if (v73 <= &v69 && v59)
                    {
                      v65 = (char *)&v69 - (_BYTE *)v73;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v58, 24);
                      v35 = (char *)v73;
                      v34 = (int *)((char *)v73 + v65);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v73, v76, v58, 24);
                      v34 = &v69;
                      v35 = (char *)v73;
                    }
                  }
                  v36 = &v35[24 * v74];
                  v37 = *(_OWORD *)v34;
                  *((_QWORD *)v36 + 2) = *((_QWORD *)v34 + 2);
                  *(_OWORD *)v36 = v37;
                  ++v74;
                  if (v72[0])
                    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v72);
                }
              }
            }
          }
        }
      }
      if (v81)
      {
        v38 = __p;
        if (__p)
        {
          v39 = v80;
          v40 = __p;
          if (v80 != __p)
          {
            do
              v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
            while (v39 != v38);
            v40 = __p;
          }
          v80 = v38;
          operator delete(v40);
        }
        v41 = v77;
        if (v77)
        {
          v42 = v78;
          v43 = v77;
          if (v78 != v77)
          {
            do
            {
              v45 = *--v42;
              v44 = v45;
              *v42 = 0;
              if (v45)
                MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
            }
            while (v42 != v41);
            v43 = v77;
          }
          v78 = v41;
          operator delete(v43);
        }
        if (v73 != v76)
          free(v73);
      }
    }
    else
    {
      v72[0] = -a2;
      v66[0] = (const void **)(a2 - 1);
      mlir::emitOptionalError<char const(&)[14],long long &,char const(&)[27],long long,char const(&)[3],long long,char const(&)[2]>(a3, a4, "invalid axis ", &v68, " is outside of the range [", v72, ", ", (uint64_t *)v66, "]");
    }
    v47 = 0;
    v46 = 0;
  }
  else
  {
    v46 = ((a2 & (a1 >> 63)) + a1) & 0xFFFFFFFFFFFFFF00;
    v47 = ((a2 & (a1 >> 63)) + a1);
  }
  return v46 | v47;
}

uint64_t mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase *this)
{
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;

  v5 = *((_QWORD *)this + 3);
  if (!v5)
    return 0;
  mlir::IntegerAttr::getValue(&v5, (llvm::APInt *)&v3);
  if (v4 <= 0x40)
    return ((uint64_t)((_QWORD)v3 << -(uint64_t)v4) >> -(uint64_t)v4) | 0x100000000;
  v2 = *v3;
  MEMORY[0x20BD002D4]();
  return v2 | 0x100000000;
}

uint64_t mlir::mps::verifyDequantLUT(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int IntOrFloatBitWidth;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  int8x8_t v18;
  int8x8_t *v19;
  unsigned int v20;
  uint64_t Shape;
  uint8x8_t v22;
  const char *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  char *v48;
  char *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  char *v63;
  char *v64;
  __int128 v65;
  _QWORD *v66;
  _QWORD *v67;
  void *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  int *v72;
  char *v73;
  char *v74;
  __int128 v75;
  uint64_t v76;
  int *v77;
  char *v78;
  char *v79;
  __int128 v80;
  uint64_t v81;
  int *v82;
  char *v83;
  char *v84;
  __int128 v85;
  uint64_t v86;
  int *v87;
  char *v88;
  char *v89;
  __int128 v90;
  uint64_t v91;
  int *v92;
  char *v93;
  char *v94;
  __int128 v95;
  uint64_t v96;
  int *v97;
  char *v98;
  char *v99;
  __int128 v100;
  _QWORD *v101;
  _QWORD *v102;
  void *v103;
  _QWORD *v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  int64_t v135;
  const void **v136[4];
  __int16 v137;
  _QWORD v138[2];
  _QWORD *v139;
  uint64_t v140;
  int v141;
  const char *v142;
  uint64_t v143;
  _QWORD v144[3];
  void *v145;
  unsigned int v146;
  unsigned int v147;
  _BYTE v148[96];
  void *v149;
  _QWORD *v150;
  void *__p;
  _QWORD *v152;
  char v153;
  uint64_t v154;

  v154 = *MEMORY[0x24BDAC8D0];
  v7 = (_QWORD *)(*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v7)
  {
    v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v7 + 8);
    v139 = v7;
    v140 = v8;
    v9 = (_QWORD *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v9)
    {
LABEL_3:
      v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v9 + 8);
      goto LABEL_6;
    }
  }
  else
  {
    v139 = 0;
    v140 = 0;
    v9 = (_QWORD *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v9)
      goto LABEL_3;
  }
  v10 = 0;
LABEL_6:
  v138[0] = v9;
  v138[1] = v10;
  v144[0] = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v139);
  IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)v144);
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v138))
    return 1;
  mlir::ShapedType::getShape((mlir::ShapedType *)v138);
  v13 = v12;
  v14 = a4 & 0xFF00000000;
  if (v12 == 1)
  {
    if (v14)
    {
      v15 = 1;
      goto LABEL_14;
    }
    goto LABEL_16;
  }
  if (!v14)
  {
LABEL_16:
    v20 = v12 - 1;
    Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v138);
    v17 = 0;
    v15 = 1;
    v18 = *(int8x8_t *)(Shape + 8 * v20);
    if (*(_QWORD *)&v18 == 0x8000000000000000)
      goto LABEL_19;
    goto LABEL_17;
  }
  v15 = *(_QWORD *)(mlir::ShapedType::getShape((mlir::ShapedType *)v138) + 8 * (v12 - 1));
  if (v13 < 3)
  {
LABEL_14:
    v19 = (int8x8_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v138);
    v17 = 1;
    v18 = *v19;
    if (*v19 == 0x8000000000000000)
      goto LABEL_19;
    goto LABEL_17;
  }
  v16 = mlir::ShapedType::getShape((mlir::ShapedType *)v138);
  v17 = 1;
  v18 = *(int8x8_t *)(v16 + 8 * (v13 - 2));
  if (*(_QWORD *)&v18 == 0x8000000000000000)
    goto LABEL_19;
LABEL_17:
  v22 = (uint8x8_t)vcnt_s8(v18);
  v22.i16[0] = vaddlv_u8(v22);
  if (v22.u32[0] != 1)
  {
    v137 = 257;
    mlir::Operation::emitOpError(a1, v136, (uint64_t)v144);
    if (v144[0])
    {
      v141 = 3;
      v143 = 10;
      v42 = &v141;
      v43 = (char *)v145;
      if (v146 >= v147)
      {
        v107 = v146 + 1;
        if (v145 <= &v141 && (char *)v145 + 24 * v146 > (char *)&v141)
        {
          v125 = (char *)&v141 - (_BYTE *)v145;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v107, 24);
          v43 = (char *)v145;
          v42 = (int *)((char *)v145 + v125);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v107, 24);
          v42 = &v141;
          v43 = (char *)v145;
        }
      }
      v44 = &v43[24 * v146];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      v46 = ++v146;
      if (v144[0])
      {
        v141 = 2;
        v142 = (const char *)v18;
        v47 = &v141;
        v48 = (char *)v145;
        if (v46 >= v147)
        {
          v109 = v46 + 1;
          v110 = (char *)v145 + 24 * v46 > (char *)&v141;
          if (v145 <= &v141 && v110)
          {
            v127 = (char *)&v141 - (_BYTE *)v145;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v109, 24);
            v48 = (char *)v145;
            v47 = (int *)((char *)v145 + v127);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v109, 24);
            v47 = &v141;
            v48 = (char *)v145;
          }
        }
        v49 = &v48[24 * v146];
        v50 = *(_OWORD *)v47;
        *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
        *(_OWORD *)v49 = v50;
        v51 = ++v146;
        if (v144[0])
        {
          v141 = 3;
          v143 = 22;
          v52 = &v141;
          v53 = (char *)v145;
          if (v51 >= v147)
          {
            v113 = v51 + 1;
            v114 = (char *)v145 + 24 * v51 > (char *)&v141;
            if (v145 <= &v141 && v114)
            {
              v130 = (char *)&v141 - (_BYTE *)v145;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v113, 24);
              v53 = (char *)v145;
              v52 = (int *)((char *)v145 + v130);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v113, 24);
              v52 = &v141;
              v53 = (char *)v145;
            }
          }
          v54 = &v53[24 * v146];
          v55 = *(_OWORD *)v52;
          *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
          *(_OWORD *)v54 = v55;
          ++v146;
        }
      }
    }
    v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v144);
    if (v144[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v144);
    if (v153)
    {
      v56 = __p;
      if (__p)
      {
        v57 = v152;
        v58 = __p;
        if (v152 != __p)
        {
          do
            v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
          while (v57 != v56);
          v58 = __p;
        }
        v152 = v56;
        operator delete(v58);
      }
      v36 = v149;
      if (!v149)
        goto LABEL_109;
      v59 = v150;
      v38 = v149;
      if (v150 == v149)
        goto LABEL_108;
      do
      {
        v61 = *--v59;
        v60 = v61;
        *v59 = 0;
        if (v61)
          MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
      }
      while (v59 != v36);
      goto LABEL_107;
    }
    return v32;
  }
  v23 = (const char *)IntOrFloatBitWidth;
  v24 = (const char *)(1 << IntOrFloatBitWidth);
  if ((const char *)v18 != v24)
  {
    v137 = 257;
    mlir::Operation::emitOpError(a1, v136, (uint64_t)v144);
    if (v144[0])
    {
      v141 = 3;
      v143 = 10;
      v72 = &v141;
      v73 = (char *)v145;
      if (v146 >= v147)
      {
        v112 = v146 + 1;
        if (v145 <= &v141 && (char *)v145 + 24 * v146 > (char *)&v141)
        {
          v129 = (char *)&v141 - (_BYTE *)v145;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v112, 24);
          v73 = (char *)v145;
          v72 = (int *)((char *)v145 + v129);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v112, 24);
          v72 = &v141;
          v73 = (char *)v145;
        }
      }
      v74 = &v73[24 * v146];
      v75 = *(_OWORD *)v72;
      *((_QWORD *)v74 + 2) = *((_QWORD *)v72 + 2);
      *(_OWORD *)v74 = v75;
      v76 = ++v146;
      if (v144[0])
      {
        v141 = 2;
        v142 = (const char *)v18;
        v77 = &v141;
        v78 = (char *)v145;
        if (v76 >= v147)
        {
          v115 = v76 + 1;
          v116 = (char *)v145 + 24 * v76 > (char *)&v141;
          if (v145 <= &v141 && v116)
          {
            v131 = (char *)&v141 - (_BYTE *)v145;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v115, 24);
            v78 = (char *)v145;
            v77 = (int *)((char *)v145 + v131);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v115, 24);
            v77 = &v141;
            v78 = (char *)v145;
          }
        }
        v79 = &v78[24 * v146];
        v80 = *(_OWORD *)v77;
        *((_QWORD *)v79 + 2) = *((_QWORD *)v77 + 2);
        *(_OWORD *)v79 = v80;
        v81 = ++v146;
        if (v144[0])
        {
          v141 = 3;
          v143 = 41;
          v82 = &v141;
          v83 = (char *)v145;
          if (v81 >= v147)
          {
            v117 = v81 + 1;
            v118 = (char *)v145 + 24 * v81 > (char *)&v141;
            if (v145 <= &v141 && v118)
            {
              v132 = (char *)&v141 - (_BYTE *)v145;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v117, 24);
              v83 = (char *)v145;
              v82 = (int *)((char *)v145 + v132);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v117, 24);
              v82 = &v141;
              v83 = (char *)v145;
            }
          }
          v84 = &v83[24 * v146];
          v85 = *(_OWORD *)v82;
          *((_QWORD *)v84 + 2) = *((_QWORD *)v82 + 2);
          *(_OWORD *)v84 = v85;
          v86 = ++v146;
          if (v144[0])
          {
            v141 = 2;
            v142 = v23;
            v87 = &v141;
            v88 = (char *)v145;
            if (v86 >= v147)
            {
              v119 = v86 + 1;
              v120 = (char *)v145 + 24 * v86 > (char *)&v141;
              if (v145 <= &v141 && v120)
              {
                v133 = (char *)&v141 - (_BYTE *)v145;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v119, 24);
                v88 = (char *)v145;
                v87 = (int *)((char *)v145 + v133);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v119, 24);
                v87 = &v141;
                v88 = (char *)v145;
              }
            }
            v89 = &v88[24 * v146];
            v90 = *(_OWORD *)v87;
            *((_QWORD *)v89 + 2) = *((_QWORD *)v87 + 2);
            *(_OWORD *)v89 = v90;
            v91 = ++v146;
            if (v144[0])
            {
              v141 = 3;
              v142 = "=";
              v143 = 1;
              v92 = &v141;
              v93 = (char *)v145;
              if (v91 >= v147)
              {
                v121 = v91 + 1;
                v122 = (char *)v145 + 24 * v91 > (char *)&v141;
                if (v145 <= &v141 && v122)
                {
                  v134 = (char *)&v141 - (_BYTE *)v145;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v121, 24);
                  v93 = (char *)v145;
                  v92 = (int *)((char *)v145 + v134);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v121, 24);
                  v92 = &v141;
                  v93 = (char *)v145;
                }
              }
              v94 = &v93[24 * v146];
              v95 = *(_OWORD *)v92;
              *((_QWORD *)v94 + 2) = *((_QWORD *)v92 + 2);
              *(_OWORD *)v94 = v95;
              v96 = ++v146;
              if (v144[0])
              {
                v141 = 2;
                v142 = v24;
                v97 = &v141;
                v98 = (char *)v145;
                if (v96 >= v147)
                {
                  v123 = v96 + 1;
                  v124 = (char *)v145 + 24 * v96 > (char *)&v141;
                  if (v145 <= &v141 && v124)
                  {
                    v135 = (char *)&v141 - (_BYTE *)v145;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v123, 24);
                    v98 = (char *)v145;
                    v97 = (int *)((char *)v145 + v135);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v123, 24);
                    v97 = &v141;
                    v98 = (char *)v145;
                  }
                }
                v99 = &v98[24 * v146];
                v100 = *(_OWORD *)v97;
                *((_QWORD *)v99 + 2) = *((_QWORD *)v97 + 2);
                *(_OWORD *)v99 = v100;
                ++v146;
              }
            }
          }
        }
      }
    }
    v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v144);
    if (v144[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v144);
    if (v153)
    {
      v101 = __p;
      if (__p)
      {
        v102 = v152;
        v103 = __p;
        if (v152 != __p)
        {
          do
            v102 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v102 - 1);
          while (v102 != v101);
          v103 = __p;
        }
        v152 = v101;
        operator delete(v103);
      }
      v36 = v149;
      if (!v149)
        goto LABEL_109;
      v104 = v150;
      v38 = v149;
      if (v150 == v149)
        goto LABEL_108;
      do
      {
        v106 = *--v104;
        v105 = v106;
        *v104 = 0;
        if (v106)
          MEMORY[0x20BD002D4](v105, 0x1000C8077774924);
      }
      while (v104 != v36);
      goto LABEL_107;
    }
    return v32;
  }
LABEL_19:
  if ((v17 & 1) != 0)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v139);
    v26 = (v25 & ((uint64_t)(int)a4 >> 31)) + (int)a4;
    if (v26 < 0 || (mlir::ShapedType::getShape((mlir::ShapedType *)&v139), v26 >= v27))
    {
      v137 = 257;
      mlir::Operation::emitOpError(a1, v136, (uint64_t)v144);
      if (v144[0])
      {
        v141 = 3;
        v142 = "axis value is not compatible with input rank";
        v143 = 44;
        v28 = &v141;
        v29 = (char *)v145;
        if (v146 >= v147)
        {
          v108 = v146 + 1;
          if (v145 <= &v141 && (char *)v145 + 24 * v146 > (char *)&v141)
          {
            v126 = (char *)&v141 - (_BYTE *)v145;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v108, 24);
            v29 = (char *)v145;
            v28 = (int *)((char *)v145 + v126);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v108, 24);
            v28 = &v141;
            v29 = (char *)v145;
          }
        }
        v30 = &v29[24 * v146];
        v31 = *(_OWORD *)v28;
        *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
        *(_OWORD *)v30 = v31;
        ++v146;
      }
      v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v144);
      if (v144[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v144);
      if (v153)
      {
        v33 = __p;
        if (__p)
        {
          v34 = v152;
          v35 = __p;
          if (v152 != __p)
          {
            do
              v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            v35 = __p;
          }
          v152 = v33;
          operator delete(v35);
        }
        v36 = v149;
        if (!v149)
          goto LABEL_109;
        v37 = v150;
        v38 = v149;
        if (v150 == v149)
        {
LABEL_108:
          v150 = v36;
          operator delete(v38);
LABEL_109:
          if (v145 != v148)
            free(v145);
          return v32;
        }
        do
        {
          v40 = *--v37;
          v39 = v40;
          *v37 = 0;
          if (v40)
            MEMORY[0x20BD002D4](v39, 0x1000C8077774924);
        }
        while (v37 != v36);
LABEL_107:
        v38 = v149;
        goto LABEL_108;
      }
      return v32;
    }
    return 1;
  }
  if (v15 < 2)
    return 1;
  v137 = 257;
  mlir::Operation::emitOpError(a1, v136, (uint64_t)v144);
  if (v144[0])
  {
    v141 = 3;
    v142 = "axis must be defined when LUT Vector size > 1";
    v143 = 45;
    v62 = &v141;
    v63 = (char *)v145;
    if (v146 >= v147)
    {
      v111 = v146 + 1;
      if (v145 <= &v141 && (char *)v145 + 24 * v146 > (char *)&v141)
      {
        v128 = (char *)&v141 - (_BYTE *)v145;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v111, 24);
        v63 = (char *)v145;
        v62 = (int *)((char *)v145 + v128);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v145, v148, v111, 24);
        v62 = &v141;
        v63 = (char *)v145;
      }
    }
    v64 = &v63[24 * v146];
    v65 = *(_OWORD *)v62;
    *((_QWORD *)v64 + 2) = *((_QWORD *)v62 + 2);
    *(_OWORD *)v64 = v65;
    ++v146;
  }
  v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v144);
  if (v144[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v144);
  if (v153)
  {
    v66 = __p;
    if (__p)
    {
      v67 = v152;
      v68 = __p;
      if (v152 != __p)
      {
        do
          v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        v68 = __p;
      }
      v152 = v66;
      operator delete(v68);
    }
    v36 = v149;
    if (!v149)
      goto LABEL_109;
    v69 = v150;
    v38 = v149;
    if (v150 == v149)
      goto LABEL_108;
    do
    {
      v71 = *--v69;
      v70 = v71;
      *v69 = 0;
      if (v71)
        MEMORY[0x20BD002D4](v70, 0x1000C8077774924);
    }
    while (v69 != v36);
    goto LABEL_107;
  }
  return v32;
}

uint64_t mlir::mps::UnrealizedFoldOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  const void **v7;
  unint64_t v8;
  int v9;
  BOOL v10;
  char v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  const void **v25[4];
  __int16 v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD v30[3];
  void *v31;
  uint64_t v32;
  void *v33;
  _QWORD *v34;
  void *__p;
  _QWORD *v36;
  char v37;
  _QWORD v38[3];
  _QWORD *v39;
  unint64_t v40[2];
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v28 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange((unint64_t *)&v41, (uint64_t)&v28, 1uLL);
  v27 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v40, (uint64_t)&v27, 1uLL);
  v38[0] = &off_24BFF49B0;
  v39 = v38;
  if (v42 != v40[1])
  {
    (*(void (**)(_QWORD *))(v38[0] + 32))(v38);
    goto LABEL_24;
  }
  v2 = v41;
  v3 = v40[0];
  v30[0] = &off_24C059F88;
  v30[1] = v38;
  v4 = v30;
  v31 = v30;
  if (v42)
  {
    v5 = 0;
    v6 = v42 - 1;
    do
    {
      v7 = (const void **)mlir::TypeRange::dereference_iterator(v2, v5);
      v8 = mlir::TypeRange::dereference_iterator(v3, v5);
      v25[0] = v7;
      v29 = v8;
      if (!v31)
        std::__throw_bad_function_call[abi:nn180100]();
      v9 = (*(uint64_t (**)(void *, const void ***, unint64_t *))(*(_QWORD *)v31 + 48))(v31, v25, &v29);
      if (v9)
        v10 = v6 == v5;
      else
        v10 = 1;
      ++v5;
    }
    while (!v10);
    v11 = v9;
    v4 = v31;
    if (v31 == v30)
    {
      v12 = 4;
      v4 = v30;
    }
    else
    {
      if (!v31)
        goto LABEL_17;
      v12 = 5;
    }
  }
  else
  {
    v11 = 1;
    v12 = 4;
  }
  (*(void (**)(void))(*v4 + 8 * v12))();
LABEL_17:
  v13 = v39;
  if (v39 == v38)
  {
    v14 = 4;
    v13 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_22;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_22:
  if ((v11 & 1) != 0)
    return 1;
LABEL_24:
  v25[0] = (const void **)"failed: the input type must be more specialized than the result type";
  v26 = 259;
  mlir::OpState::emitOpError(this, v25, (uint64_t)v30);
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
  if (v30[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
  if (v37)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v36;
      v18 = __p;
      if (v36 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v36 = v16;
      operator delete(v18);
    }
    v19 = v33;
    if (v33)
    {
      v20 = v34;
      v21 = v33;
      if (v34 != v33)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v33;
      }
      v34 = v19;
      operator delete(v21);
    }
    if (v31 != &v32)
      free(v31);
  }
  return v15;
}

uint64_t mlir::mps::TypeConstraintOp::verify(uint64_t **this)
{
  char v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const void **v15[4];
  __int16 v16;
  _QWORD v17[3];
  void *v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  void *__p;
  _QWORD *v23;
  char v24;
  _QWORD v25[3];
  _QWORD *v26;
  unint64_t v27[2];
  unint64_t v28[3];

  v28[2] = *MEMORY[0x24BDAC8D0];
  v15[0] = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  mlir::ValueRange::ValueRange(v28, (uint64_t)v15, 1uLL);
  v17[0] = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v17[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v17);
  mlir::ValueRange::ValueRange(v27, (uint64_t)v17, 1uLL);
  v25[0] = &off_24BFF4A08;
  v26 = v25;
  v3 = v26;
  if (v26 == v25)
  {
    v4 = 4;
    v3 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  if ((v2 & 1) != 0)
    return 1;
  v15[0] = (const void **)"the type constraint cannot be satisfied";
  v16 = 259;
  mlir::OpState::emitOpError(this, v15, (uint64_t)v17);
  v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
  if (v17[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
  if (v24)
  {
    v6 = __p;
    if (__p)
    {
      v7 = v23;
      v8 = __p;
      if (v23 != __p)
      {
        do
          v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
        while (v7 != v6);
        v8 = __p;
      }
      v23 = v6;
      operator delete(v8);
    }
    v9 = v20;
    if (v20)
    {
      v10 = v21;
      v11 = v20;
      if (v21 != v20)
      {
        do
        {
          v13 = *--v10;
          v12 = v13;
          *v10 = 0;
          if (v13)
            MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
        }
        while (v10 != v9);
        v11 = v20;
      }
      v21 = v9;
      operator delete(v11);
    }
    if (v18 != &v19)
      free(v18);
  }
  return v5;
}

uint64_t mlir::mps::`anonymous namespace'::areCompatibleTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t (***v18)();
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v30;
  unint64_t v31;
  _BYTE v32[24];
  _BYTE *v33;
  _BYTE v34[24];
  _BYTE *v35;
  uint64_t (**v36)();
  _BYTE *v37;
  uint64_t (***v38)();
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v10 = (_QWORD *)a5[3];
  if (v10)
  {
    if (v10 == a5)
    {
      v35 = v34;
      (*(void (**)(_QWORD *, _BYTE *))(*a5 + 24))(a5, v34);
      if (a2 != a4)
        goto LABEL_21;
    }
    else
    {
      v35 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
      if (a2 != a4)
        goto LABEL_21;
    }
  }
  else
  {
    v35 = 0;
    if (a2 != a4)
      goto LABEL_21;
  }
  v36 = &off_24C059F88;
  v37 = v34;
  v38 = &v36;
  if (!a2)
    goto LABEL_19;
  v11 = 0;
  do
  {
    v12 = mlir::TypeRange::dereference_iterator(a1, v11);
    v30 = mlir::TypeRange::dereference_iterator(a3, v11);
    v31 = v12;
    if (!v38)
LABEL_55:
      std::__throw_bad_function_call[abi:nn180100]();
    v13 = ((uint64_t (*)(uint64_t (***)(), unint64_t *, unint64_t *))(*v38)[6])(v38, &v31, &v30);
    if (v13)
      v14 = a2 - 1 == v11;
    else
      v14 = 1;
    ++v11;
  }
  while (!v14);
  v15 = v13;
  if (v38 == &v36)
  {
    v36[4]();
    if ((v15 & 1) == 0)
      goto LABEL_21;
LABEL_19:
    v16 = 1;
    goto LABEL_47;
  }
  if (v38)
  {
    (*v38)[5]();
    if ((v15 & 1) == 0)
      goto LABEL_21;
    goto LABEL_19;
  }
  if ((v13 & 1) != 0)
    goto LABEL_19;
LABEL_21:
  v17 = (_QWORD *)a5[3];
  if (v17)
  {
    if (v17 != a5)
    {
      v33 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v17 + 16))(v17);
      if (a2 == a4)
        goto LABEL_24;
LABEL_36:
      v16 = 0;
      goto LABEL_37;
    }
    v33 = v32;
    (*(void (**)(_QWORD *, _BYTE *))(*a5 + 24))(a5, v32);
    if (a2 != a4)
      goto LABEL_36;
  }
  else
  {
    v33 = 0;
    if (a2 != a4)
      goto LABEL_36;
  }
LABEL_24:
  v36 = &off_24C059F88;
  v37 = v32;
  v18 = &v36;
  v38 = &v36;
  if (!a2)
  {
    v16 = 1;
    v24 = 4;
    goto LABEL_44;
  }
  v19 = 0;
  v20 = a2 - 1;
  do
  {
    v21 = mlir::TypeRange::dereference_iterator(a3, v19);
    v30 = mlir::TypeRange::dereference_iterator(a1, v19);
    v31 = v21;
    if (!v38)
      goto LABEL_55;
    v22 = ((uint64_t (*)(uint64_t (***)(), unint64_t *, unint64_t *))(*v38)[6])(v38, &v31, &v30);
    if ((_DWORD)v22)
      v23 = v20 == v19;
    else
      v23 = 1;
    ++v19;
  }
  while (!v23);
  v16 = v22;
  v18 = v38;
  if (v38 == &v36)
  {
    v24 = 4;
    v18 = &v36;
LABEL_44:
    (*v18)[v24]();
    v25 = v33;
    if (v33 == v32)
      goto LABEL_45;
    goto LABEL_38;
  }
  if (v38)
  {
    v24 = 5;
    goto LABEL_44;
  }
LABEL_37:
  v25 = v33;
  if (v33 == v32)
  {
LABEL_45:
    v26 = 4;
    v25 = v32;
    goto LABEL_46;
  }
LABEL_38:
  if (!v25)
    goto LABEL_47;
  v26 = 5;
LABEL_46:
  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_47:
  v27 = v35;
  if (v35 == v34)
  {
    v28 = 4;
    v27 = v34;
    goto LABEL_51;
  }
  if (v35)
  {
    v28 = 5;
LABEL_51:
    (*(void (**)(void))(*v27 + 8 * v28))();
  }
  return v16;
}

uint64_t mlir::mps::TypeConstraintOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t (**a4)(), uint64_t a5, uint64_t a6, uint64_t (***a7)(), int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t (**v14)();
  uint64_t Context;
  uint64_t v16;
  mlir::MLIRContext *v17;
  unint64_t *p_Value;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t Value;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  _QWORD v39[3];
  _QWORD *v40;
  unint64_t v41[2];
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45[8];
  char v46;
  uint64_t (**v47)();
  uint64_t v48;
  uint64_t v49;
  uint64_t (**v50)();
  uint64_t v51;
  uint64_t (**v52)();
  _QWORD *v53;
  uint64_t (***v54)();
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  if (a7)
    v14 = *a7;
  else
    v14 = 0;
  v44 = a6;
  v45[0] = 0;
  v46 = 0;
  v47 = v14;
  v48 = a9;
  v49 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v44);
    if (v46)
      v46 = 0;
    mlir::OperationName::OperationName(v45, "mps.type_constraint", 19, Context);
    v46 = 1;
  }
  v50 = a4;
  v51 = a5;
  v16 = mlir::UnknownLoc::get(this, a2);
  if (!mlir::mps::TypeConstraintOpAdaptor::verify((uint64_t)&v44, v16))
  {
    v31 = mlir::Float32Type::get(this, v17);
    v32 = mlir::UnrankedTensorType::get(v31);
    v33 = *(unsigned int *)(a11 + 8);
    if (v33 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v33 + 1, 8);
      LODWORD(v33) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v33) = v32;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  v52 = v50;
  v53 = 0;
  v36 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v52 = v47;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v52);
  mlir::ValueRange::ValueRange((unint64_t *)&v42, (uint64_t)&v36, 1uLL);
  p_Value = (unint64_t *)&Value;
  mlir::ValueRange::ValueRange(v41, (uint64_t)&Value, 1uLL);
  v39[0] = &off_24BFF49B0;
  v40 = v39;
  if (v43 == v41[1])
  {
    v19 = v42;
    v20 = v41[0];
    v52 = &off_24C059F88;
    v53 = v39;
    v54 = &v52;
    if (v43)
    {
      v21 = 0;
      v22 = v43 - 1;
      do
      {
        v23 = mlir::TypeRange::dereference_iterator(v19, v21);
        v37 = mlir::TypeRange::dereference_iterator(v20, v21);
        v38 = v23;
        if (!v54)
          std::__throw_bad_function_call[abi:nn180100]();
        v24 = ((uint64_t (*)(uint64_t (***)(), unint64_t *, unint64_t *))(*v54)[6])(v54, &v38, &v37);
        if (v24)
          v25 = v22 == v21;
        else
          v25 = 1;
        ++v21;
      }
      while (!v25);
      v26 = v24;
      if (v54 == &v52)
      {
        v52[4]();
        if ((v26 & 1) != 0)
          goto LABEL_21;
      }
      else if (v54)
      {
        (*v54)[5]();
        if ((v26 & 1) != 0)
          goto LABEL_21;
      }
      else if ((v24 & 1) != 0)
      {
        goto LABEL_21;
      }
      v27 = Value;
      v28 = *(unsigned int *)(a11 + 8);
      if (v28 < *(_DWORD *)(a11 + 12))
        goto LABEL_23;
LABEL_34:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v28 + 1, 8);
      LODWORD(v28) = *(_DWORD *)(a11 + 8);
      goto LABEL_23;
    }
LABEL_21:
    p_Value = &v36;
  }
  v27 = *p_Value;
  v28 = *(unsigned int *)(a11 + 8);
  if (v28 >= *(_DWORD *)(a11 + 12))
    goto LABEL_34;
LABEL_23:
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v28) = v27;
  ++*(_DWORD *)(a11 + 8);
  v29 = v40;
  if (v40 == v39)
  {
    v30 = 4;
    v29 = v39;
    goto LABEL_30;
  }
  if (v40)
  {
    v30 = 5;
LABEL_30:
    (*(void (**)(void))(*v29 + 8 * v30))();
  }
  return 1;
}

uint64_t mlir::mps::TypeConstraintOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  _QWORD v14[3];
  void *v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *__p;
  _QWORD *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 24))
  {
    v14[0] = *(_QWORD *)(a1 + 24);
    mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    return 1;
  }
  else
  {
    v12 = "'mps.type_constraint' op requires attribute 'type_constraint'";
    v13 = 259;
    mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
    v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
    if (v14[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
    if (v21)
    {
      v4 = __p;
      if (__p)
      {
        v5 = v20;
        v6 = __p;
        if (v20 != __p)
        {
          do
            v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
          while (v5 != v4);
          v6 = __p;
        }
        v20 = v4;
        operator delete(v6);
      }
      v7 = v17;
      if (v17)
      {
        v8 = v18;
        v9 = v17;
        if (v18 != v17)
        {
          do
          {
            v11 = *--v8;
            v10 = v11;
            *v8 = 0;
            if (v11)
              MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
          }
          while (v8 != v7);
          v9 = v17;
        }
        v18 = v7;
        operator delete(v9);
      }
      if (v15 != &v16)
        free(v15);
    }
  }
  return v2;
}

uint64_t mlir::mps::CreateComplexOp::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  mlir::MLIRContext *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t OperandRange;
  uint64_t v20;
  uint64_t v21[2];
  __int128 v22;
  char v23;
  void *v24;
  uint64_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x24BDAC8D0];
  v24 = v26;
  v25 = 0x100000000;
  {
    v13 = *(_QWORD **)v24;
    if (*(_QWORD *)v24)
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v13 + 8);
    else
      v14 = 0;
    v21[0] = (uint64_t)v13;
    v21[1] = v14;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v21);
    v20 = mlir::ComplexType::get(OperandRange);
    LOBYTE(v22) = 0;
    v23 = 0;
    v16 = mlir::ShapedType::cloneWith(v21, &v22, v20);
    v17 = *(unsigned int *)(a11 + 8);
    if (v17 < *(_DWORD *)(a11 + 12))
      goto LABEL_7;
  }
  else
  {
    v15 = mlir::Float32Type::get(a1, v12);
    v16 = mlir::UnrankedTensorType::get(v15);
    v17 = *(unsigned int *)(a11 + 8);
    if (v17 < *(_DWORD *)(a11 + 12))
      goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v17 + 1, 8);
  LODWORD(v17) = *(_DWORD *)(a11 + 8);
LABEL_7:
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v17) = v16;
  ++*(_DWORD *)(a11 + 8);
  if (v24 != v26)
    free(v24);
  return 1;
}

uint64_t mlir::mps::RealPartOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t Context;
  uint64_t v15;
  uint64_t ComplexPartType;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v21;
  _BYTE v22[8];
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x24BDAC8D0];
  v21 = a6;
  v22[0] = 0;
  v23 = 0;
  v24 = a9;
  v25 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v21);
    if (v23)
      v23 = 0;
    mlir::OperationName::OperationName(v22, "mps.real_part", 13, Context);
    v23 = 1;
  }
  v26 = a4;
  v27 = a5;
  if (!a5
    || (mlir::UnknownLoc::get(this, a2),
        v28[0] = v26,
        v28[1] = 0,
        v15 = mlir::ValueRange::dereference_iterator(v28, 0),
  {
    v17 = mlir::Float32Type::get(this, a2);
    ComplexPartType = mlir::UnrankedTensorType::get(v17);
  }
  v18 = ComplexPartType;
  v19 = *(_DWORD *)(a11 + 8);
  if (v19 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v19 + 1, 8);
    v19 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v19) = v18;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::`anonymous namespace'::inferGetComplexPartType(_QWORD *a1)
{
  uint64_t v2;
  uint64_t ElementTypeOrSelf;
  uint64_t v4;
  __int128 v6;
  char v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8))
  {
    v9 = 0;
    v10 = 0;
    return 0;
  }
  v2 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
  v9 = a1;
  v10 = v2;
  if (!a1)
    return 0;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  if (*(_UNKNOWN **)(*(_QWORD *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    v4 = ElementTypeOrSelf;
  else
    v4 = 0;
  v8 = v4;
  if (v4)
    ElementTypeOrSelf = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v8);
  LOBYTE(v6) = 0;
  v7 = 0;
  return mlir::ShapedType::cloneWith((uint64_t *)&v9, &v6, ElementTypeOrSelf);
}

uint64_t mlir::mps::ImaginaryPartOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t Context;
  uint64_t v15;
  uint64_t ComplexPartType;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v21;
  _BYTE v22[8];
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x24BDAC8D0];
  v21 = a6;
  v22[0] = 0;
  v23 = 0;
  v24 = a9;
  v25 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v21);
    if (v23)
      v23 = 0;
    mlir::OperationName::OperationName(v22, "mps.imaginary_part", 18, Context);
    v23 = 1;
  }
  v26 = a4;
  v27 = a5;
  if (!a5
    || (mlir::UnknownLoc::get(this, a2),
        v28[0] = v26,
        v28[1] = 0,
        v15 = mlir::ValueRange::dereference_iterator(v28, 0),
  {
    v17 = mlir::Float32Type::get(this, a2);
    ComplexPartType = mlir::UnrankedTensorType::get(v17);
  }
  v18 = ComplexPartType;
  v19 = *(_DWORD *)(a11 + 8);
  if (v19 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v19 + 1, 8);
    v19 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v19) = v18;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::`anonymous namespace'::verifyFFTAxes(uint64_t *a1, _QWORD *a2, const char **a3)
{
  uint64_t v6;
  uint64_t DefiningOp;
  uint64_t v8;
  unint64_t v9;
  _BOOL4 v10;
  int v11;
  char v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char **v19;
  uint64_t v20;
  const char *v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  char *v33;
  char *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  char *v38;
  char *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  char *v48;
  char *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  int64_t v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  const void **v84;
  __int16 v85;
  _QWORD *v86;
  uint64_t v87;
  int v88;
  const char *v89;
  uint64_t v90;
  void *v91[2];
  uint64_t v92;
  void *v93;
  unsigned int v94;
  unsigned int v95;
  _BYTE v96[96];
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD *v100;
  char v101;
  const char **v102;
  uint64_t v103;
  _QWORD v104[7];

  v104[6] = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v86 = 0;
    v87 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v86))
      goto LABEL_5;
    return 1;
  }
  v6 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  v86 = a2;
  v87 = v6;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v86))
    return 1;
LABEL_5:
  v102 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v102);
  if (!DefiningOp)
    return 1;
  v8 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return 1;
  v91[0] = &v92;
  v91[1] = (void *)0x100000000;
  mlir::Operation::fold(v8, 0, 0, (uint64_t)v91);
  v9 = *(_QWORD *)v91[0] & 0xFFFFFFFFFFFFFFF8;
  v10 = v9 != 0;
  v11 = mlir::DenseIntElementsAttr::classof(v9);
  v12 = v11 & v10;
  if ((v11 & v10) != 0)
    v13 = (_QWORD *)v9;
  else
    v13 = 0;
  if (v91[0] != &v92)
    free(v91[0]);
  if ((v12 & 1) == 0)
    return 1;
  v102 = (const char **)v104;
  v103 = 0x600000000;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v86);
  v15 = v14;
  if (v13)
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v13 + 8);
  else
    v16 = 0;
  {
    if ((_DWORD)v103)
    {
      v19 = v102;
      v20 = 8 * v103;
      while (1)
      {
        v21 = *v19;
        if (v15 - (uint64_t)*v19 >= 5)
          break;
        ++v19;
        v20 -= 8;
        if (!v20)
          goto LABEL_23;
      }
      v84 = (const void **)"invalid axis: ";
      v85 = 259;
      mlir::Operation::emitOpError(a1, &v84, (uint64_t)v91);
      if (v91[0])
      {
        v88 = 2;
        v89 = v21;
        v22 = &v88;
        v23 = (char *)v93;
        if (v94 >= v95)
        {
          v64 = v94 + 1;
          if (v93 <= &v88 && (char *)v93 + 24 * v94 > (char *)&v88)
          {
            v77 = (char *)&v88 - (_BYTE *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v64, 24);
            v23 = (char *)v93;
            v22 = (int *)((char *)v93 + v77);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v64, 24);
            v22 = &v88;
            v23 = (char *)v93;
          }
        }
        v24 = &v23[24 * v94];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
        *(_OWORD *)v24 = v25;
        v26 = ++v94;
        if (v91[0])
        {
          v88 = 3;
          v89 = " for rank: ";
          v90 = 11;
          v27 = &v88;
          v28 = (char *)v93;
          if (v26 >= v95)
          {
            v65 = v26 + 1;
            v66 = (char *)v93 + 24 * v26 > (char *)&v88;
            if (v93 <= &v88 && v66)
            {
              v78 = (char *)&v88 - (_BYTE *)v93;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v65, 24);
              v28 = (char *)v93;
              v27 = (int *)((char *)v93 + v78);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v65, 24);
              v27 = &v88;
              v28 = (char *)v93;
            }
          }
          v29 = &v28[24 * v94];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
          *(_OWORD *)v29 = v30;
          v31 = ++v94;
          if (v91[0])
          {
            v88 = 2;
            v89 = (const char *)v15;
            v32 = &v88;
            v33 = (char *)v93;
            if (v31 >= v95)
            {
              v67 = v31 + 1;
              v68 = (char *)v93 + 24 * v31 > (char *)&v88;
              if (v93 <= &v88 && v68)
              {
                v79 = (char *)&v88 - (_BYTE *)v93;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v67, 24);
                v33 = (char *)v93;
                v32 = (int *)((char *)v93 + v79);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v67, 24);
                v32 = &v88;
                v33 = (char *)v93;
              }
            }
            v34 = &v33[24 * v94];
            v35 = *(_OWORD *)v32;
            *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
            *(_OWORD *)v34 = v35;
            v36 = ++v94;
            if (v91[0])
            {
              v88 = 3;
              v89 = ". Transform supported only on the last four dimensions";
              v90 = 54;
              v37 = &v88;
              v38 = (char *)v93;
              if (v36 >= v95)
              {
                v69 = v36 + 1;
                v70 = (char *)v93 + 24 * v36 > (char *)&v88;
                if (v93 <= &v88 && v70)
                {
                  v80 = (char *)&v88 - (_BYTE *)v93;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v69, 24);
                  v38 = (char *)v93;
                  v37 = (int *)((char *)v93 + v80);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v69, 24);
                  v37 = &v88;
                  v38 = (char *)v93;
                }
              }
              v39 = &v38[24 * v94];
              v40 = *(_OWORD *)v37;
              *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
              *(_OWORD *)v39 = v40;
              v41 = ++v94;
              if (v91[0])
              {
                v88 = 3;
                v89 = ", ie. axis must be larger than ";
                v90 = 31;
                v42 = &v88;
                v43 = (char *)v93;
                if (v41 >= v95)
                {
                  v71 = v41 + 1;
                  v72 = (char *)v93 + 24 * v41 > (char *)&v88;
                  if (v93 <= &v88 && v72)
                  {
                    v81 = (char *)&v88 - (_BYTE *)v93;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v71, 24);
                    v43 = (char *)v93;
                    v42 = (int *)((char *)v93 + v81);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v71, 24);
                    v42 = &v88;
                    v43 = (char *)v93;
                  }
                }
                v44 = &v43[24 * v94];
                v45 = *(_OWORD *)v42;
                *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                *(_OWORD *)v44 = v45;
                v46 = ++v94;
                if (v91[0])
                {
                  v88 = 2;
                  v89 = (const char *)(v15 - 5);
                  v47 = &v88;
                  v48 = (char *)v93;
                  if (v46 >= v95)
                  {
                    v73 = v46 + 1;
                    v74 = (char *)v93 + 24 * v46 > (char *)&v88;
                    if (v93 <= &v88 && v74)
                    {
                      v82 = (char *)&v88 - (_BYTE *)v93;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v73, 24);
                      v48 = (char *)v93;
                      v47 = (int *)((char *)v93 + v82);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v73, 24);
                      v47 = &v88;
                      v48 = (char *)v93;
                    }
                  }
                  v49 = &v48[24 * v94];
                  v50 = *(_OWORD *)v47;
                  *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
                  *(_OWORD *)v49 = v50;
                  v51 = ++v94;
                  if (v91[0])
                  {
                    v88 = 3;
                    v89 = ".";
                    v90 = 1;
                    v52 = &v88;
                    v53 = (char *)v93;
                    if (v51 >= v95)
                    {
                      v75 = v51 + 1;
                      v76 = (char *)v93 + 24 * v51 > (char *)&v88;
                      if (v93 <= &v88 && v76)
                      {
                        v83 = (char *)&v88 - (_BYTE *)v93;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
                        v53 = (char *)v93;
                        v52 = (int *)((char *)v93 + v83);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
                        v52 = &v88;
                        v53 = (char *)v93;
                      }
                    }
                    v54 = &v53[24 * v94];
                    v55 = *(_OWORD *)v52;
                    *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
                    *(_OWORD *)v54 = v55;
                    ++v94;
                  }
                }
              }
            }
          }
        }
      }
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v91);
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      if (v101)
      {
        v56 = __p;
        if (__p)
        {
          v57 = v100;
          v58 = __p;
          if (v100 != __p)
          {
            do
              v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            v58 = __p;
          }
          v100 = v56;
          operator delete(v58);
        }
        v59 = v97;
        if (v97)
        {
          v60 = v98;
          v61 = v97;
          if (v98 != v97)
          {
            do
            {
              v63 = *--v60;
              v62 = v63;
              *v60 = 0;
              if (v63)
                MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
            }
            while (v60 != v59);
            v61 = v97;
          }
          v98 = v59;
          operator delete(v61);
        }
        if (v93 != v96)
          free(v93);
      }
    }
    else
    {
LABEL_23:
      v17 = 1;
    }
  }
  else
  {
    v17 = 0;
  }
  if (v102 != v104)
    free(v102);
  return v17;
}

uint64_t mlir::mps::FastFourierTransformOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  uint64_t Context;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t ElementTypeOrSelf;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[8];
  char v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD v37[2];
  __int128 v38;
  char v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v37[0] = a4;
  v37[1] = a5;
  if (a7)
    v14 = *a7;
  else
    v14 = 0uLL;
  v29 = a6;
  v30[0] = 0;
  v31 = 0;
  v32 = v14;
  v33 = a9;
  v34 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v29);
    if (v31)
      v31 = 0;
    mlir::OperationName::OperationName(v30, "mps.fast_fourier_transform", 26, Context);
    v31 = 1;
  }
  v35 = a4;
  v36 = a5;
  if (a5)
  {
    v16 = mlir::UnknownLoc::get(this, a2);
    if (mlir::mps::FastFourierTransformOpAdaptor::verify((uint64_t)&v29, v16))
    {
      v38 = v35;
      v17 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v38, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8))
      {
        v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
        v27 = v17;
        v28 = v18;
        if (v17)
        {
          ElementTypeOrSelf = mlir::getElementTypeOrSelf(v17);
          v20 = ElementTypeOrSelf;
          if (!ElementTypeOrSelf
            || *(_UNKNOWN **)(*(_QWORD *)ElementTypeOrSelf + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
          {
            v20 = mlir::ComplexType::get(ElementTypeOrSelf);
          }
          LOBYTE(v38) = 0;
          v39 = 0;
          v21 = mlir::ShapedType::cloneWith((uint64_t *)&v27, &v38, v20);
          v22 = *(_DWORD *)(a11 + 8);
          if (v22 < *(_DWORD *)(a11 + 12))
            goto LABEL_16;
          goto LABEL_23;
        }
      }
      else
      {
        v27 = 0;
        v28 = 0;
      }
      v21 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      v22 = *(_DWORD *)(a11 + 8);
      if (v22 < *(_DWORD *)(a11 + 12))
      {
LABEL_16:
        *(_QWORD *)(*(_QWORD *)a11 + 8 * v22) = v21;
        goto LABEL_20;
      }
LABEL_23:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
      v22 = *(_DWORD *)(a11 + 8);
      goto LABEL_16;
    }
  }
  v23 = mlir::Float32Type::get(this, a2);
  v24 = mlir::UnrankedTensorType::get(v23);
  v25 = *(unsigned int *)(a11 + 8);
  if (v25 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v25 + 1, 8);
    LODWORD(v25) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v25) = v24;
LABEL_20:
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::FastFourierTransformOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  _QWORD v14[3];
  void *v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *__p;
  _QWORD *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 32))
    return 1;
  v12 = "'mps.fast_fourier_transform' op requires attribute 'scaling_mode'";
  v13 = 259;
  mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
  v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
  if (v14[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
  if (v21)
  {
    v4 = __p;
    if (__p)
    {
      v5 = v20;
      v6 = __p;
      if (v20 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v20 = v4;
      operator delete(v6);
    }
    v7 = v17;
    if (v17)
    {
      v8 = v18;
      v9 = v17;
      if (v18 != v17)
      {
        do
        {
          v11 = *--v8;
          v10 = v11;
          *v8 = 0;
          if (v11)
            MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
        }
        while (v8 != v7);
        v9 = v17;
      }
      v18 = v7;
      operator delete(v9);
    }
    if (v15 != &v16)
      free(v15);
  }
  return v2;
}

uint64_t mlir::mps::RealToHermiteanFFTOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  uint64_t Context;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v24;
  char v25[8];
  char v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (a7)
    v14 = *a7;
  else
    v14 = 0uLL;
  v24 = a6;
  v25[0] = 0;
  v26 = 0;
  v27 = v14;
  v28 = a9;
  v29 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v24);
    if (v26)
      v26 = 0;
    mlir::OperationName::OperationName(v25, "mps.real_to_hermitean_fft", 25, Context);
    v26 = 1;
  }
  v30 = a4;
  v31 = a5;
  if (!a5)
    goto LABEL_11;
  v16 = mlir::UnknownLoc::get(this, a2);
  if (!mlir::mps::RealToHermiteanFFTOpAdaptor::verify((uint64_t)&v24, v16))
    goto LABEL_11;
  v32 = v30;
  v33 = 0;
  v17 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v32, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v32 = v30;
  v33 = 1;
  v32 = mlir::ValueRange::offset_base(&v32, 1);
  v33 = 0;
  v18 = mlir::ValueRange::dereference_iterator(&v32, 0);
  if (!v19)
  {
LABEL_11:
    v20 = mlir::Float32Type::get(this, a2);
    v19 = mlir::UnrankedTensorType::get(v20);
  }
  v21 = v19;
  v22 = *(_DWORD *)(a11 + 8);
  if (v22 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v22 + 1, 8);
    v22 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v22) = v21;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::RealToHermiteanFFTOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  _QWORD v14[3];
  void *v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *__p;
  _QWORD *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 32))
    return 1;
  v12 = "'mps.real_to_hermitean_fft' op requires attribute 'scaling_mode'";
  v13 = 259;
  mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
  v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
  if (v14[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
  if (v21)
  {
    v4 = __p;
    if (__p)
    {
      v5 = v20;
      v6 = __p;
      if (v20 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v20 = v4;
      operator delete(v6);
    }
    v7 = v17;
    if (v17)
    {
      v8 = v18;
      v9 = v17;
      if (v18 != v17)
      {
        do
        {
          v11 = *--v8;
          v10 = v11;
          *v8 = 0;
          if (v11)
            MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
        }
        while (v8 != v7);
        v9 = v17;
      }
      v18 = v7;
      operator delete(v9);
    }
    if (v15 != &v16)
      free(v15);
  }
  return v2;
}

uint64_t mlir::mps::`anonymous namespace'::inferHermiteanFFTType(_QWORD *a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t ElementTypeOrSelf;
  uint64_t v9;
  uint64_t Value;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *Shape;
  unint64_t v15;
  unint64_t v16;
  char matched;
  unint64_t v18;
  int8x8_t v19;
  uint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  int8x16_t v23;
  int64x2_t *v24;
  int64x2_t v25;
  uint64_t v26;
  int64x2_t v27;
  int64x2_t v28;
  int64x2_t v29;
  int8x16_t v30;
  uint64_t v31;
  uint64_t v32;
  int8x8_t v33;
  uint64_t v34;
  uint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  void *__b;
  uint64_t v49;
  _BYTE v50[32];
  void *v51;
  uint64_t v52;
  _QWORD v53[5];

  v53[4] = *MEMORY[0x24BDAC8D0];
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  if (*(_UNKNOWN **)(*(_QWORD *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    v9 = ElementTypeOrSelf;
  else
    v9 = 0;
  v47 = v9;
  if (!a3)
  {
    if (!v9)
    {
      Value = mlir::ComplexType::get(ElementTypeOrSelf);
      v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
      if (v11)
        goto LABEL_7;
LABEL_12:
      v45 = 0;
      v46 = v11;
      return mlir::UnrankedTensorType::get(Value);
    }
    return 0;
  }
  if (!v9)
    return 0;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v47);
  v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
  if (!v11)
    goto LABEL_12;
LABEL_7:
  v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a1 + 8);
  v45 = a1;
  v46 = v12;
  if (!a1 || (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v45) & 1) == 0)
    return mlir::UnrankedTensorType::get(Value);
  __b = v50;
  v49 = 0x400000000;
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  v16 = v15;
  v51 = v53;
  v52 = 0x400000000;
  matched = mlir::matchConstantWithIntVector<long long>(a2, (uint64_t)&v51);
  if (!matched || !(_DWORD)v52)
  {
    v19 = (int8x8_t)-1;
    goto LABEL_26;
  }
  v18 = (v52 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v18 >= 3)
  {
    v21 = v18 + 1;
    v22 = (v18 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    v20 = (uint64_t *)((char *)v51 + 8 * v22);
    v23 = (int8x16_t)vdupq_n_s64(v16);
    v24 = (int64x2_t *)((char *)v51 + 16);
    v25.i64[0] = -1;
    v25.i64[1] = -1;
    v26 = v22;
    v27.i64[0] = -1;
    v27.i64[1] = -1;
    do
    {
      v28 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vcltzq_s64(v24[-1]), v23), v24[-1]);
      v29 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vcltzq_s64(*v24), v23), *v24);
      v25 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v28, v25), (int8x16_t)v28, (int8x16_t)v25);
      v27 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v29, v27), (int8x16_t)v29, (int8x16_t)v27);
      v24 += 2;
      v26 -= 4;
    }
    while (v26);
    v30 = vbslq_s8((int8x16_t)vcgtq_s64(v25, v27), (int8x16_t)v25, (int8x16_t)v27);
    v31 = vextq_s8(v30, v30, 8uLL).u64[0];
    v19 = vbsl_s8((int8x8_t)vcgtd_s64(v30.i64[0], v31), *(int8x8_t *)v30.i8, (int8x8_t)v31);
    if (v21 == v22)
      goto LABEL_26;
  }
  else
  {
    v19 = (int8x8_t)-1;
    v20 = (uint64_t *)v51;
  }
  do
  {
    v32 = *v20++;
    v33 = (int8x8_t)((v16 & (v32 >> 63)) + v32);
    if (*(_QWORD *)&v33 > *(_QWORD *)&v19)
      v19 = v33;
  }
  while (v20 != (uint64_t *)((char *)v51 + 8 * v52));
LABEL_26:
  v34 = v49;
  if (v16 != v49)
  {
    if (v16 >= v49)
    {
      if (v16 > HIDWORD(v49))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v50, v16, 8);
        v34 = v49;
      }
      if (v16 != v34)
        bzero((char *)__b + 8 * v34, 8 * (v16 - v34));
    }
    LODWORD(v49) = v16;
    LODWORD(v34) = v16;
  }
  if (!v16)
    goto LABEL_54;
  v35 = (uint64_t *)__b;
  if (a3)
  {
    if (matched)
    {
      do
      {
        v37 = *Shape++;
        v36 = v37;
        v38 = (a4 | (2 * v37)) - 2;
        if (v37 == 0x8000000000000000)
          v38 = 0x8000000000000000;
        if (!*(_QWORD *)&v19)
          v36 = v38;
        *v35++ = v36;
        --*(_QWORD *)&v19;
        --v16;
      }
      while (v16);
      goto LABEL_54;
    }
  }
  else if (matched)
  {
    do
    {
      v40 = *Shape++;
      v39 = v40;
      if (v40 >= 0)
        v41 = v39;
      else
        v41 = v39 + 1;
      v42 = v41 >> 1;
      if (v39 == 0x8000000000000000)
        v43 = 0x8000000000000000;
      else
        v43 = v42 + 1;
      if (!*(_QWORD *)&v19)
        v39 = v43;
      *v35++ = v39;
      --*(_QWORD *)&v19;
      --v16;
    }
    while (v16);
    goto LABEL_54;
  }
  memset_pattern16(__b, &unk_207AB7410, 8 * v16);
LABEL_54:
  if (v51 != v53)
  {
    free(v51);
    LODWORD(v34) = v49;
  }
  v13 = mlir::RankedTensorType::get((uint64_t)__b, v34, Value, 0);
  if (__b != v50)
    free(__b);
  return v13;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  uint64_t v15;
  uint64_t Context;
  uint64_t v17;
  unsigned int v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v26;
  char v27[8];
  char v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (a7)
  {
    v14 = *a7;
    v15 = *((_QWORD *)a7 + 2);
  }
  else
  {
    v15 = 0;
    v14 = 0uLL;
  }
  v26 = a6;
  v27[0] = 0;
  v28 = 0;
  v29 = v14;
  v30 = v15;
  v31 = a9;
  v32 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v28)
      v28 = 0;
    mlir::OperationName::OperationName(v27, "mps.hermitean_to_real_fft", 25, Context);
    v28 = 1;
  }
  v33 = a4;
  v34 = a5;
  if (!a5)
    goto LABEL_11;
  v17 = mlir::UnknownLoc::get(this, a2);
  if (!mlir::mps::HermiteanToRealFFTOpAdaptor::verify((uint64_t)&v26, v17))
    goto LABEL_11;
  v18 = *((_QWORD *)&v29 + 1) != 0;
  v35 = v33;
  v36 = 0;
  v19 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v35, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v35 = v33;
  v36 = 1;
  v35 = mlir::ValueRange::offset_base(&v35, 1);
  v36 = 0;
  v20 = mlir::ValueRange::dereference_iterator(&v35, 0);
  if (!v21)
  {
LABEL_11:
    v22 = mlir::Float32Type::get(this, a2);
    v21 = mlir::UnrankedTensorType::get(v22);
  }
  v23 = v21;
  v24 = *(_DWORD *)(a11 + 8);
  if (v24 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v24 + 1, 8);
    v24 = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v24) = v23;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::HermiteanToRealFFTOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  _QWORD v14[3];
  void *v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *__p;
  _QWORD *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 40))
    return 1;
  v12 = "'mps.hermitean_to_real_fft' op requires attribute 'scaling_mode'";
  v13 = 259;
  mlir::emitError(a2, (uint64_t)&v12, (uint64_t)v14);
  v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v14);
  if (v14[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v14);
  if (v21)
  {
    v4 = __p;
    if (__p)
    {
      v5 = v20;
      v6 = __p;
      if (v20 != __p)
      {
        do
          v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
        while (v5 != v4);
        v6 = __p;
      }
      v20 = v4;
      operator delete(v6);
    }
    v7 = v17;
    if (v17)
    {
      v8 = v18;
      v9 = v17;
      if (v18 != v17)
      {
        do
        {
          v11 = *--v8;
          v10 = v11;
          *v8 = 0;
          if (v11)
            MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
        }
        while (v8 != v7);
        v9 = v17;
      }
      v18 = v7;
      operator delete(v9);
    }
    if (v15 != &v16)
      free(v15);
  }
  return v2;
}

uint64_t mlir::mps::NonZeroOp::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  mlir::MLIRContext *v15;
  uint64_t Context;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v29;
  char v30[8];
  char v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  _BYTE v38[16];
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v36 = v38;
  memset_pattern16(v38, &unk_207AB7410, 0x10uLL);
  v37 = 0x200000002;
  v29 = a6;
  v30[0] = 0;
  v31 = 0;
  v32 = a9;
  v33 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v29);
    if (v31)
      v31 = 0;
    mlir::OperationName::OperationName(v30, "mps.non_zero", 12, Context);
    v31 = 1;
  }
  v34 = a4;
  v35 = a5;
  if (a5)
  {
    mlir::UnknownLoc::get(a1, v15);
    v39 = v34;
    v40 = 0;
    v17 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v39, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8))
    {
      v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
      v39 = v17;
      v40 = v18;
      if (v17 && (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39) & 1) != 0)
      {
        mlir::ShapedType::getShape((mlir::ShapedType *)&v39);
        if (v23 <= 1)
          v24 = 1;
        else
          v24 = v23;
        *((_QWORD *)v36 + 1) = v24;
      }
    }
    else
    {
      v39 = 0;
      v40 = 0;
    }
    v25 = mlir::IntegerType::get((uint64_t)a1, 0x20u, 1u);
    v26 = mlir::RankedTensorType::get((uint64_t)v36, v37, v25, 0);
    v27 = *(_DWORD *)(a11 + 8);
    if (v27 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v27 + 1, 8);
      v27 = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v27) = v26;
    ++*(_DWORD *)(a11 + 8);
    v22 = v36;
    if (v36 != v38)
LABEL_22:
      free(v22);
  }
  else
  {
    v19 = mlir::IntegerType::get((uint64_t)a1, 0x20u, 1u);
    v20 = mlir::RankedTensorType::get((uint64_t)v36, v37, v19, 0);
    v21 = *(unsigned int *)(a11 + 8);
    if (v21 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v21 + 1, 8);
      LODWORD(v21) = *(_DWORD *)(a11 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v21) = v20;
    ++*(_DWORD *)(a11 + 8);
    v22 = v36;
    if (v36 != v38)
      goto LABEL_22;
  }
  return 1;
}

uint64_t mlir::mps::ImToColOp::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v14;
  __int128 v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t Context;
  uint64_t v19;
  uint64_t v20;
  uint64_t ElementTypeOrSelf;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t *Shape;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  _QWORD v67[3];
  void *v68;
  uint64_t v69;
  _QWORD v70[4];
  void *v71[2];
  _BYTE v72[64];
  void *v73;
  uint64_t v74;
  __int128 v75;
  void *v76[2];
  _BYTE v77[16];
  void *v78;
  uint64_t v79;
  __int128 v80;
  void *v81[2];
  _BYTE v82[16];
  void *v83;
  uint64_t v84;
  __int128 v85;
  void *v86[2];
  _BYTE v87[16];
  void *v88;
  uint64_t v89;
  _QWORD v90[4];
  uint64_t v91;
  _BYTE v92[8];
  char v93;
  __int128 v94;
  __int128 v95;
  _QWORD *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x24BDAC8D0];
  v101 = a4;
  v102 = a5;
  if (a7)
  {
    v14 = *a7;
    v15 = a7[1];
    v16 = (_QWORD *)*((_QWORD *)a7 + 4);
  }
  else
  {
    v16 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
  }
  v91 = a6;
  v92[0] = 0;
  v93 = 0;
  v94 = v14;
  v95 = v15;
  v96 = v16;
  v97 = a9;
  v17 = a5;
  v98 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v91);
    if (v93)
      v93 = 0;
    mlir::OperationName::OperationName(v92, "mps.im_to_col", 13, Context);
    v93 = 1;
    v17 = v102;
  }
  v99 = a4;
  v100 = a5;
  if (v17 != 1
    || (v19 = mlir::UnknownLoc::get(this, a2), !mlir::mps::ImToColOpAdaptor::verify(&v91, v19)))
  {
    v24 = mlir::Float32Type::get(this, a2);
    v25 = mlir::UnrankedTensorType::get(v24);
    v26 = *(unsigned int *)(a11 + 8);
    if (v26 >= *(_DWORD *)(a11 + 12))
    {
LABEL_28:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v26 + 1, 8);
      LODWORD(v26) = *(_DWORD *)(a11 + 8);
    }
LABEL_14:
    *(_QWORD *)(*(_QWORD *)a11 + 8 * v26) = v25;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  v20 = mlir::ValueRange::dereference_iterator(&v101, 0);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
  v22 = (_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8))
  {
    v63 = 0;
    v64 = 0;
    goto LABEL_27;
  }
  v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  v63 = v22;
  v64 = v23;
  if (!v22
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v63)
    || (mlir::ShapedType::getShape((mlir::ShapedType *)&v63), v28 != 4))
  {
LABEL_27:
    v25 = mlir::UnrankedTensorType::get(ElementTypeOrSelf);
    v26 = *(unsigned int *)(a11 + 8);
    if (v26 >= *(_DWORD *)(a11 + 12))
      goto LABEL_28;
    goto LABEL_14;
  }
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v63);
  v30 = *((_QWORD *)&v95 + 1);
  v31 = *Shape;
  v32 = 3;
  v33 = 1;
  if (*(_DWORD *)(v94 + 8))
    v34 = 3;
  else
    v34 = 1;
  if (*(_DWORD *)(v94 + 8))
    v32 = 2;
  else
    v33 = 2;
  v35 = Shape[v34];
  v36 = Shape[v33];
  v37 = Shape[v32];
  v88 = v90;
  v90[0] = v31;
  v90[1] = v35;
  v90[2] = v36;
  v90[3] = v37;
  v89 = 0x400000004;
  v86[0] = v87;
  v86[1] = (void *)0x200000000;
  if (*((_QWORD *)&v95 + 1))
    v38 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v95 + 1) + 8);
  else
    v38 = 0;
  mlir::getIntValues<long long>(v30, v38, (uint64_t)v86, 1);
  v83 = &v85;
  v85 = *(_OWORD *)v86[0];
  v84 = 0x200000002;
  v81[0] = v82;
  v81[1] = (void *)0x200000000;
  v39 = (uint64_t)v96;
  if (v96)
    v40 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v96 + 8);
  else
    v40 = 0;
  mlir::getIntValues<long long>(v39, v40, (uint64_t)v81, 1);
  v78 = &v80;
  v80 = *(_OWORD *)v81[0];
  v79 = 0x200000002;
  v76[0] = v77;
  v76[1] = (void *)0x200000000;
  v41 = *((_QWORD *)&v94 + 1);
  if (*((_QWORD *)&v94 + 1))
    v42 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(**((_QWORD **)&v94 + 1) + 8);
  else
    v42 = 0;
  mlir::getIntValues<long long>(v41, v42, (uint64_t)v76, 1);
  v73 = &v75;
  v75 = *(_OWORD *)v76[0];
  v74 = 0x200000002;
  v71[0] = v72;
  v71[1] = (void *)0x800000000;
  v43 = v95;
  if ((_QWORD)v95)
    v44 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v95 + 8);
  else
    v44 = 0;
  mlir::getIntValues<long long>(v43, v44, (uint64_t)v71, 1);
  v45 = 16;
  v46 = 32;
  if (!*(_DWORD *)(v94 + 8))
    v45 = 32;
  v47 = 24;
  v48 = 40;
  if (!*(_DWORD *)(v94 + 8))
  {
    v47 = 40;
    v46 = 48;
    v48 = 56;
  }
  v49 = *(_QWORD *)((char *)v71[0] + v45);
  v50 = *(_QWORD *)((char *)v71[0] + v47);
  v51 = *(_QWORD *)((char *)v71[0] + v46);
  v52 = *(_QWORD *)((char *)v71[0] + v48);
  v68 = v70;
  v70[0] = v49;
  v70[1] = v50;
  v70[2] = v51;
  v70[3] = v52;
  v69 = 0x400000004;
  v65 = v67;
  v66 = 0x300000003;
  v67[0] = *(_QWORD *)v88;
  v53 = *(_QWORD *)v83;
  v54 = *((_QWORD *)v83 + 1);
  v67[1] = *(_QWORD *)v83 * *((_QWORD *)v88 + 1) * v54;
  v55 = *((_QWORD *)v88 + 2);
  v56 = *((_QWORD *)v88 + 3);
  v57 = 0x8000000000000000;
  v58 = 0x8000000000000000;
  if (v55 != 0x8000000000000000 && v53 != 0x8000000000000000)
    v58 = (v55 + v49 + ~(*(_QWORD *)v73 * (v53 - 1)) + v50 + *(_QWORD *)v78) / *(_QWORD *)v78;
  if (v56 != 0x8000000000000000 && v54 != 0x8000000000000000)
    v57 = (v51 + v56 + ~(*((_QWORD *)v73 + 1) * (v54 - 1)) + v52 + *((_QWORD *)v78 + 1)) / *((_QWORD *)v78 + 1);
  v59 = 0x8000000000000000;
  if (v57 != 0x8000000000000000 && v58 != 0x8000000000000000)
    v59 = v57 * v58;
  v67[2] = v59;
  v61 = mlir::RankedTensorType::get((uint64_t)v67, 3, ElementTypeOrSelf, 0);
  v62 = *(unsigned int *)(a11 + 8);
  if (v62 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v62 + 1, 8);
    LODWORD(v62) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v62) = v61;
  ++*(_DWORD *)(a11 + 8);
  if (v65 != v67)
    free(v65);
  if (v68 != v70)
    free(v68);
  if (v71[0] != v72)
    free(v71[0]);
  if (v73 != &v75)
    free(v73);
  if (v76[0] != v77)
    free(v76[0]);
  if (v78 != &v80)
    free(v78);
  if (v81[0] != v82)
    free(v81[0]);
  if (v83 != &v85)
    free(v83);
  if (v86[0] != v87)
    free(v86[0]);
  if (v88 != v90)
    free(v88);
  return 1;
}

uint64_t mlir::mps::ImToColOpAdaptor::verify(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  _QWORD *Type;
  _QWORD *v10;
  _QWORD *Shape;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  const char *v68;
  uint64_t v69;
  const char *OperandRange;
  const char *v71;
  uint64_t v72;
  __int16 v73;
  _QWORD v74[2];
  __int128 v75;
  _QWORD *v76;
  _QWORD *v77;
  void *v78;
  uint64_t v79;
  void *v80;
  _QWORD *v81;
  void *__p;
  _QWORD *v83;
  char v84;
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  v3 = a1[3];
  if (v3)
  {
    v4 = (const char *)a1[4];
    if (v4)
    {
      v5 = (const char *)a1[5];
      if (v5)
      {
        v6 = (const char *)a1[6];
        if (v6)
        {
          v7 = (const char *)a1[7];
          if (v7)
          {
            v8 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v6 + 8);
            v71 = v6;
            v72 = v8;
            Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
            v10 = Type;
            if (Type)
              Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
            v76 = v10;
            v77 = Type;
            Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
            v74[0] = 2;
            if (v12 == 1
              && *Shape == v74[0]
              && (OperandRange = v6,
                  llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
              && (v68 = v6,
                  *(_QWORD *)&v75 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68),
                  *((_QWORD *)&v75 + 1) = v13,
                  v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75),
                  mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 64)))
            {
              v14 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v7 + 8);
              v71 = v7;
              v72 = v14;
              v15 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
              v16 = v15;
              if (v15)
                v15 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v15 + 8);
              v76 = v16;
              v77 = v15;
              v17 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
              v74[0] = 2;
              if (v18 == 1
                && *v17 == v74[0]
                && (OperandRange = v7,
                    llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                && (v68 = v7,
                    *(_QWORD *)&v75 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68),
                    *((_QWORD *)&v75 + 1) = v19,
                    v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75),
                    mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 64)))
              {
                v20 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v4 + 8);
                v71 = v4;
                v72 = v20;
                v21 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
                v22 = v21;
                if (v21)
                  v21 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
                v76 = v22;
                v77 = v21;
                v23 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
                v74[0] = 2;
                if (v24 == 1
                  && *v23 == v74[0]
                  && (OperandRange = v4,
                      llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>((uint64_t *)&OperandRange))
                  && (v68 = v4,
                      *(_QWORD *)&v75 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v68),
                      *((_QWORD *)&v75 + 1) = v25,
                      v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75),
                      mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 64)))
                {
                  v26 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v5 + 8);
                  v71 = v5;
                  v72 = v26;
                  v27 = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v71);
                  v28 = v27;
                  if (v27)
                    v27 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v27 + 8);
                  v76 = v28;
                  v77 = v27;
                  v29 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v76);
                  v75 = xmmword_207A7D550;
                  if (v30 == 2
                    && (*v29 == (_QWORD)v75 ? (v31 = v29[1] == *((_QWORD *)&v75 + 1)) : (v31 = 0),
                        v31
                     && (v69 = (uint64_t)v5,
                         v74[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69),
                         v74[1] = v32,
                         OperandRange = (const char *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v74),
                         mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))))
                  {
                    if (*(_DWORD *)(v3 + 8) < 2u)
                      return 1;
                    v60 = "'mps.im_to_col' op attribute 'data_layout' failed to satisfy constraint: valid TensorDataLayou"
                          "t is one of NCHW or NHWC";
                  }
                  else
                  {
                    v60 = "'mps.im_to_col' op attribute 'explicit_padding' failed to satisfy constraint: ui64 elements at"
                          "tribute of shape {4, 2}";
                  }
                }
                else
                {
                  v60 = "'mps.im_to_col' op attribute 'dilation_rates' failed to satisfy constraint: positive ui64 elemen"
                        "ts attribute of shape {2}";
                }
              }
              else
              {
                v60 = "'mps.im_to_col' op attribute 'strides' failed to satisfy constraint: positive ui64 elements attrib"
                      "ute of shape {2}";
              }
            }
            else
            {
              v60 = "'mps.im_to_col' op attribute 'kernel_sizes' failed to satisfy constraint: positive ui64 elements att"
                    "ribute of shape {2}";
            }
            v71 = v60;
            v73 = 259;
            mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
            v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v76);
            return v33;
          }
          v71 = "'mps.im_to_col' op requires attribute 'strides'";
          v73 = 259;
          mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
          v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
          if (v76)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
          if (v84)
          {
            v61 = __p;
            if (__p)
            {
              v62 = v83;
              v63 = __p;
              if (v83 != __p)
              {
                do
                  v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
                while (v62 != v61);
                v63 = __p;
              }
              v83 = v61;
              operator delete(v63);
            }
            v37 = v80;
            if (!v80)
              goto LABEL_109;
            v64 = v81;
            v39 = v80;
            if (v81 == v80)
            {
LABEL_108:
              v81 = v37;
              operator delete(v39);
LABEL_109:
              if (v78 != &v79)
                free(v78);
              return v33;
            }
            do
            {
              v66 = *--v64;
              v65 = v66;
              *v64 = 0;
              if (v66)
                MEMORY[0x20BD002D4](v65, 0x1000C8077774924);
            }
            while (v64 != v37);
LABEL_107:
            v39 = v80;
            goto LABEL_108;
          }
        }
        else
        {
          v71 = "'mps.im_to_col' op requires attribute 'kernel_sizes'";
          v73 = 259;
          mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
          v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
          if (v76)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
          if (v84)
          {
            v54 = __p;
            if (__p)
            {
              v55 = v83;
              v56 = __p;
              if (v83 != __p)
              {
                do
                  v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
                while (v55 != v54);
                v56 = __p;
              }
              v83 = v54;
              operator delete(v56);
            }
            v37 = v80;
            if (!v80)
              goto LABEL_109;
            v57 = v81;
            v39 = v80;
            if (v81 == v80)
              goto LABEL_108;
            do
            {
              v59 = *--v57;
              v58 = v59;
              *v57 = 0;
              if (v59)
                MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
            }
            while (v57 != v37);
            goto LABEL_107;
          }
        }
      }
      else
      {
        v71 = "'mps.im_to_col' op requires attribute 'explicit_padding'";
        v73 = 259;
        mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
        v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
        if (v76)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
        if (v84)
        {
          v48 = __p;
          if (__p)
          {
            v49 = v83;
            v50 = __p;
            if (v83 != __p)
            {
              do
                v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
              while (v49 != v48);
              v50 = __p;
            }
            v83 = v48;
            operator delete(v50);
          }
          v37 = v80;
          if (!v80)
            goto LABEL_109;
          v51 = v81;
          v39 = v80;
          if (v81 == v80)
            goto LABEL_108;
          do
          {
            v53 = *--v51;
            v52 = v53;
            *v51 = 0;
            if (v53)
              MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
          }
          while (v51 != v37);
          goto LABEL_107;
        }
      }
    }
    else
    {
      v71 = "'mps.im_to_col' op requires attribute 'dilation_rates'";
      v73 = 259;
      mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
      v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
      if (v76)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
      if (v84)
      {
        v42 = __p;
        if (__p)
        {
          v43 = v83;
          v44 = __p;
          if (v83 != __p)
          {
            do
              v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            v44 = __p;
          }
          v83 = v42;
          operator delete(v44);
        }
        v37 = v80;
        if (!v80)
          goto LABEL_109;
        v45 = v81;
        v39 = v80;
        if (v81 == v80)
          goto LABEL_108;
        do
        {
          v47 = *--v45;
          v46 = v47;
          *v45 = 0;
          if (v47)
            MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
        }
        while (v45 != v37);
        goto LABEL_107;
      }
    }
  }
  else
  {
    v71 = "'mps.im_to_col' op requires attribute 'data_layout'";
    v73 = 259;
    mlir::emitError(a2, (uint64_t)&v71, (uint64_t)&v76);
    v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v76);
    if (v76)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v76);
    if (v84)
    {
      v34 = __p;
      if (__p)
      {
        v35 = v83;
        v36 = __p;
        if (v83 != __p)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = __p;
        }
        v83 = v34;
        operator delete(v36);
      }
      v37 = v80;
      if (!v80)
        goto LABEL_109;
      v38 = v81;
      v39 = v80;
      if (v81 == v80)
        goto LABEL_108;
      do
      {
        v41 = *--v38;
        v40 = v41;
        *v38 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v38 != v37);
      goto LABEL_107;
    }
  }
  return v33;
}

uint64_t mlir::mps::ImToColOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const void **v17;
  __int16 v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  _QWORD v27[2];
  _QWORD v28[7];

  v28[6] = *MEMORY[0x24BDAC8D0];
  v27[0] = v28;
  v27[1] = 0x600000000;
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v3 = *(_QWORD **)(v2 + 16);
  if (v3)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  else
    v4 = 0;
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v27, 1);
  v5 = (void *)v27[0];
  v6 = *(_QWORD *)v27[0];
  if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8))
  {
    if (!v6 && !*(_QWORD *)(v27[0] + 8) && !*(_QWORD *)(v27[0] + 48) && !*(_QWORD *)(v27[0] + 56))
      goto LABEL_37;
  }
  else if (!v6 && !*(_QWORD *)(v27[0] + 8) && !*(_QWORD *)(v27[0] + 16) && !*(_QWORD *)(v27[0] + 24))
  {
LABEL_37:
    v7 = 1;
    if ((_QWORD *)v27[0] == v28)
      return v7;
    goto LABEL_35;
  }
  v17 = (const void **)"failed: padding should be nonzero on spatial dimension only";
  v18 = 259;
  mlir::OpState::emitOpError(this, &v17, (uint64_t)v19);
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  v5 = (void *)v27[0];
  if ((_QWORD *)v27[0] != v28)
LABEL_35:
    free(v5);
  return v7;
}

uint64_t mlir::mps::ColToImOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t Context;
  uint64_t v17;
  uint64_t v18;
  uint64_t ElementTypeOrSelf;
  uint64_t TensorType;
  uint64_t v21;
  uint64_t v23;
  char v24[8];
  char v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD v33[2];
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v33[0] = a4;
  v33[1] = a5;
  if (a7)
  {
    v13 = *a7;
    v14 = a7[1];
    v15 = *((_QWORD *)a7 + 4);
  }
  else
  {
    v15 = 0;
    v13 = 0uLL;
    v14 = 0uLL;
  }
  v23 = a6;
  v24[0] = 0;
  v25 = 0;
  v26 = v13;
  v27 = v14;
  v28 = v15;
  v29 = a9;
  v30 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v23);
    if (v25)
      v25 = 0;
    mlir::OperationName::OperationName(v24, "mps.col_to_im", 13, Context);
    v25 = 1;
  }
  v31 = a4;
  v32 = a5;
  v17 = mlir::ValueRange::dereference_iterator(v33, 0);
  v34 = v31;
  v35 = 1;
  v34 = mlir::ValueRange::offset_base(&v34, 1);
  v35 = 0;
  v18 = mlir::ValueRange::dereference_iterator(&v34, 0);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
  TensorType = mlir::mps::getTensorType(v18, ElementTypeOrSelf);
  v21 = *(unsigned int *)(a11 + 8);
  if (v21 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v21 + 1, 8);
    LODWORD(v21) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v21) = TensorType;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::mps::ColToImOp::verify(uint64_t **this)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _BYTE *Shape;
  uint64_t v41;
  uint64_t v42;
  _BYTE *v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  void *v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  const void **v75;
  __int16 v76;
  _QWORD v77[2];
  _QWORD v78[2];
  void *v79;
  uint64_t v80;
  _QWORD v81[2];
  unint64_t v82;
  void *v83;
  uint64_t v84;
  _QWORD v85[4];
  void *v86;
  uint64_t v87;
  _WORD v88[16];
  void *v89;
  uint64_t v90;
  __int128 v91;
  void *v92[2];
  _BYTE v93[16];
  void *v94;
  uint64_t v95;
  __int128 v96;
  void *v97[2];
  _BYTE v98[16];
  void *v99;
  uint64_t v100;
  __int128 v101;
  _QWORD v102[2];
  _BYTE v103[16];
  _QWORD v104[3];
  void *v105;
  _BYTE v106[96];
  void *v107;
  _QWORD *v108;
  void *__p;
  _QWORD *v110;
  char v111;
  void *v112[2];
  _QWORD v113[8];

  v113[6] = *MEMORY[0x24BDAC8D0];
  v112[0] = v113;
  v112[1] = (void *)0x600000000;
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v3 = *(_QWORD **)(v2 + 16);
  if (v3)
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v3 + 8);
  else
    v4 = 0;
  mlir::getIntValues<long long>((uint64_t)v3, v4, (uint64_t)v112, 1);
  v5 = *((unsigned int *)*this + 11);
  v6 = (uint64_t)&(*this)[2 * ((v5 >> 23) & 1)];
  v8 = *(_QWORD *)(v6 + 64);
  v7 = v6 + 64;
  v9 = *(_QWORD *)v112[0];
  if (*(_DWORD *)(v8 + 8))
  {
    if (!v9 && !*((_QWORD *)v112[0] + 1) && !*((_QWORD *)v112[0] + 6) && !*((_QWORD *)v112[0] + 7))
    {
LABEL_37:
      v102[0] = v103;
      v102[1] = 0x200000000;
      if (BYTE3(v5))
        v21 = v7;
      else
        v21 = 0;
      v22 = *(_QWORD **)(v21 + 24);
      if (v22)
        v23 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v22 + 8);
      else
        v23 = 0;
      mlir::getIntValues<long long>((uint64_t)v22, v23, (uint64_t)v102, 1);
      v24 = *((unsigned int *)*this + 11);
      v25 = (uint64_t)&(*this)[2 * ((v24 >> 23) & 1) + 8];
      v99 = &v101;
      v101 = *(_OWORD *)v102[0];
      v100 = 0x200000002;
      v97[0] = v98;
      v97[1] = (void *)0x200000000;
      if (BYTE3(v24))
        v26 = v25;
      else
        v26 = 0;
      v27 = *(_QWORD **)(v26 + 32);
      if (v27)
        v28 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v27 + 8);
      else
        v28 = 0;
      mlir::getIntValues<long long>((uint64_t)v27, v28, (uint64_t)v97, 1);
      v29 = *((unsigned int *)*this + 11);
      v30 = (uint64_t)&(*this)[2 * ((v29 >> 23) & 1) + 8];
      v94 = &v96;
      v96 = *(_OWORD *)v97[0];
      v95 = 0x200000002;
      v92[0] = v93;
      v92[1] = (void *)0x200000000;
      if (BYTE3(v29))
        v31 = v30;
      else
        v31 = 0;
      v32 = *(_QWORD **)(v31 + 8);
      if (v32)
        v33 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v32 + 8);
      else
        v33 = 0;
      v10 = 1;
      mlir::getIntValues<long long>((uint64_t)v32, v33, (uint64_t)v92, 1);
      v34 = *this;
      v89 = &v91;
      v91 = *(_OWORD *)v92[0];
      v90 = 0x200000002;
      v35 = *((_DWORD *)v34 + 9);
      v36 = (uint64_t)(v34 - 2);
      if (v35)
        v37 = v36;
      else
        v37 = 0;
      v38 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v37, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (v38)
      {
        v39 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v38 + 8);
        v78[0] = v38;
        v78[1] = v39;
        if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v78))
        {
          Shape = (_BYTE *)mlir::ShapedType::getShape((mlir::ShapedType *)v78);
          v41 = mlir::ShapedType::getShape((mlir::ShapedType *)v78);
          v43 = (_BYTE *)(v41 + 8 * v42);
          v86 = v88;
          v87 = 0x400000000;
          v44 = v43 - Shape;
          if ((unint64_t)(v43 - Shape) < 0x21)
          {
            v45 = 0;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v86, v88, v44 >> 3, 8);
            v45 = v87;
          }
          if (v43 != Shape)
          {
            memcpy((char *)v86 + 8 * v45, Shape, v43 - Shape);
            v45 = v87;
          }
          LODWORD(v87) = v45 + ((unint64_t)v44 >> 3);
          v46 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v78);
          v47 = *this;
          v48 = *v46;
          v49 = 3;
          v50 = 1;
          if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8))
            v51 = 3;
          else
            v51 = 1;
          if (!*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8))
            v50 = 2;
          v52 = v46[v51];
          if (*(_DWORD *)((*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8] + 8))
            v49 = 2;
          v53 = v46[v50];
          v54 = v46[v49];
          v82 = 0;
          v83 = v85;
          v85[0] = v48;
          v85[1] = v52;
          v85[2] = v53;
          v85[3] = v54;
          v84 = 0x400000004;
          v79 = v81;
          v80 = 0x300000003;
          v81[0] = v48;
          v56 = *(_QWORD *)v99;
          v55 = *((_QWORD *)v99 + 1);
          v81[1] = *(_QWORD *)v99 * v52 * v55;
          v57 = 0x8000000000000000;
          v58 = 0x8000000000000000;
          if (v53 != 0x8000000000000000 && v56 != 0x8000000000000000)
            v58 = (*(_QWORD *)v112[0] + ~(*(_QWORD *)v89 * (v56 - 1)) + *((_QWORD *)v112[0] + 1) + *(_QWORD *)v94 + v53)
                / *(_QWORD *)v94;
          if (v54 != 0x8000000000000000 && v55 != 0x8000000000000000)
            v57 = (*((_QWORD *)v112[0] + 2)
                 + ~(*((_QWORD *)v89 + 1) * (v55 - 1))
                 + *((_QWORD *)v112[0] + 3)
                 + *((_QWORD *)v94 + 1)
                 + v54)
                / *((_QWORD *)v94 + 1);
          v59 = 0x8000000000000000;
          if (v57 != 0x8000000000000000 && v58 != 0x8000000000000000)
            v59 = v57 * v58;
          v82 = v59;
          v61 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v47[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (v61)
            v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v61 + 8);
          else
            v62 = 0;
          v77[0] = v61;
          v77[1] = v62;
          v63 = mlir::ShapedType::getShape((mlir::ShapedType *)v77);
          if (!v77[0]
            || (v65 = (_QWORD *)v63,
                v66 = v64,
                !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v77))
            || *v65 == *(_QWORD *)v79
            && v65[1] == *((_QWORD *)v79 + 1)
            && v65[2] == *((_QWORD *)v79 + 2)
            && v66 == 3
            && v80 == 3)
          {
            v10 = 1;
          }
          else
          {
            v75 = (const void **)"failed: invalid output shape for input & attributes.";
            v76 = 259;
            mlir::OpState::emitOpError(this, &v75, (uint64_t)v104);
            v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v104);
            if (v104[0])
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v104);
            if (v111)
            {
              v67 = __p;
              if (__p)
              {
                v68 = v110;
                v69 = __p;
                if (v110 != __p)
                {
                  do
                    v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
                  while (v68 != v67);
                  v69 = __p;
                }
                v110 = v67;
                operator delete(v69);
              }
              v70 = v107;
              if (v107)
              {
                v71 = v108;
                v72 = v107;
                if (v108 != v107)
                {
                  do
                  {
                    v74 = *--v71;
                    v73 = v74;
                    *v71 = 0;
                    if (v74)
                      MEMORY[0x20BD002D4](v73, 0x1000C8077774924);
                  }
                  while (v71 != v70);
                  v72 = v107;
                }
                v108 = v70;
                operator delete(v72);
              }
              if (v105 != v106)
                free(v105);
            }
          }
          if (v79 != v81)
            free(v79);
          if (v83 != v85)
            free(v83);
          if (v86 != v88)
            free(v86);
        }
      }
      if (v89 != &v91)
        free(v89);
      if (v92[0] != v93)
        free(v92[0]);
      if (v94 != &v96)
        free(v94);
      if (v97[0] != v98)
        free(v97[0]);
      if (v99 != &v101)
        free(v99);
      v19 = (void *)v102[0];
      if ((_BYTE *)v102[0] == v103)
        goto LABEL_34;
LABEL_33:
      free(v19);
      goto LABEL_34;
    }
  }
  else if (!v9 && !*((_QWORD *)v112[0] + 1) && !*((_QWORD *)v112[0] + 2) && !*((_QWORD *)v112[0] + 3))
  {
    goto LABEL_37;
  }
  v86 = "failed: padding should be nonzero on spatial dimension only";
  v88[8] = 259;
  mlir::OpState::emitOpError(this, (const void ***)&v86, (uint64_t)v104);
  v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v104);
  if (v104[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v104);
  if (v111)
  {
    v11 = __p;
    if (__p)
    {
      v12 = v110;
      v13 = __p;
      if (v110 != __p)
      {
        do
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        v13 = __p;
      }
      v110 = v11;
      operator delete(v13);
    }
    v14 = v107;
    if (v107)
    {
      v15 = v108;
      v16 = v107;
      if (v108 != v107)
      {
        do
        {
          v18 = *--v15;
          v17 = v18;
          *v15 = 0;
          if (v18)
            MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
        }
        while (v15 != v14);
        v16 = v107;
      }
      v108 = v14;
      operator delete(v16);
    }
    v19 = v105;
    if (v105 != v106)
      goto LABEL_33;
  }
LABEL_34:
  if (v112[0] != v113)
    free(v112[0]);
  return v10;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  mlir::MLIRContext *v15;
  __int128 v16;
  uint64_t v17;
  uint64_t Context;
  uint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *Shape;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v45;
  uint64_t v46;
  _QWORD v47[2];
  mlir::UnknownLoc *v48;
  uint64_t v49;
  char v50[8];
  char v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  void *v58[2];
  _QWORD v59[3];
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v47[1] = a11;
  v48 = a1;
  v47[0] = &v48;
  v58[0] = v59;
  memset_pattern16(v59, &unk_207AB7410, 0x18uLL);
  v58[1] = (void *)0x300000003;
  v59[2] = 2;
  if (a7)
  {
    v16 = *a7;
    v17 = *((_QWORD *)a7 + 2);
  }
  else
  {
    v17 = 0;
    v16 = 0uLL;
  }
  v49 = a6;
  v50[0] = 0;
  v51 = 0;
  v52 = v16;
  v53 = v17;
  v54 = a9;
  v55 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v49);
    if (v51)
      v51 = 0;
    mlir::OperationName::OperationName(v50, "mps.non_maximum_suppression", 27, Context);
    v51 = 1;
  }
  v56 = a4;
  v57 = a5;
  if (a5)
  {
    v19 = mlir::UnknownLoc::get(v48, v15);
    if (mlir::mps::NonMaximumSuppressionOpAdaptor::verify((uint64_t)&v49, v19))
    {
      v45 = (_QWORD *)*((_QWORD *)&v52 + 1);
      if (*((_QWORD *)&v52 + 1))
      {
        mlir::IntegerAttr::getValue(&v45, (llvm::APInt *)&v60);
        if (v61 >= 0x41 && v60)
          MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
        v45 = (_QWORD *)*((_QWORD *)&v52 + 1);
        if (*((_QWORD *)&v52 + 1))
        {
          mlir::IntegerAttr::getValue(&v45, (llvm::APInt *)&v60);
          if (v61 >= 0x41)
            v20 = (unint64_t *)v60;
          else
            v20 = &v60;
          v21 = *(unsigned int *)v20;
          if (v61 >= 0x41 && v60)
            MEMORY[0x20BD002D4](v60, 0x1000C8000313F17);
        }
        else
        {
          v21 = 0;
        }
        *((_QWORD *)v58[0] + 1) = v21;
      }
      v60 = v56;
      v61 = 0;
      v22 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8))
      {
        v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
        v45 = v22;
        v46 = v23;
        if (v22)
        {
          if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v45))
          {
            mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
            if (v24 == 3)
            {
              Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
              v26 = v58[0];
              *(_QWORD *)v58[0] = *Shape;
              if (v26[1] == 0x8000000000000000)
              {
                v27 = mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
                *((_QWORD *)v58[0] + 1) = *(_QWORD *)(v27 + 8);
              }
            }
          }
        }
      }
      else
      {
        v45 = 0;
        v46 = 0;
      }
      v28 = v58[0];
      if (*(_QWORD *)v58[0] == 0x8000000000000000 || *((_QWORD *)v58[0] + 1) == 0x8000000000000000)
      {
        if (a5 < 2)
          goto LABEL_59;
        v60 = v56;
        v61 = 1;
        v60 = mlir::ValueRange::offset_base(&v60, 1);
        v61 = 0;
        v29 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v29 + 8))
        {
          v30 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v29 + 8);
          v60 = (unint64_t)v29;
          v61 = v30;
          if (v29)
          {
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v60))
            {
              mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
              if (v31 == 3)
              {
                v32 = v58[0];
                if (*(_QWORD *)v58[0] == 0x8000000000000000)
                {
                  v33 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
                  v32 = v58[0];
                  *(_QWORD *)v58[0] = *v33;
                }
                if (v32[1] == 0x8000000000000000)
                {
                  v34 = mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
                  *((_QWORD *)v58[0] + 1) = *(_QWORD *)(v34 + 8);
                }
              }
            }
          }
        }
        else
        {
          v60 = 0;
          v61 = 0;
        }
        v28 = v58[0];
        if (*(_QWORD *)v58[0] == 0x8000000000000000)
          goto LABEL_64;
      }
      if (v28[1] == 0x8000000000000000)
      {
LABEL_64:
        if (a5 >= 3)
        {
          v35 = v57;
          v60 = v56;
          v61 = 2;
          v36 = mlir::ValueRange::offset_base(&v60, 2);
          if (v35 - 2 != v61)
          {
            v60 = v36;
            v61 = 0;
            if (mlir::ValueRange::dereference_iterator(&v60, 0))
            {
              v60 = v56;
              v61 = 2;
              v60 = mlir::ValueRange::offset_base(&v60, 2);
              v61 = 0;
              v37 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
              v38 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v37 + 8);
              if (v38)
                v38 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v37 + 8);
              else
                v37 = 0;
              v60 = (unint64_t)v37;
              v61 = v38;
              if (v37)
              {
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v60))
                {
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
                  if (v39 == 2)
                  {
                    v40 = v58[0];
                    if (*(_QWORD *)v58[0] == 0x8000000000000000)
                    {
                      v41 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
                      v40 = v58[0];
                      *(_QWORD *)v58[0] = *v41;
                    }
                    if (v40[1] == 0x8000000000000000)
                    {
                      v42 = mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
                      *((_QWORD *)v58[0] + 1) = *(_QWORD *)(v42 + 8);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_59:
  v43 = mlir::mps::NonMaximumSuppressionOp::inferReturnTypes(mlir::MLIRContext *,std::optional<mlir::Location>,mlir::ValueRange,mlir::DictionaryAttr,mlir::OpaqueProperties,mlir::RegionRange,llvm::SmallVectorImpl<mlir::Type> &)::$_0::operator()((uint64_t)v47, (uint64_t)v58);
  if (v58[0] != v59)
    free(v58[0]);
  return v43;
}

uint64_t mlir::mps::NonMaximumSuppressionOpAdaptor::verify(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[4];
  __int16 v14;
  _QWORD v15[3];
  void *v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  void *__p;
  _QWORD *v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 32))
    return 1;
  v13[0] = *(_QWORD *)(a1 + 32);
  v15[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)v15, 32))
    return 1;
  v13[0] = "'mps.non_maximum_suppression' op attribute 'max_boxes' failed to satisfy constraint: 32-bit unsigned integer attribute";
  v14 = 259;
  mlir::emitError(a2, (uint64_t)v13, (uint64_t)v15);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
  if (v15[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
  if (v22)
  {
    v5 = __p;
    if (__p)
    {
      v6 = v21;
      v7 = __p;
      if (v21 != __p)
      {
        do
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        v7 = __p;
      }
      v21 = v5;
      operator delete(v7);
    }
    v8 = v18;
    if (v18)
    {
      v9 = v19;
      v10 = v18;
      if (v19 != v18)
      {
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
        }
        while (v9 != v8);
        v10 = v18;
      }
      v19 = v8;
      operator delete(v10);
    }
    if (v16 != &v17)
      free(v16);
  }
  return v3;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::inferReturnTypes(mlir::MLIRContext *,std::optional<mlir::Location>,mlir::ValueRange,mlir::DictionaryAttr,mlir::OpaqueProperties,mlir::RegionRange,llvm::SmallVectorImpl<mlir::Type> &)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x24BDAC8D0];
  v4 = mlir::IntegerType::get(**(_QWORD **)a1, 0x20u, 1u);
  v5 = mlir::IntegerType::get(**(_QWORD **)a1, 0x20u, 2u);
  v6 = *(_QWORD **)a2;
  v14[0] = **(_QWORD **)a2;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = mlir::RankedTensorType::get((uint64_t)v6, *(unsigned int *)(a2 + 8), v4, 0);
  v9 = *(unsigned int *)(v7 + 8);
  if (v9 >= *(_DWORD *)(v7 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(v7 + 8);
  }
  *(_QWORD *)(*(_QWORD *)v7 + 8 * v9) = v8;
  ++*(_DWORD *)(v7 + 8);
  v10 = *(_QWORD *)(a1 + 8);
  v11 = mlir::RankedTensorType::get((uint64_t)v14, 1, v5, 0);
  v12 = *(unsigned int *)(v10 + 8);
  if (v12 >= *(_DWORD *)(v10 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v10 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(v10 + 8);
  }
  *(_QWORD *)(*(_QWORD *)v10 + 8 * v12) = v11;
  ++*(_DWORD *)(v10 + 8);
  return 1;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::verify(uint64_t **this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t *Shape;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v50;
  uint64_t v51;
  const void **v52[4];
  __int16 v53;
  _QWORD *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  _QWORD v58[3];
  void *v59;
  uint64_t v60;
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD *v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v2 = (*this)[9];
  v3 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v3)
  {
    v4 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v3 + 8);
    v5 = (*this)[9];
    v56 = v3;
    v57 = v4;
    v6 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v6)
      goto LABEL_3;
LABEL_20:
    v54 = v6;
    v55 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v56))
      goto LABEL_4;
LABEL_21:
    v15 = 0;
    v14 = 0;
    v13 = 0;
    v12 = 0;
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54))
      goto LABEL_14;
LABEL_22:
    Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v54);
    mlir::ShapedType::getShape((mlir::ShapedType *)&v54);
    if (v23 != 3
      || v12 && *Shape != 0x8000000000000000 && *Shape != v13
      || (v24 = Shape[1], v14) && v24 != 0x8000000000000000 && v24 != v15)
    {
      v52[0] = (const void **)"scores tensor must have shape [N, B, K]";
      v53 = 259;
      mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
      v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
      if (v58[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
      if (!v65)
        return v25;
      v26 = __p;
      if (__p)
      {
        v27 = v64;
        v28 = __p;
        if (v64 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v64 = v26;
        operator delete(v28);
      }
      v29 = v61;
      if (v61)
      {
        v30 = v62;
        v31 = v61;
        if (v62 == v61)
          goto LABEL_93;
        do
        {
          v33 = *--v30;
          v32 = v33;
          *v30 = 0;
          if (v33)
            MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
        }
        while (v30 != v29);
LABEL_92:
        v31 = v61;
LABEL_93:
        v62 = v29;
        operator delete(v31);
      }
LABEL_94:
      if (v59 != &v60)
        free(v59);
      return v25;
    }
    if (*Shape != 0x8000000000000000)
    {
      v13 = *Shape;
      v12 = 1;
    }
    if (v24 != 0x8000000000000000)
    {
      v15 = Shape[1];
      v14 = 1;
    }
    v40 = Shape[2];
    v17 = v40 != 0x8000000000000000;
    if (v40 == 0x8000000000000000)
      v16 = 0;
    else
      v16 = Shape[2];
    v18 = *this;
    if (*((_DWORD *)*this + 17) == 4)
      return 1;
    goto LABEL_15;
  }
  v56 = 0;
  v57 = 0;
  v6 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_20;
LABEL_3:
  v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v6 + 8);
  v54 = v6;
  v55 = v7;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v56))
    goto LABEL_21;
LABEL_4:
  v8 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v56);
  mlir::ShapedType::getShape((mlir::ShapedType *)&v56);
  if (v9 != 3 || (v10 = v8[2], v10 != 0x8000000000000000) && v10 != 4)
  {
    v52[0] = (const void **)"boxes tensor must have shape [N, B, 4]";
    v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
    if (v58[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
    if (!v65)
      return v25;
    v34 = __p;
    if (__p)
    {
      v35 = v64;
      v36 = __p;
      if (v64 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v64 = v34;
      operator delete(v36);
    }
    v29 = v61;
    if (v61)
    {
      v37 = v62;
      v31 = v61;
      if (v62 == v61)
        goto LABEL_93;
      do
      {
        v39 = *--v37;
        v38 = v39;
        *v37 = 0;
        if (v39)
          MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
      }
      while (v37 != v29);
      goto LABEL_92;
    }
    goto LABEL_94;
  }
  v11 = v8[1];
  v12 = *v8 != 0x8000000000000000;
  if (*v8 == 0x8000000000000000)
    v13 = 0;
  else
    v13 = *v8;
  v14 = v11 != 0x8000000000000000;
  if (v11 == 0x8000000000000000)
    v15 = 0;
  else
    v15 = v8[1];
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54))
    goto LABEL_22;
LABEL_14:
  v16 = 0;
  v17 = 0;
  v18 = *this;
  if (*((_DWORD *)*this + 17) == 4)
    return 1;
LABEL_15:
  v19 = *(_QWORD *)(v18[9] + 88);
  if (!v19)
    return 1;
  v20 = (_QWORD *)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v20)
  {
    v50 = 0;
    v51 = 0;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50))
      goto LABEL_67;
    return 1;
  }
  v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  v50 = v20;
  v51 = v21;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50))
    return 1;
LABEL_67:
  v41 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v50);
  mlir::ShapedType::getShape((mlir::ShapedType *)&v50);
  if (v42 != 2
    || v12 && *v41 != 0x8000000000000000 && *v41 != v13
    || v14 && *v41 != 0x8000000000000000 && v41[1] != v15)
  {
    v52[0] = (const void **)"class_indices tensor must have shape [N, B]";
    v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
    if (v58[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
    if (!v65)
      return v25;
    v43 = __p;
    if (__p)
    {
      v44 = v64;
      v45 = __p;
      if (v64 != __p)
      {
        do
          v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
        while (v44 != v43);
        v45 = __p;
      }
      v64 = v43;
      operator delete(v45);
    }
    v29 = v61;
    if (v61)
    {
      v46 = v62;
      v31 = v61;
      if (v62 == v61)
        goto LABEL_93;
      do
      {
        v48 = *--v46;
        v47 = v48;
        *v46 = 0;
        if (v48)
          MEMORY[0x20BD002D4](v47, 0x1000C8077774924);
      }
      while (v46 != v29);
      goto LABEL_92;
    }
    goto LABEL_94;
  }
  if (v16 == 1 || !v17)
    return 1;
  v52[0] = (const void **)"when class_indices tensor is provided, scores tensor must have shape [N, B, 1]";
  v53 = 259;
  mlir::OpState::emitOpError(this, v52, (uint64_t)v58);
  v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v58);
  return v25;
}

uint64_t mlir::mps::ACosOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ACoshOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ASinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ASinhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ATan2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ATanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ATanhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::AbsoluteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::AbsoluteSquareOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::AddOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::AndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::AssignVariableOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BandPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BatchToSpaceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BiasAddGradOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BiasAddOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwiseAndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwiseLeftShiftOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwiseNotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwiseOrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwisePopcountOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwiseRightShiftOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BitwiseXorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BroadcastGradientArgsOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::BroadcastToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CallOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CeilOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ClampOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ColToImOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ConcatOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ConjugateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ConstantOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Conv2DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Conv2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Conv3DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Conv3DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CosOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CoshOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CostVolumeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CreateComplexOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CreateTextureTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CropOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CropResizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeMaximumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeMinimumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeProductOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeSumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DegammaOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthToSpace2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthwiseConv2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthwiseConv3DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DequantizeLUTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DequantizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DimensionSizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DiracOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DivideOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::DynamicShapeCastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::EluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::EqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ErfOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ExpandDimsOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ExponentBase10Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ExponentBase2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ExponentOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::FastFourierTransformOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Flatten2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::FloorDivideOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::FloorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GRUGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GRUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GatherAlongAxisOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GatherNDOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GatherOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GeluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GetCoordOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GreaterThanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GreaterThanOrEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::HammingDistanceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IdentityOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ImToColOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ImaginaryPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::InitRandomPhiloxStateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::InstanceNormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IsFiniteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IsInfiniteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IsNaNOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LPNormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LSTMGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LSTMOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LeakyReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LessThanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LessThanOrEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LocalConvolutionOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LocalConvolutionWeightGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LogarithmBase10Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LogarithmBase2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LogarithmOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatMulOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MaterializeSparseTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatrixDecompositionLUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatrixInverseOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatrixSolverLUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MaximumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MinimumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ModuloOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MultiplyOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NandOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NegativeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NonZeroOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NormalizationOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NotEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::OneHotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::OrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PadGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PadOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PermuteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PlaceholderOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolAvgGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolAvgOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolL2NormGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolL2NormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolMaxGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PowerOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PruningGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PruningOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::QuantizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RandomNormalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RandomTruncatedNormalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RandomUniformOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RankOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReadVariableOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RealPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RealToHermiteanFFTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReciprocalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionAndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionArgMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionArgMinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionLogSumExpOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionMeanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionMinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionOrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionProdOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionSumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionVarianceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReinterpretCastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Relu6Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReluGradOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReshapeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ResizeGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ResizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReverseOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReverseSquareRootOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RintOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RoundOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SampleGridDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SampleGridOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ScatterAlongAxisOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ScatterNDOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ScatterOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SelectOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ShapeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidGradientWithSigmoidOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidHardOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SignOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SignbitOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SingleGateRNNGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SingleGateRNNOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SinhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SliceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftmaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftplusOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftplusParametricOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftsignOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SortOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SpaceToBatchOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SpaceToDepth2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SplitOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SquareOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SquareRootOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SqueezeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StencilOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StridedSliceGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StridedSliceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StridedSliceUpdateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SubtractOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SwishOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TanhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TileGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TileOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TopKGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TopKOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TransposeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TruncateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TypeConstraintOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::UnrealizedFoldOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::UpdateRandomStateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::VariableFromTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::XnorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::XorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::RegionBranchOpInterface::getEntrySuccessorOperands((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::symbolizeMetalPixelFormat(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v6;

  switch(a2)
  {
    case 7:
      if (*(_DWORD *)a1 != 1851078738 || *(_DWORD *)(a1 + 3) != 1836216174)
        goto LABEL_40;
      result = 0x100000000;
      break;
    case 8:
      switch(*(_QWORD *)a1)
      {
        case 0x6D726F6E55384752:
          result = 0x100000001;
          break;
        case 0x74616F6C46363152:
          result = 0x100000004;
          break;
        case 0x74616F6C46323352:
          result = 0x100000007;
          break;
        default:
          goto LABEL_40;
      }
      break;
    case 9:
      if (*(_QWORD *)a1 == 0x616F6C4636314752 && *(_BYTE *)(a1 + 8) == 116)
      {
        result = 0x100000005;
      }
      else
      {
        if (*(_QWORD *)a1 != 0x616F6C4632334752 || *(_BYTE *)(a1 + 8) != 116)
          goto LABEL_40;
        result = 0x100000008;
      }
      break;
    case 10:
      v6 = 0x100000002;
      if (*(_QWORD *)a1 == 0x6F6E553841424752 && *(_WORD *)(a1 + 8) == 28018)
        goto LABEL_41;
      if (*(_QWORD *)a1 != 0x6F6E553841524742 || *(_WORD *)(a1 + 8) != 28018)
        goto LABEL_40;
      result = 0x100000003;
      break;
    case 11:
      if (*(_QWORD *)a1 == 0x6C46363141424752 && *(_QWORD *)(a1 + 3) == 0x74616F6C46363141)
      {
        result = 0x100000006;
      }
      else
      {
        if (*(_QWORD *)a1 != 0x6C46323341424752 || *(_QWORD *)(a1 + 3) != 0x74616F6C46323341)
          goto LABEL_40;
        result = 0x100000009;
      }
      break;
    default:
LABEL_40:
      v6 = 0;
LABEL_41:
      result = v6;
      break;
  }
  return result;
}

uint64_t mlir::mps::symbolizeNearestRoundingMode(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  switch(a2)
  {
    case 4:
      if (*(_DWORD *)a1 != 1818846563)
        goto LABEL_38;
      result = 0x100000002;
      break;
    case 5:
      if (*(_DWORD *)a1 != 1869573222 || *(_BYTE *)(a1 + 4) != 114)
        goto LABEL_38;
      result = 0x100000003;
      break;
    case 12:
      if (*(_QWORD *)a1 != 0x6F745F646E756F72 || *(_DWORD *)(a1 + 8) != 1684303711)
        goto LABEL_38;
      result = 0x100000005;
      break;
    case 13:
      if (*(_QWORD *)a1 != 0x6F745F646E756F72 || *(_QWORD *)(a1 + 5) != 0x6E6576655F6F745FLL)
        goto LABEL_38;
      result = 0x100000004;
      break;
    case 17:
      if (*(_QWORD *)a1 != 0x72705F646E756F72
        || *(_QWORD *)(a1 + 8) != 0x6965635F72656665
        || *(_BYTE *)(a1 + 16) != 108)
      {
        goto LABEL_38;
      }
      result = 0x100000000;
      break;
    case 18:
      if (*(_QWORD *)a1 != 0x72705F646E756F72
        || *(_QWORD *)(a1 + 8) != 0x6F6C665F72656665
        || *(_WORD *)(a1 + 16) != 29295)
      {
        goto LABEL_38;
      }
      result = 0x100000001;
      break;
    default:
LABEL_38:
      result = 0;
      break;
  }
  return result;
}

uint64_t mlir::mps::symbolizePaddingStyle(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    if (*(_DWORD *)a1 == 1398752852 && *(_DWORD *)(a1 + 3) == 1162690899)
      return 0x100000002;
    return 0;
  }
  if (a2 == 15)
  {
    if (*(_QWORD *)a1 == 0x544943494C505845 && *(_QWORD *)(a1 + 7) == 0x54455346464F5F54)
      return 0x100000003;
    if (*(_QWORD *)a1 == 0x4D41535F584E4E4FLL && *(_QWORD *)(a1 + 7) == 0x5245574F4C5F454DLL)
      return 0x100000004;
    return 0;
  }
  if (a2 != 8)
    return 0;
  if (*(_QWORD *)a1 != 0x544943494C505845)
  {
    if (*(_QWORD *)a1 == 0x44494C41565F4654)
      return 0x100000001;
    return 0;
  }
  return 0x100000000;
}

uint64_t mlir::mps::symbolizePoolIndicesMode(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  if (a2 == 15)
  {
    if (*a1 == 0x6C465F6C61636F4CLL && *(_QWORD *)((char *)a1 + 7) == 0x44316E657474616CLL)
      return 0x100000004;
    if (*a1 == 0x6C465F6C61636F4CLL && *(_QWORD *)((char *)a1 + 7) == 0x44326E657474616CLL)
      return 0x100000005;
    if (*a1 == 0x6C465F6C61636F4CLL && *(_QWORD *)((char *)a1 + 7) == 0x44336E657474616CLL)
      return 0x100000006;
    v4 = 0x100000007;
    if (*a1 ^ 0x6C465F6C61636F4CLL | *(_QWORD *)((char *)a1 + 7) ^ 0x44346E657474616CLL)
      return 0;
    return v4;
  }
  if (a2 != 16)
    return 0;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44316E657474616CLL)
    return 0x100000000;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44326E657474616CLL)
    return 0x100000001;
  v4 = 0x100000002;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44336E657474616CLL)
    return v4;
  if (*a1 != 0x465F6C61626F6C47 || a1[1] != 0x44346E657474616CLL)
    return 0;
  return 0x100000003;
}

uint64_t mlir::mps::symbolizeRNNActivation(int *a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  int v5;
  uint64_t v7;
  int v8;

  result = 0;
  switch(a2)
  {
    case 4:
      switch(*a1)
      {
        case 1701736302:
          result = 0x100000000;
          break;
        case 1970038130:
          result = 0x100000001;
          break;
        case 1752064372:
          result = 0x100000002;
          break;
        default:
          goto LABEL_19;
      }
      break;
    case 7:
      v4 = *a1;
      v5 = *(int *)((char *)a1 + 3);
      if (v4 != 1835493747 || v5 != 1684631405)
        goto LABEL_19;
      result = 0x100000003;
      break;
    case 11:
      if (*(_QWORD *)a1 ^ 0x745F64656C616373 | *(_QWORD *)((char *)a1 + 3) ^ 0x686E61745F64656CLL)
        result = 0;
      else
        result = 0x100000005;
      break;
    case 12:
      v7 = *(_QWORD *)a1;
      v8 = a1[2];
      if (v7 == 0x6769735F64726168 && v8 == 1684631405)
        result = 0x100000004;
      else
LABEL_19:
        result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::symbolizeReductionMode(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    if (*(_DWORD *)a1 == 1685025392 && *(_DWORD *)(a1 + 3) == 1952675172)
      return 0x100000003;
    if (*(_DWORD *)a1 == 1298625121 && *(_DWORD *)(a1 + 3) == 544106829)
      return 0x100000004;
    return 0;
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 ^ 0x4D677261 | *(unsigned __int16 *)(a1 + 4) ^ 0x7861)
      return 0;
    else
      return 0x100000005;
  }
  if (a2 != 3)
    return 0;
  if (*(_WORD *)a1 == 26989 && *(_BYTE *)(a1 + 2) == 110)
    return 0x100000000;
  if (*(_WORD *)a1 != 24941 || *(_BYTE *)(a1 + 2) != 120)
  {
    if (*(_WORD *)a1 == 30067 && *(_BYTE *)(a1 + 2) == 109)
      return 0x100000002;
    return 0;
  }
  return 0x100000001;
}

uint64_t mlir::mps::symbolizeScatterMode(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    if (*(_QWORD *)a1 != 0x7463617274627573)
    {
      if (*(_QWORD *)a1 == 0x796C7069746C756DLL)
        return 0x100000002;
      return 0;
    }
    return 0x100000001;
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 == 1769367908 && *(_WORD *)(a1 + 4) == 25956)
      return 0x100000003;
    return 0;
  }
  if (a2 != 3)
    return 0;
  if (*(_WORD *)a1 == 25697 && *(_BYTE *)(a1 + 2) == 100)
    return 0x100000000;
  if (*(_WORD *)a1 == 26989 && *(_BYTE *)(a1 + 2) == 110)
    return 0x100000004;
  if (*(_WORD *)a1 != 24941 || *(_BYTE *)(a1 + 2) != 120)
  {
    if (*(_WORD *)a1 == 25971 && *(_BYTE *)(a1 + 2) == 116)
      return 0x100000006;
    return 0;
  }
  return 0x100000005;
}

uint64_t mlir::mps::symbolizeStencilPaddingMode(int *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  int v6;
  int v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  result = 0;
  switch(a2)
  {
    case 4:
      v4 = 0x100000004;
      v5 = *a1 == 1869768058;
      goto LABEL_18;
    case 6:
      v6 = *a1;
      v7 = *((unsigned __int16 *)a1 + 2);
      if (v6 != 1920100717 || v7 != 29295)
        return 0;
      return 0x100000001;
    case 8:
      if (*(_QWORD *)a1 == 0x746E6174736E6F63)
      {
        result = 0x100000000;
      }
      else if (*(_QWORD *)a1 == 0x6369646F69726570)
      {
        result = 0x100000005;
      }
      else
      {
LABEL_25:
        result = 0;
      }
      break;
    case 11:
      v9 = *(_QWORD *)a1;
      v10 = *(_QWORD *)((char *)a1 + 3);
      if (v9 == 0x456F54706D616C63 && v10 == 0x656764456F54706DLL)
        return 0x100000003;
      else
        return 0;
    case 12:
      v4 = 0x100000006;
      v5 = (*(_QWORD *)a1 ^ 0x6972655069746E61 | a1[2] ^ 0x6369646FLL) == 0;
LABEL_18:
      if (v5)
        return v4;
      else
        return 0;
    case 14:
      v12 = *(_QWORD *)a1;
      v13 = *(_QWORD *)((char *)a1 + 6);
      if (v12 != 0x6957726F7272696DLL || v13 != 0x6567644568746957)
        goto LABEL_25;
      result = 0x100000002;
      break;
    default:
      return result;
  }
  return result;
}

char *mlir::mps::stringifyTensorDataLayout(unsigned int a1)
{
  if (a1 > 0xA)
    return &byte_207AF6795;
  else
    return off_24C061168[a1];
}

uint64_t mlir::mps::symbolizeTensorDataLayout(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  switch(a2)
  {
    case 2:
      if (*(_WORD *)a1 != 22344)
        goto LABEL_18;
      result = 0x100000006;
      break;
    case 3:
      if (*(_WORD *)a1 == 18499 && *(_BYTE *)(a1 + 2) == 87)
      {
        result = 0x100000004;
      }
      else
      {
        if (*(_WORD *)a1 != 22344 || *(_BYTE *)(a1 + 2) != 67)
          goto LABEL_18;
        result = 0x100000005;
      }
      break;
    case 4:
      if (*(_DWORD *)a1 == 1464353614)
      {
        result = 0x100000000;
      }
      else if (*(_DWORD *)a1 == 1129793614)
      {
        result = 0x100000001;
      }
      else
      {
        v5 = 0x100000002;
        if (*(_DWORD *)a1 == 1464355151)
          goto LABEL_33;
        if (*(_DWORD *)a1 != 1330206536)
          goto LABEL_18;
        result = 0x100000003;
      }
      break;
    case 5:
      if (*(_DWORD *)a1 == 1212433230 && *(_BYTE *)(a1 + 4) == 87)
      {
        result = 0x100000007;
      }
      else if (*(_DWORD *)a1 == 1464353870 && *(_BYTE *)(a1 + 4) == 67)
      {
        result = 0x100000008;
      }
      else if (*(_DWORD *)a1 == 1212434767 && *(_BYTE *)(a1 + 4) == 87)
      {
        result = 0x100000009;
      }
      else
      {
        v5 = 0x10000000ALL;
        if (*(_DWORD *)a1 ^ 0x49574844 | *(unsigned __int8 *)(a1 + 4) ^ 0x4F)
          v5 = 0;
LABEL_33:
        result = v5;
      }
      break;
    default:
LABEL_18:
      result = 0;
      break;
  }
  return result;
}

mlir::mps::MPSDialect *mlir::mps::MPSDialect::MPSDialect(mlir::mps::MPSDialect *this, mlir::MLIRContext *a2)
{
  mlir::mps::MPSDialect *v3;

  v3 = (mlir::mps::MPSDialect *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"mps", 3, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id);
  *(_QWORD *)v3 = off_24C04FD48;
  mlir::mps::MPSDialect::initialize(v3);
  return this;
}

void mlir::mps::MPSDialect::~MPSDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_20773282C()
{
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::mps::TensorDataLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::TensorDataLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  uint64_t v87;
  int *v88;
  int *v89;
  int *v90;
  __int128 v91;
  uint64_t v92;
  int *v93;
  int *v94;
  int *v95;
  __int128 v96;
  uint64_t v97;
  int *v98;
  int *v99;
  int *v100;
  __int128 v101;
  uint64_t v102;
  int *v103;
  int *v104;
  int *v105;
  __int128 v106;
  uint64_t v107;
  int *v108;
  int *v109;
  int *v110;
  __int128 v111;
  uint64_t v112;
  int *v113;
  int *v114;
  int *v115;
  __int128 v116;
  uint64_t v117;
  int *v118;
  int *v119;
  int *v120;
  __int128 v121;
  uint64_t v122;
  int *v123;
  int *v124;
  int *v125;
  __int128 v126;
  _QWORD *v127;
  _QWORD *v128;
  void *v129;
  _QWORD *v130;
  _QWORD *v131;
  void *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _QWORD *v136;
  _QWORD *v137;
  void *v138;
  _QWORD *v139;
  _QWORD *v140;
  void *v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  unint64_t v145;
  BOOL v146;
  unint64_t v147;
  BOOL v148;
  unint64_t v149;
  BOOL v150;
  unint64_t v151;
  BOOL v152;
  unint64_t v153;
  BOOL v154;
  unint64_t v155;
  BOOL v156;
  unint64_t v157;
  BOOL v158;
  unint64_t v159;
  BOOL v160;
  unint64_t v161;
  BOOL v162;
  unint64_t v163;
  BOOL v164;
  unint64_t v165;
  BOOL v166;
  unint64_t v167;
  BOOL v168;
  unint64_t v169;
  BOOL v170;
  unint64_t v171;
  BOOL v172;
  unint64_t v173;
  BOOL v174;
  unint64_t v175;
  BOOL v176;
  int64_t v177;
  unint64_t v178;
  BOOL v179;
  int64_t v180;
  unint64_t v181;
  BOOL v182;
  int64_t v183;
  unint64_t v184;
  BOOL v185;
  int64_t v186;
  unint64_t v187;
  BOOL v188;
  int64_t v189;
  unint64_t v190;
  BOOL v191;
  int64_t v192;
  unint64_t v193;
  BOOL v194;
  int64_t v195;
  unint64_t v196;
  BOOL v197;
  int64_t v198;
  int64_t v199;
  int64_t v200;
  int64_t v201;
  int64_t v202;
  int64_t v203;
  int64_t v204;
  int64_t v205;
  int64_t v206;
  int64_t v207;
  int64_t v208;
  int64_t v209;
  int64_t v210;
  int64_t v211;
  int64_t v212;
  int64_t v213;
  int64_t v214;
  unsigned int v215[8];
  __int16 v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  const char *v220;
  uint64_t v221;
  _QWORD v222[3];
  void *v223;
  uint64_t v224;
  void *v225;
  _QWORD *v226;
  void *__p;
  _QWORD *v228;
  char v229;
  _QWORD v230[3];
  int *v231;
  unsigned int v232;
  unsigned int v233;
  _BYTE v234[96];
  _QWORD *v235;
  _QWORD *v236;
  _QWORD *v237;
  _QWORD *v238;
  char v239;
  uint64_t v240;

  v240 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v217 = 0;
  v218 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v217))
  {
LABEL_73:
    v135 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v232) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v222, a1, v135, v230);
    if (v222[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v222);
    if (v229)
    {
      v136 = __p;
      if (__p)
      {
        v137 = v228;
        v138 = __p;
        if (v228 != __p)
        {
          do
            v137 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v137 - 1);
          while (v137 != v136);
          v138 = __p;
        }
        v228 = v136;
        operator delete(v138);
      }
      v139 = v225;
      if (v225)
      {
        v140 = v226;
        v141 = v225;
        if (v226 != v225)
        {
          do
          {
            v143 = *--v140;
            v142 = v143;
            *v140 = 0;
            if (v143)
              MEMORY[0x20BD002D4](v142, 0x1000C8077774924);
          }
          while (v140 != v139);
          v141 = v225;
        }
        v226 = v139;
        operator delete(v141);
      }
      if (v223 != &v224)
        free(v223);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeTensorDataLayout(v217, v218);
  if ((v3 & 0xFF00000000) == 0)
  {
    v216 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v230, a1, v2, v215);
    if (v230[0])
    {
      v219 = 3;
      v220 = "expected ";
      v221 = 9;
      v8 = &v219;
      v9 = v231;
      if (v232 >= v233)
      {
        v144 = v232 + 1;
        if (v231 <= &v219 && &v231[6 * v232] > &v219)
        {
          v177 = (char *)&v219 - (char *)v231;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v144, 24);
          v9 = v231;
          v8 = (int *)((char *)v231 + v177);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v144, 24);
          v8 = &v219;
          v9 = v231;
        }
      }
      v10 = &v9[6 * v232];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v232;
      if (v230[0])
      {
        v219 = 3;
        v220 = "::mlir::mps::TensorDataLayout";
        v221 = 29;
        v13 = &v219;
        v14 = v231;
        if (v12 >= v233)
        {
          v145 = v12 + 1;
          v146 = &v231[6 * v12] > &v219;
          if (v231 <= &v219 && v146)
          {
            v180 = (char *)&v219 - (char *)v231;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v145, 24);
            v14 = v231;
            v13 = (int *)((char *)v231 + v180);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v145, 24);
            v13 = &v219;
            v14 = v231;
          }
        }
        v15 = &v14[6 * v232];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v232;
        if (v230[0])
        {
          v219 = 3;
          v220 = " to be one of: ";
          v221 = 15;
          v18 = &v219;
          v19 = v231;
          if (v17 >= v233)
          {
            v147 = v17 + 1;
            v148 = &v231[6 * v17] > &v219;
            if (v231 <= &v219 && v148)
            {
              v183 = (char *)&v219 - (char *)v231;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v147, 24);
              v19 = v231;
              v18 = (int *)((char *)v231 + v183);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v147, 24);
              v18 = &v219;
              v19 = v231;
            }
          }
          v20 = &v19[6 * v232];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v232;
          if (v230[0])
          {
            v219 = 3;
            v220 = "NCHW";
            v221 = 4;
            v23 = &v219;
            v24 = v231;
            if (v22 >= v233)
            {
              v149 = v22 + 1;
              v150 = &v231[6 * v22] > &v219;
              if (v231 <= &v219 && v150)
              {
                v186 = (char *)&v219 - (char *)v231;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v149, 24);
                v24 = v231;
                v23 = (int *)((char *)v231 + v186);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v149, 24);
                v23 = &v219;
                v24 = v231;
              }
            }
            v25 = &v24[6 * v232];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v232;
            if (v230[0])
            {
              v219 = 3;
              v220 = ", ";
              v221 = 2;
              v28 = &v219;
              v29 = v231;
              if (v27 >= v233)
              {
                v151 = v27 + 1;
                v152 = &v231[6 * v27] > &v219;
                if (v231 <= &v219 && v152)
                {
                  v189 = (char *)&v219 - (char *)v231;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v151, 24);
                  v29 = v231;
                  v28 = (int *)((char *)v231 + v189);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v151, 24);
                  v28 = &v219;
                  v29 = v231;
                }
              }
              v30 = &v29[6 * v232];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v232;
              if (v230[0])
              {
                v219 = 3;
                v220 = "NHWC";
                v221 = 4;
                v33 = &v219;
                v34 = v231;
                if (v32 >= v233)
                {
                  v153 = v32 + 1;
                  v154 = &v231[6 * v32] > &v219;
                  if (v231 <= &v219 && v154)
                  {
                    v192 = (char *)&v219 - (char *)v231;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v153, 24);
                    v34 = v231;
                    v33 = (int *)((char *)v231 + v192);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v153, 24);
                    v33 = &v219;
                    v34 = v231;
                  }
                }
                v35 = &v34[6 * v232];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v232;
                if (v230[0])
                {
                  v219 = 3;
                  v220 = ", ";
                  v221 = 2;
                  v38 = &v219;
                  v39 = v231;
                  if (v37 >= v233)
                  {
                    v155 = v37 + 1;
                    v156 = &v231[6 * v37] > &v219;
                    if (v231 <= &v219 && v156)
                    {
                      v195 = (char *)&v219 - (char *)v231;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v155, 24);
                      v39 = v231;
                      v38 = (int *)((char *)v231 + v195);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v155, 24);
                      v38 = &v219;
                      v39 = v231;
                    }
                  }
                  v40 = &v39[6 * v232];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v232;
                  if (v230[0])
                  {
                    v219 = 3;
                    v220 = "OIHW";
                    v221 = 4;
                    v43 = &v219;
                    v44 = v231;
                    if (v42 >= v233)
                    {
                      v157 = v42 + 1;
                      v158 = &v231[6 * v42] > &v219;
                      if (v231 <= &v219 && v158)
                      {
                        v198 = (char *)&v219 - (char *)v231;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v157, 24);
                        v44 = v231;
                        v43 = (int *)((char *)v231 + v198);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v157, 24);
                        v43 = &v219;
                        v44 = v231;
                      }
                    }
                    v45 = &v44[6 * v232];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v232;
                    if (v230[0])
                    {
                      v219 = 3;
                      v220 = ", ";
                      v221 = 2;
                      v48 = &v219;
                      v49 = v231;
                      if (v47 >= v233)
                      {
                        v159 = v47 + 1;
                        v160 = &v231[6 * v47] > &v219;
                        if (v231 <= &v219 && v160)
                        {
                          v199 = (char *)&v219 - (char *)v231;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v159, 24);
                          v49 = v231;
                          v48 = (int *)((char *)v231 + v199);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v159, 24);
                          v48 = &v219;
                          v49 = v231;
                        }
                      }
                      v50 = &v49[6 * v232];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v232;
                      if (v230[0])
                      {
                        v219 = 3;
                        v220 = "HWIO";
                        v221 = 4;
                        v53 = &v219;
                        v54 = v231;
                        if (v52 >= v233)
                        {
                          v161 = v52 + 1;
                          v162 = &v231[6 * v52] > &v219;
                          if (v231 <= &v219 && v162)
                          {
                            v200 = (char *)&v219 - (char *)v231;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v161, 24);
                            v54 = v231;
                            v53 = (int *)((char *)v231 + v200);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v161, 24);
                            v53 = &v219;
                            v54 = v231;
                          }
                        }
                        v55 = &v54[6 * v232];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v232;
                        if (v230[0])
                        {
                          v219 = 3;
                          v220 = ", ";
                          v221 = 2;
                          v58 = &v219;
                          v59 = v231;
                          if (v57 >= v233)
                          {
                            v163 = v57 + 1;
                            v164 = &v231[6 * v57] > &v219;
                            if (v231 <= &v219 && v164)
                            {
                              v201 = (char *)&v219 - (char *)v231;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v163, 24);
                              v59 = v231;
                              v58 = (int *)((char *)v231 + v201);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v163, 24);
                              v58 = &v219;
                              v59 = v231;
                            }
                          }
                          v60 = &v59[6 * v232];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v232;
                          if (v230[0])
                          {
                            v219 = 3;
                            v220 = "CHW";
                            v221 = 3;
                            v63 = &v219;
                            v64 = v231;
                            if (v62 >= v233)
                            {
                              v165 = v62 + 1;
                              v166 = &v231[6 * v62] > &v219;
                              if (v231 <= &v219 && v166)
                              {
                                v202 = (char *)&v219 - (char *)v231;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v165, 24);
                                v64 = v231;
                                v63 = (int *)((char *)v231 + v202);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v165, 24);
                                v63 = &v219;
                                v64 = v231;
                              }
                            }
                            v65 = &v64[6 * v232];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v232;
                            if (v230[0])
                            {
                              v219 = 3;
                              v220 = ", ";
                              v221 = 2;
                              v68 = &v219;
                              v69 = v231;
                              if (v67 >= v233)
                              {
                                v167 = v67 + 1;
                                v168 = &v231[6 * v67] > &v219;
                                if (v231 <= &v219 && v168)
                                {
                                  v203 = (char *)&v219 - (char *)v231;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v167, 24);
                                  v69 = v231;
                                  v68 = (int *)((char *)v231 + v203);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v167, 24);
                                  v68 = &v219;
                                  v69 = v231;
                                }
                              }
                              v70 = &v69[6 * v232];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v232;
                              if (v230[0])
                              {
                                v219 = 3;
                                v220 = "HWC";
                                v221 = 3;
                                v73 = &v219;
                                v74 = v231;
                                if (v72 >= v233)
                                {
                                  v169 = v72 + 1;
                                  v170 = &v231[6 * v72] > &v219;
                                  if (v231 <= &v219 && v170)
                                  {
                                    v204 = (char *)&v219 - (char *)v231;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v169, 24);
                                    v74 = v231;
                                    v73 = (int *)((char *)v231 + v204);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v169, 24);
                                    v73 = &v219;
                                    v74 = v231;
                                  }
                                }
                                v75 = &v74[6 * v232];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v232;
                                if (v230[0])
                                {
                                  v219 = 3;
                                  v220 = ", ";
                                  v221 = 2;
                                  v78 = &v219;
                                  v79 = v231;
                                  if (v77 >= v233)
                                  {
                                    v171 = v77 + 1;
                                    v172 = &v231[6 * v77] > &v219;
                                    if (v231 <= &v219 && v172)
                                    {
                                      v205 = (char *)&v219 - (char *)v231;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v171, 24);
                                      v79 = v231;
                                      v78 = (int *)((char *)v231 + v205);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v171, 24);
                                      v78 = &v219;
                                      v79 = v231;
                                    }
                                  }
                                  v80 = &v79[6 * v232];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v232;
                                  if (v230[0])
                                  {
                                    v219 = 3;
                                    v220 = "HW";
                                    v221 = 2;
                                    v83 = &v219;
                                    v84 = v231;
                                    if (v82 >= v233)
                                    {
                                      v173 = v82 + 1;
                                      v174 = &v231[6 * v82] > &v219;
                                      if (v231 <= &v219 && v174)
                                      {
                                        v206 = (char *)&v219 - (char *)v231;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v173, 24);
                                        v84 = v231;
                                        v83 = (int *)((char *)v231 + v206);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v173, 24);
                                        v83 = &v219;
                                        v84 = v231;
                                      }
                                    }
                                    v85 = &v84[6 * v232];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    v87 = ++v232;
                                    if (v230[0])
                                    {
                                      v219 = 3;
                                      v220 = ", ";
                                      v221 = 2;
                                      v88 = &v219;
                                      v89 = v231;
                                      if (v87 >= v233)
                                      {
                                        v175 = v87 + 1;
                                        v176 = &v231[6 * v87] > &v219;
                                        if (v231 <= &v219 && v176)
                                        {
                                          v207 = (char *)&v219 - (char *)v231;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v175, 24);
                                          v89 = v231;
                                          v88 = (int *)((char *)v231 + v207);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v175, 24);
                                          v88 = &v219;
                                          v89 = v231;
                                        }
                                      }
                                      v90 = &v89[6 * v232];
                                      v91 = *(_OWORD *)v88;
                                      *((_QWORD *)v90 + 2) = *((_QWORD *)v88 + 2);
                                      *(_OWORD *)v90 = v91;
                                      v92 = ++v232;
                                      if (v230[0])
                                      {
                                        v219 = 3;
                                        v220 = "NCDHW";
                                        v221 = 5;
                                        v93 = &v219;
                                        v94 = v231;
                                        if (v92 >= v233)
                                        {
                                          v178 = v92 + 1;
                                          v179 = &v231[6 * v92] > &v219;
                                          if (v231 <= &v219 && v179)
                                          {
                                            v208 = (char *)&v219 - (char *)v231;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v178, 24);
                                            v94 = v231;
                                            v93 = (int *)((char *)v231 + v208);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v178, 24);
                                            v93 = &v219;
                                            v94 = v231;
                                          }
                                        }
                                        v95 = &v94[6 * v232];
                                        v96 = *(_OWORD *)v93;
                                        *((_QWORD *)v95 + 2) = *((_QWORD *)v93 + 2);
                                        *(_OWORD *)v95 = v96;
                                        v97 = ++v232;
                                        if (v230[0])
                                        {
                                          v219 = 3;
                                          v220 = ", ";
                                          v221 = 2;
                                          v98 = &v219;
                                          v99 = v231;
                                          if (v97 >= v233)
                                          {
                                            v181 = v97 + 1;
                                            v182 = &v231[6 * v97] > &v219;
                                            if (v231 <= &v219 && v182)
                                            {
                                              v209 = (char *)&v219 - (char *)v231;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v181, 24);
                                              v99 = v231;
                                              v98 = (int *)((char *)v231 + v209);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v181, 24);
                                              v98 = &v219;
                                              v99 = v231;
                                            }
                                          }
                                          v100 = &v99[6 * v232];
                                          v101 = *(_OWORD *)v98;
                                          *((_QWORD *)v100 + 2) = *((_QWORD *)v98 + 2);
                                          *(_OWORD *)v100 = v101;
                                          v102 = ++v232;
                                          if (v230[0])
                                          {
                                            v219 = 3;
                                            v220 = "NDHWC";
                                            v221 = 5;
                                            v103 = &v219;
                                            v104 = v231;
                                            if (v102 >= v233)
                                            {
                                              v184 = v102 + 1;
                                              v185 = &v231[6 * v102] > &v219;
                                              if (v231 <= &v219 && v185)
                                              {
                                                v210 = (char *)&v219 - (char *)v231;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v184, 24);
                                                v104 = v231;
                                                v103 = (int *)((char *)v231 + v210);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v184, 24);
                                                v103 = &v219;
                                                v104 = v231;
                                              }
                                            }
                                            v105 = &v104[6 * v232];
                                            v106 = *(_OWORD *)v103;
                                            *((_QWORD *)v105 + 2) = *((_QWORD *)v103 + 2);
                                            *(_OWORD *)v105 = v106;
                                            v107 = ++v232;
                                            if (v230[0])
                                            {
                                              v219 = 3;
                                              v220 = ", ";
                                              v221 = 2;
                                              v108 = &v219;
                                              v109 = v231;
                                              if (v107 >= v233)
                                              {
                                                v187 = v107 + 1;
                                                v188 = &v231[6 * v107] > &v219;
                                                if (v231 <= &v219 && v188)
                                                {
                                                  v211 = (char *)&v219 - (char *)v231;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v187, 24);
                                                  v109 = v231;
                                                  v108 = (int *)((char *)v231 + v211);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v187, 24);
                                                  v108 = &v219;
                                                  v109 = v231;
                                                }
                                              }
                                              v110 = &v109[6 * v232];
                                              v111 = *(_OWORD *)v108;
                                              *((_QWORD *)v110 + 2) = *((_QWORD *)v108 + 2);
                                              *(_OWORD *)v110 = v111;
                                              v112 = ++v232;
                                              if (v230[0])
                                              {
                                                v219 = 3;
                                                v220 = "OIDHW";
                                                v221 = 5;
                                                v113 = &v219;
                                                v114 = v231;
                                                if (v112 >= v233)
                                                {
                                                  v190 = v112 + 1;
                                                  v191 = &v231[6 * v112] > &v219;
                                                  if (v231 <= &v219 && v191)
                                                  {
                                                    v212 = (char *)&v219 - (char *)v231;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v190, 24);
                                                    v114 = v231;
                                                    v113 = (int *)((char *)v231 + v212);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v190, 24);
                                                    v113 = &v219;
                                                    v114 = v231;
                                                  }
                                                }
                                                v115 = &v114[6 * v232];
                                                v116 = *(_OWORD *)v113;
                                                *((_QWORD *)v115 + 2) = *((_QWORD *)v113 + 2);
                                                *(_OWORD *)v115 = v116;
                                                v117 = ++v232;
                                                if (v230[0])
                                                {
                                                  v219 = 3;
                                                  v220 = ", ";
                                                  v221 = 2;
                                                  v118 = &v219;
                                                  v119 = v231;
                                                  if (v117 >= v233)
                                                  {
                                                    v193 = v117 + 1;
                                                    v194 = &v231[6 * v117] > &v219;
                                                    if (v231 <= &v219 && v194)
                                                    {
                                                      v213 = (char *)&v219 - (char *)v231;
                                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v193, 24);
                                                      v119 = v231;
                                                      v118 = (int *)((char *)v231 + v213);
                                                    }
                                                    else
                                                    {
                                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v193, 24);
                                                      v118 = &v219;
                                                      v119 = v231;
                                                    }
                                                  }
                                                  v120 = &v119[6 * v232];
                                                  v121 = *(_OWORD *)v118;
                                                  *((_QWORD *)v120 + 2) = *((_QWORD *)v118 + 2);
                                                  *(_OWORD *)v120 = v121;
                                                  v122 = ++v232;
                                                  if (v230[0])
                                                  {
                                                    v219 = 3;
                                                    v220 = "DHWIO";
                                                    v221 = 5;
                                                    v123 = &v219;
                                                    v124 = v231;
                                                    if (v122 >= v233)
                                                    {
                                                      v196 = v122 + 1;
                                                      v197 = &v231[6 * v122] > &v219;
                                                      if (v231 <= &v219 && v197)
                                                      {
                                                        v214 = (char *)&v219 - (char *)v231;
                                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v196, 24);
                                                        v124 = v231;
                                                        v123 = (int *)((char *)v231 + v214);
                                                      }
                                                      else
                                                      {
                                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v196, 24);
                                                        v123 = &v219;
                                                        v124 = v231;
                                                      }
                                                    }
                                                    v125 = &v124[6 * v232];
                                                    v126 = *(_OWORD *)v123;
                                                    *((_QWORD *)v125 + 2) = *((_QWORD *)v123 + 2);
                                                    *(_OWORD *)v125 = v126;
                                                    ++v232;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v230);
    if (v230[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v230);
    if (v239)
    {
      v127 = v237;
      if (v237)
      {
        v128 = v238;
        v129 = v237;
        if (v238 != v237)
        {
          do
            v128 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v128 - 1);
          while (v128 != v127);
          v129 = v237;
        }
        v238 = v127;
        operator delete(v129);
      }
      v130 = v235;
      if (v235)
      {
        v131 = v236;
        v132 = v235;
        if (v236 != v235)
        {
          do
          {
            v134 = *--v131;
            v133 = v134;
            *v131 = 0;
            if (v134)
              MEMORY[0x20BD002D4](v133, 0x1000C8077774924);
          }
          while (v131 != v130);
          v132 = v235;
        }
        v236 = v130;
        operator delete(v132);
      }
      if (v231 != (int *)v234)
        free(v231);
    }
    goto LABEL_73;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v215[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v230[0] = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    v230[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v230, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, v215);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::TensorDataLayoutAttr::print(mlir::mps::TensorDataLayoutAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 0xA)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_17;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "NCHW";
  v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "NHWC";
      v9 = 4;
      break;
    case 2u:
      v7 = 0;
      v8 = "OIHW";
      v9 = 4;
      break;
    case 3u:
      v7 = 0;
      v8 = "HWIO";
      v9 = 4;
      break;
    case 4u:
      v7 = 0;
      v8 = "CHW";
      v9 = 3;
      break;
    case 5u:
      v7 = 0;
      v8 = "HWC";
      v9 = 3;
      break;
    case 6u:
      v7 = 0;
      v8 = "HW";
      v9 = 2;
      break;
    case 7u:
      v7 = 0;
      v8 = "NCDHW";
      goto LABEL_16;
    case 8u:
      v7 = 0;
      v8 = "NDHWC";
      goto LABEL_16;
    case 9u:
      v7 = 0;
      v8 = "OIDHW";
      goto LABEL_16;
    case 0xAu:
      v7 = 0;
      v8 = "DHWIO";
LABEL_16:
      v9 = 5;
      break;
    default:
      goto LABEL_6;
  }
LABEL_17:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::ReductionModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::ReductionModeAttrStorage,mlir::mps::ReductionMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24ReductionModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17ReductionModeAttrEJNS2_13ReductionModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::ReductionModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  unsigned int v135[8];
  __int16 v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  _QWORD v142[3];
  void *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  void *__p;
  _QWORD *v148;
  char v149;
  _QWORD v150[3];
  int *v151;
  unsigned int v152;
  unsigned int v153;
  _BYTE v154[96];
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  _QWORD *v158;
  char v159;
  uint64_t v160;

  v160 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v137 = 0;
  v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    if (v149)
    {
      v86 = __p;
      if (__p)
      {
        v87 = v148;
        v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            v93 = *--v90;
            v92 = v93;
            *v90 = 0;
            if (v93)
              MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144)
        free(v143);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeReductionMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    v136 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      v139 = 3;
      v140 = "expected ";
      v141 = 9;
      v8 = &v139;
      v9 = v151;
      if (v152 >= v153)
      {
        v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v9 = v151;
          v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v8 = &v139;
          v9 = v151;
        }
      }
      v10 = &v9[6 * v152];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v152;
      if (v150[0])
      {
        v139 = 3;
        v140 = "::mlir::mps::ReductionMode";
        v141 = 26;
        v13 = &v139;
        v14 = v151;
        if (v12 >= v153)
        {
          v95 = v12 + 1;
          v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v14 = v151;
            v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v13 = &v139;
            v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v152;
        if (v150[0])
        {
          v139 = 3;
          v140 = " to be one of: ";
          v141 = 15;
          v18 = &v139;
          v19 = v151;
          if (v17 >= v153)
          {
            v97 = v17 + 1;
            v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v19 = v151;
              v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v18 = &v139;
              v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v152;
          if (v150[0])
          {
            v139 = 3;
            v140 = "min";
            v141 = 3;
            v23 = &v139;
            v24 = v151;
            if (v22 >= v153)
            {
              v99 = v22 + 1;
              v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v24 = v151;
                v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v23 = &v139;
                v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v152;
            if (v150[0])
            {
              v139 = 3;
              v140 = ", ";
              v141 = 2;
              v28 = &v139;
              v29 = v151;
              if (v27 >= v153)
              {
                v101 = v27 + 1;
                v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v29 = v151;
                  v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v28 = &v139;
                  v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v152;
              if (v150[0])
              {
                v139 = 3;
                v140 = "max";
                v141 = 3;
                v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  v103 = v32 + 1;
                  v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v152;
                if (v150[0])
                {
                  v139 = 3;
                  v140 = ", ";
                  v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    v105 = v37 + 1;
                    v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  v40 = &v39[6 * v152];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v152;
                  if (v150[0])
                  {
                    v139 = 3;
                    v140 = "sum";
                    v141 = 3;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      v107 = v42 + 1;
                      v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v152;
                    if (v150[0])
                    {
                      v139 = 3;
                      v140 = ", ";
                      v141 = 2;
                      v48 = &v139;
                      v49 = v151;
                      if (v47 >= v153)
                      {
                        v109 = v47 + 1;
                        v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          v49 = v151;
                        }
                      }
                      v50 = &v49[6 * v152];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v152;
                      if (v150[0])
                      {
                        v139 = 3;
                        v140 = "product";
                        v141 = 7;
                        v53 = &v139;
                        v54 = v151;
                        if (v52 >= v153)
                        {
                          v111 = v52 + 1;
                          v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            v54 = v151;
                          }
                        }
                        v55 = &v54[6 * v152];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v152;
                        if (v150[0])
                        {
                          v139 = 3;
                          v140 = ", ";
                          v141 = 2;
                          v58 = &v139;
                          v59 = v151;
                          if (v57 >= v153)
                          {
                            v113 = v57 + 1;
                            v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v59 = v151;
                              v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v58 = &v139;
                              v59 = v151;
                            }
                          }
                          v60 = &v59[6 * v152];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v152;
                          if (v150[0])
                          {
                            v139 = 3;
                            v140 = "argMin ";
                            v141 = 7;
                            v63 = &v139;
                            v64 = v151;
                            if (v62 >= v153)
                            {
                              v115 = v62 + 1;
                              v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v64 = v151;
                                v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v63 = &v139;
                                v64 = v151;
                              }
                            }
                            v65 = &v64[6 * v152];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v152;
                            if (v150[0])
                            {
                              v139 = 3;
                              v140 = ", ";
                              v141 = 2;
                              v68 = &v139;
                              v69 = v151;
                              if (v67 >= v153)
                              {
                                v117 = v67 + 1;
                                v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v69 = v151;
                                  v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v68 = &v139;
                                  v69 = v151;
                                }
                              }
                              v70 = &v69[6 * v152];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v152;
                              if (v150[0])
                              {
                                v139 = 3;
                                v140 = "argMax";
                                v141 = 6;
                                v73 = &v139;
                                v74 = v151;
                                if (v72 >= v153)
                                {
                                  v119 = v72 + 1;
                                  v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v74 = v151;
                                    v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v73 = &v139;
                                    v74 = v151;
                                  }
                                }
                                v75 = &v74[6 * v152];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    if (v159)
    {
      v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            v84 = *--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              MEMORY[0x20BD002D4](v83, 0x1000C8077774924);
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154)
        free(v151);
    }
    goto LABEL_53;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::ReductionModeAttrStorage,mlir::mps::ReductionMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24ReductionModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17ReductionModeAttrEJNS2_13ReductionModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::ReductionModeAttr::print(mlir::mps::ReductionModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "min";
  v9 = 3;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "max";
      v9 = 3;
      break;
    case 2u:
      v7 = 0;
      v8 = "sum";
      v9 = 3;
      break;
    case 3u:
      v7 = 0;
      v8 = "product";
      v9 = 7;
      break;
    case 4u:
      v7 = 0;
      v8 = "argMin ";
      v9 = 7;
      break;
    case 5u:
      v7 = 0;
      v8 = "argMax";
      v9 = 6;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::DeviceHintAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::DeviceHintAttrStorage,mlir::mps::DeviceHint>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail21DeviceHintAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14DeviceHintAttrEJNS2_10DeviceHintEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id, &v5);
}

uint64_t mlir::mps::DeviceHintAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD *v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v89 = 0;
    v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_53:
      v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      if (v101)
      {
        v55 = __p;
        if (__p)
        {
          v56 = v100;
          v57 = __p;
          if (v100 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v100 = v55;
          operator delete(v57);
        }
        v58 = v97;
        if (v97)
        {
          v59 = v98;
          v60 = v97;
          if (v98 != v97)
          {
            do
            {
              v62 = *--v59;
              v61 = v62;
              *v59 = 0;
              if (v62)
                MEMORY[0x20BD002D4](v61, 0x1000C8077774924);
            }
            while (v59 != v58);
            v60 = v97;
          }
          v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96)
          free(v95);
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      v88 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        v91 = 3;
        v92 = "expected ";
        v93 = 9;
        v6 = &v91;
        v7 = v103;
        if (v104 >= v105)
        {
          v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v7 = v103;
            v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v6 = &v91;
            v7 = v103;
          }
        }
        v8 = &v7[6 * v104];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = "::mlir::mps::DeviceHint";
          v93 = 23;
          v11 = &v91;
          v12 = v103;
          if (v10 >= v105)
          {
            v67 = v10 + 1;
            v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v12 = v103;
              v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v11 = &v91;
              v12 = v103;
            }
          }
          v13 = &v12[6 * v104];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = " to be one of: ";
            v93 = 15;
            v16 = &v91;
            v17 = v103;
            if (v15 >= v105)
            {
              v69 = v15 + 1;
              v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v17 = v103;
                v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v16 = &v91;
                v17 = v103;
              }
            }
            v18 = &v17[6 * v104];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            v20 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = "ANE";
              v93 = 3;
              v21 = &v91;
              v22 = v103;
              if (v20 >= v105)
              {
                v71 = v20 + 1;
                v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v22 = v103;
                  v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v21 = &v91;
                  v22 = v103;
                }
              }
              v23 = &v22[6 * v104];
              v24 = *(_OWORD *)v21;
              *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
              *(_OWORD *)v23 = v24;
              v25 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = ", ";
                v93 = 2;
                v26 = &v91;
                v27 = v103;
                if (v25 >= v105)
                {
                  v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v27 = v103;
                    v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v26 = &v91;
                    v27 = v103;
                  }
                }
                v28 = &v27[6 * v104];
                v29 = *(_OWORD *)v26;
                *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
                *(_OWORD *)v28 = v29;
                v30 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = "GPU";
                  v93 = 3;
                  v31 = &v91;
                  v32 = v103;
                  if (v30 >= v105)
                  {
                    v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v32 = v103;
                      v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v31 = &v91;
                      v32 = v103;
                    }
                  }
                  v33 = &v32[6 * v104];
                  v34 = *(_OWORD *)v31;
                  *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                  *(_OWORD *)v33 = v34;
                  v35 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = ", ";
                    v93 = 2;
                    v36 = &v91;
                    v37 = v103;
                    if (v35 >= v105)
                    {
                      v75 = v35 + 1;
                      v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v37 = v103;
                        v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v36 = &v91;
                        v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    v39 = *(_OWORD *)v36;
                    *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    v40 = ++v104;
                    if (v102[0])
                    {
                      v91 = 3;
                      v92 = "CPU";
                      v93 = 3;
                      v41 = &v91;
                      v42 = v103;
                      if (v40 >= v105)
                      {
                        v77 = v40 + 1;
                        v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v42 = v103;
                          v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v41 = &v91;
                          v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      v44 = *(_OWORD *)v41;
                      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          v46 = v110;
          v47 = v109;
          if (v110 != v109)
          {
            do
              v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            v47 = v109;
          }
          v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          v49 = v108;
          v50 = v107;
          if (v108 != v107)
          {
            do
            {
              v52 = *--v49;
              v51 = v52;
              *v49 = 0;
              if (v52)
                MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
            }
            while (v49 != v48);
            v50 = v107;
          }
          v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106)
          free(v103);
      }
      goto LABEL_53;
    }
    if (*(_WORD *)v89 == 20033 && *(_BYTE *)(v89 + 2) == 69)
    {
      v53 = 0;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else if (*(_WORD *)v89 == 20551 && *(_BYTE *)(v89 + 2) == 85)
    {
      v53 = 1;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else
    {
      if (*(_WORD *)v89 != 20547 || *(_BYTE *)(v89 + 2) != 85)
        goto LABEL_16;
      v53 = 2;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
LABEL_76:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v87[0] = v53;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
        v102[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::DeviceHintAttrStorage,mlir::mps::DeviceHint>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail21DeviceHintAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14DeviceHintAttrEJNS2_10DeviceHintEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id, v87);
      }
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::DeviceHintAttr::print(mlir::mps::DeviceHintAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "ANE";
LABEL_13:
    v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "CPU";
    goto LABEL_13;
  }
  v7 = v6 != 1;
  if (v6 == 1)
    v8 = 3;
  else
    v8 = 0;
  if (v6 == 1)
    v9 = "GPU";
  else
    v9 = &byte_207AF6795;
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::ScatterModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::ScatterModeAttrStorage,mlir::mps::ScatterMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22ScatterModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15ScatterModeAttrEJNS2_11ScatterModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::ScatterModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  _QWORD *v87;
  _QWORD *v88;
  void *v89;
  _QWORD *v90;
  _QWORD *v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  void *v98;
  _QWORD *v99;
  _QWORD *v100;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  int64_t v135;
  int64_t v136;
  int64_t v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  int64_t v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  int64_t v147;
  int64_t v148;
  int64_t v149;
  int64_t v150;
  unsigned int v151[8];
  __int16 v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  const char *v156;
  uint64_t v157;
  _QWORD v158[3];
  void *v159;
  uint64_t v160;
  void *v161;
  _QWORD *v162;
  void *__p;
  _QWORD *v164;
  char v165;
  _QWORD v166[3];
  int *v167;
  unsigned int v168;
  unsigned int v169;
  _BYTE v170[96];
  _QWORD *v171;
  _QWORD *v172;
  _QWORD *v173;
  _QWORD *v174;
  char v175;
  uint64_t v176;

  v176 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v153 = 0;
  v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    if (v165)
    {
      v96 = __p;
      if (__p)
      {
        v97 = v164;
        v98 = __p;
        if (v164 != __p)
        {
          do
            v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          v98 = __p;
        }
        v164 = v96;
        operator delete(v98);
      }
      v99 = v161;
      if (v161)
      {
        v100 = v162;
        v101 = v161;
        if (v162 != v161)
        {
          do
          {
            v103 = *--v100;
            v102 = v103;
            *v100 = 0;
            if (v103)
              MEMORY[0x20BD002D4](v102, 0x1000C8077774924);
          }
          while (v100 != v99);
          v101 = v161;
        }
        v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160)
        free(v159);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeScatterMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    v152 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      v155 = 3;
      v156 = "expected ";
      v157 = 9;
      v8 = &v155;
      v9 = v167;
      if (v168 >= v169)
      {
        v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v9 = v167;
          v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v8 = &v155;
          v9 = v167;
        }
      }
      v10 = &v9[6 * v168];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v168;
      if (v166[0])
      {
        v155 = 3;
        v156 = "::mlir::mps::ScatterMode";
        v157 = 24;
        v13 = &v155;
        v14 = v167;
        if (v12 >= v169)
        {
          v105 = v12 + 1;
          v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v14 = v167;
            v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v13 = &v155;
            v14 = v167;
          }
        }
        v15 = &v14[6 * v168];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v168;
        if (v166[0])
        {
          v155 = 3;
          v156 = " to be one of: ";
          v157 = 15;
          v18 = &v155;
          v19 = v167;
          if (v17 >= v169)
          {
            v107 = v17 + 1;
            v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v19 = v167;
              v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v18 = &v155;
              v19 = v167;
            }
          }
          v20 = &v19[6 * v168];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v168;
          if (v166[0])
          {
            v155 = 3;
            v156 = "add";
            v157 = 3;
            v23 = &v155;
            v24 = v167;
            if (v22 >= v169)
            {
              v109 = v22 + 1;
              v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v24 = v167;
                v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v23 = &v155;
                v24 = v167;
              }
            }
            v25 = &v24[6 * v168];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v168;
            if (v166[0])
            {
              v155 = 3;
              v156 = ", ";
              v157 = 2;
              v28 = &v155;
              v29 = v167;
              if (v27 >= v169)
              {
                v111 = v27 + 1;
                v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v29 = v167;
                  v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v28 = &v155;
                  v29 = v167;
                }
              }
              v30 = &v29[6 * v168];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v168;
              if (v166[0])
              {
                v155 = 3;
                v156 = "subtract";
                v157 = 8;
                v33 = &v155;
                v34 = v167;
                if (v32 >= v169)
                {
                  v113 = v32 + 1;
                  v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v34 = v167;
                    v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v33 = &v155;
                    v34 = v167;
                  }
                }
                v35 = &v34[6 * v168];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v168;
                if (v166[0])
                {
                  v155 = 3;
                  v156 = ", ";
                  v157 = 2;
                  v38 = &v155;
                  v39 = v167;
                  if (v37 >= v169)
                  {
                    v115 = v37 + 1;
                    v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v39 = v167;
                      v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v38 = &v155;
                      v39 = v167;
                    }
                  }
                  v40 = &v39[6 * v168];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v168;
                  if (v166[0])
                  {
                    v155 = 3;
                    v156 = "multiply";
                    v157 = 8;
                    v43 = &v155;
                    v44 = v167;
                    if (v42 >= v169)
                    {
                      v117 = v42 + 1;
                      v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v44 = v167;
                        v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v43 = &v155;
                        v44 = v167;
                      }
                    }
                    v45 = &v44[6 * v168];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v168;
                    if (v166[0])
                    {
                      v155 = 3;
                      v156 = ", ";
                      v157 = 2;
                      v48 = &v155;
                      v49 = v167;
                      if (v47 >= v169)
                      {
                        v119 = v47 + 1;
                        v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v49 = v167;
                          v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v48 = &v155;
                          v49 = v167;
                        }
                      }
                      v50 = &v49[6 * v168];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v168;
                      if (v166[0])
                      {
                        v155 = 3;
                        v156 = "divide";
                        v157 = 6;
                        v53 = &v155;
                        v54 = v167;
                        if (v52 >= v169)
                        {
                          v121 = v52 + 1;
                          v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v54 = v167;
                            v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v53 = &v155;
                            v54 = v167;
                          }
                        }
                        v55 = &v54[6 * v168];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v168;
                        if (v166[0])
                        {
                          v155 = 3;
                          v156 = ", ";
                          v157 = 2;
                          v58 = &v155;
                          v59 = v167;
                          if (v57 >= v169)
                          {
                            v123 = v57 + 1;
                            v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v59 = v167;
                              v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v58 = &v155;
                              v59 = v167;
                            }
                          }
                          v60 = &v59[6 * v168];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v168;
                          if (v166[0])
                          {
                            v155 = 3;
                            v156 = "min";
                            v157 = 3;
                            v63 = &v155;
                            v64 = v167;
                            if (v62 >= v169)
                            {
                              v125 = v62 + 1;
                              v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v64 = v167;
                                v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v63 = &v155;
                                v64 = v167;
                              }
                            }
                            v65 = &v64[6 * v168];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v168;
                            if (v166[0])
                            {
                              v155 = 3;
                              v156 = ", ";
                              v157 = 2;
                              v68 = &v155;
                              v69 = v167;
                              if (v67 >= v169)
                              {
                                v127 = v67 + 1;
                                v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v69 = v167;
                                  v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v68 = &v155;
                                  v69 = v167;
                                }
                              }
                              v70 = &v69[6 * v168];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v168;
                              if (v166[0])
                              {
                                v155 = 3;
                                v156 = "max";
                                v157 = 3;
                                v73 = &v155;
                                v74 = v167;
                                if (v72 >= v169)
                                {
                                  v129 = v72 + 1;
                                  v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v74 = v167;
                                    v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v73 = &v155;
                                    v74 = v167;
                                  }
                                }
                                v75 = &v74[6 * v168];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v168;
                                if (v166[0])
                                {
                                  v155 = 3;
                                  v156 = ", ";
                                  v157 = 2;
                                  v78 = &v155;
                                  v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    v131 = v77 + 1;
                                    v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v79 = v167;
                                      v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v78 = &v155;
                                      v79 = v167;
                                    }
                                  }
                                  v80 = &v79[6 * v168];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v168;
                                  if (v166[0])
                                  {
                                    v155 = 3;
                                    v156 = "set";
                                    v157 = 3;
                                    v83 = &v155;
                                    v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      v133 = v82 + 1;
                                      v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v84 = v167;
                                        v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v83 = &v155;
                                        v84 = v167;
                                      }
                                    }
                                    v85 = &v84[6 * v168];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    if (v175)
    {
      v87 = v173;
      if (v173)
      {
        v88 = v174;
        v89 = v173;
        if (v174 != v173)
        {
          do
            v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          v89 = v173;
        }
        v174 = v87;
        operator delete(v89);
      }
      v90 = v171;
      if (v171)
      {
        v91 = v172;
        v92 = v171;
        if (v172 != v171)
        {
          do
          {
            v94 = *--v91;
            v93 = v94;
            *v91 = 0;
            if (v94)
              MEMORY[0x20BD002D4](v93, 0x1000C8077774924);
          }
          while (v91 != v90);
          v92 = v171;
        }
        v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170)
        free(v167);
    }
    goto LABEL_57;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::ScatterModeAttrStorage,mlir::mps::ScatterMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22ScatterModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15ScatterModeAttrEJNS2_11ScatterModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::ScatterModeAttr::print(mlir::mps::ScatterModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "add";
  v9 = 3;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "subtract";
      v9 = 8;
      break;
    case 2u:
      v7 = 0;
      v8 = "multiply";
      v9 = 8;
      break;
    case 3u:
      v7 = 0;
      v8 = "divide";
      v9 = 6;
      break;
    case 4u:
      v7 = 0;
      v8 = "min";
      goto LABEL_12;
    case 5u:
      v7 = 0;
      v8 = "max";
      goto LABEL_12;
    case 6u:
      v7 = 0;
      v8 = "set";
LABEL_12:
      v9 = 3;
      break;
    default:
      goto LABEL_6;
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v7;
  int *v8;
  int *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  int *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  int *v48;
  int *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  int *v53;
  int *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  void *v67;
  _QWORD *v68;
  _QWORD *v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t result;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v76;
  unint64_t v77;
  BOOL v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  BOOL v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  BOOL v88;
  unint64_t v89;
  BOOL v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  unsigned int v101[8];
  __int16 v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  const char *v106;
  uint64_t v107;
  _QWORD v108[3];
  void *v109;
  uint64_t v110;
  void *v111;
  _QWORD *v112;
  void *__p;
  _QWORD *v114;
  char v115;
  _QWORD v116[3];
  int *v117;
  unsigned int v118;
  unsigned int v119;
  _BYTE v120[96];
  _QWORD *v121;
  _QWORD *v122;
  _QWORD *v123;
  _QWORD *v124;
  char v125;
  uint64_t v126;

  v126 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v103 = 0;
  v104 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v103))
  {
LABEL_64:
    v64 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v118) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v108, a1, v64, v116);
    if (v108[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    if (v115)
    {
      v65 = __p;
      if (__p)
      {
        v66 = v114;
        v67 = __p;
        if (v114 != __p)
        {
          do
            v66 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v66 - 1);
          while (v66 != v65);
          v67 = __p;
        }
        v114 = v65;
        operator delete(v67);
      }
      v68 = v111;
      if (v111)
      {
        v69 = v112;
        v70 = v111;
        if (v112 != v111)
        {
          do
          {
            v72 = *--v69;
            v71 = v72;
            *v69 = 0;
            if (v72)
              MEMORY[0x20BD002D4](v71, 0x1000C8077774924);
          }
          while (v69 != v68);
          v70 = v111;
        }
        v112 = v68;
        operator delete(v70);
      }
      if (v109 != &v110)
        free(v109);
    }
    return 0;
  }
  switch(v104)
  {
    case 7:
      if (*(_DWORD *)v103 != 1818649970 || *(_DWORD *)(v103 + 3) != 1952671084)
        goto LABEL_25;
      v4 = 1;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
      goto LABEL_85;
    case 8:
      if (*(_QWORD *)v103 != 0x746E6174736E6F63)
        goto LABEL_25;
      v4 = 0;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
      goto LABEL_85;
    case 9:
      if (*(_QWORD *)v103 != 0x697274656D6D7973 || *(_BYTE *)(v103 + 8) != 99)
        goto LABEL_25;
      v4 = 2;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
      goto LABEL_85;
    case 11:
      if (*(_QWORD *)v103 != 0x456F54706D616C63 || *(_QWORD *)(v103 + 3) != 0x656764456F54706DLL)
        goto LABEL_25;
      v4 = 3;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
LABEL_85:
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v101[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v116[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
      v116[1] = Context;
      result = mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v116, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, v101);
      break;
    default:
LABEL_25:
      v102 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v116, a1, v2, v101);
      if (v116[0])
      {
        v105 = 3;
        v106 = "expected ";
        v107 = 9;
        v7 = &v105;
        v8 = v117;
        if (v118 >= v119)
        {
          v76 = v118 + 1;
          if (v117 <= &v105 && &v117[6 * v118] > &v105)
          {
            v91 = (char *)&v105 - (char *)v117;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v76, 24);
            v8 = v117;
            v7 = (int *)((char *)v117 + v91);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v76, 24);
            v7 = &v105;
            v8 = v117;
          }
        }
        v9 = &v8[6 * v118];
        v10 = *(_OWORD *)v7;
        *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
        *(_OWORD *)v9 = v10;
        v11 = ++v118;
        if (v116[0])
        {
          v105 = 3;
          v106 = "::mlir::mps::PaddingMode";
          v107 = 24;
          v12 = &v105;
          v13 = v117;
          if (v11 >= v119)
          {
            v77 = v11 + 1;
            v78 = &v117[6 * v11] > &v105;
            if (v117 <= &v105 && v78)
            {
              v92 = (char *)&v105 - (char *)v117;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v77, 24);
              v13 = v117;
              v12 = (int *)((char *)v117 + v92);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v77, 24);
              v12 = &v105;
              v13 = v117;
            }
          }
          v14 = &v13[6 * v118];
          v15 = *(_OWORD *)v12;
          *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
          *(_OWORD *)v14 = v15;
          v16 = ++v118;
          if (v116[0])
          {
            v105 = 3;
            v106 = " to be one of: ";
            v107 = 15;
            v17 = &v105;
            v18 = v117;
            if (v16 >= v119)
            {
              v79 = v16 + 1;
              v80 = &v117[6 * v16] > &v105;
              if (v117 <= &v105 && v80)
              {
                v93 = (char *)&v105 - (char *)v117;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v79, 24);
                v18 = v117;
                v17 = (int *)((char *)v117 + v93);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v79, 24);
                v17 = &v105;
                v18 = v117;
              }
            }
            v19 = &v18[6 * v118];
            v20 = *(_OWORD *)v17;
            *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
            *(_OWORD *)v19 = v20;
            v21 = ++v118;
            if (v116[0])
            {
              v105 = 3;
              v106 = "constant";
              v107 = 8;
              v22 = &v105;
              v23 = v117;
              if (v21 >= v119)
              {
                v81 = v21 + 1;
                v82 = &v117[6 * v21] > &v105;
                if (v117 <= &v105 && v82)
                {
                  v94 = (char *)&v105 - (char *)v117;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v81, 24);
                  v23 = v117;
                  v22 = (int *)((char *)v117 + v94);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v81, 24);
                  v22 = &v105;
                  v23 = v117;
                }
              }
              v24 = &v23[6 * v118];
              v25 = *(_OWORD *)v22;
              *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
              *(_OWORD *)v24 = v25;
              v26 = ++v118;
              if (v116[0])
              {
                v105 = 3;
                v106 = ", ";
                v107 = 2;
                v27 = &v105;
                v28 = v117;
                if (v26 >= v119)
                {
                  v83 = v26 + 1;
                  if (v117 <= &v105 && &v117[6 * v26] > &v105)
                  {
                    v95 = (char *)&v105 - (char *)v117;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v83, 24);
                    v28 = v117;
                    v27 = (int *)((char *)v117 + v95);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v83, 24);
                    v27 = &v105;
                    v28 = v117;
                  }
                }
                v29 = &v28[6 * v118];
                v30 = *(_OWORD *)v27;
                *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
                *(_OWORD *)v29 = v30;
                v31 = ++v118;
                if (v116[0])
                {
                  v105 = 3;
                  v106 = "reflect";
                  v107 = 7;
                  v32 = &v105;
                  v33 = v117;
                  if (v31 >= v119)
                  {
                    v84 = v31 + 1;
                    if (v117 <= &v105 && &v117[6 * v31] > &v105)
                    {
                      v96 = (char *)&v105 - (char *)v117;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v84, 24);
                      v33 = v117;
                      v32 = (int *)((char *)v117 + v96);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v84, 24);
                      v32 = &v105;
                      v33 = v117;
                    }
                  }
                  v34 = &v33[6 * v118];
                  v35 = *(_OWORD *)v32;
                  *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
                  *(_OWORD *)v34 = v35;
                  v36 = ++v118;
                  if (v116[0])
                  {
                    v105 = 3;
                    v106 = ", ";
                    v107 = 2;
                    v37 = &v105;
                    v38 = v117;
                    if (v36 >= v119)
                    {
                      v85 = v36 + 1;
                      if (v117 <= &v105 && &v117[6 * v36] > &v105)
                      {
                        v97 = (char *)&v105 - (char *)v117;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v85, 24);
                        v38 = v117;
                        v37 = (int *)((char *)v117 + v97);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v85, 24);
                        v37 = &v105;
                        v38 = v117;
                      }
                    }
                    v39 = &v38[6 * v118];
                    v40 = *(_OWORD *)v37;
                    *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
                    *(_OWORD *)v39 = v40;
                    v41 = ++v118;
                    if (v116[0])
                    {
                      v105 = 3;
                      v106 = "symmetric";
                      v107 = 9;
                      v42 = &v105;
                      v43 = v117;
                      if (v41 >= v119)
                      {
                        v86 = v41 + 1;
                        if (v117 <= &v105 && &v117[6 * v41] > &v105)
                        {
                          v98 = (char *)&v105 - (char *)v117;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v86, 24);
                          v43 = v117;
                          v42 = (int *)((char *)v117 + v98);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v86, 24);
                          v42 = &v105;
                          v43 = v117;
                        }
                      }
                      v44 = &v43[6 * v118];
                      v45 = *(_OWORD *)v42;
                      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                      *(_OWORD *)v44 = v45;
                      v46 = ++v118;
                      if (v116[0])
                      {
                        v105 = 3;
                        v106 = ", ";
                        v107 = 2;
                        v47 = &v105;
                        v48 = v117;
                        if (v46 >= v119)
                        {
                          v87 = v46 + 1;
                          v88 = &v117[6 * v46] > &v105;
                          if (v117 <= &v105 && v88)
                          {
                            v99 = (char *)&v105 - (char *)v117;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v87, 24);
                            v48 = v117;
                            v47 = (int *)((char *)v117 + v99);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v87, 24);
                            v47 = &v105;
                            v48 = v117;
                          }
                        }
                        v49 = &v48[6 * v118];
                        v50 = *(_OWORD *)v47;
                        *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
                        *(_OWORD *)v49 = v50;
                        v51 = ++v118;
                        if (v116[0])
                        {
                          v105 = 3;
                          v106 = "clampToEdge";
                          v107 = 11;
                          v52 = &v105;
                          v53 = v117;
                          if (v51 >= v119)
                          {
                            v89 = v51 + 1;
                            v90 = &v117[6 * v51] > &v105;
                            if (v117 <= &v105 && v90)
                            {
                              v100 = (char *)&v105 - (char *)v117;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v89, 24);
                              v53 = v117;
                              v52 = (int *)((char *)v117 + v100);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v89, 24);
                              v52 = &v105;
                              v53 = v117;
                            }
                          }
                          v54 = &v53[6 * v118];
                          v55 = *(_OWORD *)v52;
                          *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
                          *(_OWORD *)v54 = v55;
                          ++v118;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v116);
      if (v116[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v116);
      if (v125)
      {
        v56 = v123;
        if (v123)
        {
          v57 = v124;
          v58 = v123;
          if (v124 != v123)
          {
            do
              v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            v58 = v123;
          }
          v124 = v56;
          operator delete(v58);
        }
        v59 = v121;
        if (v121)
        {
          v60 = v122;
          v61 = v121;
          if (v122 != v121)
          {
            do
            {
              v63 = *--v60;
              v62 = v63;
              *v60 = 0;
              if (v63)
                MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
            }
            while (v60 != v59);
            v61 = v121;
          }
          v122 = v59;
          operator delete(v61);
        }
        if (v117 != (int *)v120)
          free(v117);
      }
      goto LABEL_64;
  }
  return result;
}

llvm::raw_ostream *mlir::mps::PaddingModeAttr::print(mlir::mps::PaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_9;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "constant";
  v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "reflect";
      v9 = 7;
      break;
    case 2u:
      v7 = 0;
      v8 = "symmetric";
      v9 = 9;
      break;
    case 3u:
      v7 = 0;
      v8 = "clampToEdge";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_9:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::SamplingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SamplingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  uint64_t v24;
  int *v25;
  int *v26;
  int *v27;
  __int128 v28;
  uint64_t v29;
  int *v30;
  int *v31;
  int *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  unsigned int v71[8];
  __int16 v72;
  _DWORD *v73;
  uint64_t v74;
  int v75;
  const char *v76;
  uint64_t v77;
  _QWORD v78[3];
  void *v79;
  uint64_t v80;
  void *v81;
  _QWORD *v82;
  void *__p;
  _QWORD *v84;
  char v85;
  _QWORD v86[3];
  int *v87;
  unsigned int v88;
  unsigned int v89;
  _BYTE v90[96];
  _QWORD *v91;
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  char v95;
  uint64_t v96;

  v96 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v73 = 0;
  v74 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
  {
LABEL_44:
    v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v88) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v78, a1, v42, v86);
    if (v78[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
    if (v85)
    {
      v43 = __p;
      if (__p)
      {
        v44 = v84;
        v45 = __p;
        if (v84 != __p)
        {
          do
            v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
          while (v44 != v43);
          v45 = __p;
        }
        v84 = v43;
        operator delete(v45);
      }
      v46 = v81;
      if (v81)
      {
        v47 = v82;
        v48 = v81;
        if (v82 != v81)
        {
          do
          {
            v50 = *--v47;
            v49 = v50;
            *v47 = 0;
            if (v50)
              MEMORY[0x20BD002D4](v49, 0x1000C8077774924);
          }
          while (v47 != v46);
          v48 = v81;
        }
        v82 = v46;
        operator delete(v48);
      }
      if (v79 != &v80)
        free(v79);
    }
    return 0;
  }
  if (v74 != 8)
  {
    if (v74 != 7)
      goto LABEL_13;
    if (*v73 != 1918985582 || *(_DWORD *)((char *)v73 + 3) != 1953719666)
      goto LABEL_13;
    v4 = 0;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_65:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v71[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
    v86[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, v71);
  }
  if (*(_QWORD *)v73 != 0x7261656E696C6962)
  {
LABEL_13:
    v72 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v86, a1, v2, v71);
    if (v86[0])
    {
      v75 = 3;
      v76 = "expected ";
      v77 = 9;
      v5 = &v75;
      v6 = v87;
      if (v88 >= v89)
      {
        v54 = v88 + 1;
        if (v87 <= &v75 && &v87[6 * v88] > &v75)
        {
          v65 = (char *)&v75 - (char *)v87;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v6 = v87;
          v5 = (int *)((char *)v87 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v5 = &v75;
          v6 = v87;
        }
      }
      v7 = &v6[6 * v88];
      v8 = *(_OWORD *)v5;
      *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v7 = v8;
      v9 = ++v88;
      if (v86[0])
      {
        v75 = 3;
        v76 = "::mlir::mps::SamplingMode";
        v77 = 25;
        v10 = &v75;
        v11 = v87;
        if (v9 >= v89)
        {
          v55 = v9 + 1;
          v56 = &v87[6 * v9] > &v75;
          if (v87 <= &v75 && v56)
          {
            v66 = (char *)&v75 - (char *)v87;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v11 = v87;
            v10 = (int *)((char *)v87 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v10 = &v75;
            v11 = v87;
          }
        }
        v12 = &v11[6 * v88];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        v14 = ++v88;
        if (v86[0])
        {
          v75 = 3;
          v76 = " to be one of: ";
          v77 = 15;
          v15 = &v75;
          v16 = v87;
          if (v14 >= v89)
          {
            v57 = v14 + 1;
            v58 = &v87[6 * v14] > &v75;
            if (v87 <= &v75 && v58)
            {
              v67 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v16 = v87;
              v15 = (int *)((char *)v87 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v15 = &v75;
              v16 = v87;
            }
          }
          v17 = &v16[6 * v88];
          v18 = *(_OWORD *)v15;
          *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
          *(_OWORD *)v17 = v18;
          v19 = ++v88;
          if (v86[0])
          {
            v75 = 3;
            v76 = "nearest";
            v77 = 7;
            v20 = &v75;
            v21 = v87;
            if (v19 >= v89)
            {
              v59 = v19 + 1;
              v60 = &v87[6 * v19] > &v75;
              if (v87 <= &v75 && v60)
              {
                v68 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v21 = v87;
                v20 = (int *)((char *)v87 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v20 = &v75;
                v21 = v87;
              }
            }
            v22 = &v21[6 * v88];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
            *(_OWORD *)v22 = v23;
            v24 = ++v88;
            if (v86[0])
            {
              v75 = 3;
              v76 = ", ";
              v77 = 2;
              v25 = &v75;
              v26 = v87;
              if (v24 >= v89)
              {
                v61 = v24 + 1;
                v62 = &v87[6 * v24] > &v75;
                if (v87 <= &v75 && v62)
                {
                  v69 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v26 = v87;
                  v25 = (int *)((char *)v87 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v25 = &v75;
                  v26 = v87;
                }
              }
              v27 = &v26[6 * v88];
              v28 = *(_OWORD *)v25;
              *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
              *(_OWORD *)v27 = v28;
              v29 = ++v88;
              if (v86[0])
              {
                v75 = 3;
                v76 = "bilinear";
                v77 = 8;
                v30 = &v75;
                v31 = v87;
                if (v29 >= v89)
                {
                  v63 = v29 + 1;
                  v64 = &v87[6 * v29] > &v75;
                  if (v87 <= &v75 && v64)
                  {
                    v70 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v31 = v87;
                    v30 = (int *)((char *)v87 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v30 = &v75;
                    v31 = v87;
                  }
                }
                v32 = &v31[6 * v88];
                v33 = *(_OWORD *)v30;
                *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
                *(_OWORD *)v32 = v33;
                ++v88;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
    if (v86[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
    if (v95)
    {
      v34 = v93;
      if (v93)
      {
        v35 = v94;
        v36 = v93;
        if (v94 != v93)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = v93;
        }
        v94 = v34;
        operator delete(v36);
      }
      v37 = v91;
      if (v91)
      {
        v38 = v92;
        v39 = v91;
        if (v92 != v91)
        {
          do
          {
            v41 = *--v38;
            v40 = v41;
            *v38 = 0;
            if (v41)
              MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
          }
          while (v38 != v37);
          v39 = v91;
        }
        v92 = v37;
        operator delete(v39);
      }
      if (v87 != (int *)v90)
        free(v87);
    }
    goto LABEL_44;
  }
  v4 = 1;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_65;
  return 0;
}

llvm::raw_ostream *mlir::mps::SamplingModeAttr::print(mlir::mps::SamplingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = &byte_207AF6795;
  v8 = 8;
  if (v6 == 1)
    v7 = "bilinear";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 7;
  if (v6)
    v11 = v7;
  else
    v11 = "nearest";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::NearestRoundingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::NearestRoundingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  unsigned int v135[8];
  __int16 v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  _QWORD v142[3];
  void *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  void *__p;
  _QWORD *v148;
  char v149;
  _QWORD v150[3];
  int *v151;
  unsigned int v152;
  unsigned int v153;
  _BYTE v154[96];
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  _QWORD *v158;
  char v159;
  uint64_t v160;

  v160 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v137 = 0;
  v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    if (v149)
    {
      v86 = __p;
      if (__p)
      {
        v87 = v148;
        v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            v93 = *--v90;
            v92 = v93;
            *v90 = 0;
            if (v93)
              MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144)
        free(v143);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeNearestRoundingMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    v136 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      v139 = 3;
      v140 = "expected ";
      v141 = 9;
      v8 = &v139;
      v9 = v151;
      if (v152 >= v153)
      {
        v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v9 = v151;
          v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v8 = &v139;
          v9 = v151;
        }
      }
      v10 = &v9[6 * v152];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v152;
      if (v150[0])
      {
        v139 = 3;
        v140 = "mlir::mps::NearestRoundingMode";
        v141 = 30;
        v13 = &v139;
        v14 = v151;
        if (v12 >= v153)
        {
          v95 = v12 + 1;
          v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v14 = v151;
            v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v13 = &v139;
            v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v152;
        if (v150[0])
        {
          v139 = 3;
          v140 = " to be one of: ";
          v141 = 15;
          v18 = &v139;
          v19 = v151;
          if (v17 >= v153)
          {
            v97 = v17 + 1;
            v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v19 = v151;
              v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v18 = &v139;
              v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v152;
          if (v150[0])
          {
            v139 = 3;
            v140 = "round_prefer_ceil";
            v141 = 17;
            v23 = &v139;
            v24 = v151;
            if (v22 >= v153)
            {
              v99 = v22 + 1;
              v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v24 = v151;
                v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v23 = &v139;
                v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v152;
            if (v150[0])
            {
              v139 = 3;
              v140 = ", ";
              v141 = 2;
              v28 = &v139;
              v29 = v151;
              if (v27 >= v153)
              {
                v101 = v27 + 1;
                v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v29 = v151;
                  v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v28 = &v139;
                  v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v152;
              if (v150[0])
              {
                v139 = 3;
                v140 = "round_prefer_floor";
                v141 = 18;
                v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  v103 = v32 + 1;
                  v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v152;
                if (v150[0])
                {
                  v139 = 3;
                  v140 = ", ";
                  v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    v105 = v37 + 1;
                    v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  v40 = &v39[6 * v152];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v152;
                  if (v150[0])
                  {
                    v139 = 3;
                    v140 = "ceil";
                    v141 = 4;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      v107 = v42 + 1;
                      v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v152;
                    if (v150[0])
                    {
                      v139 = 3;
                      v140 = ", ";
                      v141 = 2;
                      v48 = &v139;
                      v49 = v151;
                      if (v47 >= v153)
                      {
                        v109 = v47 + 1;
                        v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          v49 = v151;
                        }
                      }
                      v50 = &v49[6 * v152];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v152;
                      if (v150[0])
                      {
                        v139 = 3;
                        v140 = "floor";
                        v141 = 5;
                        v53 = &v139;
                        v54 = v151;
                        if (v52 >= v153)
                        {
                          v111 = v52 + 1;
                          v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            v54 = v151;
                          }
                        }
                        v55 = &v54[6 * v152];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v152;
                        if (v150[0])
                        {
                          v139 = 3;
                          v140 = ", ";
                          v141 = 2;
                          v58 = &v139;
                          v59 = v151;
                          if (v57 >= v153)
                          {
                            v113 = v57 + 1;
                            v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v59 = v151;
                              v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v58 = &v139;
                              v59 = v151;
                            }
                          }
                          v60 = &v59[6 * v152];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v152;
                          if (v150[0])
                          {
                            v139 = 3;
                            v140 = "round_to_even";
                            v141 = 13;
                            v63 = &v139;
                            v64 = v151;
                            if (v62 >= v153)
                            {
                              v115 = v62 + 1;
                              v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v64 = v151;
                                v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v63 = &v139;
                                v64 = v151;
                              }
                            }
                            v65 = &v64[6 * v152];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v152;
                            if (v150[0])
                            {
                              v139 = 3;
                              v140 = ", ";
                              v141 = 2;
                              v68 = &v139;
                              v69 = v151;
                              if (v67 >= v153)
                              {
                                v117 = v67 + 1;
                                v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v69 = v151;
                                  v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v68 = &v139;
                                  v69 = v151;
                                }
                              }
                              v70 = &v69[6 * v152];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v152;
                              if (v150[0])
                              {
                                v139 = 3;
                                v140 = "round_to_odd";
                                v141 = 12;
                                v73 = &v139;
                                v74 = v151;
                                if (v72 >= v153)
                                {
                                  v119 = v72 + 1;
                                  v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v74 = v151;
                                    v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v73 = &v139;
                                    v74 = v151;
                                  }
                                }
                                v75 = &v74[6 * v152];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    if (v159)
    {
      v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            v84 = *--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              MEMORY[0x20BD002D4](v83, 0x1000C8077774924);
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154)
        free(v151);
    }
    goto LABEL_53;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::NearestRoundingModeAttr::print(mlir::mps::NearestRoundingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "round_prefer_ceil";
  v9 = 17;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "round_prefer_floor";
      v9 = 18;
      break;
    case 2u:
      v7 = 0;
      v8 = "ceil";
      v9 = 4;
      break;
    case 3u:
      v7 = 0;
      v8 = "floor";
      v9 = 5;
      break;
    case 4u:
      v7 = 0;
      v8 = "round_to_even";
      v9 = 13;
      break;
    case 5u:
      v7 = 0;
      v8 = "round_to_odd";
      v9 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::SparseTensorStorageAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, &v5);
}

uint64_t mlir::mps::SparseTensorStorageAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD *v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v89 = 0;
    v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_53:
      v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      if (v101)
      {
        v55 = __p;
        if (__p)
        {
          v56 = v100;
          v57 = __p;
          if (v100 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v100 = v55;
          operator delete(v57);
        }
        v58 = v97;
        if (v97)
        {
          v59 = v98;
          v60 = v97;
          if (v98 != v97)
          {
            do
            {
              v62 = *--v59;
              v61 = v62;
              *v59 = 0;
              if (v62)
                MEMORY[0x20BD002D4](v61, 0x1000C8077774924);
            }
            while (v59 != v58);
            v60 = v97;
          }
          v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96)
          free(v95);
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      v88 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        v91 = 3;
        v92 = "expected ";
        v93 = 9;
        v6 = &v91;
        v7 = v103;
        if (v104 >= v105)
        {
          v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v7 = v103;
            v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v6 = &v91;
            v7 = v103;
          }
        }
        v8 = &v7[6 * v104];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = "::mlir::mps::SparseTensorStorage";
          v93 = 32;
          v11 = &v91;
          v12 = v103;
          if (v10 >= v105)
          {
            v67 = v10 + 1;
            v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v12 = v103;
              v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v11 = &v91;
              v12 = v103;
            }
          }
          v13 = &v12[6 * v104];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = " to be one of: ";
            v93 = 15;
            v16 = &v91;
            v17 = v103;
            if (v15 >= v105)
            {
              v69 = v15 + 1;
              v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v17 = v103;
                v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v16 = &v91;
                v17 = v103;
              }
            }
            v18 = &v17[6 * v104];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            v20 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = "COO";
              v93 = 3;
              v21 = &v91;
              v22 = v103;
              if (v20 >= v105)
              {
                v71 = v20 + 1;
                v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v22 = v103;
                  v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v21 = &v91;
                  v22 = v103;
                }
              }
              v23 = &v22[6 * v104];
              v24 = *(_OWORD *)v21;
              *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
              *(_OWORD *)v23 = v24;
              v25 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = ", ";
                v93 = 2;
                v26 = &v91;
                v27 = v103;
                if (v25 >= v105)
                {
                  v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v27 = v103;
                    v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v26 = &v91;
                    v27 = v103;
                  }
                }
                v28 = &v27[6 * v104];
                v29 = *(_OWORD *)v26;
                *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
                *(_OWORD *)v28 = v29;
                v30 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = "CSC";
                  v93 = 3;
                  v31 = &v91;
                  v32 = v103;
                  if (v30 >= v105)
                  {
                    v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v32 = v103;
                      v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v31 = &v91;
                      v32 = v103;
                    }
                  }
                  v33 = &v32[6 * v104];
                  v34 = *(_OWORD *)v31;
                  *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                  *(_OWORD *)v33 = v34;
                  v35 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = ", ";
                    v93 = 2;
                    v36 = &v91;
                    v37 = v103;
                    if (v35 >= v105)
                    {
                      v75 = v35 + 1;
                      v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v37 = v103;
                        v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v36 = &v91;
                        v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    v39 = *(_OWORD *)v36;
                    *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    v40 = ++v104;
                    if (v102[0])
                    {
                      v91 = 3;
                      v92 = "CSR";
                      v93 = 3;
                      v41 = &v91;
                      v42 = v103;
                      if (v40 >= v105)
                      {
                        v77 = v40 + 1;
                        v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v42 = v103;
                          v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v41 = &v91;
                          v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      v44 = *(_OWORD *)v41;
                      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          v46 = v110;
          v47 = v109;
          if (v110 != v109)
          {
            do
              v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            v47 = v109;
          }
          v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          v49 = v108;
          v50 = v107;
          if (v108 != v107)
          {
            do
            {
              v52 = *--v49;
              v51 = v52;
              *v49 = 0;
              if (v52)
                MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
            }
            while (v49 != v48);
            v50 = v107;
          }
          v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106)
          free(v103);
      }
      goto LABEL_53;
    }
    if (*(_WORD *)v89 == 20291 && *(_BYTE *)(v89 + 2) == 79)
    {
      v53 = 0;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else if (*(_WORD *)v89 == 21315 && *(_BYTE *)(v89 + 2) == 67)
    {
      v53 = 1;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else
    {
      if (*(_WORD *)v89 != 21315 || *(_BYTE *)(v89 + 2) != 82)
        goto LABEL_16;
      v53 = 2;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
LABEL_76:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v87[0] = v53;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
        v102[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, v87);
      }
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SparseTensorStorageAttr::print(mlir::mps::SparseTensorStorageAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "COO";
LABEL_13:
    v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "CSR";
    goto LABEL_13;
  }
  v7 = v6 != 1;
  if (v6 == 1)
    v8 = 3;
  else
    v8 = 0;
  if (v6 == 1)
    v9 = "CSC";
  else
    v9 = &byte_207AF6795;
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::MetalPixelFormatAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, &v5);
}

uint64_t mlir::mps::MetalPixelFormatAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  uint64_t v87;
  int *v88;
  int *v89;
  int *v90;
  __int128 v91;
  uint64_t v92;
  int *v93;
  int *v94;
  int *v95;
  __int128 v96;
  uint64_t v97;
  int *v98;
  int *v99;
  int *v100;
  __int128 v101;
  uint64_t v102;
  int *v103;
  int *v104;
  int *v105;
  __int128 v106;
  uint64_t v107;
  int *v108;
  int *v109;
  int *v110;
  __int128 v111;
  uint64_t v112;
  int *v113;
  int *v114;
  int *v115;
  __int128 v116;
  _QWORD *v117;
  _QWORD *v118;
  void *v119;
  _QWORD *v120;
  _QWORD *v121;
  void *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  _QWORD *v127;
  void *v128;
  _QWORD *v129;
  _QWORD *v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  BOOL v136;
  unint64_t v137;
  BOOL v138;
  unint64_t v139;
  BOOL v140;
  unint64_t v141;
  BOOL v142;
  unint64_t v143;
  BOOL v144;
  unint64_t v145;
  BOOL v146;
  unint64_t v147;
  BOOL v148;
  unint64_t v149;
  BOOL v150;
  unint64_t v151;
  BOOL v152;
  unint64_t v153;
  BOOL v154;
  unint64_t v155;
  BOOL v156;
  unint64_t v157;
  BOOL v158;
  unint64_t v159;
  BOOL v160;
  unint64_t v161;
  BOOL v162;
  unint64_t v163;
  BOOL v164;
  unint64_t v165;
  BOOL v166;
  int64_t v167;
  unint64_t v168;
  BOOL v169;
  int64_t v170;
  unint64_t v171;
  BOOL v172;
  int64_t v173;
  unint64_t v174;
  BOOL v175;
  int64_t v176;
  unint64_t v177;
  BOOL v178;
  int64_t v179;
  unint64_t v180;
  BOOL v181;
  int64_t v182;
  int64_t v183;
  int64_t v184;
  int64_t v185;
  int64_t v186;
  int64_t v187;
  int64_t v188;
  int64_t v189;
  int64_t v190;
  int64_t v191;
  int64_t v192;
  int64_t v193;
  int64_t v194;
  int64_t v195;
  int64_t v196;
  int64_t v197;
  int64_t v198;
  unsigned int v199[8];
  __int16 v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  const char *v204;
  uint64_t v205;
  _QWORD v206[3];
  void *v207;
  uint64_t v208;
  void *v209;
  _QWORD *v210;
  void *__p;
  _QWORD *v212;
  char v213;
  _QWORD v214[3];
  int *v215;
  unsigned int v216;
  unsigned int v217;
  _BYTE v218[96];
  _QWORD *v219;
  _QWORD *v220;
  _QWORD *v221;
  _QWORD *v222;
  char v223;
  uint64_t v224;

  v224 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v201 = 0;
  v202 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v201))
  {
LABEL_69:
    v125 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v216) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v206, a1, v125, v214);
    if (v206[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v206);
    if (v213)
    {
      v126 = __p;
      if (__p)
      {
        v127 = v212;
        v128 = __p;
        if (v212 != __p)
        {
          do
            v127 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v127 - 1);
          while (v127 != v126);
          v128 = __p;
        }
        v212 = v126;
        operator delete(v128);
      }
      v129 = v209;
      if (v209)
      {
        v130 = v210;
        v131 = v209;
        if (v210 != v209)
        {
          do
          {
            v133 = *--v130;
            v132 = v133;
            *v130 = 0;
            if (v133)
              MEMORY[0x20BD002D4](v132, 0x1000C8077774924);
          }
          while (v130 != v129);
          v131 = v209;
        }
        v210 = v129;
        operator delete(v131);
      }
      if (v207 != &v208)
        free(v207);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeMetalPixelFormat(v201, v202);
  if ((v3 & 0xFF00000000) == 0)
  {
    v200 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v214, a1, v2, v199);
    if (v214[0])
    {
      v203 = 3;
      v204 = "expected ";
      v205 = 9;
      v8 = &v203;
      v9 = v215;
      if (v216 >= v217)
      {
        v134 = v216 + 1;
        if (v215 <= &v203 && &v215[6 * v216] > &v203)
        {
          v167 = (char *)&v203 - (char *)v215;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          v9 = v215;
          v8 = (int *)((char *)v215 + v167);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          v8 = &v203;
          v9 = v215;
        }
      }
      v10 = &v9[6 * v216];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v216;
      if (v214[0])
      {
        v203 = 3;
        v204 = "::mlir::mps::MetalPixelFormat";
        v205 = 29;
        v13 = &v203;
        v14 = v215;
        if (v12 >= v217)
        {
          v135 = v12 + 1;
          v136 = &v215[6 * v12] > &v203;
          if (v215 <= &v203 && v136)
          {
            v170 = (char *)&v203 - (char *)v215;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            v14 = v215;
            v13 = (int *)((char *)v215 + v170);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            v13 = &v203;
            v14 = v215;
          }
        }
        v15 = &v14[6 * v216];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v216;
        if (v214[0])
        {
          v203 = 3;
          v204 = " to be one of: ";
          v205 = 15;
          v18 = &v203;
          v19 = v215;
          if (v17 >= v217)
          {
            v137 = v17 + 1;
            v138 = &v215[6 * v17] > &v203;
            if (v215 <= &v203 && v138)
            {
              v173 = (char *)&v203 - (char *)v215;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              v19 = v215;
              v18 = (int *)((char *)v215 + v173);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              v18 = &v203;
              v19 = v215;
            }
          }
          v20 = &v19[6 * v216];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v216;
          if (v214[0])
          {
            v203 = 3;
            v204 = "R8Unorm";
            v205 = 7;
            v23 = &v203;
            v24 = v215;
            if (v22 >= v217)
            {
              v139 = v22 + 1;
              v140 = &v215[6 * v22] > &v203;
              if (v215 <= &v203 && v140)
              {
                v176 = (char *)&v203 - (char *)v215;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                v24 = v215;
                v23 = (int *)((char *)v215 + v176);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                v23 = &v203;
                v24 = v215;
              }
            }
            v25 = &v24[6 * v216];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v216;
            if (v214[0])
            {
              v203 = 3;
              v204 = ", ";
              v205 = 2;
              v28 = &v203;
              v29 = v215;
              if (v27 >= v217)
              {
                v141 = v27 + 1;
                v142 = &v215[6 * v27] > &v203;
                if (v215 <= &v203 && v142)
                {
                  v179 = (char *)&v203 - (char *)v215;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  v29 = v215;
                  v28 = (int *)((char *)v215 + v179);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  v28 = &v203;
                  v29 = v215;
                }
              }
              v30 = &v29[6 * v216];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v216;
              if (v214[0])
              {
                v203 = 3;
                v204 = "RG8Unorm";
                v205 = 8;
                v33 = &v203;
                v34 = v215;
                if (v32 >= v217)
                {
                  v143 = v32 + 1;
                  v144 = &v215[6 * v32] > &v203;
                  if (v215 <= &v203 && v144)
                  {
                    v182 = (char *)&v203 - (char *)v215;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    v34 = v215;
                    v33 = (int *)((char *)v215 + v182);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    v33 = &v203;
                    v34 = v215;
                  }
                }
                v35 = &v34[6 * v216];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v216;
                if (v214[0])
                {
                  v203 = 3;
                  v204 = ", ";
                  v205 = 2;
                  v38 = &v203;
                  v39 = v215;
                  if (v37 >= v217)
                  {
                    v145 = v37 + 1;
                    v146 = &v215[6 * v37] > &v203;
                    if (v215 <= &v203 && v146)
                    {
                      v183 = (char *)&v203 - (char *)v215;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      v39 = v215;
                      v38 = (int *)((char *)v215 + v183);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      v38 = &v203;
                      v39 = v215;
                    }
                  }
                  v40 = &v39[6 * v216];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v216;
                  if (v214[0])
                  {
                    v203 = 3;
                    v204 = "RGBA8Unorm";
                    v205 = 10;
                    v43 = &v203;
                    v44 = v215;
                    if (v42 >= v217)
                    {
                      v147 = v42 + 1;
                      v148 = &v215[6 * v42] > &v203;
                      if (v215 <= &v203 && v148)
                      {
                        v184 = (char *)&v203 - (char *)v215;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        v44 = v215;
                        v43 = (int *)((char *)v215 + v184);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        v43 = &v203;
                        v44 = v215;
                      }
                    }
                    v45 = &v44[6 * v216];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v216;
                    if (v214[0])
                    {
                      v203 = 3;
                      v204 = ", ";
                      v205 = 2;
                      v48 = &v203;
                      v49 = v215;
                      if (v47 >= v217)
                      {
                        v149 = v47 + 1;
                        v150 = &v215[6 * v47] > &v203;
                        if (v215 <= &v203 && v150)
                        {
                          v185 = (char *)&v203 - (char *)v215;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          v49 = v215;
                          v48 = (int *)((char *)v215 + v185);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          v48 = &v203;
                          v49 = v215;
                        }
                      }
                      v50 = &v49[6 * v216];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v216;
                      if (v214[0])
                      {
                        v203 = 3;
                        v204 = "BGRA8Unorm";
                        v205 = 10;
                        v53 = &v203;
                        v54 = v215;
                        if (v52 >= v217)
                        {
                          v151 = v52 + 1;
                          v152 = &v215[6 * v52] > &v203;
                          if (v215 <= &v203 && v152)
                          {
                            v186 = (char *)&v203 - (char *)v215;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            v54 = v215;
                            v53 = (int *)((char *)v215 + v186);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            v53 = &v203;
                            v54 = v215;
                          }
                        }
                        v55 = &v54[6 * v216];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v216;
                        if (v214[0])
                        {
                          v203 = 3;
                          v204 = ", ";
                          v205 = 2;
                          v58 = &v203;
                          v59 = v215;
                          if (v57 >= v217)
                          {
                            v153 = v57 + 1;
                            v154 = &v215[6 * v57] > &v203;
                            if (v215 <= &v203 && v154)
                            {
                              v187 = (char *)&v203 - (char *)v215;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              v59 = v215;
                              v58 = (int *)((char *)v215 + v187);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              v58 = &v203;
                              v59 = v215;
                            }
                          }
                          v60 = &v59[6 * v216];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v216;
                          if (v214[0])
                          {
                            v203 = 3;
                            v204 = "R16Float";
                            v205 = 8;
                            v63 = &v203;
                            v64 = v215;
                            if (v62 >= v217)
                            {
                              v155 = v62 + 1;
                              v156 = &v215[6 * v62] > &v203;
                              if (v215 <= &v203 && v156)
                              {
                                v188 = (char *)&v203 - (char *)v215;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                v64 = v215;
                                v63 = (int *)((char *)v215 + v188);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                v63 = &v203;
                                v64 = v215;
                              }
                            }
                            v65 = &v64[6 * v216];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v216;
                            if (v214[0])
                            {
                              v203 = 3;
                              v204 = ", ";
                              v205 = 2;
                              v68 = &v203;
                              v69 = v215;
                              if (v67 >= v217)
                              {
                                v157 = v67 + 1;
                                v158 = &v215[6 * v67] > &v203;
                                if (v215 <= &v203 && v158)
                                {
                                  v189 = (char *)&v203 - (char *)v215;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  v69 = v215;
                                  v68 = (int *)((char *)v215 + v189);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  v68 = &v203;
                                  v69 = v215;
                                }
                              }
                              v70 = &v69[6 * v216];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v216;
                              if (v214[0])
                              {
                                v203 = 3;
                                v204 = "RG16Float";
                                v205 = 9;
                                v73 = &v203;
                                v74 = v215;
                                if (v72 >= v217)
                                {
                                  v159 = v72 + 1;
                                  v160 = &v215[6 * v72] > &v203;
                                  if (v215 <= &v203 && v160)
                                  {
                                    v190 = (char *)&v203 - (char *)v215;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    v74 = v215;
                                    v73 = (int *)((char *)v215 + v190);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    v73 = &v203;
                                    v74 = v215;
                                  }
                                }
                                v75 = &v74[6 * v216];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v216;
                                if (v214[0])
                                {
                                  v203 = 3;
                                  v204 = ", ";
                                  v205 = 2;
                                  v78 = &v203;
                                  v79 = v215;
                                  if (v77 >= v217)
                                  {
                                    v161 = v77 + 1;
                                    v162 = &v215[6 * v77] > &v203;
                                    if (v215 <= &v203 && v162)
                                    {
                                      v191 = (char *)&v203 - (char *)v215;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      v79 = v215;
                                      v78 = (int *)((char *)v215 + v191);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      v78 = &v203;
                                      v79 = v215;
                                    }
                                  }
                                  v80 = &v79[6 * v216];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v216;
                                  if (v214[0])
                                  {
                                    v203 = 3;
                                    v204 = "RGBA16Float";
                                    v205 = 11;
                                    v83 = &v203;
                                    v84 = v215;
                                    if (v82 >= v217)
                                    {
                                      v163 = v82 + 1;
                                      v164 = &v215[6 * v82] > &v203;
                                      if (v215 <= &v203 && v164)
                                      {
                                        v192 = (char *)&v203 - (char *)v215;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        v84 = v215;
                                        v83 = (int *)((char *)v215 + v192);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        v83 = &v203;
                                        v84 = v215;
                                      }
                                    }
                                    v85 = &v84[6 * v216];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    v87 = ++v216;
                                    if (v214[0])
                                    {
                                      v203 = 3;
                                      v204 = ", ";
                                      v205 = 2;
                                      v88 = &v203;
                                      v89 = v215;
                                      if (v87 >= v217)
                                      {
                                        v165 = v87 + 1;
                                        v166 = &v215[6 * v87] > &v203;
                                        if (v215 <= &v203 && v166)
                                        {
                                          v193 = (char *)&v203 - (char *)v215;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          v89 = v215;
                                          v88 = (int *)((char *)v215 + v193);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          v88 = &v203;
                                          v89 = v215;
                                        }
                                      }
                                      v90 = &v89[6 * v216];
                                      v91 = *(_OWORD *)v88;
                                      *((_QWORD *)v90 + 2) = *((_QWORD *)v88 + 2);
                                      *(_OWORD *)v90 = v91;
                                      v92 = ++v216;
                                      if (v214[0])
                                      {
                                        v203 = 3;
                                        v204 = "R32Float";
                                        v205 = 8;
                                        v93 = &v203;
                                        v94 = v215;
                                        if (v92 >= v217)
                                        {
                                          v168 = v92 + 1;
                                          v169 = &v215[6 * v92] > &v203;
                                          if (v215 <= &v203 && v169)
                                          {
                                            v194 = (char *)&v203 - (char *)v215;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            v94 = v215;
                                            v93 = (int *)((char *)v215 + v194);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            v93 = &v203;
                                            v94 = v215;
                                          }
                                        }
                                        v95 = &v94[6 * v216];
                                        v96 = *(_OWORD *)v93;
                                        *((_QWORD *)v95 + 2) = *((_QWORD *)v93 + 2);
                                        *(_OWORD *)v95 = v96;
                                        v97 = ++v216;
                                        if (v214[0])
                                        {
                                          v203 = 3;
                                          v204 = ", ";
                                          v205 = 2;
                                          v98 = &v203;
                                          v99 = v215;
                                          if (v97 >= v217)
                                          {
                                            v171 = v97 + 1;
                                            v172 = &v215[6 * v97] > &v203;
                                            if (v215 <= &v203 && v172)
                                            {
                                              v195 = (char *)&v203 - (char *)v215;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              v99 = v215;
                                              v98 = (int *)((char *)v215 + v195);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              v98 = &v203;
                                              v99 = v215;
                                            }
                                          }
                                          v100 = &v99[6 * v216];
                                          v101 = *(_OWORD *)v98;
                                          *((_QWORD *)v100 + 2) = *((_QWORD *)v98 + 2);
                                          *(_OWORD *)v100 = v101;
                                          v102 = ++v216;
                                          if (v214[0])
                                          {
                                            v203 = 3;
                                            v204 = "RG32Float";
                                            v205 = 9;
                                            v103 = &v203;
                                            v104 = v215;
                                            if (v102 >= v217)
                                            {
                                              v174 = v102 + 1;
                                              v175 = &v215[6 * v102] > &v203;
                                              if (v215 <= &v203 && v175)
                                              {
                                                v196 = (char *)&v203 - (char *)v215;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                v104 = v215;
                                                v103 = (int *)((char *)v215 + v196);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                v103 = &v203;
                                                v104 = v215;
                                              }
                                            }
                                            v105 = &v104[6 * v216];
                                            v106 = *(_OWORD *)v103;
                                            *((_QWORD *)v105 + 2) = *((_QWORD *)v103 + 2);
                                            *(_OWORD *)v105 = v106;
                                            v107 = ++v216;
                                            if (v214[0])
                                            {
                                              v203 = 3;
                                              v204 = ", ";
                                              v205 = 2;
                                              v108 = &v203;
                                              v109 = v215;
                                              if (v107 >= v217)
                                              {
                                                v177 = v107 + 1;
                                                v178 = &v215[6 * v107] > &v203;
                                                if (v215 <= &v203 && v178)
                                                {
                                                  v197 = (char *)&v203 - (char *)v215;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  v109 = v215;
                                                  v108 = (int *)((char *)v215 + v197);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  v108 = &v203;
                                                  v109 = v215;
                                                }
                                              }
                                              v110 = &v109[6 * v216];
                                              v111 = *(_OWORD *)v108;
                                              *((_QWORD *)v110 + 2) = *((_QWORD *)v108 + 2);
                                              *(_OWORD *)v110 = v111;
                                              v112 = ++v216;
                                              if (v214[0])
                                              {
                                                v203 = 3;
                                                v204 = "RGBA32Float";
                                                v205 = 11;
                                                v113 = &v203;
                                                v114 = v215;
                                                if (v112 >= v217)
                                                {
                                                  v180 = v112 + 1;
                                                  v181 = &v215[6 * v112] > &v203;
                                                  if (v215 <= &v203 && v181)
                                                  {
                                                    v198 = (char *)&v203 - (char *)v215;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    v114 = v215;
                                                    v113 = (int *)((char *)v215 + v198);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    v113 = &v203;
                                                    v114 = v215;
                                                  }
                                                }
                                                v115 = &v114[6 * v216];
                                                v116 = *(_OWORD *)v113;
                                                *((_QWORD *)v115 + 2) = *((_QWORD *)v113 + 2);
                                                *(_OWORD *)v115 = v116;
                                                ++v216;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v214);
    if (v214[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v214);
    if (v223)
    {
      v117 = v221;
      if (v221)
      {
        v118 = v222;
        v119 = v221;
        if (v222 != v221)
        {
          do
            v118 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v118 - 1);
          while (v118 != v117);
          v119 = v221;
        }
        v222 = v117;
        operator delete(v119);
      }
      v120 = v219;
      if (v219)
      {
        v121 = v220;
        v122 = v219;
        if (v220 != v219)
        {
          do
          {
            v124 = *--v121;
            v123 = v124;
            *v121 = 0;
            if (v124)
              MEMORY[0x20BD002D4](v123, 0x1000C8077774924);
          }
          while (v121 != v120);
          v122 = v219;
        }
        v220 = v120;
        operator delete(v122);
      }
      if (v215 != (int *)v218)
        free(v215);
    }
    goto LABEL_69;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v199[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v214[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
    v214[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v214, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, v199);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::MetalPixelFormatAttr::print(mlir::mps::MetalPixelFormatAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 9)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_16;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "R8Unorm";
  v9 = 7;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "RG8Unorm";
      v9 = 8;
      break;
    case 2u:
      v7 = 0;
      v8 = "RGBA8Unorm";
      v9 = 10;
      break;
    case 3u:
      v7 = 0;
      v8 = "BGRA8Unorm";
      v9 = 10;
      break;
    case 4u:
      v7 = 0;
      v8 = "R16Float";
      v9 = 8;
      break;
    case 5u:
      v7 = 0;
      v8 = "RG16Float";
      goto LABEL_15;
    case 6u:
      v7 = 0;
      v8 = "RGBA16Float";
      v9 = 11;
      break;
    case 7u:
      v7 = 0;
      v8 = "R32Float";
      v9 = 8;
      break;
    case 8u:
      v7 = 0;
      v8 = "RG32Float";
LABEL_15:
      v9 = 9;
      break;
    case 9u:
      v7 = 0;
      v8 = "RGBA32Float";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_16:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::NormalSamplingMethodAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, &v5);
}

uint64_t mlir::mps::NormalSamplingMethodAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  unsigned int v4;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  BOOL v59;
  unint64_t v60;
  BOOL v61;
  unint64_t v62;
  BOOL v63;
  unint64_t v64;
  BOOL v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  unsigned int v72[8];
  __int16 v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  uint64_t v81;
  void *v82;
  _QWORD *v83;
  void *__p;
  _QWORD *v85;
  char v86;
  _QWORD v87[3];
  int *v88;
  unsigned int v89;
  unsigned int v90;
  _BYTE v91[96];
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  _QWORD *v95;
  char v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v74 = 0;
  v75 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v74))
  {
LABEL_47:
    v43 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v89) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v79, a1, v43, v87);
    if (v79[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    if (v86)
    {
      v44 = __p;
      if (__p)
      {
        v45 = v85;
        v46 = __p;
        if (v85 != __p)
        {
          do
            v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
          while (v45 != v44);
          v46 = __p;
        }
        v85 = v44;
        operator delete(v46);
      }
      v47 = v82;
      if (v82)
      {
        v48 = v83;
        v49 = v82;
        if (v83 != v82)
        {
          do
          {
            v51 = *--v48;
            v50 = v51;
            *v48 = 0;
            if (v51)
              MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
          }
          while (v48 != v47);
          v49 = v82;
        }
        v83 = v47;
        operator delete(v49);
      }
      if (v80 != &v81)
        free(v80);
    }
    return 0;
  }
  if (v75 == 10)
  {
    if (*(_QWORD *)v74 != 0x6C6C756D5F786F62 || *(_WORD *)(v74 + 8) != 29285)
      goto LABEL_16;
    v4 = 1;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_68:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v72[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v87[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
    v87[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v87, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, v72);
  }
  if (v75 != 7 || (*(_DWORD *)v74 == 1601597033 ? (v3 = *(_DWORD *)(v74 + 3) == 1717855071) : (v3 = 0), !v3))
  {
LABEL_16:
    v73 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v87, a1, v2, v72);
    if (v87[0])
    {
      v76 = 3;
      v77 = "expected ";
      v78 = 9;
      v6 = &v76;
      v7 = v88;
      if (v89 >= v90)
      {
        v55 = v89 + 1;
        if (v88 <= &v76 && &v88[6 * v89] > &v76)
        {
          v66 = (char *)&v76 - (char *)v88;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
          v7 = v88;
          v6 = (int *)((char *)v88 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
          v6 = &v76;
          v7 = v88;
        }
      }
      v8 = &v7[6 * v89];
      v9 = *(_OWORD *)v6;
      *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
      *(_OWORD *)v8 = v9;
      v10 = ++v89;
      if (v87[0])
      {
        v76 = 3;
        v77 = "::mlir::mps::NormalSamplingMethod";
        v78 = 33;
        v11 = &v76;
        v12 = v88;
        if (v10 >= v90)
        {
          v56 = v10 + 1;
          v57 = &v88[6 * v10] > &v76;
          if (v88 <= &v76 && v57)
          {
            v67 = (char *)&v76 - (char *)v88;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
            v12 = v88;
            v11 = (int *)((char *)v88 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
            v11 = &v76;
            v12 = v88;
          }
        }
        v13 = &v12[6 * v89];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
        *(_OWORD *)v13 = v14;
        v15 = ++v89;
        if (v87[0])
        {
          v76 = 3;
          v77 = " to be one of: ";
          v78 = 15;
          v16 = &v76;
          v17 = v88;
          if (v15 >= v90)
          {
            v58 = v15 + 1;
            v59 = &v88[6 * v15] > &v76;
            if (v88 <= &v76 && v59)
            {
              v68 = (char *)&v76 - (char *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
              v17 = v88;
              v16 = (int *)((char *)v88 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
              v16 = &v76;
              v17 = v88;
            }
          }
          v18 = &v17[6 * v89];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
          *(_OWORD *)v18 = v19;
          v20 = ++v89;
          if (v87[0])
          {
            v76 = 3;
            v77 = "inv_cdf";
            v78 = 7;
            v21 = &v76;
            v22 = v88;
            if (v20 >= v90)
            {
              v60 = v20 + 1;
              v61 = &v88[6 * v20] > &v76;
              if (v88 <= &v76 && v61)
              {
                v69 = (char *)&v76 - (char *)v88;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                v22 = v88;
                v21 = (int *)((char *)v88 + v69);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                v21 = &v76;
                v22 = v88;
              }
            }
            v23 = &v22[6 * v89];
            v24 = *(_OWORD *)v21;
            *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
            *(_OWORD *)v23 = v24;
            v25 = ++v89;
            if (v87[0])
            {
              v76 = 3;
              v77 = ", ";
              v78 = 2;
              v26 = &v76;
              v27 = v88;
              if (v25 >= v90)
              {
                v62 = v25 + 1;
                v63 = &v88[6 * v25] > &v76;
                if (v88 <= &v76 && v63)
                {
                  v70 = (char *)&v76 - (char *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                  v27 = v88;
                  v26 = (int *)((char *)v88 + v70);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                  v26 = &v76;
                  v27 = v88;
                }
              }
              v28 = &v27[6 * v89];
              v29 = *(_OWORD *)v26;
              *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
              *(_OWORD *)v28 = v29;
              v30 = ++v89;
              if (v87[0])
              {
                v76 = 3;
                v77 = "box_muller";
                v78 = 10;
                v31 = &v76;
                v32 = v88;
                if (v30 >= v90)
                {
                  v64 = v30 + 1;
                  v65 = &v88[6 * v30] > &v76;
                  if (v88 <= &v76 && v65)
                  {
                    v71 = (char *)&v76 - (char *)v88;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                    v32 = v88;
                    v31 = (int *)((char *)v88 + v71);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                    v31 = &v76;
                    v32 = v88;
                  }
                }
                v33 = &v32[6 * v89];
                v34 = *(_OWORD *)v31;
                *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                *(_OWORD *)v33 = v34;
                ++v89;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
    if (v87[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
    if (v96)
    {
      v35 = v94;
      if (v94)
      {
        v36 = v95;
        v37 = v94;
        if (v95 != v94)
        {
          do
            v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
          while (v36 != v35);
          v37 = v94;
        }
        v95 = v35;
        operator delete(v37);
      }
      v38 = v92;
      if (v92)
      {
        v39 = v93;
        v40 = v92;
        if (v93 != v92)
        {
          do
          {
            v42 = *--v39;
            v41 = v42;
            *v39 = 0;
            if (v42)
              MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
          }
          while (v39 != v38);
          v40 = v92;
        }
        v93 = v38;
        operator delete(v40);
      }
      if (v88 != (int *)v91)
        free(v88);
    }
    goto LABEL_47;
  }
  v4 = 0;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_68;
  return 0;
}

llvm::raw_ostream *mlir::mps::NormalSamplingMethodAttr::print(mlir::mps::NormalSamplingMethodAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = &byte_207AF6795;
  v8 = 10;
  if (v6 == 1)
    v7 = "box_muller";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 7;
  if (v6)
    v11 = v7;
  else
    v11 = "inv_cdf";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PaddingStyleAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingStyleAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  _QWORD *v67;
  _QWORD *v68;
  void *v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  void *v78;
  _QWORD *v79;
  _QWORD *v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  BOOL v86;
  unint64_t v87;
  BOOL v88;
  unint64_t v89;
  BOOL v90;
  unint64_t v91;
  BOOL v92;
  unint64_t v93;
  BOOL v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  int64_t v107;
  int64_t v108;
  int64_t v109;
  int64_t v110;
  int64_t v111;
  int64_t v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  unsigned int v119[8];
  __int16 v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  const char *v124;
  uint64_t v125;
  _QWORD v126[3];
  void *v127;
  uint64_t v128;
  void *v129;
  _QWORD *v130;
  void *__p;
  _QWORD *v132;
  char v133;
  _QWORD v134[3];
  int *v135;
  unsigned int v136;
  unsigned int v137;
  _BYTE v138[96];
  _QWORD *v139;
  _QWORD *v140;
  _QWORD *v141;
  _QWORD *v142;
  char v143;
  uint64_t v144;

  v144 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v121 = 0;
  v122 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v121))
  {
LABEL_49:
    v75 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v136) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v126, a1, v75, v134);
    if (v126[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v126);
    if (v133)
    {
      v76 = __p;
      if (__p)
      {
        v77 = v132;
        v78 = __p;
        if (v132 != __p)
        {
          do
            v77 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v77 - 1);
          while (v77 != v76);
          v78 = __p;
        }
        v132 = v76;
        operator delete(v78);
      }
      v79 = v129;
      if (v129)
      {
        v80 = v130;
        v81 = v129;
        if (v130 != v129)
        {
          do
          {
            v83 = *--v80;
            v82 = v83;
            *v80 = 0;
            if (v83)
              MEMORY[0x20BD002D4](v82, 0x1000C8077774924);
          }
          while (v80 != v79);
          v81 = v129;
        }
        v130 = v79;
        operator delete(v81);
      }
      if (v127 != &v128)
        free(v127);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizePaddingStyle(v121, v122);
  if ((v3 & 0xFF00000000) == 0)
  {
    v120 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v134, a1, v2, v119);
    if (v134[0])
    {
      v123 = 3;
      v124 = "expected ";
      v125 = 9;
      v8 = &v123;
      v9 = v135;
      if (v136 >= v137)
      {
        v84 = v136 + 1;
        if (v135 <= &v123 && &v135[6 * v136] > &v123)
        {
          v107 = (char *)&v123 - (char *)v135;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          v9 = v135;
          v8 = (int *)((char *)v135 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          v8 = &v123;
          v9 = v135;
        }
      }
      v10 = &v9[6 * v136];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v136;
      if (v134[0])
      {
        v123 = 3;
        v124 = "::mlir::mps::PaddingStyle";
        v125 = 25;
        v13 = &v123;
        v14 = v135;
        if (v12 >= v137)
        {
          v85 = v12 + 1;
          v86 = &v135[6 * v12] > &v123;
          if (v135 <= &v123 && v86)
          {
            v108 = (char *)&v123 - (char *)v135;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            v14 = v135;
            v13 = (int *)((char *)v135 + v108);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            v13 = &v123;
            v14 = v135;
          }
        }
        v15 = &v14[6 * v136];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v136;
        if (v134[0])
        {
          v123 = 3;
          v124 = " to be one of: ";
          v125 = 15;
          v18 = &v123;
          v19 = v135;
          if (v17 >= v137)
          {
            v87 = v17 + 1;
            v88 = &v135[6 * v17] > &v123;
            if (v135 <= &v123 && v88)
            {
              v109 = (char *)&v123 - (char *)v135;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              v19 = v135;
              v18 = (int *)((char *)v135 + v109);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              v18 = &v123;
              v19 = v135;
            }
          }
          v20 = &v19[6 * v136];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v136;
          if (v134[0])
          {
            v123 = 3;
            v124 = "EXPLICIT";
            v125 = 8;
            v23 = &v123;
            v24 = v135;
            if (v22 >= v137)
            {
              v89 = v22 + 1;
              v90 = &v135[6 * v22] > &v123;
              if (v135 <= &v123 && v90)
              {
                v110 = (char *)&v123 - (char *)v135;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                v24 = v135;
                v23 = (int *)((char *)v135 + v110);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                v23 = &v123;
                v24 = v135;
              }
            }
            v25 = &v24[6 * v136];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v136;
            if (v134[0])
            {
              v123 = 3;
              v124 = ", ";
              v125 = 2;
              v28 = &v123;
              v29 = v135;
              if (v27 >= v137)
              {
                v91 = v27 + 1;
                v92 = &v135[6 * v27] > &v123;
                if (v135 <= &v123 && v92)
                {
                  v111 = (char *)&v123 - (char *)v135;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  v29 = v135;
                  v28 = (int *)((char *)v135 + v111);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  v28 = &v123;
                  v29 = v135;
                }
              }
              v30 = &v29[6 * v136];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v136;
              if (v134[0])
              {
                v123 = 3;
                v124 = "TF_VALID";
                v125 = 8;
                v33 = &v123;
                v34 = v135;
                if (v32 >= v137)
                {
                  v93 = v32 + 1;
                  v94 = &v135[6 * v32] > &v123;
                  if (v135 <= &v123 && v94)
                  {
                    v112 = (char *)&v123 - (char *)v135;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    v34 = v135;
                    v33 = (int *)((char *)v135 + v112);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    v33 = &v123;
                    v34 = v135;
                  }
                }
                v35 = &v34[6 * v136];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v136;
                if (v134[0])
                {
                  v123 = 3;
                  v124 = ", ";
                  v125 = 2;
                  v38 = &v123;
                  v39 = v135;
                  if (v37 >= v137)
                  {
                    v95 = v37 + 1;
                    v96 = &v135[6 * v37] > &v123;
                    if (v135 <= &v123 && v96)
                    {
                      v113 = (char *)&v123 - (char *)v135;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      v39 = v135;
                      v38 = (int *)((char *)v135 + v113);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      v38 = &v123;
                      v39 = v135;
                    }
                  }
                  v40 = &v39[6 * v136];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v136;
                  if (v134[0])
                  {
                    v123 = 3;
                    v124 = "TF_SAME";
                    v125 = 7;
                    v43 = &v123;
                    v44 = v135;
                    if (v42 >= v137)
                    {
                      v97 = v42 + 1;
                      v98 = &v135[6 * v42] > &v123;
                      if (v135 <= &v123 && v98)
                      {
                        v114 = (char *)&v123 - (char *)v135;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        v44 = v135;
                        v43 = (int *)((char *)v135 + v114);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        v43 = &v123;
                        v44 = v135;
                      }
                    }
                    v45 = &v44[6 * v136];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v136;
                    if (v134[0])
                    {
                      v123 = 3;
                      v124 = ", ";
                      v125 = 2;
                      v48 = &v123;
                      v49 = v135;
                      if (v47 >= v137)
                      {
                        v99 = v47 + 1;
                        v100 = &v135[6 * v47] > &v123;
                        if (v135 <= &v123 && v100)
                        {
                          v115 = (char *)&v123 - (char *)v135;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          v49 = v135;
                          v48 = (int *)((char *)v135 + v115);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          v48 = &v123;
                          v49 = v135;
                        }
                      }
                      v50 = &v49[6 * v136];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v136;
                      if (v134[0])
                      {
                        v123 = 3;
                        v124 = "EXPLICIT_OFFSET";
                        v125 = 15;
                        v53 = &v123;
                        v54 = v135;
                        if (v52 >= v137)
                        {
                          v101 = v52 + 1;
                          v102 = &v135[6 * v52] > &v123;
                          if (v135 <= &v123 && v102)
                          {
                            v116 = (char *)&v123 - (char *)v135;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            v54 = v135;
                            v53 = (int *)((char *)v135 + v116);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            v53 = &v123;
                            v54 = v135;
                          }
                        }
                        v55 = &v54[6 * v136];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v136;
                        if (v134[0])
                        {
                          v123 = 3;
                          v124 = ", ";
                          v125 = 2;
                          v58 = &v123;
                          v59 = v135;
                          if (v57 >= v137)
                          {
                            v103 = v57 + 1;
                            v104 = &v135[6 * v57] > &v123;
                            if (v135 <= &v123 && v104)
                            {
                              v117 = (char *)&v123 - (char *)v135;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              v59 = v135;
                              v58 = (int *)((char *)v135 + v117);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              v58 = &v123;
                              v59 = v135;
                            }
                          }
                          v60 = &v59[6 * v136];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v136;
                          if (v134[0])
                          {
                            v123 = 3;
                            v124 = "ONNX_SAME_LOWER";
                            v125 = 15;
                            v63 = &v123;
                            v64 = v135;
                            if (v62 >= v137)
                            {
                              v105 = v62 + 1;
                              v106 = &v135[6 * v62] > &v123;
                              if (v135 <= &v123 && v106)
                              {
                                v118 = (char *)&v123 - (char *)v135;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                v64 = v135;
                                v63 = (int *)((char *)v135 + v118);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                v63 = &v123;
                                v64 = v135;
                              }
                            }
                            v65 = &v64[6 * v136];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            ++v136;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v134);
    if (v134[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v134);
    if (v143)
    {
      v67 = v141;
      if (v141)
      {
        v68 = v142;
        v69 = v141;
        if (v142 != v141)
        {
          do
            v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
          while (v68 != v67);
          v69 = v141;
        }
        v142 = v67;
        operator delete(v69);
      }
      v70 = v139;
      if (v139)
      {
        v71 = v140;
        v72 = v139;
        if (v140 != v139)
        {
          do
          {
            v74 = *--v71;
            v73 = v74;
            *v71 = 0;
            if (v74)
              MEMORY[0x20BD002D4](v73, 0x1000C8077774924);
          }
          while (v71 != v70);
          v72 = v139;
        }
        v140 = v70;
        operator delete(v72);
      }
      if (v135 != (int *)v138)
        free(v135);
    }
    goto LABEL_49;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v119[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v134[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
    v134[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v134, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, v119);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PaddingStyleAttr::print(mlir::mps::PaddingStyleAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 4)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "EXPLICIT";
  v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "TF_VALID";
      v9 = 8;
      break;
    case 2u:
      v7 = 0;
      v8 = "TF_SAME";
      v9 = 7;
      break;
    case 3u:
      v7 = 0;
      v8 = "EXPLICIT_OFFSET";
      goto LABEL_10;
    case 4u:
      v7 = 0;
      v8 = "ONNX_SAME_LOWER";
LABEL_10:
      v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PoolIndicesModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PoolIndicesModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  uint64_t v87;
  int *v88;
  int *v89;
  int *v90;
  __int128 v91;
  uint64_t v92;
  int *v93;
  int *v94;
  int *v95;
  __int128 v96;
  _QWORD *v97;
  _QWORD *v98;
  void *v99;
  _QWORD *v100;
  _QWORD *v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  void *v108;
  _QWORD *v109;
  _QWORD *v110;
  void *v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  unint64_t v135;
  BOOL v136;
  unint64_t v137;
  BOOL v138;
  unint64_t v139;
  BOOL v140;
  unint64_t v141;
  BOOL v142;
  unint64_t v143;
  BOOL v144;
  unint64_t v145;
  BOOL v146;
  int64_t v147;
  unint64_t v148;
  BOOL v149;
  int64_t v150;
  int64_t v151;
  int64_t v152;
  int64_t v153;
  int64_t v154;
  int64_t v155;
  int64_t v156;
  int64_t v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  int64_t v161;
  int64_t v162;
  int64_t v163;
  int64_t v164;
  int64_t v165;
  int64_t v166;
  unsigned int v167[8];
  __int16 v168;
  _QWORD *v169;
  uint64_t v170;
  int v171;
  const char *v172;
  uint64_t v173;
  _QWORD v174[3];
  void *v175;
  uint64_t v176;
  void *v177;
  _QWORD *v178;
  void *__p;
  _QWORD *v180;
  char v181;
  _QWORD v182[3];
  int *v183;
  unsigned int v184;
  unsigned int v185;
  _BYTE v186[96];
  _QWORD *v187;
  _QWORD *v188;
  _QWORD *v189;
  _QWORD *v190;
  char v191;
  uint64_t v192;

  v192 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v169 = 0;
  v170 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v169))
  {
LABEL_61:
    v105 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v184) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v174, a1, v105, v182);
    if (v174[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v174);
    if (v181)
    {
      v106 = __p;
      if (__p)
      {
        v107 = v180;
        v108 = __p;
        if (v180 != __p)
        {
          do
            v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          v108 = __p;
        }
        v180 = v106;
        operator delete(v108);
      }
      v109 = v177;
      if (v177)
      {
        v110 = v178;
        v111 = v177;
        if (v178 != v177)
        {
          do
          {
            v113 = *--v110;
            v112 = v113;
            *v110 = 0;
            if (v113)
              MEMORY[0x20BD002D4](v112, 0x1000C8077774924);
          }
          while (v110 != v109);
          v111 = v177;
        }
        v178 = v109;
        operator delete(v111);
      }
      if (v175 != &v176)
        free(v175);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizePoolIndicesMode(v169, v170);
  if ((v3 & 0xFF00000000) == 0)
  {
    v168 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v182, a1, v2, v167);
    if (v182[0])
    {
      v171 = 3;
      v172 = "expected ";
      v173 = 9;
      v8 = &v171;
      v9 = v183;
      if (v184 >= v185)
      {
        v114 = v184 + 1;
        if (v183 <= &v171 && &v183[6 * v184] > &v171)
        {
          v147 = (char *)&v171 - (char *)v183;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          v9 = v183;
          v8 = (int *)((char *)v183 + v147);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          v8 = &v171;
          v9 = v183;
        }
      }
      v10 = &v9[6 * v184];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v184;
      if (v182[0])
      {
        v171 = 3;
        v172 = "::mlir::mps::PoolIndicesMode";
        v173 = 28;
        v13 = &v171;
        v14 = v183;
        if (v12 >= v185)
        {
          v115 = v12 + 1;
          v116 = &v183[6 * v12] > &v171;
          if (v183 <= &v171 && v116)
          {
            v150 = (char *)&v171 - (char *)v183;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            v14 = v183;
            v13 = (int *)((char *)v183 + v150);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            v13 = &v171;
            v14 = v183;
          }
        }
        v15 = &v14[6 * v184];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v184;
        if (v182[0])
        {
          v171 = 3;
          v172 = " to be one of: ";
          v173 = 15;
          v18 = &v171;
          v19 = v183;
          if (v17 >= v185)
          {
            v117 = v17 + 1;
            v118 = &v183[6 * v17] > &v171;
            if (v183 <= &v171 && v118)
            {
              v151 = (char *)&v171 - (char *)v183;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              v19 = v183;
              v18 = (int *)((char *)v183 + v151);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              v18 = &v171;
              v19 = v183;
            }
          }
          v20 = &v19[6 * v184];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v184;
          if (v182[0])
          {
            v171 = 3;
            v172 = "Global_Flatten1D";
            v173 = 16;
            v23 = &v171;
            v24 = v183;
            if (v22 >= v185)
            {
              v119 = v22 + 1;
              v120 = &v183[6 * v22] > &v171;
              if (v183 <= &v171 && v120)
              {
                v152 = (char *)&v171 - (char *)v183;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                v24 = v183;
                v23 = (int *)((char *)v183 + v152);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                v23 = &v171;
                v24 = v183;
              }
            }
            v25 = &v24[6 * v184];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v184;
            if (v182[0])
            {
              v171 = 3;
              v172 = ", ";
              v173 = 2;
              v28 = &v171;
              v29 = v183;
              if (v27 >= v185)
              {
                v121 = v27 + 1;
                v122 = &v183[6 * v27] > &v171;
                if (v183 <= &v171 && v122)
                {
                  v153 = (char *)&v171 - (char *)v183;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  v29 = v183;
                  v28 = (int *)((char *)v183 + v153);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  v28 = &v171;
                  v29 = v183;
                }
              }
              v30 = &v29[6 * v184];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v184;
              if (v182[0])
              {
                v171 = 3;
                v172 = "Global_Flatten2D";
                v173 = 16;
                v33 = &v171;
                v34 = v183;
                if (v32 >= v185)
                {
                  v123 = v32 + 1;
                  v124 = &v183[6 * v32] > &v171;
                  if (v183 <= &v171 && v124)
                  {
                    v154 = (char *)&v171 - (char *)v183;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    v34 = v183;
                    v33 = (int *)((char *)v183 + v154);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    v33 = &v171;
                    v34 = v183;
                  }
                }
                v35 = &v34[6 * v184];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v184;
                if (v182[0])
                {
                  v171 = 3;
                  v172 = ", ";
                  v173 = 2;
                  v38 = &v171;
                  v39 = v183;
                  if (v37 >= v185)
                  {
                    v125 = v37 + 1;
                    v126 = &v183[6 * v37] > &v171;
                    if (v183 <= &v171 && v126)
                    {
                      v155 = (char *)&v171 - (char *)v183;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      v39 = v183;
                      v38 = (int *)((char *)v183 + v155);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      v38 = &v171;
                      v39 = v183;
                    }
                  }
                  v40 = &v39[6 * v184];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v184;
                  if (v182[0])
                  {
                    v171 = 3;
                    v172 = "Global_Flatten3D";
                    v173 = 16;
                    v43 = &v171;
                    v44 = v183;
                    if (v42 >= v185)
                    {
                      v127 = v42 + 1;
                      v128 = &v183[6 * v42] > &v171;
                      if (v183 <= &v171 && v128)
                      {
                        v156 = (char *)&v171 - (char *)v183;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        v44 = v183;
                        v43 = (int *)((char *)v183 + v156);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        v43 = &v171;
                        v44 = v183;
                      }
                    }
                    v45 = &v44[6 * v184];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v184;
                    if (v182[0])
                    {
                      v171 = 3;
                      v172 = ", ";
                      v173 = 2;
                      v48 = &v171;
                      v49 = v183;
                      if (v47 >= v185)
                      {
                        v129 = v47 + 1;
                        v130 = &v183[6 * v47] > &v171;
                        if (v183 <= &v171 && v130)
                        {
                          v157 = (char *)&v171 - (char *)v183;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          v49 = v183;
                          v48 = (int *)((char *)v183 + v157);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          v48 = &v171;
                          v49 = v183;
                        }
                      }
                      v50 = &v49[6 * v184];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v184;
                      if (v182[0])
                      {
                        v171 = 3;
                        v172 = "Global_Flatten4D";
                        v173 = 16;
                        v53 = &v171;
                        v54 = v183;
                        if (v52 >= v185)
                        {
                          v131 = v52 + 1;
                          v132 = &v183[6 * v52] > &v171;
                          if (v183 <= &v171 && v132)
                          {
                            v158 = (char *)&v171 - (char *)v183;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            v54 = v183;
                            v53 = (int *)((char *)v183 + v158);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            v53 = &v171;
                            v54 = v183;
                          }
                        }
                        v55 = &v54[6 * v184];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v184;
                        if (v182[0])
                        {
                          v171 = 3;
                          v172 = ", ";
                          v173 = 2;
                          v58 = &v171;
                          v59 = v183;
                          if (v57 >= v185)
                          {
                            v133 = v57 + 1;
                            v134 = &v183[6 * v57] > &v171;
                            if (v183 <= &v171 && v134)
                            {
                              v159 = (char *)&v171 - (char *)v183;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              v59 = v183;
                              v58 = (int *)((char *)v183 + v159);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              v58 = &v171;
                              v59 = v183;
                            }
                          }
                          v60 = &v59[6 * v184];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v184;
                          if (v182[0])
                          {
                            v171 = 3;
                            v172 = "Local_Flatten1D";
                            v173 = 15;
                            v63 = &v171;
                            v64 = v183;
                            if (v62 >= v185)
                            {
                              v135 = v62 + 1;
                              v136 = &v183[6 * v62] > &v171;
                              if (v183 <= &v171 && v136)
                              {
                                v160 = (char *)&v171 - (char *)v183;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                v64 = v183;
                                v63 = (int *)((char *)v183 + v160);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                v63 = &v171;
                                v64 = v183;
                              }
                            }
                            v65 = &v64[6 * v184];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v184;
                            if (v182[0])
                            {
                              v171 = 3;
                              v172 = ", ";
                              v173 = 2;
                              v68 = &v171;
                              v69 = v183;
                              if (v67 >= v185)
                              {
                                v137 = v67 + 1;
                                v138 = &v183[6 * v67] > &v171;
                                if (v183 <= &v171 && v138)
                                {
                                  v161 = (char *)&v171 - (char *)v183;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  v69 = v183;
                                  v68 = (int *)((char *)v183 + v161);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  v68 = &v171;
                                  v69 = v183;
                                }
                              }
                              v70 = &v69[6 * v184];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v184;
                              if (v182[0])
                              {
                                v171 = 3;
                                v172 = "Local_Flatten2D";
                                v173 = 15;
                                v73 = &v171;
                                v74 = v183;
                                if (v72 >= v185)
                                {
                                  v139 = v72 + 1;
                                  v140 = &v183[6 * v72] > &v171;
                                  if (v183 <= &v171 && v140)
                                  {
                                    v162 = (char *)&v171 - (char *)v183;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    v74 = v183;
                                    v73 = (int *)((char *)v183 + v162);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    v73 = &v171;
                                    v74 = v183;
                                  }
                                }
                                v75 = &v74[6 * v184];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v184;
                                if (v182[0])
                                {
                                  v171 = 3;
                                  v172 = ", ";
                                  v173 = 2;
                                  v78 = &v171;
                                  v79 = v183;
                                  if (v77 >= v185)
                                  {
                                    v141 = v77 + 1;
                                    v142 = &v183[6 * v77] > &v171;
                                    if (v183 <= &v171 && v142)
                                    {
                                      v163 = (char *)&v171 - (char *)v183;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      v79 = v183;
                                      v78 = (int *)((char *)v183 + v163);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      v78 = &v171;
                                      v79 = v183;
                                    }
                                  }
                                  v80 = &v79[6 * v184];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v184;
                                  if (v182[0])
                                  {
                                    v171 = 3;
                                    v172 = "Local_Flatten3D";
                                    v173 = 15;
                                    v83 = &v171;
                                    v84 = v183;
                                    if (v82 >= v185)
                                    {
                                      v143 = v82 + 1;
                                      v144 = &v183[6 * v82] > &v171;
                                      if (v183 <= &v171 && v144)
                                      {
                                        v164 = (char *)&v171 - (char *)v183;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        v84 = v183;
                                        v83 = (int *)((char *)v183 + v164);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        v83 = &v171;
                                        v84 = v183;
                                      }
                                    }
                                    v85 = &v84[6 * v184];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    v87 = ++v184;
                                    if (v182[0])
                                    {
                                      v171 = 3;
                                      v172 = ", ";
                                      v173 = 2;
                                      v88 = &v171;
                                      v89 = v183;
                                      if (v87 >= v185)
                                      {
                                        v145 = v87 + 1;
                                        v146 = &v183[6 * v87] > &v171;
                                        if (v183 <= &v171 && v146)
                                        {
                                          v165 = (char *)&v171 - (char *)v183;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          v89 = v183;
                                          v88 = (int *)((char *)v183 + v165);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          v88 = &v171;
                                          v89 = v183;
                                        }
                                      }
                                      v90 = &v89[6 * v184];
                                      v91 = *(_OWORD *)v88;
                                      *((_QWORD *)v90 + 2) = *((_QWORD *)v88 + 2);
                                      *(_OWORD *)v90 = v91;
                                      v92 = ++v184;
                                      if (v182[0])
                                      {
                                        v171 = 3;
                                        v172 = "Local_Flatten4D";
                                        v173 = 15;
                                        v93 = &v171;
                                        v94 = v183;
                                        if (v92 >= v185)
                                        {
                                          v148 = v92 + 1;
                                          v149 = &v183[6 * v92] > &v171;
                                          if (v183 <= &v171 && v149)
                                          {
                                            v166 = (char *)&v171 - (char *)v183;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            v94 = v183;
                                            v93 = (int *)((char *)v183 + v166);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            v93 = &v171;
                                            v94 = v183;
                                          }
                                        }
                                        v95 = &v94[6 * v184];
                                        v96 = *(_OWORD *)v93;
                                        *((_QWORD *)v95 + 2) = *((_QWORD *)v93 + 2);
                                        *(_OWORD *)v95 = v96;
                                        ++v184;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v182);
    if (v182[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v182);
    if (v191)
    {
      v97 = v189;
      if (v189)
      {
        v98 = v190;
        v99 = v189;
        if (v190 != v189)
        {
          do
            v98 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v98 - 1);
          while (v98 != v97);
          v99 = v189;
        }
        v190 = v97;
        operator delete(v99);
      }
      v100 = v187;
      if (v187)
      {
        v101 = v188;
        v102 = v187;
        if (v188 != v187)
        {
          do
          {
            v104 = *--v101;
            v103 = v104;
            *v101 = 0;
            if (v104)
              MEMORY[0x20BD002D4](v103, 0x1000C8077774924);
          }
          while (v101 != v100);
          v102 = v187;
        }
        v188 = v100;
        operator delete(v102);
      }
      if (v183 != (int *)v186)
        free(v183);
    }
    goto LABEL_61;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v167[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v182[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
    v182[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v182, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, v167);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PoolIndicesModeAttr::print(mlir::mps::PoolIndicesModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 7)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_14;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "Global_Flatten1D";
  v9 = 16;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "Global_Flatten2D";
      v9 = 16;
      break;
    case 2u:
      v7 = 0;
      v8 = "Global_Flatten3D";
      v9 = 16;
      break;
    case 3u:
      v7 = 0;
      v8 = "Global_Flatten4D";
      v9 = 16;
      break;
    case 4u:
      v7 = 0;
      v8 = "Local_Flatten1D";
      goto LABEL_13;
    case 5u:
      v7 = 0;
      v8 = "Local_Flatten2D";
      goto LABEL_13;
    case 6u:
      v7 = 0;
      v8 = "Local_Flatten3D";
      goto LABEL_13;
    case 7u:
      v7 = 0;
      v8 = "Local_Flatten4D";
LABEL_13:
      v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::RNNActivationAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v5);
}

uint64_t mlir::mps::RNNActivationAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  unsigned int v135[8];
  __int16 v136;
  int *v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  _QWORD v142[3];
  void *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  void *__p;
  _QWORD *v148;
  char v149;
  _QWORD v150[3];
  int *v151;
  unsigned int v152;
  unsigned int v153;
  _BYTE v154[96];
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  _QWORD *v158;
  char v159;
  uint64_t v160;

  v160 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v137 = 0;
  v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    if (v149)
    {
      v86 = __p;
      if (__p)
      {
        v87 = v148;
        v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            v93 = *--v90;
            v92 = v93;
            *v90 = 0;
            if (v93)
              MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144)
        free(v143);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeRNNActivation(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    v136 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      v139 = 3;
      v140 = "expected ";
      v141 = 9;
      v8 = &v139;
      v9 = v151;
      if (v152 >= v153)
      {
        v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v9 = v151;
          v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v8 = &v139;
          v9 = v151;
        }
      }
      v10 = &v9[6 * v152];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v152;
      if (v150[0])
      {
        v139 = 3;
        v140 = "::mlir::mps::RNNActivation";
        v141 = 26;
        v13 = &v139;
        v14 = v151;
        if (v12 >= v153)
        {
          v95 = v12 + 1;
          v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v14 = v151;
            v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v13 = &v139;
            v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v152;
        if (v150[0])
        {
          v139 = 3;
          v140 = " to be one of: ";
          v141 = 15;
          v18 = &v139;
          v19 = v151;
          if (v17 >= v153)
          {
            v97 = v17 + 1;
            v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v19 = v151;
              v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v18 = &v139;
              v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v152;
          if (v150[0])
          {
            v139 = 3;
            v140 = "none";
            v141 = 4;
            v23 = &v139;
            v24 = v151;
            if (v22 >= v153)
            {
              v99 = v22 + 1;
              v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v24 = v151;
                v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v23 = &v139;
                v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v152;
            if (v150[0])
            {
              v139 = 3;
              v140 = ", ";
              v141 = 2;
              v28 = &v139;
              v29 = v151;
              if (v27 >= v153)
              {
                v101 = v27 + 1;
                v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v29 = v151;
                  v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v28 = &v139;
                  v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v152;
              if (v150[0])
              {
                v139 = 3;
                v140 = "relu";
                v141 = 4;
                v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  v103 = v32 + 1;
                  v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v152;
                if (v150[0])
                {
                  v139 = 3;
                  v140 = ", ";
                  v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    v105 = v37 + 1;
                    v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  v40 = &v39[6 * v152];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v152;
                  if (v150[0])
                  {
                    v139 = 3;
                    v140 = "tanh";
                    v141 = 4;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      v107 = v42 + 1;
                      v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v152;
                    if (v150[0])
                    {
                      v139 = 3;
                      v140 = ", ";
                      v141 = 2;
                      v48 = &v139;
                      v49 = v151;
                      if (v47 >= v153)
                      {
                        v109 = v47 + 1;
                        v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          v49 = v151;
                        }
                      }
                      v50 = &v49[6 * v152];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v152;
                      if (v150[0])
                      {
                        v139 = 3;
                        v140 = "sigmoid";
                        v141 = 7;
                        v53 = &v139;
                        v54 = v151;
                        if (v52 >= v153)
                        {
                          v111 = v52 + 1;
                          v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            v54 = v151;
                          }
                        }
                        v55 = &v54[6 * v152];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v152;
                        if (v150[0])
                        {
                          v139 = 3;
                          v140 = ", ";
                          v141 = 2;
                          v58 = &v139;
                          v59 = v151;
                          if (v57 >= v153)
                          {
                            v113 = v57 + 1;
                            v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v59 = v151;
                              v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v58 = &v139;
                              v59 = v151;
                            }
                          }
                          v60 = &v59[6 * v152];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v152;
                          if (v150[0])
                          {
                            v139 = 3;
                            v140 = "hard_sigmoid";
                            v141 = 12;
                            v63 = &v139;
                            v64 = v151;
                            if (v62 >= v153)
                            {
                              v115 = v62 + 1;
                              v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v64 = v151;
                                v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v63 = &v139;
                                v64 = v151;
                              }
                            }
                            v65 = &v64[6 * v152];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v152;
                            if (v150[0])
                            {
                              v139 = 3;
                              v140 = ", ";
                              v141 = 2;
                              v68 = &v139;
                              v69 = v151;
                              if (v67 >= v153)
                              {
                                v117 = v67 + 1;
                                v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v69 = v151;
                                  v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v68 = &v139;
                                  v69 = v151;
                                }
                              }
                              v70 = &v69[6 * v152];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v152;
                              if (v150[0])
                              {
                                v139 = 3;
                                v140 = "scaled_tanh";
                                v141 = 11;
                                v73 = &v139;
                                v74 = v151;
                                if (v72 >= v153)
                                {
                                  v119 = v72 + 1;
                                  v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v74 = v151;
                                    v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v73 = &v139;
                                    v74 = v151;
                                  }
                                }
                                v75 = &v74[6 * v152];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    if (v159)
    {
      v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            v84 = *--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              MEMORY[0x20BD002D4](v83, 0x1000C8077774924);
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154)
        free(v151);
    }
    goto LABEL_53;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::RNNActivationAttr::print(mlir::mps::RNNActivationAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "none";
  v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "relu";
      v9 = 4;
      break;
    case 2u:
      v7 = 0;
      v8 = "tanh";
      v9 = 4;
      break;
    case 3u:
      v7 = 0;
      v8 = "sigmoid";
      v9 = 7;
      break;
    case 4u:
      v7 = 0;
      v8 = "hard_sigmoid";
      v9 = 12;
      break;
    case 5u:
      v7 = 0;
      v8 = "scaled_tanh";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::LSTMGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::LSTMGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v3;
  int *v4;
  int *v5;
  __int128 v6;
  uint64_t v7;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  _QWORD *v65;
  _QWORD *v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  BOOL v77;
  unint64_t v78;
  BOOL v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  unsigned int v98[8];
  __int16 v99;
  _DWORD *v100;
  uint64_t v101;
  int v102;
  const char *v103;
  uint64_t v104;
  _QWORD v105[3];
  void *v106;
  uint64_t v107;
  void *v108;
  _QWORD *v109;
  void *__p;
  _QWORD *v111;
  char v112;
  _QWORD v113[3];
  int *v114;
  unsigned int v115;
  unsigned int v116;
  _BYTE v117[96];
  _QWORD *v118;
  _QWORD *v119;
  _QWORD *v120;
  _QWORD *v121;
  char v122;
  uint64_t v123;

  v123 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v100 = 0;
    v101 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v100))
    {
LABEL_49:
      v61 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v115) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v105, a1, v61, v113);
      if (v105[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
      if (v112)
      {
        v62 = __p;
        if (__p)
        {
          v63 = v111;
          v64 = __p;
          if (v111 != __p)
          {
            do
              v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
            while (v63 != v62);
            v64 = __p;
          }
          v111 = v62;
          operator delete(v64);
        }
        v65 = v108;
        if (v108)
        {
          v66 = v109;
          v67 = v108;
          if (v109 != v108)
          {
            do
            {
              v69 = *--v66;
              v68 = v69;
              *v66 = 0;
              if (v69)
                MEMORY[0x20BD002D4](v68, 0x1000C8077774924);
            }
            while (v66 != v65);
            v67 = v108;
          }
          v109 = v65;
          operator delete(v67);
        }
        if (v106 != &v107)
          free(v106);
      }
      return 0;
    }
    if (v101 != 4)
    {
LABEL_8:
      v99 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v113, a1, v2, v98);
      if (v113[0])
      {
        v102 = 3;
        v103 = "expected ";
        v104 = 9;
        v3 = &v102;
        v4 = v114;
        if (v115 >= v116)
        {
          v73 = v115 + 1;
          if (v114 <= &v102 && &v114[6 * v115] > &v102)
          {
            v88 = (char *)&v102 - (char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            v4 = v114;
            v3 = (int *)((char *)v114 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            v3 = &v102;
            v4 = v114;
          }
        }
        v5 = &v4[6 * v115];
        v6 = *(_OWORD *)v3;
        *((_QWORD *)v5 + 2) = *((_QWORD *)v3 + 2);
        *(_OWORD *)v5 = v6;
        v7 = ++v115;
        if (v113[0])
        {
          v102 = 3;
          v103 = "::mlir::mps::LSTMGateLayout";
          v104 = 27;
          v8 = &v102;
          v9 = v114;
          if (v7 >= v116)
          {
            v74 = v7 + 1;
            v75 = &v114[6 * v7] > &v102;
            if (v114 <= &v102 && v75)
            {
              v89 = (char *)&v102 - (char *)v114;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              v9 = v114;
              v8 = (int *)((char *)v114 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              v8 = &v102;
              v9 = v114;
            }
          }
          v10 = &v9[6 * v115];
          v11 = *(_OWORD *)v8;
          *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
          *(_OWORD *)v10 = v11;
          v12 = ++v115;
          if (v113[0])
          {
            v102 = 3;
            v103 = " to be one of: ";
            v104 = 15;
            v13 = &v102;
            v14 = v114;
            if (v12 >= v116)
            {
              v76 = v12 + 1;
              v77 = &v114[6 * v12] > &v102;
              if (v114 <= &v102 && v77)
              {
                v90 = (char *)&v102 - (char *)v114;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                v14 = v114;
                v13 = (int *)((char *)v114 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                v13 = &v102;
                v14 = v114;
              }
            }
            v15 = &v14[6 * v115];
            v16 = *(_OWORD *)v13;
            *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
            *(_OWORD *)v15 = v16;
            v17 = ++v115;
            if (v113[0])
            {
              v102 = 3;
              v103 = "IFZO";
              v104 = 4;
              v18 = &v102;
              v19 = v114;
              if (v17 >= v116)
              {
                v78 = v17 + 1;
                v79 = &v114[6 * v17] > &v102;
                if (v114 <= &v102 && v79)
                {
                  v91 = (char *)&v102 - (char *)v114;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  v19 = v114;
                  v18 = (int *)((char *)v114 + v91);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  v18 = &v102;
                  v19 = v114;
                }
              }
              v20 = &v19[6 * v115];
              v21 = *(_OWORD *)v18;
              *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
              *(_OWORD *)v20 = v21;
              v22 = ++v115;
              if (v113[0])
              {
                v102 = 3;
                v103 = ", ";
                v104 = 2;
                v23 = &v102;
                v24 = v114;
                if (v22 >= v116)
                {
                  v80 = v22 + 1;
                  if (v114 <= &v102 && &v114[6 * v22] > &v102)
                  {
                    v92 = (char *)&v102 - (char *)v114;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    v24 = v114;
                    v23 = (int *)((char *)v114 + v92);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    v23 = &v102;
                    v24 = v114;
                  }
                }
                v25 = &v24[6 * v115];
                v26 = *(_OWORD *)v23;
                *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
                *(_OWORD *)v25 = v26;
                v27 = ++v115;
                if (v113[0])
                {
                  v102 = 3;
                  v103 = "IZFO";
                  v104 = 4;
                  v28 = &v102;
                  v29 = v114;
                  if (v27 >= v116)
                  {
                    v81 = v27 + 1;
                    if (v114 <= &v102 && &v114[6 * v27] > &v102)
                    {
                      v93 = (char *)&v102 - (char *)v114;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      v29 = v114;
                      v28 = (int *)((char *)v114 + v93);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      v28 = &v102;
                      v29 = v114;
                    }
                  }
                  v30 = &v29[6 * v115];
                  v31 = *(_OWORD *)v28;
                  *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
                  *(_OWORD *)v30 = v31;
                  v32 = ++v115;
                  if (v113[0])
                  {
                    v102 = 3;
                    v103 = ", ";
                    v104 = 2;
                    v33 = &v102;
                    v34 = v114;
                    if (v32 >= v116)
                    {
                      v82 = v32 + 1;
                      if (v114 <= &v102 && &v114[6 * v32] > &v102)
                      {
                        v94 = (char *)&v102 - (char *)v114;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        v34 = v114;
                        v33 = (int *)((char *)v114 + v94);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        v33 = &v102;
                        v34 = v114;
                      }
                    }
                    v35 = &v34[6 * v115];
                    v36 = *(_OWORD *)v33;
                    *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                    *(_OWORD *)v35 = v36;
                    v37 = ++v115;
                    if (v113[0])
                    {
                      v102 = 3;
                      v103 = "IFOZ";
                      v104 = 4;
                      v38 = &v102;
                      v39 = v114;
                      if (v37 >= v116)
                      {
                        v83 = v37 + 1;
                        if (v114 <= &v102 && &v114[6 * v37] > &v102)
                        {
                          v95 = (char *)&v102 - (char *)v114;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          v39 = v114;
                          v38 = (int *)((char *)v114 + v95);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          v38 = &v102;
                          v39 = v114;
                        }
                      }
                      v40 = &v39[6 * v115];
                      v41 = *(_OWORD *)v38;
                      *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                      *(_OWORD *)v40 = v41;
                      v42 = ++v115;
                      if (v113[0])
                      {
                        v102 = 3;
                        v103 = ", ";
                        v104 = 2;
                        v43 = &v102;
                        v44 = v114;
                        if (v42 >= v116)
                        {
                          v84 = v42 + 1;
                          v85 = &v114[6 * v42] > &v102;
                          if (v114 <= &v102 && v85)
                          {
                            v96 = (char *)&v102 - (char *)v114;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            v44 = v114;
                            v43 = (int *)((char *)v114 + v96);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            v43 = &v102;
                            v44 = v114;
                          }
                        }
                        v45 = &v44[6 * v115];
                        v46 = *(_OWORD *)v43;
                        *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                        *(_OWORD *)v45 = v46;
                        v47 = ++v115;
                        if (v113[0])
                        {
                          v102 = 3;
                          v103 = "IOFZ";
                          v104 = 4;
                          v48 = &v102;
                          v49 = v114;
                          if (v47 >= v116)
                          {
                            v86 = v47 + 1;
                            v87 = &v114[6 * v47] > &v102;
                            if (v114 <= &v102 && v87)
                            {
                              v97 = (char *)&v102 - (char *)v114;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              v49 = v114;
                              v48 = (int *)((char *)v114 + v97);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              v48 = &v102;
                              v49 = v114;
                            }
                          }
                          v50 = &v49[6 * v115];
                          v51 = *(_OWORD *)v48;
                          *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                          *(_OWORD *)v50 = v51;
                          ++v115;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v113);
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      if (v122)
      {
        v52 = v120;
        if (v120)
        {
          v53 = v121;
          v54 = v120;
          if (v121 != v120)
          {
            do
              v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
            while (v53 != v52);
            v54 = v120;
          }
          v121 = v52;
          operator delete(v54);
        }
        v55 = v118;
        if (v118)
        {
          v56 = v119;
          v57 = v118;
          if (v119 != v118)
          {
            do
            {
              v59 = *--v56;
              v58 = v59;
              *v56 = 0;
              if (v59)
                MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
            }
            while (v56 != v55);
            v57 = v118;
          }
          v119 = v55;
          operator delete(v57);
        }
        if (v114 != (int *)v117)
          free(v114);
      }
      goto LABEL_49;
    }
    switch(*v100)
    {
      case 0x4F5A4649:
        v60 = 0;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          goto LABEL_74;
        break;
      case 0x4F465A49:
        v60 = 1;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          goto LABEL_74;
        break;
      case 0x5A4F4649:
        v60 = 2;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          goto LABEL_74;
        break;
      case 0x5A464F49:
        v60 = 3;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        {
LABEL_74:
          Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
          v98[0] = v60;
          AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
          v113[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
          v113[1] = Context;
          return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v113, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, v98);
        }
        break;
      default:
        goto LABEL_8;
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::LSTMGateLayoutAttr::print(mlir::mps::LSTMGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "IFZO";
  v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "IZFO";
      goto LABEL_9;
    case 2u:
      v7 = 0;
      v8 = "IFOZ";
      goto LABEL_9;
    case 3u:
      v7 = 0;
      v8 = "IOFZ";
LABEL_9:
      v9 = 4;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::GRUGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::GRUGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD *v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v89 = 0;
    v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_53:
      v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      if (v101)
      {
        v55 = __p;
        if (__p)
        {
          v56 = v100;
          v57 = __p;
          if (v100 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v100 = v55;
          operator delete(v57);
        }
        v58 = v97;
        if (v97)
        {
          v59 = v98;
          v60 = v97;
          if (v98 != v97)
          {
            do
            {
              v62 = *--v59;
              v61 = v62;
              *v59 = 0;
              if (v62)
                MEMORY[0x20BD002D4](v61, 0x1000C8077774924);
            }
            while (v59 != v58);
            v60 = v97;
          }
          v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96)
          free(v95);
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      v88 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        v91 = 3;
        v92 = "expected ";
        v93 = 9;
        v6 = &v91;
        v7 = v103;
        if (v104 >= v105)
        {
          v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v7 = v103;
            v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v6 = &v91;
            v7 = v103;
          }
        }
        v8 = &v7[6 * v104];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = "::mlir::mps::GRUGateLayout";
          v93 = 26;
          v11 = &v91;
          v12 = v103;
          if (v10 >= v105)
          {
            v67 = v10 + 1;
            v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v12 = v103;
              v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v11 = &v91;
              v12 = v103;
            }
          }
          v13 = &v12[6 * v104];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = " to be one of: ";
            v93 = 15;
            v16 = &v91;
            v17 = v103;
            if (v15 >= v105)
            {
              v69 = v15 + 1;
              v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v17 = v103;
                v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v16 = &v91;
                v17 = v103;
              }
            }
            v18 = &v17[6 * v104];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            v20 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = "ZRO";
              v93 = 3;
              v21 = &v91;
              v22 = v103;
              if (v20 >= v105)
              {
                v71 = v20 + 1;
                v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v22 = v103;
                  v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v21 = &v91;
                  v22 = v103;
                }
              }
              v23 = &v22[6 * v104];
              v24 = *(_OWORD *)v21;
              *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
              *(_OWORD *)v23 = v24;
              v25 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = ", ";
                v93 = 2;
                v26 = &v91;
                v27 = v103;
                if (v25 >= v105)
                {
                  v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v27 = v103;
                    v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v26 = &v91;
                    v27 = v103;
                  }
                }
                v28 = &v27[6 * v104];
                v29 = *(_OWORD *)v26;
                *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
                *(_OWORD *)v28 = v29;
                v30 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = "RZO";
                  v93 = 3;
                  v31 = &v91;
                  v32 = v103;
                  if (v30 >= v105)
                  {
                    v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v32 = v103;
                      v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v31 = &v91;
                      v32 = v103;
                    }
                  }
                  v33 = &v32[6 * v104];
                  v34 = *(_OWORD *)v31;
                  *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                  *(_OWORD *)v33 = v34;
                  v35 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = ", ";
                    v93 = 2;
                    v36 = &v91;
                    v37 = v103;
                    if (v35 >= v105)
                    {
                      v75 = v35 + 1;
                      v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v37 = v103;
                        v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v36 = &v91;
                        v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    v39 = *(_OWORD *)v36;
                    *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    v40 = ++v104;
                    if (v102[0])
                    {
                      v91 = 3;
                      v92 = "ROZ";
                      v93 = 3;
                      v41 = &v91;
                      v42 = v103;
                      if (v40 >= v105)
                      {
                        v77 = v40 + 1;
                        v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v42 = v103;
                          v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v41 = &v91;
                          v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      v44 = *(_OWORD *)v41;
                      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          v46 = v110;
          v47 = v109;
          if (v110 != v109)
          {
            do
              v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            v47 = v109;
          }
          v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          v49 = v108;
          v50 = v107;
          if (v108 != v107)
          {
            do
            {
              v52 = *--v49;
              v51 = v52;
              *v49 = 0;
              if (v52)
                MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
            }
            while (v49 != v48);
            v50 = v107;
          }
          v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106)
          free(v103);
      }
      goto LABEL_53;
    }
    if (*(_WORD *)v89 == 21082 && *(_BYTE *)(v89 + 2) == 79)
    {
      v53 = 0;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else if (*(_WORD *)v89 == 23122 && *(_BYTE *)(v89 + 2) == 79)
    {
      v53 = 1;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else
    {
      if (*(_WORD *)v89 != 20306 || *(_BYTE *)(v89 + 2) != 90)
        goto LABEL_16;
      v53 = 2;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
LABEL_76:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v87[0] = v53;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
        v102[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, v87);
      }
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::GRUGateLayoutAttr::print(mlir::mps::GRUGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "ZRO";
LABEL_13:
    v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "ROZ";
    goto LABEL_13;
  }
  v7 = v6 != 1;
  if (v6 == 1)
    v8 = 3;
  else
    v8 = 0;
  if (v6 == 1)
    v9 = "RZO";
  else
    v9 = &byte_207AF6795;
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::StencilPaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::StencilPaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  _QWORD *v87;
  _QWORD *v88;
  void *v89;
  _QWORD *v90;
  _QWORD *v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  void *v98;
  _QWORD *v99;
  _QWORD *v100;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  int64_t v135;
  int64_t v136;
  int64_t v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  int64_t v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  int64_t v147;
  int64_t v148;
  int64_t v149;
  int64_t v150;
  unsigned int v151[8];
  __int16 v152;
  int *v153;
  uint64_t v154;
  int v155;
  const char *v156;
  uint64_t v157;
  _QWORD v158[3];
  void *v159;
  uint64_t v160;
  void *v161;
  _QWORD *v162;
  void *__p;
  _QWORD *v164;
  char v165;
  _QWORD v166[3];
  int *v167;
  unsigned int v168;
  unsigned int v169;
  _BYTE v170[96];
  _QWORD *v171;
  _QWORD *v172;
  _QWORD *v173;
  _QWORD *v174;
  char v175;
  uint64_t v176;

  v176 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v153 = 0;
  v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    if (v165)
    {
      v96 = __p;
      if (__p)
      {
        v97 = v164;
        v98 = __p;
        if (v164 != __p)
        {
          do
            v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          v98 = __p;
        }
        v164 = v96;
        operator delete(v98);
      }
      v99 = v161;
      if (v161)
      {
        v100 = v162;
        v101 = v161;
        if (v162 != v161)
        {
          do
          {
            v103 = *--v100;
            v102 = v103;
            *v100 = 0;
            if (v103)
              MEMORY[0x20BD002D4](v102, 0x1000C8077774924);
          }
          while (v100 != v99);
          v101 = v161;
        }
        v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160)
        free(v159);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeStencilPaddingMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    v152 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      v155 = 3;
      v156 = "expected ";
      v157 = 9;
      v8 = &v155;
      v9 = v167;
      if (v168 >= v169)
      {
        v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v9 = v167;
          v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v8 = &v155;
          v9 = v167;
        }
      }
      v10 = &v9[6 * v168];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v168;
      if (v166[0])
      {
        v155 = 3;
        v156 = "::mlir::mps::StencilPaddingMode";
        v157 = 31;
        v13 = &v155;
        v14 = v167;
        if (v12 >= v169)
        {
          v105 = v12 + 1;
          v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v14 = v167;
            v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v13 = &v155;
            v14 = v167;
          }
        }
        v15 = &v14[6 * v168];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v168;
        if (v166[0])
        {
          v155 = 3;
          v156 = " to be one of: ";
          v157 = 15;
          v18 = &v155;
          v19 = v167;
          if (v17 >= v169)
          {
            v107 = v17 + 1;
            v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v19 = v167;
              v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v18 = &v155;
              v19 = v167;
            }
          }
          v20 = &v19[6 * v168];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v168;
          if (v166[0])
          {
            v155 = 3;
            v156 = "zero";
            v157 = 4;
            v23 = &v155;
            v24 = v167;
            if (v22 >= v169)
            {
              v109 = v22 + 1;
              v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v24 = v167;
                v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v23 = &v155;
                v24 = v167;
              }
            }
            v25 = &v24[6 * v168];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v168;
            if (v166[0])
            {
              v155 = 3;
              v156 = ", ";
              v157 = 2;
              v28 = &v155;
              v29 = v167;
              if (v27 >= v169)
              {
                v111 = v27 + 1;
                v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v29 = v167;
                  v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v28 = &v155;
                  v29 = v167;
                }
              }
              v30 = &v29[6 * v168];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v168;
              if (v166[0])
              {
                v155 = 3;
                v156 = "constant";
                v157 = 8;
                v33 = &v155;
                v34 = v167;
                if (v32 >= v169)
                {
                  v113 = v32 + 1;
                  v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v34 = v167;
                    v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v33 = &v155;
                    v34 = v167;
                  }
                }
                v35 = &v34[6 * v168];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v168;
                if (v166[0])
                {
                  v155 = 3;
                  v156 = ", ";
                  v157 = 2;
                  v38 = &v155;
                  v39 = v167;
                  if (v37 >= v169)
                  {
                    v115 = v37 + 1;
                    v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v39 = v167;
                      v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v38 = &v155;
                      v39 = v167;
                    }
                  }
                  v40 = &v39[6 * v168];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v168;
                  if (v166[0])
                  {
                    v155 = 3;
                    v156 = "clampToEdge";
                    v157 = 11;
                    v43 = &v155;
                    v44 = v167;
                    if (v42 >= v169)
                    {
                      v117 = v42 + 1;
                      v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v44 = v167;
                        v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v43 = &v155;
                        v44 = v167;
                      }
                    }
                    v45 = &v44[6 * v168];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v168;
                    if (v166[0])
                    {
                      v155 = 3;
                      v156 = ", ";
                      v157 = 2;
                      v48 = &v155;
                      v49 = v167;
                      if (v47 >= v169)
                      {
                        v119 = v47 + 1;
                        v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v49 = v167;
                          v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v48 = &v155;
                          v49 = v167;
                        }
                      }
                      v50 = &v49[6 * v168];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v168;
                      if (v166[0])
                      {
                        v155 = 3;
                        v156 = "mirror";
                        v157 = 6;
                        v53 = &v155;
                        v54 = v167;
                        if (v52 >= v169)
                        {
                          v121 = v52 + 1;
                          v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v54 = v167;
                            v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v53 = &v155;
                            v54 = v167;
                          }
                        }
                        v55 = &v54[6 * v168];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v168;
                        if (v166[0])
                        {
                          v155 = 3;
                          v156 = ", ";
                          v157 = 2;
                          v58 = &v155;
                          v59 = v167;
                          if (v57 >= v169)
                          {
                            v123 = v57 + 1;
                            v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v59 = v167;
                              v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v58 = &v155;
                              v59 = v167;
                            }
                          }
                          v60 = &v59[6 * v168];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v168;
                          if (v166[0])
                          {
                            v155 = 3;
                            v156 = "mirrorWithEdge";
                            v157 = 14;
                            v63 = &v155;
                            v64 = v167;
                            if (v62 >= v169)
                            {
                              v125 = v62 + 1;
                              v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v64 = v167;
                                v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v63 = &v155;
                                v64 = v167;
                              }
                            }
                            v65 = &v64[6 * v168];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v168;
                            if (v166[0])
                            {
                              v155 = 3;
                              v156 = ", ";
                              v157 = 2;
                              v68 = &v155;
                              v69 = v167;
                              if (v67 >= v169)
                              {
                                v127 = v67 + 1;
                                v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v69 = v167;
                                  v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v68 = &v155;
                                  v69 = v167;
                                }
                              }
                              v70 = &v69[6 * v168];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v168;
                              if (v166[0])
                              {
                                v155 = 3;
                                v156 = "periodic";
                                v157 = 8;
                                v73 = &v155;
                                v74 = v167;
                                if (v72 >= v169)
                                {
                                  v129 = v72 + 1;
                                  v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v74 = v167;
                                    v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v73 = &v155;
                                    v74 = v167;
                                  }
                                }
                                v75 = &v74[6 * v168];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v168;
                                if (v166[0])
                                {
                                  v155 = 3;
                                  v156 = ", ";
                                  v157 = 2;
                                  v78 = &v155;
                                  v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    v131 = v77 + 1;
                                    v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v79 = v167;
                                      v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v78 = &v155;
                                      v79 = v167;
                                    }
                                  }
                                  v80 = &v79[6 * v168];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v168;
                                  if (v166[0])
                                  {
                                    v155 = 3;
                                    v156 = "antiPeriodic";
                                    v157 = 12;
                                    v83 = &v155;
                                    v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      v133 = v82 + 1;
                                      v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v84 = v167;
                                        v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v83 = &v155;
                                        v84 = v167;
                                      }
                                    }
                                    v85 = &v84[6 * v168];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    if (v175)
    {
      v87 = v173;
      if (v173)
      {
        v88 = v174;
        v89 = v173;
        if (v174 != v173)
        {
          do
            v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          v89 = v173;
        }
        v174 = v87;
        operator delete(v89);
      }
      v90 = v171;
      if (v171)
      {
        v91 = v172;
        v92 = v171;
        if (v172 != v171)
        {
          do
          {
            v94 = *--v91;
            v93 = v94;
            *v91 = 0;
            if (v94)
              MEMORY[0x20BD002D4](v93, 0x1000C8077774924);
          }
          while (v91 != v90);
          v92 = v171;
        }
        v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170)
        free(v167);
    }
    goto LABEL_57;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::StencilPaddingModeAttr::print(mlir::mps::StencilPaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  size_t v6;
  char v7;
  char *v8;
  llvm::raw_ostream *v9;
  void *v10;
  llvm::raw_ostream *result;
  _BYTE *v12;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(unsigned int *)(*(_QWORD *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      v6 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(unsigned int *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "zero";
  switch((int)v6)
  {
    case 0:
      v7 = 0;
      v8 = "constant";
      v6 = 8;
      break;
    case 1:
      v7 = 0;
      v8 = "mirror";
      v6 = 6;
      break;
    case 2:
      v7 = 0;
      v8 = "mirrorWithEdge";
      v6 = 14;
      break;
    case 3:
      v7 = 0;
      v8 = "clampToEdge";
      v6 = 11;
      break;
    case 4:
      break;
    case 5:
      v7 = 0;
      v8 = "periodic";
      v6 = 8;
      break;
    case 6:
      v7 = 0;
      v8 = "antiPeriodic";
      v6 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_12:
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v10 = (void *)*((_QWORD *)v9 + 4);
  if (v6 <= *((_QWORD *)v9 + 3) - (_QWORD)v10)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v10, v8, v6);
      *((_QWORD *)v9 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, v8, v6);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v12 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v12)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v12 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  unsigned int v4;
  int *v7;
  int *v8;
  int *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  int *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD *v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v89 = 0;
  v90 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
  {
LABEL_59:
    v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v104) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
    if (v94[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
    if (v101)
    {
      v55 = __p;
      if (__p)
      {
        v56 = v100;
        v57 = __p;
        if (v100 != __p)
        {
          do
            v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
          while (v56 != v55);
          v57 = __p;
        }
        v100 = v55;
        operator delete(v57);
      }
      v58 = v97;
      if (v97)
      {
        v59 = v98;
        v60 = v97;
        if (v98 != v97)
        {
          do
          {
            v62 = *--v59;
            v61 = v62;
            *v59 = 0;
            if (v62)
              MEMORY[0x20BD002D4](v61, 0x1000C8077774924);
          }
          while (v59 != v58);
          v60 = v97;
        }
        v98 = v58;
        operator delete(v60);
      }
      if (v95 != &v96)
        free(v95);
    }
    return 0;
  }
  if (v90 == 12)
  {
    if (*(_QWORD *)v89 != 0x726F436E67696C61 || *(_DWORD *)(v89 + 8) != 1936876910)
      goto LABEL_24;
    v4 = 1;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
    goto LABEL_80;
  }
  if (v90 == 13)
  {
    if (*(_QWORD *)v89 != 0x6F4374657366666FLL || *(_QWORD *)(v89 + 5) != 0x7372656E726F4374)
      goto LABEL_24;
    v4 = 2;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_80:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v87[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
    v102[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, v87);
  }
  if (v90 != 16
    || (*(_QWORD *)v89 == 0x41746C7561666564 ? (v3 = *(_QWORD *)(v89 + 8) == 0x746E656D6E67696CLL) : (v3 = 0), !v3))
  {
LABEL_24:
    v88 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
    if (v102[0])
    {
      v91 = 3;
      v92 = "expected ";
      v93 = 9;
      v7 = &v91;
      v8 = v103;
      if (v104 >= v105)
      {
        v66 = v104 + 1;
        if (v103 <= &v91 && &v103[6 * v104] > &v91)
        {
          v79 = (char *)&v91 - (char *)v103;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
          v8 = v103;
          v7 = (int *)((char *)v103 + v79);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
          v7 = &v91;
          v8 = v103;
        }
      }
      v9 = &v8[6 * v104];
      v10 = *(_OWORD *)v7;
      *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
      *(_OWORD *)v9 = v10;
      v11 = ++v104;
      if (v102[0])
      {
        v91 = 3;
        v92 = "::mlir::mps::CropResizeAlignmentMode";
        v93 = 36;
        v12 = &v91;
        v13 = v103;
        if (v11 >= v105)
        {
          v67 = v11 + 1;
          v68 = &v103[6 * v11] > &v91;
          if (v103 <= &v91 && v68)
          {
            v80 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
            v13 = v103;
            v12 = (int *)((char *)v103 + v80);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
            v12 = &v91;
            v13 = v103;
          }
        }
        v14 = &v13[6 * v104];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        v16 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = " to be one of: ";
          v93 = 15;
          v17 = &v91;
          v18 = v103;
          if (v16 >= v105)
          {
            v69 = v16 + 1;
            v70 = &v103[6 * v16] > &v91;
            if (v103 <= &v91 && v70)
            {
              v81 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
              v18 = v103;
              v17 = (int *)((char *)v103 + v81);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
              v17 = &v91;
              v18 = v103;
            }
          }
          v19 = &v18[6 * v104];
          v20 = *(_OWORD *)v17;
          *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
          *(_OWORD *)v19 = v20;
          v21 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = "defaultAlignment";
            v93 = 16;
            v22 = &v91;
            v23 = v103;
            if (v21 >= v105)
            {
              v71 = v21 + 1;
              v72 = &v103[6 * v21] > &v91;
              if (v103 <= &v91 && v72)
              {
                v82 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                v23 = v103;
                v22 = (int *)((char *)v103 + v82);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                v22 = &v91;
                v23 = v103;
              }
            }
            v24 = &v23[6 * v104];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
            *(_OWORD *)v24 = v25;
            v26 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = ", ";
              v93 = 2;
              v27 = &v91;
              v28 = v103;
              if (v26 >= v105)
              {
                v73 = v26 + 1;
                if (v103 <= &v91 && &v103[6 * v26] > &v91)
                {
                  v83 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                  v28 = v103;
                  v27 = (int *)((char *)v103 + v83);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                  v27 = &v91;
                  v28 = v103;
                }
              }
              v29 = &v28[6 * v104];
              v30 = *(_OWORD *)v27;
              *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
              *(_OWORD *)v29 = v30;
              v31 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = "alignCorners";
                v93 = 12;
                v32 = &v91;
                v33 = v103;
                if (v31 >= v105)
                {
                  v74 = v31 + 1;
                  if (v103 <= &v91 && &v103[6 * v31] > &v91)
                  {
                    v84 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                    v33 = v103;
                    v32 = (int *)((char *)v103 + v84);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                    v32 = &v91;
                    v33 = v103;
                  }
                }
                v34 = &v33[6 * v104];
                v35 = *(_OWORD *)v32;
                *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
                *(_OWORD *)v34 = v35;
                v36 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = ", ";
                  v93 = 2;
                  v37 = &v91;
                  v38 = v103;
                  if (v36 >= v105)
                  {
                    v75 = v36 + 1;
                    v76 = &v103[6 * v36] > &v91;
                    if (v103 <= &v91 && v76)
                    {
                      v85 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                      v38 = v103;
                      v37 = (int *)((char *)v103 + v85);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                      v37 = &v91;
                      v38 = v103;
                    }
                  }
                  v39 = &v38[6 * v104];
                  v40 = *(_OWORD *)v37;
                  *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
                  *(_OWORD *)v39 = v40;
                  v41 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = "offsetCorners";
                    v93 = 13;
                    v42 = &v91;
                    v43 = v103;
                    if (v41 >= v105)
                    {
                      v77 = v41 + 1;
                      v78 = &v103[6 * v41] > &v91;
                      if (v103 <= &v91 && v78)
                      {
                        v86 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                        v43 = v103;
                        v42 = (int *)((char *)v103 + v86);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                        v42 = &v91;
                        v43 = v103;
                      }
                    }
                    v44 = &v43[6 * v104];
                    v45 = *(_OWORD *)v42;
                    *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                    *(_OWORD *)v44 = v45;
                    ++v104;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
    if (v102[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
    if (v111)
    {
      v46 = v109;
      if (v109)
      {
        v47 = v110;
        v48 = v109;
        if (v110 != v109)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = v109;
        }
        v110 = v46;
        operator delete(v48);
      }
      v49 = v107;
      if (v107)
      {
        v50 = v108;
        v51 = v107;
        if (v108 != v107)
        {
          do
          {
            v53 = *--v50;
            v52 = v53;
            *v50 = 0;
            if (v53)
              MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
          }
          while (v50 != v49);
          v51 = v107;
        }
        v108 = v49;
        operator delete(v51);
      }
      if (v103 != (int *)v106)
        free(v103);
    }
    goto LABEL_59;
  }
  v4 = 0;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_80;
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeAlignmentModeAttr::print(mlir::mps::CropResizeAlignmentModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "defaultAlignment";
    v8 = 16;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "offsetCorners";
    v8 = 13;
  }
  else
  {
    v7 = v6 != 1;
    if (v6 == 1)
      v8 = 12;
    else
      v8 = 0;
    if (v6 == 1)
      v9 = "alignCorners";
    else
      v9 = &byte_207AF6795;
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v7;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  int *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  int *v48;
  int *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  int *v53;
  int *v54;
  __int128 v55;
  uint64_t v56;
  int *v57;
  int *v58;
  int *v59;
  __int128 v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v63;
  _QWORD *v64;
  _QWORD *v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v81;
  unint64_t v82;
  BOOL v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  BOOL v93;
  unint64_t v94;
  BOOL v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  unsigned int v106[8];
  __int16 v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  const char *v111;
  uint64_t v112;
  _QWORD v113[3];
  void *v114;
  uint64_t v115;
  void *v116;
  _QWORD *v117;
  void *__p;
  _QWORD *v119;
  char v120;
  _QWORD v121[3];
  int *v122;
  unsigned int v123;
  unsigned int v124;
  _BYTE v125[96];
  _QWORD *v126;
  _QWORD *v127;
  _QWORD *v128;
  _QWORD *v129;
  char v130;
  uint64_t v131;

  v131 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v108 = 0;
  v109 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v108))
  {
LABEL_75:
    v69 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v123) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v113, a1, v69, v121);
    if (v113[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    if (v120)
    {
      v70 = __p;
      if (__p)
      {
        v71 = v119;
        v72 = __p;
        if (v119 != __p)
        {
          do
            v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
          while (v71 != v70);
          v72 = __p;
        }
        v119 = v70;
        operator delete(v72);
      }
      v73 = v116;
      if (v116)
      {
        v74 = v117;
        v75 = v116;
        if (v117 != v116)
        {
          do
          {
            v77 = *--v74;
            v76 = v77;
            *v74 = 0;
            if (v77)
              MEMORY[0x20BD002D4](v76, 0x1000C8077774924);
          }
          while (v74 != v73);
          v75 = v116;
        }
        v117 = v73;
        operator delete(v75);
      }
      if (v114 != &v115)
        free(v114);
    }
    return 0;
  }
  if (v109 == 17)
  {
    if (*(_QWORD *)v108 == 0x577372656E726F63
      && *(_QWORD *)(v108 + 8) == 0x7372694668746469
      && *(_BYTE *)(v108 + 16) == 116)
    {
      v7 = 1;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
    else
    {
      if (*(_QWORD *)v108 != 0x57737265746E6563
        || *(_QWORD *)(v108 + 8) != 0x7372694668746469
        || *(_BYTE *)(v108 + 16) != 116)
      {
        goto LABEL_36;
      }
      v7 = 3;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
LABEL_100:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v106[0] = v7;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v121[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
    v121[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v121, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, v106);
  }
  if (v109 != 18)
  {
LABEL_36:
    v107 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v121, a1, v2, v106);
    if (v121[0])
    {
      v110 = 3;
      v111 = "expected ";
      v112 = 9;
      v12 = &v110;
      v13 = v122;
      if (v123 >= v124)
      {
        v81 = v123 + 1;
        if (v122 <= &v110 && &v122[6 * v123] > &v110)
        {
          v96 = (char *)&v110 - (char *)v122;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
          v13 = v122;
          v12 = (int *)((char *)v122 + v96);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
          v12 = &v110;
          v13 = v122;
        }
      }
      v14 = &v13[6 * v123];
      v15 = *(_OWORD *)v12;
      *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
      *(_OWORD *)v14 = v15;
      v16 = ++v123;
      if (v121[0])
      {
        v110 = 3;
        v111 = "::mlir::mps::CropResizeCoordinateMode";
        v112 = 37;
        v17 = &v110;
        v18 = v122;
        if (v16 >= v124)
        {
          v82 = v16 + 1;
          v83 = &v122[6 * v16] > &v110;
          if (v122 <= &v110 && v83)
          {
            v97 = (char *)&v110 - (char *)v122;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
            v18 = v122;
            v17 = (int *)((char *)v122 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
            v17 = &v110;
            v18 = v122;
          }
        }
        v19 = &v18[6 * v123];
        v20 = *(_OWORD *)v17;
        *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
        *(_OWORD *)v19 = v20;
        v21 = ++v123;
        if (v121[0])
        {
          v110 = 3;
          v111 = " to be one of: ";
          v112 = 15;
          v22 = &v110;
          v23 = v122;
          if (v21 >= v124)
          {
            v84 = v21 + 1;
            v85 = &v122[6 * v21] > &v110;
            if (v122 <= &v110 && v85)
            {
              v98 = (char *)&v110 - (char *)v122;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
              v23 = v122;
              v22 = (int *)((char *)v122 + v98);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
              v22 = &v110;
              v23 = v122;
            }
          }
          v24 = &v23[6 * v123];
          v25 = *(_OWORD *)v22;
          *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
          *(_OWORD *)v24 = v25;
          v26 = ++v123;
          if (v121[0])
          {
            v110 = 3;
            v111 = "cornersHeightFirst";
            v112 = 18;
            v27 = &v110;
            v28 = v122;
            if (v26 >= v124)
            {
              v86 = v26 + 1;
              v87 = &v122[6 * v26] > &v110;
              if (v122 <= &v110 && v87)
              {
                v99 = (char *)&v110 - (char *)v122;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                v28 = v122;
                v27 = (int *)((char *)v122 + v99);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                v27 = &v110;
                v28 = v122;
              }
            }
            v29 = &v28[6 * v123];
            v30 = *(_OWORD *)v27;
            *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
            *(_OWORD *)v29 = v30;
            v31 = ++v123;
            if (v121[0])
            {
              v110 = 3;
              v111 = ", ";
              v112 = 2;
              v32 = &v110;
              v33 = v122;
              if (v31 >= v124)
              {
                v88 = v31 + 1;
                if (v122 <= &v110 && &v122[6 * v31] > &v110)
                {
                  v100 = (char *)&v110 - (char *)v122;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                  v33 = v122;
                  v32 = (int *)((char *)v122 + v100);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                  v32 = &v110;
                  v33 = v122;
                }
              }
              v34 = &v33[6 * v123];
              v35 = *(_OWORD *)v32;
              *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
              *(_OWORD *)v34 = v35;
              v36 = ++v123;
              if (v121[0])
              {
                v110 = 3;
                v111 = "cornersWidthFirst";
                v112 = 17;
                v37 = &v110;
                v38 = v122;
                if (v36 >= v124)
                {
                  v89 = v36 + 1;
                  if (v122 <= &v110 && &v122[6 * v36] > &v110)
                  {
                    v101 = (char *)&v110 - (char *)v122;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                    v38 = v122;
                    v37 = (int *)((char *)v122 + v101);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                    v37 = &v110;
                    v38 = v122;
                  }
                }
                v39 = &v38[6 * v123];
                v40 = *(_OWORD *)v37;
                *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
                *(_OWORD *)v39 = v40;
                v41 = ++v123;
                if (v121[0])
                {
                  v110 = 3;
                  v111 = ", ";
                  v112 = 2;
                  v42 = &v110;
                  v43 = v122;
                  if (v41 >= v124)
                  {
                    v90 = v41 + 1;
                    if (v122 <= &v110 && &v122[6 * v41] > &v110)
                    {
                      v102 = (char *)&v110 - (char *)v122;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                      v43 = v122;
                      v42 = (int *)((char *)v122 + v102);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                      v42 = &v110;
                      v43 = v122;
                    }
                  }
                  v44 = &v43[6 * v123];
                  v45 = *(_OWORD *)v42;
                  *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                  *(_OWORD *)v44 = v45;
                  v46 = ++v123;
                  if (v121[0])
                  {
                    v110 = 3;
                    v111 = "centersHeightFirst";
                    v112 = 18;
                    v47 = &v110;
                    v48 = v122;
                    if (v46 >= v124)
                    {
                      v91 = v46 + 1;
                      if (v122 <= &v110 && &v122[6 * v46] > &v110)
                      {
                        v103 = (char *)&v110 - (char *)v122;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                        v48 = v122;
                        v47 = (int *)((char *)v122 + v103);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                        v47 = &v110;
                        v48 = v122;
                      }
                    }
                    v49 = &v48[6 * v123];
                    v50 = *(_OWORD *)v47;
                    *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
                    *(_OWORD *)v49 = v50;
                    v51 = ++v123;
                    if (v121[0])
                    {
                      v110 = 3;
                      v111 = ", ";
                      v112 = 2;
                      v52 = &v110;
                      v53 = v122;
                      if (v51 >= v124)
                      {
                        v92 = v51 + 1;
                        v93 = &v122[6 * v51] > &v110;
                        if (v122 <= &v110 && v93)
                        {
                          v104 = (char *)&v110 - (char *)v122;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                          v53 = v122;
                          v52 = (int *)((char *)v122 + v104);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                          v52 = &v110;
                          v53 = v122;
                        }
                      }
                      v54 = &v53[6 * v123];
                      v55 = *(_OWORD *)v52;
                      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
                      *(_OWORD *)v54 = v55;
                      v56 = ++v123;
                      if (v121[0])
                      {
                        v110 = 3;
                        v111 = "centersWidthFirst";
                        v112 = 17;
                        v57 = &v110;
                        v58 = v122;
                        if (v56 >= v124)
                        {
                          v94 = v56 + 1;
                          v95 = &v122[6 * v56] > &v110;
                          if (v122 <= &v110 && v95)
                          {
                            v105 = (char *)&v110 - (char *)v122;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                            v58 = v122;
                            v57 = (int *)((char *)v122 + v105);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                            v57 = &v110;
                            v58 = v122;
                          }
                        }
                        v59 = &v58[6 * v123];
                        v60 = *(_OWORD *)v57;
                        *((_QWORD *)v59 + 2) = *((_QWORD *)v57 + 2);
                        *(_OWORD *)v59 = v60;
                        ++v123;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v121);
    if (v121[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v121);
    if (v130)
    {
      v61 = v128;
      if (v128)
      {
        v62 = v129;
        v63 = v128;
        if (v129 != v128)
        {
          do
            v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
          while (v62 != v61);
          v63 = v128;
        }
        v129 = v61;
        operator delete(v63);
      }
      v64 = v126;
      if (v126)
      {
        v65 = v127;
        v66 = v126;
        if (v127 != v126)
        {
          do
          {
            v68 = *--v65;
            v67 = v68;
            *v65 = 0;
            if (v68)
              MEMORY[0x20BD002D4](v67, 0x1000C8077774924);
          }
          while (v65 != v64);
          v66 = v126;
        }
        v127 = v64;
        operator delete(v66);
      }
      if (v122 != (int *)v125)
        free(v122);
    }
    goto LABEL_75;
  }
  if (*(_QWORD *)v108 == 0x487372656E726F63
    && *(_QWORD *)(v108 + 8) == 0x7269467468676965
    && *(_WORD *)(v108 + 16) == 29811)
  {
    v7 = 0;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
    goto LABEL_100;
  }
  if (*(_QWORD *)v108 != 0x48737265746E6563
    || *(_QWORD *)(v108 + 8) != 0x7269467468676965
    || *(_WORD *)(v108 + 16) != 29811)
  {
    goto LABEL_36;
  }
  v7 = 2;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_100;
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeCoordinateModeAttr::print(mlir::mps::CropResizeCoordinateModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_207AF6795;
      v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "cornersHeightFirst";
  v9 = 18;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "cornersWidthFirst";
      goto LABEL_9;
    case 2u:
      v7 = 0;
      v8 = "centersHeightFirst";
      v9 = 18;
      break;
    case 3u:
      v7 = 0;
      v8 = "centersWidthFirst";
LABEL_9:
      v9 = 17;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PruningMetricAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningMetricAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  BOOL v4;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  BOOL v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  unsigned int v55[8];
  __int16 v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  const char *v60;
  uint64_t v61;
  _QWORD v62[3];
  void *v63;
  uint64_t v64;
  void *v65;
  _QWORD *v66;
  void *__p;
  _QWORD *v68;
  char v69;
  _QWORD v70[3];
  int *v71;
  unsigned int v72;
  unsigned int v73;
  _BYTE v74[96];
  _QWORD *v75;
  _QWORD *v76;
  _QWORD *v77;
  _QWORD *v78;
  char v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v57 = 0;
    v58 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v57))
    {
LABEL_38:
      v32 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v72) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v62, a1, v32, v70);
      if (v62[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
      if (v69)
      {
        v33 = __p;
        if (__p)
        {
          v34 = v68;
          v35 = __p;
          if (v68 != __p)
          {
            do
              v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            v35 = __p;
          }
          v68 = v33;
          operator delete(v35);
        }
        v36 = v65;
        if (v65)
        {
          v37 = v66;
          v38 = v65;
          if (v66 != v65)
          {
            do
            {
              v40 = *--v37;
              v39 = v40;
              *v37 = 0;
              if (v40)
                MEMORY[0x20BD002D4](v39, 0x1000C8077774924);
            }
            while (v37 != v36);
            v38 = v65;
          }
          v66 = v36;
          operator delete(v38);
        }
        if (v63 != &v64)
          free(v63);
      }
      return 0;
    }
    if (v58 != 17
      || (*(_QWORD *)v57 == 0x647574696E67616DLL ? (v3 = *(_QWORD *)(v57 + 8) == 0x6E696E7572705F65) : (v3 = 0),
          v3 ? (v4 = *(_BYTE *)(v57 + 16) == 103) : (v4 = 0),
          !v4))
    {
      v56 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v70, a1, v2, v55);
      if (v70[0])
      {
        v59 = 3;
        v60 = "expected ";
        v61 = 9;
        v5 = &v59;
        v6 = v71;
        if (v72 >= v73)
        {
          v44 = v72 + 1;
          if (v71 <= &v59 && &v71[6 * v72] > &v59)
          {
            v51 = (char *)&v59 - (char *)v71;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            v6 = v71;
            v5 = (int *)((char *)v71 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            v5 = &v59;
            v6 = v71;
          }
        }
        v7 = &v6[6 * v72];
        v8 = *(_OWORD *)v5;
        *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
        *(_OWORD *)v7 = v8;
        v9 = ++v72;
        if (v70[0])
        {
          v59 = 3;
          v60 = "::mlir::mps::PruningMetric";
          v61 = 26;
          v10 = &v59;
          v11 = v71;
          if (v9 >= v73)
          {
            v45 = v9 + 1;
            v46 = &v71[6 * v9] > &v59;
            if (v71 <= &v59 && v46)
            {
              v52 = (char *)&v59 - (char *)v71;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              v11 = v71;
              v10 = (int *)((char *)v71 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              v10 = &v59;
              v11 = v71;
            }
          }
          v12 = &v11[6 * v72];
          v13 = *(_OWORD *)v10;
          *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
          *(_OWORD *)v12 = v13;
          v14 = ++v72;
          if (v70[0])
          {
            v59 = 3;
            v60 = " to be one of: ";
            v61 = 15;
            v15 = &v59;
            v16 = v71;
            if (v14 >= v73)
            {
              v47 = v14 + 1;
              v48 = &v71[6 * v14] > &v59;
              if (v71 <= &v59 && v48)
              {
                v53 = (char *)&v59 - (char *)v71;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                v16 = v71;
                v15 = (int *)((char *)v71 + v53);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                v15 = &v59;
                v16 = v71;
              }
            }
            v17 = &v16[6 * v72];
            v18 = *(_OWORD *)v15;
            *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
            *(_OWORD *)v17 = v18;
            v19 = ++v72;
            if (v70[0])
            {
              v59 = 3;
              v60 = "magnitude_pruning";
              v61 = 17;
              v20 = &v59;
              v21 = v71;
              if (v19 >= v73)
              {
                v49 = v19 + 1;
                v50 = &v71[6 * v19] > &v59;
                if (v71 <= &v59 && v50)
                {
                  v54 = (char *)&v59 - (char *)v71;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  v21 = v71;
                  v20 = (int *)((char *)v71 + v54);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  v20 = &v59;
                  v21 = v71;
                }
              }
              v22 = &v21[6 * v72];
              v23 = *(_OWORD *)v20;
              *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
              *(_OWORD *)v22 = v23;
              ++v72;
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v70);
      if (v70[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v70);
      if (v79)
      {
        v24 = v77;
        if (v77)
        {
          v25 = v78;
          v26 = v77;
          if (v78 != v77)
          {
            do
              v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            v26 = v77;
          }
          v78 = v24;
          operator delete(v26);
        }
        v27 = v75;
        if (v75)
        {
          v28 = v76;
          v29 = v75;
          if (v76 != v75)
          {
            do
            {
              v31 = *--v28;
              v30 = v31;
              *v28 = 0;
              if (v31)
                MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
            }
            while (v28 != v27);
            v29 = v75;
          }
          v76 = v27;
          operator delete(v29);
        }
        if (v71 != (int *)v74)
          free(v71);
      }
      goto LABEL_38;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v55[0] = 0;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v70[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
      v70[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, v55);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningMetricAttr::print(mlir::mps::PruningMetricAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  size_t v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  const char *v10;
  llvm::raw_ostream *result;
  _BYTE *v12;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (v6)
    v7 = 0;
  else
    v7 = 17;
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = *((_QWORD *)v8 + 4);
  if (v7 <= *((_QWORD *)v8 + 3) - v9)
  {
    if (!v6)
    {
      *(_BYTE *)(v9 + 16) = 103;
      *(_OWORD *)v9 = *(_OWORD *)"magnitude_pruning";
      *((_QWORD *)v8 + 4) += 17;
    }
  }
  else
  {
    if (v6)
      v10 = &byte_207AF6795;
    else
      v10 = "magnitude_pruning";
    llvm::raw_ostream::write(v8, v10, v7);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v12 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v12)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v12 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PruningStructureAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningStructureAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  unsigned int v4;
  int *v7;
  int *v8;
  int *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  _QWORD *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  unsigned int v73[8];
  __int16 v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  const char *v78;
  uint64_t v79;
  _QWORD v80[3];
  void *v81;
  uint64_t v82;
  void *v83;
  _QWORD *v84;
  void *__p;
  _QWORD *v86;
  char v87;
  _QWORD v88[3];
  int *v89;
  unsigned int v90;
  unsigned int v91;
  _BYTE v92[96];
  _QWORD *v93;
  _QWORD *v94;
  _QWORD *v95;
  _QWORD *v96;
  char v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v75 = 0;
  v76 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v75))
  {
LABEL_50:
    v44 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v90) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v80, a1, v44, v88);
    if (v80[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
    if (v87)
    {
      v45 = __p;
      if (__p)
      {
        v46 = v86;
        v47 = __p;
        if (v86 != __p)
        {
          do
            v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
          while (v46 != v45);
          v47 = __p;
        }
        v86 = v45;
        operator delete(v47);
      }
      v48 = v83;
      if (v83)
      {
        v49 = v84;
        v50 = v83;
        if (v84 != v83)
        {
          do
          {
            v52 = *--v49;
            v51 = v52;
            *v49 = 0;
            if (v52)
              MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
          }
          while (v49 != v48);
          v50 = v83;
        }
        v84 = v48;
        operator delete(v50);
      }
      if (v81 != &v82)
        free(v81);
    }
    return 0;
  }
  if (v76 == 20)
  {
    if (*(_QWORD *)v75 != 0x64315F6B636F6C62
      || *(_QWORD *)(v75 + 8) != 0x7572705F345F325FLL
      || *(_DWORD *)(v75 + 16) != 1735289198)
    {
      goto LABEL_19;
    }
    v4 = 1;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_71:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v73[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v88[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
    v88[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v88, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, v73);
  }
  if (v76 != 14
    || (*(_QWORD *)v75 == 0x705F6D6F646E6172 ? (v3 = *(_QWORD *)(v75 + 6) == 0x676E696E7572705FLL) : (v3 = 0), !v3))
  {
LABEL_19:
    v74 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v88, a1, v2, v73);
    if (v88[0])
    {
      v77 = 3;
      v78 = "expected ";
      v79 = 9;
      v7 = &v77;
      v8 = v89;
      if (v90 >= v91)
      {
        v56 = v90 + 1;
        if (v89 <= &v77 && &v89[6 * v90] > &v77)
        {
          v67 = (char *)&v77 - (char *)v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
          v8 = v89;
          v7 = (int *)((char *)v89 + v67);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
          v7 = &v77;
          v8 = v89;
        }
      }
      v9 = &v8[6 * v90];
      v10 = *(_OWORD *)v7;
      *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
      *(_OWORD *)v9 = v10;
      v11 = ++v90;
      if (v88[0])
      {
        v77 = 3;
        v78 = "::mlir::mps::PruningStructure";
        v79 = 29;
        v12 = &v77;
        v13 = v89;
        if (v11 >= v91)
        {
          v57 = v11 + 1;
          v58 = &v89[6 * v11] > &v77;
          if (v89 <= &v77 && v58)
          {
            v68 = (char *)&v77 - (char *)v89;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
            v13 = v89;
            v12 = (int *)((char *)v89 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
            v12 = &v77;
            v13 = v89;
          }
        }
        v14 = &v13[6 * v90];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        v16 = ++v90;
        if (v88[0])
        {
          v77 = 3;
          v78 = " to be one of: ";
          v79 = 15;
          v17 = &v77;
          v18 = v89;
          if (v16 >= v91)
          {
            v59 = v16 + 1;
            v60 = &v89[6 * v16] > &v77;
            if (v89 <= &v77 && v60)
            {
              v69 = (char *)&v77 - (char *)v89;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
              v18 = v89;
              v17 = (int *)((char *)v89 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
              v17 = &v77;
              v18 = v89;
            }
          }
          v19 = &v18[6 * v90];
          v20 = *(_OWORD *)v17;
          *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
          *(_OWORD *)v19 = v20;
          v21 = ++v90;
          if (v88[0])
          {
            v77 = 3;
            v78 = "random_pruning";
            v79 = 14;
            v22 = &v77;
            v23 = v89;
            if (v21 >= v91)
            {
              v61 = v21 + 1;
              v62 = &v89[6 * v21] > &v77;
              if (v89 <= &v77 && v62)
              {
                v70 = (char *)&v77 - (char *)v89;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                v23 = v89;
                v22 = (int *)((char *)v89 + v70);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                v22 = &v77;
                v23 = v89;
              }
            }
            v24 = &v23[6 * v90];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
            *(_OWORD *)v24 = v25;
            v26 = ++v90;
            if (v88[0])
            {
              v77 = 3;
              v78 = ", ";
              v79 = 2;
              v27 = &v77;
              v28 = v89;
              if (v26 >= v91)
              {
                v63 = v26 + 1;
                v64 = &v89[6 * v26] > &v77;
                if (v89 <= &v77 && v64)
                {
                  v71 = (char *)&v77 - (char *)v89;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                  v28 = v89;
                  v27 = (int *)((char *)v89 + v71);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                  v27 = &v77;
                  v28 = v89;
                }
              }
              v29 = &v28[6 * v90];
              v30 = *(_OWORD *)v27;
              *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
              *(_OWORD *)v29 = v30;
              v31 = ++v90;
              if (v88[0])
              {
                v77 = 3;
                v78 = "block_1d_2_4_pruning";
                v79 = 20;
                v32 = &v77;
                v33 = v89;
                if (v31 >= v91)
                {
                  v65 = v31 + 1;
                  v66 = &v89[6 * v31] > &v77;
                  if (v89 <= &v77 && v66)
                  {
                    v72 = (char *)&v77 - (char *)v89;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                    v33 = v89;
                    v32 = (int *)((char *)v89 + v72);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                    v32 = &v77;
                    v33 = v89;
                  }
                }
                v34 = &v33[6 * v90];
                v35 = *(_OWORD *)v32;
                *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
                *(_OWORD *)v34 = v35;
                ++v90;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v88);
    if (v88[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v88);
    if (v97)
    {
      v36 = v95;
      if (v95)
      {
        v37 = v96;
        v38 = v95;
        if (v96 != v95)
        {
          do
            v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
          while (v37 != v36);
          v38 = v95;
        }
        v96 = v36;
        operator delete(v38);
      }
      v39 = v93;
      if (v93)
      {
        v40 = v94;
        v41 = v93;
        if (v94 != v93)
        {
          do
          {
            v43 = *--v40;
            v42 = v43;
            *v40 = 0;
            if (v43)
              MEMORY[0x20BD002D4](v42, 0x1000C8077774924);
          }
          while (v40 != v39);
          v41 = v93;
        }
        v94 = v39;
        operator delete(v41);
      }
      if (v89 != (int *)v92)
        free(v89);
    }
    goto LABEL_50;
  }
  v4 = 0;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_71;
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningStructureAttr::print(mlir::mps::PruningStructureAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = &byte_207AF6795;
  v8 = 20;
  if (v6 == 1)
    v7 = "block_1d_2_4_pruning";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 14;
  if (v6)
    v11 = v7;
  else
    v11 = "random_pruning";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::SimilarityTypeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SimilarityTypeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  uint64_t v24;
  int *v25;
  int *v26;
  int *v27;
  __int128 v28;
  uint64_t v29;
  int *v30;
  int *v31;
  int *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  unsigned int v71[8];
  __int16 v72;
  _QWORD *v73;
  uint64_t v74;
  int v75;
  const char *v76;
  uint64_t v77;
  _QWORD v78[3];
  void *v79;
  uint64_t v80;
  void *v81;
  _QWORD *v82;
  void *__p;
  _QWORD *v84;
  char v85;
  _QWORD v86[3];
  int *v87;
  unsigned int v88;
  unsigned int v89;
  _BYTE v90[96];
  _QWORD *v91;
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  char v95;
  uint64_t v96;

  v96 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v73 = 0;
  v74 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
  {
LABEL_44:
    v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v88) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v78, a1, v42, v86);
    if (v78[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
    if (v85)
    {
      v43 = __p;
      if (__p)
      {
        v44 = v84;
        v45 = __p;
        if (v84 != __p)
        {
          do
            v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
          while (v44 != v43);
          v45 = __p;
        }
        v84 = v43;
        operator delete(v45);
      }
      v46 = v81;
      if (v81)
      {
        v47 = v82;
        v48 = v81;
        if (v82 != v81)
        {
          do
          {
            v50 = *--v47;
            v49 = v50;
            *v47 = 0;
            if (v50)
              MEMORY[0x20BD002D4](v49, 0x1000C8077774924);
          }
          while (v47 != v46);
          v48 = v81;
        }
        v82 = v46;
        operator delete(v48);
      }
      if (v79 != &v80)
        free(v79);
    }
    return 0;
  }
  if (v74 != 8)
  {
    if (v74 != 11)
      goto LABEL_13;
    if (*v73 != 0x646F72705F746F64 || *(_QWORD *)((char *)v73 + 3) != 0x746375646F72705FLL)
      goto LABEL_13;
    v4 = 0;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_65:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v71[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
    v86[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, v71);
  }
  if (*v73 != 0x666669645F736261)
  {
LABEL_13:
    v72 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v86, a1, v2, v71);
    if (v86[0])
    {
      v75 = 3;
      v76 = "expected ";
      v77 = 9;
      v5 = &v75;
      v6 = v87;
      if (v88 >= v89)
      {
        v54 = v88 + 1;
        if (v87 <= &v75 && &v87[6 * v88] > &v75)
        {
          v65 = (char *)&v75 - (char *)v87;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v6 = v87;
          v5 = (int *)((char *)v87 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v5 = &v75;
          v6 = v87;
        }
      }
      v7 = &v6[6 * v88];
      v8 = *(_OWORD *)v5;
      *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v7 = v8;
      v9 = ++v88;
      if (v86[0])
      {
        v75 = 3;
        v76 = "::mlir::mps::SimilarityType";
        v77 = 27;
        v10 = &v75;
        v11 = v87;
        if (v9 >= v89)
        {
          v55 = v9 + 1;
          v56 = &v87[6 * v9] > &v75;
          if (v87 <= &v75 && v56)
          {
            v66 = (char *)&v75 - (char *)v87;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v11 = v87;
            v10 = (int *)((char *)v87 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v10 = &v75;
            v11 = v87;
          }
        }
        v12 = &v11[6 * v88];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        v14 = ++v88;
        if (v86[0])
        {
          v75 = 3;
          v76 = " to be one of: ";
          v77 = 15;
          v15 = &v75;
          v16 = v87;
          if (v14 >= v89)
          {
            v57 = v14 + 1;
            v58 = &v87[6 * v14] > &v75;
            if (v87 <= &v75 && v58)
            {
              v67 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v16 = v87;
              v15 = (int *)((char *)v87 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v15 = &v75;
              v16 = v87;
            }
          }
          v17 = &v16[6 * v88];
          v18 = *(_OWORD *)v15;
          *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
          *(_OWORD *)v17 = v18;
          v19 = ++v88;
          if (v86[0])
          {
            v75 = 3;
            v76 = "dot_product";
            v77 = 11;
            v20 = &v75;
            v21 = v87;
            if (v19 >= v89)
            {
              v59 = v19 + 1;
              v60 = &v87[6 * v19] > &v75;
              if (v87 <= &v75 && v60)
              {
                v68 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v21 = v87;
                v20 = (int *)((char *)v87 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v20 = &v75;
                v21 = v87;
              }
            }
            v22 = &v21[6 * v88];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
            *(_OWORD *)v22 = v23;
            v24 = ++v88;
            if (v86[0])
            {
              v75 = 3;
              v76 = ", ";
              v77 = 2;
              v25 = &v75;
              v26 = v87;
              if (v24 >= v89)
              {
                v61 = v24 + 1;
                v62 = &v87[6 * v24] > &v75;
                if (v87 <= &v75 && v62)
                {
                  v69 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v26 = v87;
                  v25 = (int *)((char *)v87 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v25 = &v75;
                  v26 = v87;
                }
              }
              v27 = &v26[6 * v88];
              v28 = *(_OWORD *)v25;
              *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
              *(_OWORD *)v27 = v28;
              v29 = ++v88;
              if (v86[0])
              {
                v75 = 3;
                v76 = "abs_diff";
                v77 = 8;
                v30 = &v75;
                v31 = v87;
                if (v29 >= v89)
                {
                  v63 = v29 + 1;
                  v64 = &v87[6 * v29] > &v75;
                  if (v87 <= &v75 && v64)
                  {
                    v70 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v31 = v87;
                    v30 = (int *)((char *)v87 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v30 = &v75;
                    v31 = v87;
                  }
                }
                v32 = &v31[6 * v88];
                v33 = *(_OWORD *)v30;
                *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
                *(_OWORD *)v32 = v33;
                ++v88;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
    if (v86[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
    if (v95)
    {
      v34 = v93;
      if (v93)
      {
        v35 = v94;
        v36 = v93;
        if (v94 != v93)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = v93;
        }
        v94 = v34;
        operator delete(v36);
      }
      v37 = v91;
      if (v91)
      {
        v38 = v92;
        v39 = v91;
        if (v92 != v91)
        {
          do
          {
            v41 = *--v38;
            v40 = v41;
            *v38 = 0;
            if (v41)
              MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
          }
          while (v38 != v37);
          v39 = v91;
        }
        v92 = v37;
        operator delete(v39);
      }
      if (v87 != (int *)v90)
        free(v87);
    }
    goto LABEL_44;
  }
  v4 = 1;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_65;
  return 0;
}

llvm::raw_ostream *mlir::mps::SimilarityTypeAttr::print(mlir::mps::SimilarityTypeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = &byte_207AF6795;
  v8 = 8;
  if (v6 == 1)
    v7 = "abs_diff";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 11;
  if (v6)
    v11 = v7;
  else
    v11 = "dot_product";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::FFTScalingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::FFTScalingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v3;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  uint64_t v24;
  int *v25;
  int *v26;
  int *v27;
  __int128 v28;
  uint64_t v29;
  int *v30;
  int *v31;
  int *v32;
  __int128 v33;
  uint64_t v34;
  int *v35;
  int *v36;
  int *v37;
  __int128 v38;
  uint64_t v39;
  int *v40;
  int *v41;
  int *v42;
  __int128 v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  void *v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  int64_t v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  unsigned int v85[8];
  __int16 v86;
  _DWORD *v87;
  uint64_t v88;
  int v89;
  const char *v90;
  uint64_t v91;
  _QWORD v92[3];
  void *v93;
  uint64_t v94;
  void *v95;
  _QWORD *v96;
  void *__p;
  _QWORD *v98;
  char v99;
  _QWORD v100[3];
  int *v101;
  unsigned int v102;
  unsigned int v103;
  _BYTE v104[96];
  _QWORD *v105;
  _QWORD *v106;
  _QWORD *v107;
  _QWORD *v108;
  char v109;
  uint64_t v110;

  v110 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v87 = 0;
  v88 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v87))
  {
LABEL_48:
    v52 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v102) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v92, a1, v52, v100);
    if (v92[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
    if (v99)
    {
      v53 = __p;
      if (__p)
      {
        v54 = v98;
        v55 = __p;
        if (v98 != __p)
        {
          do
            v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v54 - 1);
          while (v54 != v53);
          v55 = __p;
        }
        v98 = v53;
        operator delete(v55);
      }
      v56 = v95;
      if (v95)
      {
        v57 = v96;
        v58 = v95;
        if (v96 != v95)
        {
          do
          {
            v60 = *--v57;
            v59 = v60;
            *v57 = 0;
            if (v60)
              MEMORY[0x20BD002D4](v59, 0x1000C8077774924);
          }
          while (v57 != v56);
          v58 = v95;
        }
        v96 = v56;
        operator delete(v58);
      }
      if (v93 != &v94)
        free(v93);
    }
    return 0;
  }
  if (v88 != 7)
  {
    if (v88 == 4)
    {
      if (*v87 == 1701736302)
      {
        v3 = 0;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          return 0;
        goto LABEL_71;
      }
      if (*v87 == 1702521203)
      {
        v3 = 1;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          return 0;
LABEL_71:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v85[0] = v3;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v100[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
        v100[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v100, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, v85);
      }
    }
    goto LABEL_13;
  }
  if (*v87 != 1953066613 || *(_DWORD *)((char *)v87 + 3) != 2037539188)
  {
LABEL_13:
    v86 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v100, a1, v2, v85);
    if (v100[0])
    {
      v89 = 3;
      v90 = "expected ";
      v91 = 9;
      v5 = &v89;
      v6 = v101;
      if (v102 >= v103)
      {
        v64 = v102 + 1;
        if (v101 <= &v89 && &v101[6 * v102] > &v89)
        {
          v77 = (char *)&v89 - (char *)v101;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          v6 = v101;
          v5 = (int *)((char *)v101 + v77);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          v5 = &v89;
          v6 = v101;
        }
      }
      v7 = &v6[6 * v102];
      v8 = *(_OWORD *)v5;
      *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v7 = v8;
      v9 = ++v102;
      if (v100[0])
      {
        v89 = 3;
        v90 = "::mlir::mps::FFTScalingMode";
        v91 = 27;
        v10 = &v89;
        v11 = v101;
        if (v9 >= v103)
        {
          v65 = v9 + 1;
          v66 = &v101[6 * v9] > &v89;
          if (v101 <= &v89 && v66)
          {
            v78 = (char *)&v89 - (char *)v101;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            v11 = v101;
            v10 = (int *)((char *)v101 + v78);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            v10 = &v89;
            v11 = v101;
          }
        }
        v12 = &v11[6 * v102];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        v14 = ++v102;
        if (v100[0])
        {
          v89 = 3;
          v90 = " to be one of: ";
          v91 = 15;
          v15 = &v89;
          v16 = v101;
          if (v14 >= v103)
          {
            v67 = v14 + 1;
            v68 = &v101[6 * v14] > &v89;
            if (v101 <= &v89 && v68)
            {
              v79 = (char *)&v89 - (char *)v101;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              v16 = v101;
              v15 = (int *)((char *)v101 + v79);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              v15 = &v89;
              v16 = v101;
            }
          }
          v17 = &v16[6 * v102];
          v18 = *(_OWORD *)v15;
          *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
          *(_OWORD *)v17 = v18;
          v19 = ++v102;
          if (v100[0])
          {
            v89 = 3;
            v90 = "none";
            v91 = 4;
            v20 = &v89;
            v21 = v101;
            if (v19 >= v103)
            {
              v69 = v19 + 1;
              v70 = &v101[6 * v19] > &v89;
              if (v101 <= &v89 && v70)
              {
                v80 = (char *)&v89 - (char *)v101;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                v21 = v101;
                v20 = (int *)((char *)v101 + v80);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                v20 = &v89;
                v21 = v101;
              }
            }
            v22 = &v21[6 * v102];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
            *(_OWORD *)v22 = v23;
            v24 = ++v102;
            if (v100[0])
            {
              v89 = 3;
              v90 = ", ";
              v91 = 2;
              v25 = &v89;
              v26 = v101;
              if (v24 >= v103)
              {
                v71 = v24 + 1;
                if (v101 <= &v89 && &v101[6 * v24] > &v89)
                {
                  v81 = (char *)&v89 - (char *)v101;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  v26 = v101;
                  v25 = (int *)((char *)v101 + v81);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  v25 = &v89;
                  v26 = v101;
                }
              }
              v27 = &v26[6 * v102];
              v28 = *(_OWORD *)v25;
              *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
              *(_OWORD *)v27 = v28;
              v29 = ++v102;
              if (v100[0])
              {
                v89 = 3;
                v90 = "size";
                v91 = 4;
                v30 = &v89;
                v31 = v101;
                if (v29 >= v103)
                {
                  v72 = v29 + 1;
                  if (v101 <= &v89 && &v101[6 * v29] > &v89)
                  {
                    v82 = (char *)&v89 - (char *)v101;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    v31 = v101;
                    v30 = (int *)((char *)v101 + v82);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    v30 = &v89;
                    v31 = v101;
                  }
                }
                v32 = &v31[6 * v102];
                v33 = *(_OWORD *)v30;
                *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
                *(_OWORD *)v32 = v33;
                v34 = ++v102;
                if (v100[0])
                {
                  v89 = 3;
                  v90 = ", ";
                  v91 = 2;
                  v35 = &v89;
                  v36 = v101;
                  if (v34 >= v103)
                  {
                    v73 = v34 + 1;
                    v74 = &v101[6 * v34] > &v89;
                    if (v101 <= &v89 && v74)
                    {
                      v83 = (char *)&v89 - (char *)v101;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      v36 = v101;
                      v35 = (int *)((char *)v101 + v83);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      v35 = &v89;
                      v36 = v101;
                    }
                  }
                  v37 = &v36[6 * v102];
                  v38 = *(_OWORD *)v35;
                  *((_QWORD *)v37 + 2) = *((_QWORD *)v35 + 2);
                  *(_OWORD *)v37 = v38;
                  v39 = ++v102;
                  if (v100[0])
                  {
                    v89 = 3;
                    v90 = "unitary";
                    v91 = 7;
                    v40 = &v89;
                    v41 = v101;
                    if (v39 >= v103)
                    {
                      v75 = v39 + 1;
                      v76 = &v101[6 * v39] > &v89;
                      if (v101 <= &v89 && v76)
                      {
                        v84 = (char *)&v89 - (char *)v101;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        v41 = v101;
                        v40 = (int *)((char *)v101 + v84);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        v40 = &v89;
                        v41 = v101;
                      }
                    }
                    v42 = &v41[6 * v102];
                    v43 = *(_OWORD *)v40;
                    *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
                    *(_OWORD *)v42 = v43;
                    ++v102;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v100);
    if (v100[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v100);
    if (v109)
    {
      v44 = v107;
      if (v107)
      {
        v45 = v108;
        v46 = v107;
        if (v108 != v107)
        {
          do
            v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
          while (v45 != v44);
          v46 = v107;
        }
        v108 = v44;
        operator delete(v46);
      }
      v47 = v105;
      if (v105)
      {
        v48 = v106;
        v49 = v105;
        if (v106 != v105)
        {
          do
          {
            v51 = *--v48;
            v50 = v51;
            *v48 = 0;
            if (v51)
              MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
          }
          while (v48 != v47);
          v49 = v105;
        }
        v106 = v47;
        operator delete(v49);
      }
      if (v101 != (int *)v104)
        free(v101);
    }
    goto LABEL_48;
  }
  v3 = 2;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_71;
  return 0;
}

llvm::raw_ostream *mlir::mps::FFTScalingModeAttr::print(mlir::mps::FFTScalingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "none";
    v8 = 4;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "unitary";
    v8 = 7;
  }
  else
  {
    v7 = v6 != 1;
    if (v6 == 1)
      v8 = 4;
    else
      v8 = 0;
    if (v6 == 1)
      v9 = "size";
    else
      v9 = &byte_207AF6795;
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::MPSBufferTensorAttr::parse(mlir::AsmParser *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  mlir::MLIRContext *Context;
  _BYTE v39[24];
  char v40;
  __int16 v41;
  _QWORD v42[24];
  _QWORD v43[3];
  uint64_t *v44;
  uint64_t v45;
  void *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  char v50;
  _BYTE v51[23];
  _QWORD v52[3];
  void *v53;
  uint64_t v54;
  void *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  char v59;
  _QWORD v60[3];
  uint64_t *v61;
  uint64_t v62;
  void *v63;
  _QWORD *v64;
  void *__p;
  _QWORD *v66;
  char v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!a2)
  {
    *(_QWORD *)v39 = "expected a trailing type";
    v41 = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v52, a1, v4, v39);
    if (v52[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v52);
    if (!v59)
      return 0;
    v13 = v57;
    if (v57)
    {
      v14 = v58;
      v15 = v57;
      if (v58 != v57)
      {
        do
          v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
        while (v14 != v13);
        v15 = v57;
      }
      v58 = v13;
      operator delete(v15);
    }
    v16 = v55;
    if (v55)
    {
      v17 = v56;
      v18 = v55;
      if (v56 != v55)
      {
        do
        {
          v20 = *--v17;
          v19 = v20;
          *v17 = 0;
          if (v20)
            MEMORY[0x20BD002D4](v19, 0x1000C8077774924);
        }
        while (v17 != v16);
        v18 = v55;
      }
      v56 = v16;
      operator delete(v18);
    }
    v24 = v53;
    if (v53 == &v54)
      return 0;
    goto LABEL_45;
  }
  if (*(_UNKNOWN **)(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    *(_QWORD *)v39 = "invalid kind of type specified";
    v41 = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v60, a1, v4, v39);
    if (v60[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
    if (!v67)
      return 0;
    v5 = __p;
    if (__p)
    {
      v6 = v66;
      v7 = __p;
      if (v66 != __p)
      {
        do
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        v7 = __p;
      }
      v66 = v5;
      operator delete(v7);
    }
    v8 = v63;
    if (v63)
    {
      v9 = v64;
      v10 = v63;
      if (v64 != v63)
      {
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
        }
        while (v9 != v8);
        v10 = v63;
      }
      v64 = v8;
      operator delete(v10);
    }
    v24 = v61;
    if (v61 == &v62)
      return 0;
    goto LABEL_45;
  }
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(a1, (uint64_t)v39);
    v21 = v39[0];
    *(_OWORD *)v51 = *(_OWORD *)&v39[1];
    *(_QWORD *)&v51[15] = *(_QWORD *)&v39[16];
    v22 = *(_QWORD *)a1;
    if (v40)
    {
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(v22 + 128))(a1))
      {
        v41 = 257;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 368))(a1, "handle_offset", 13, v39)|| !(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 136))(a1))
        {
          return 0;
        }
        *(_QWORD *)v39 = 0;
        if (!mlir::AsmParser::parseInteger<unsigned long long>((uint64_t)a1, (uint64_t *)v39))
        {
          v35 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
          v41 = 259;
          (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v42, a1, v35, v39);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v42);
          return 0;
        }
        v23 = *(_QWORD *)v39;
      }
      else
      {
        v23 = 0;
      }
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
        v37 = a2;
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v39[0] = v21;
        *(_OWORD *)&v39[1] = *(_OWORD *)v51;
        *(_QWORD *)&v39[16] = *(_QWORD *)&v51[15];
        v36 = v23;
        return mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>((uint64_t)a1, v4, &Context, &v37, (uint64_t)v39, &v36);
      }
      return 0;
    }
    v26 = (*(uint64_t (**)(mlir::AsmParser *))(v22 + 40))(a1);
    v41 = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v43, a1, v26, v39);
    if (v43[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
    if (!v50)
      return 0;
    v27 = v48;
    if (v48)
    {
      v28 = v49;
      v29 = v48;
      if (v49 != v48)
      {
        do
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        v29 = v48;
      }
      v49 = v27;
      operator delete(v29);
    }
    v30 = v46;
    if (v46)
    {
      v31 = v47;
      v32 = v46;
      if (v47 != v46)
      {
        do
        {
          v34 = *--v31;
          v33 = v34;
          *v31 = 0;
          if (v34)
            MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
        }
        while (v31 != v30);
        v32 = v46;
      }
      v47 = v30;
      operator delete(v32);
    }
    v24 = v44;
    if (v44 == &v45)
      return 0;
LABEL_45:
    free(v24);
  }
  return 0;
}

void mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(mlir::AsmParser *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  mlir::Dialect *Dialect;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  int *v9;
  char *v10;
  char *v11;
  __int128 v12;
  char *v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  char *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  __int128 v51;
  uint64_t v52;
  char v53;
  __int16 v54;
  const void **v55;
  const char *v56;
  uint64_t v57;
  __int16 v58;
  int v59;
  const char *v60;
  uint64_t v61;
  char *Context;
  unint64_t v63;
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD *v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  Context = (char *)mlir::AsmParser::getContext(a1);
  Dialect = mlir::MLIRContext::getOrLoadDialect(Context, (uint64_t)"mps", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::mps::MPSDialect * mlir::MLIRContext::getOrLoadDialect<mlir::mps::MPSDialect>(void)::{lambda(void)#1}>, (uint64_t)&Context);
  if (Dialect)
  {
    (*(void (**)(__int128 *__return_ptr, mlir::AsmParser *, mlir::Dialect *))(*(_QWORD *)a1 + 584))(&v51, a1, Dialect);
    if (!v53)
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      return;
    }
    v6 = *((_QWORD *)&v51 + 1);
    v8 = &unk_25451E000;
    if ((v7 & 1) == 0)
    {
      v8 = (_QWORD *)&unk_25451E000;
      if (v40)
      {
        Context = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MPSDialectResourceBlobHandle]";
        v63 = 89;
        v41 = llvm::StringRef::find((uint64_t *)&Context, "DesiredTypeName = ", 0x12uLL, 0);
        if (v63 >= v41)
          v42 = v41;
        else
          v42 = v63;
        v43 = &Context[v42];
        v44 = v63 - v42;
        if (v63 - v42 >= 0x12)
          v45 = 18;
        else
          v45 = v63 - v42;
        v46 = v44 - v45;
        if (v46 >= v46 - 1)
          v47 = v46 - 1;
        else
          v47 = v46;
        mlir::detail::TypeIDResolver<mlir::mps::MPSDialectResourceBlobHandle,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
        v8 = (_QWORD *)&unk_25451E000;
      }
    }
    if (v6 == v8[90])
    {
      *(_OWORD *)a2 = v51;
      *(_QWORD *)(a2 + 16) = v52;
      *(_BYTE *)(a2 + 24) = 1;
      return;
    }
    v58 = 257;
    (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(_QWORD *)a1 + 24))(&Context, a1, v4, &v55);
    if (Context)
    {
      v59 = 3;
      v60 = "provided resource handle differs from the expected resource type";
      v61 = 64;
      v9 = &v59;
      v10 = (char *)v64;
      if (v65 >= v66)
      {
        v38 = v65 + 1;
        if (v64 <= &v59 && (char *)v64 + 24 * v65 > (char *)&v59)
        {
          v49 = (char *)&v59 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v38, 24);
          v10 = (char *)v64;
          v9 = (int *)((char *)v64 + v49);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v38, 24);
          v9 = &v59;
          v10 = (char *)v64;
        }
      }
      v11 = &v10[24 * v65];
      v12 = *(_OWORD *)v9;
      *((_QWORD *)v11 + 2) = *((_QWORD *)v9 + 2);
      *(_OWORD *)v11 = v12;
      ++v65;
      v13 = Context;
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      if (v13)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
      if (!v72)
        return;
    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      if (!v72)
        return;
    }
    v31 = __p;
    if (__p)
    {
      v32 = v71;
      v33 = __p;
      if (v71 != __p)
      {
        do
          v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v32 - 1);
        while (v32 != v31);
        v33 = __p;
      }
      v71 = v31;
      operator delete(v33);
    }
    v26 = v68;
    if (!v68)
    {
LABEL_47:
      if (v64 != v67)
        free(v64);
      return;
    }
    v34 = v69;
    v28 = v68;
    if (v69 == v68)
    {
LABEL_46:
      v69 = v26;
      operator delete(v28);
      goto LABEL_47;
    }
    do
    {
      v36 = *--v34;
      v35 = v36;
      *v34 = 0;
      if (v36)
        MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
    }
    while (v34 != v26);
LABEL_45:
    v28 = v68;
    goto LABEL_46;
  }
  v54 = 257;
  (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, __int128 *))(*(_QWORD *)a1 + 24))(&Context, a1, v4, &v51);
  if (!Context)
    goto LABEL_18;
  LODWORD(v55) = 3;
  v56 = "dialect '";
  v57 = 9;
  v14 = &v55;
  v15 = (char *)v64;
  if (v65 >= v66)
  {
    v37 = v65 + 1;
    if (v64 <= &v55 && (char *)v64 + 24 * v65 > (char *)&v55)
    {
      v48 = (char *)&v55 - (_BYTE *)v64;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v37, 24);
      v15 = (char *)v64;
      v14 = (const void ***)((char *)v64 + v48);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v37, 24);
      v14 = &v55;
      v15 = (char *)v64;
    }
  }
  v16 = &v15[24 * v65];
  v17 = *(_OWORD *)v14;
  *((_QWORD *)v16 + 2) = v14[2];
  *(_OWORD *)v16 = v17;
  ++v65;
  if (!Context)
    goto LABEL_18;
  v58 = 262;
  v55 = (const void **)"mps";
  v56 = (const char *)3;
  mlir::Diagnostic::operator<<((uint64_t)&v63, &v55);
  if (Context)
  {
    LODWORD(v55) = 3;
    v56 = "' is unknown";
    v57 = 12;
    v18 = &v55;
    v19 = (char *)v64;
    if (v65 >= v66)
    {
      v39 = v65 + 1;
      if (v64 <= &v55 && (char *)v64 + 24 * v65 > (char *)&v55)
      {
        v50 = (char *)&v55 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v39, 24);
        v19 = (char *)v64;
        v18 = (const void ***)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v39, 24);
        v18 = &v55;
        v19 = (char *)v64;
      }
    }
    v20 = &v19[24 * v65];
    v21 = *(_OWORD *)v18;
    *((_QWORD *)v20 + 2) = v18[2];
    *(_OWORD *)v20 = v21;
    ++v65;
    v22 = Context;
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
  }
  else
  {
LABEL_18:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }
  if (v72)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v71;
      v25 = __p;
      if (v71 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v71 = v23;
      operator delete(v25);
    }
    v26 = v68;
    if (!v68)
      goto LABEL_47;
    v27 = v69;
    v28 = v68;
    if (v69 == v68)
      goto LABEL_46;
    do
    {
      v30 = *--v27;
      v29 = v30;
      *v27 = 0;
      if (v30)
        MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
    }
    while (v27 != v26);
    goto LABEL_45;
  }
}

uint64_t mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, _QWORD **a4, uint64_t a5, uint64_t *a6)
{
  mlir::MLIRContext *v6;
  _QWORD *v7;
  unsigned __int8 **AttributeUniquer;
  _QWORD v10[2];
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD v16[2];

  v10[0] = a1;
  v10[1] = &v11;
  v11 = a2;
  v6 = *a3;
  v7 = *a4;
  v12 = *(_OWORD *)a5;
  v13 = *(_QWORD *)(a5 + 16);
  v14 = *a6;
  v15 = v7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v6);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  v16[1] = v6;
  return mlir::StorageUniquer::get<mlir::mps::detail::MPSBufferTensorAttrStorage,mlir::RankedTensorType &,mlir::mps::MPSDialectResourceBlobHandle &,unsigned long long &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26MPSBufferTensorAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19MPSBufferTensorAttrEJRNS1_16RankedTensorTypeERNS2_28MPSDialectResourceBlobHandleERyEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id, (uint64_t *)&v15, &v12, &v14);
}

llvm::raw_ostream *mlir::mps::MPSBufferTensorAttr::print(mlir::mps::MPSBufferTensorAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  __int128 v6;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  llvm::raw_ostream *v9;
  _BYTE *v10;
  llvm::raw_ostream *v11;
  void *v12;
  llvm::raw_ostream *v13;
  _BYTE *v14;
  llvm::raw_ostream *v15;
  _BYTE *v16;
  llvm::raw_ostream *v17;
  _BYTE *v18;
  unint64_t v19;
  llvm::raw_ostream *v20;
  llvm::raw_ostream *result;
  _BYTE *v22;
  __int128 v23;
  uint64_t v24;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_OWORD *)(*(_QWORD *)this + 16);
  v24 = *(_QWORD *)(*(_QWORD *)this + 32);
  v23 = v6;
  (*(void (**)(mlir::AsmPrinter *, __int128 *))(*(_QWORD *)a2 + 80))(a2, &v23);
  if (!*(_QWORD *)(*(_QWORD *)this + 40))
    goto LABEL_25;
  v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (_BYTE *)*((_QWORD *)v7 + 4);
  if (*((_BYTE **)v7 + 3) == v8)
  {
    llvm::raw_ostream::write(v7, ",", 1uLL);
  }
  else
  {
    *v8 = 44;
    ++*((_QWORD *)v7 + 4);
  }
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v10 = (_BYTE *)*((_QWORD *)v9 + 4);
  if ((unint64_t)v10 >= *((_QWORD *)v9 + 3))
  {
    llvm::raw_ostream::write(v9, 32);
  }
  else
  {
    *((_QWORD *)v9 + 4) = v10 + 1;
    *v10 = 32;
  }
  v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v12 = (void *)*((_QWORD *)v11 + 4);
  if (*((_QWORD *)v11 + 3) - (_QWORD)v12 > 0xCuLL)
  {
    qmemcpy(v12, "handle_offset", 13);
    *((_QWORD *)v11 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(v11, "handle_offset", 0xDuLL);
  }
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v14 = (_BYTE *)*((_QWORD *)v13 + 4);
  if ((unint64_t)v14 >= *((_QWORD *)v13 + 3))
  {
    llvm::raw_ostream::write(v13, 32);
  }
  else
  {
    *((_QWORD *)v13 + 4) = v14 + 1;
    *v14 = 32;
  }
  v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v16 = (_BYTE *)*((_QWORD *)v15 + 4);
  if (*((_BYTE **)v15 + 3) == v16)
  {
    llvm::raw_ostream::write(v15, "=", 1uLL);
    if (!*(_QWORD *)(*(_QWORD *)this + 40))
      goto LABEL_25;
  }
  else
  {
    *v16 = 61;
    ++*((_QWORD *)v15 + 4);
    if (!*(_QWORD *)(*(_QWORD *)this + 40))
      goto LABEL_25;
  }
  v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v18 = (_BYTE *)*((_QWORD *)v17 + 4);
  if ((unint64_t)v18 >= *((_QWORD *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, 32);
  }
  else
  {
    *((_QWORD *)v17 + 4) = v18 + 1;
    *v18 = 32;
  }
  v19 = *(_QWORD *)(*(_QWORD *)this + 40);
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  llvm::raw_ostream::operator<<(v20, v19);
LABEL_25:
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v22 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v22)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v22 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::CallInlineModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CallInlineModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v65;
  unint64_t v66;
  BOOL v67;
  unint64_t v68;
  BOOL v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  BOOL v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  unsigned int v86[8];
  __int16 v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  const char *v91;
  uint64_t v92;
  _QWORD v93[3];
  void *v94;
  uint64_t v95;
  void *v96;
  _QWORD *v97;
  void *__p;
  _QWORD *v99;
  char v100;
  _QWORD v101[3];
  int *v102;
  unsigned int v103;
  unsigned int v104;
  _BYTE v105[96];
  _QWORD *v106;
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  char v110;
  uint64_t v111;

  v111 = *MEMORY[0x24BDAC8D0];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v88 = 0;
  v89 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v88))
  {
LABEL_55:
    v53 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v103) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v93, a1, v53, v101);
    if (v93[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v93);
    if (v100)
    {
      v54 = __p;
      if (__p)
      {
        v55 = v99;
        v56 = __p;
        if (v99 != __p)
        {
          do
            v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
          while (v55 != v54);
          v56 = __p;
        }
        v99 = v54;
        operator delete(v56);
      }
      v57 = v96;
      if (v96)
      {
        v58 = v97;
        v59 = v96;
        if (v97 != v96)
        {
          do
          {
            v61 = *--v58;
            v60 = v61;
            *v58 = 0;
            if (v61)
              MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
          }
          while (v58 != v57);
          v59 = v96;
        }
        v97 = v57;
        operator delete(v59);
      }
      if (v94 != &v95)
        free(v94);
    }
    return 0;
  }
  if (v89 != 2)
  {
    if (v89 == 9)
    {
      if (*(_QWORD *)v88 != 0x6974616D6F747561 || *(_BYTE *)(v88 + 8) != 99)
        goto LABEL_20;
      v4 = 2;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
    else
    {
      if (v89 != 3)
        goto LABEL_20;
      if (*(_WORD *)v88 != 26223 || *(_BYTE *)(v88 + 2) != 102)
        goto LABEL_20;
      v4 = 0;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
LABEL_76:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v86[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v101[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
    v101[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v101, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, v86);
  }
  if (*(_WORD *)v88 != 28271)
  {
LABEL_20:
    v87 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v101, a1, v2, v86);
    if (v101[0])
    {
      v90 = 3;
      v91 = "expected ";
      v92 = 9;
      v6 = &v90;
      v7 = v102;
      if (v103 >= v104)
      {
        v65 = v103 + 1;
        if (v102 <= &v90 && &v102[6 * v103] > &v90)
        {
          v78 = (char *)&v90 - (char *)v102;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
          v7 = v102;
          v6 = (int *)((char *)v102 + v78);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
          v6 = &v90;
          v7 = v102;
        }
      }
      v8 = &v7[6 * v103];
      v9 = *(_OWORD *)v6;
      *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
      *(_OWORD *)v8 = v9;
      v10 = ++v103;
      if (v101[0])
      {
        v90 = 3;
        v91 = "::mlir::mps::CallInlineMode";
        v92 = 27;
        v11 = &v90;
        v12 = v102;
        if (v10 >= v104)
        {
          v66 = v10 + 1;
          v67 = &v102[6 * v10] > &v90;
          if (v102 <= &v90 && v67)
          {
            v79 = (char *)&v90 - (char *)v102;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
            v12 = v102;
            v11 = (int *)((char *)v102 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
            v11 = &v90;
            v12 = v102;
          }
        }
        v13 = &v12[6 * v103];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
        *(_OWORD *)v13 = v14;
        v15 = ++v103;
        if (v101[0])
        {
          v90 = 3;
          v91 = " to be one of: ";
          v92 = 15;
          v16 = &v90;
          v17 = v102;
          if (v15 >= v104)
          {
            v68 = v15 + 1;
            v69 = &v102[6 * v15] > &v90;
            if (v102 <= &v90 && v69)
            {
              v80 = (char *)&v90 - (char *)v102;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
              v17 = v102;
              v16 = (int *)((char *)v102 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
              v16 = &v90;
              v17 = v102;
            }
          }
          v18 = &v17[6 * v103];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
          *(_OWORD *)v18 = v19;
          v20 = ++v103;
          if (v101[0])
          {
            v90 = 3;
            v91 = "off";
            v92 = 3;
            v21 = &v90;
            v22 = v102;
            if (v20 >= v104)
            {
              v70 = v20 + 1;
              v71 = &v102[6 * v20] > &v90;
              if (v102 <= &v90 && v71)
              {
                v81 = (char *)&v90 - (char *)v102;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                v22 = v102;
                v21 = (int *)((char *)v102 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                v21 = &v90;
                v22 = v102;
              }
            }
            v23 = &v22[6 * v103];
            v24 = *(_OWORD *)v21;
            *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
            *(_OWORD *)v23 = v24;
            v25 = ++v103;
            if (v101[0])
            {
              v90 = 3;
              v91 = ", ";
              v92 = 2;
              v26 = &v90;
              v27 = v102;
              if (v25 >= v104)
              {
                v72 = v25 + 1;
                if (v102 <= &v90 && &v102[6 * v25] > &v90)
                {
                  v82 = (char *)&v90 - (char *)v102;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                  v27 = v102;
                  v26 = (int *)((char *)v102 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                  v26 = &v90;
                  v27 = v102;
                }
              }
              v28 = &v27[6 * v103];
              v29 = *(_OWORD *)v26;
              *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
              *(_OWORD *)v28 = v29;
              v30 = ++v103;
              if (v101[0])
              {
                v90 = 3;
                v91 = "on";
                v92 = 2;
                v31 = &v90;
                v32 = v102;
                if (v30 >= v104)
                {
                  v73 = v30 + 1;
                  if (v102 <= &v90 && &v102[6 * v30] > &v90)
                  {
                    v83 = (char *)&v90 - (char *)v102;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                    v32 = v102;
                    v31 = (int *)((char *)v102 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                    v31 = &v90;
                    v32 = v102;
                  }
                }
                v33 = &v32[6 * v103];
                v34 = *(_OWORD *)v31;
                *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                *(_OWORD *)v33 = v34;
                v35 = ++v103;
                if (v101[0])
                {
                  v90 = 3;
                  v91 = ", ";
                  v92 = 2;
                  v36 = &v90;
                  v37 = v102;
                  if (v35 >= v104)
                  {
                    v74 = v35 + 1;
                    v75 = &v102[6 * v35] > &v90;
                    if (v102 <= &v90 && v75)
                    {
                      v84 = (char *)&v90 - (char *)v102;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                      v37 = v102;
                      v36 = (int *)((char *)v102 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                      v36 = &v90;
                      v37 = v102;
                    }
                  }
                  v38 = &v37[6 * v103];
                  v39 = *(_OWORD *)v36;
                  *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                  *(_OWORD *)v38 = v39;
                  v40 = ++v103;
                  if (v101[0])
                  {
                    v90 = 3;
                    v91 = "automatic";
                    v92 = 9;
                    v41 = &v90;
                    v42 = v102;
                    if (v40 >= v104)
                    {
                      v76 = v40 + 1;
                      v77 = &v102[6 * v40] > &v90;
                      if (v102 <= &v90 && v77)
                      {
                        v85 = (char *)&v90 - (char *)v102;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                        v42 = v102;
                        v41 = (int *)((char *)v102 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                        v41 = &v90;
                        v42 = v102;
                      }
                    }
                    v43 = &v42[6 * v103];
                    v44 = *(_OWORD *)v41;
                    *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                    *(_OWORD *)v43 = v44;
                    ++v103;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v101);
    if (v101[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v101);
    if (v110)
    {
      v45 = v108;
      if (v108)
      {
        v46 = v109;
        v47 = v108;
        if (v109 != v108)
        {
          do
            v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
          while (v46 != v45);
          v47 = v108;
        }
        v109 = v45;
        operator delete(v47);
      }
      v48 = v106;
      if (v106)
      {
        v49 = v107;
        v50 = v106;
        if (v107 != v106)
        {
          do
          {
            v52 = *--v49;
            v51 = v52;
            *v49 = 0;
            if (v52)
              MEMORY[0x20BD002D4](v51, 0x1000C8077774924);
          }
          while (v49 != v48);
          v50 = v106;
        }
        v107 = v48;
        operator delete(v50);
      }
      if (v102 != (int *)v105)
        free(v102);
    }
    goto LABEL_55;
  }
  v4 = 1;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_76;
  return 0;
}

llvm::raw_ostream *mlir::mps::CallInlineModeAttr::print(mlir::mps::CallInlineModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "off";
    v8 = 3;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "automatic";
    v8 = 9;
  }
  else
  {
    v7 = v6 != 1;
    if (v6 == 1)
      v8 = 2;
    else
      v8 = 0;
    if (v6 == 1)
      v9 = "on";
    else
      v9 = &byte_207AF6795;
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::MPSDialect::parseAttribute(uint64_t a1, mlir::AsmParser *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  BOOL v9;
  BOOL v16;
  BOOL v18;
  BOOL v20;
  BOOL v21;
  BOOL v23;
  BOOL v24;
  BOOL v27;
  BOOL v32;
  BOOL v34;
  BOOL v35;
  BOOL v37;
  BOOL v38;
  BOOL v41;
  BOOL v42;
  uint64_t v47;
  const void **v48;
  const void ***v49;
  char *v50;
  char *v51;
  __int128 v52;
  const void ***v53;
  char *v54;
  char *v55;
  __int128 v56;
  const void **v57;
  uint64_t v58;
  const void ***v59;
  char *v60;
  char *v61;
  __int128 v62;
  _QWORD *v63;
  _QWORD *v64;
  void *v65;
  _QWORD *v66;
  _QWORD *v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  int64_t v76;
  int64_t v77;
  int64_t v78;
  char v79[32];
  __int16 v80;
  const void **v81;
  uint64_t v82;
  uint64_t v83;
  __int16 v84;
  mlir::AsmParser *v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  unsigned int v89;
  unsigned int v90;
  _BYTE v91[96];
  void *v92;
  _QWORD *v93;
  void *__p;
  _QWORD *v95;
  char v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a2 + 40))(a2);
  v85 = a2;
  v7 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a2 + 40))(a2);
  BYTE2(v89) = 0;
  v87 = 0;
  v88 = 0;
  v86 = v7;
  LOBYTE(v89) = 0;
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, uint64_t *))(*(_QWORD *)a2 + 608))(a2, &v87))
  {
    LOWORD(v89) = 256;
    if (!BYTE2(v89))
      BYTE2(v89) = 1;
    goto LABEL_238;
  }
  v81 = (const void **)"tensor_data_layout";
  v82 = 18;
  if (BYTE2(v89))
  {
LABEL_238:
    v47 = 0;
LABEL_239:
    v8 = 0;
    v48 = 0;
    goto LABEL_240;
  }
  v8 = v88;
  if (v88)
  {
    if (v88 == (void *)18)
    {
      v9 = *(_QWORD *)v87 == 0x645F726F736E6574 && *(_QWORD *)(v87 + 8) == 0x6F79616C5F617461;
      if (v9 && *(_WORD *)(v87 + 16) == 29813)
      {
        v72 = mlir::mps::TensorDataLayoutAttr::parse(a2);
        goto LABEL_301;
      }
    }
    v81 = (const void **)"reduction_mode";
    v82 = 14;
  }
  else
  {
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
    v81 = (const void **)"reduction_mode";
    v82 = 14;
    if (BYTE2(v89))
      goto LABEL_238;
    v8 = v88;
    if (!v88)
    {
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"device_hint";
      v82 = 11;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_19;
LABEL_197:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"scatter_mode";
      v82 = 12;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_25;
LABEL_199:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"padding_mode";
      v82 = 12;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_31;
LABEL_201:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"sampling_mode";
      v82 = 13;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_37;
LABEL_203:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"nearest_rounding_mode";
      v82 = 21;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_43;
LABEL_205:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"sparse_tensor_storage";
      v82 = 21;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_52;
LABEL_207:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"texture_tensor_pixel_format";
      v82 = 27;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_61;
LABEL_209:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"random_normal_sampling_method";
      v82 = 29;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_73;
LABEL_211:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"padding_style";
      v82 = 13;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_85;
LABEL_213:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"pooling_indices_mode";
      v82 = 20;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_91;
LABEL_215:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"rnn_activation";
      v82 = 14;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_100;
LABEL_217:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"lstm_gate_layout";
      v82 = 16;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_106;
LABEL_219:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"gru_gate_layout";
      v82 = 15;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_112;
LABEL_221:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"stencil_padding_mode";
      v82 = 20;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_118;
LABEL_223:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"crop_resize_alignment_mode";
      v82 = 26;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_127;
LABEL_225:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"crop_resize_coordinate_mode";
      v82 = 27;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_139;
LABEL_227:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"pruning_metric";
      v82 = 14;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_151;
      goto LABEL_229;
    }
  }
  if (v8 == (void *)14 && *(_QWORD *)v87 == 0x6F69746375646572 && *(_QWORD *)(v87 + 6) == 0x65646F6D5F6E6F69)
  {
    v72 = mlir::mps::ReductionModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"device_hint";
  v82 = 11;
  if (!v8)
    goto LABEL_197;
LABEL_19:
  if (v8 == (void *)11 && *(_QWORD *)v87 == 0x685F656369766564 && *(_QWORD *)(v87 + 3) == 0x746E69685F656369)
  {
    v72 = mlir::mps::DeviceHintAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"scatter_mode";
  v82 = 12;
  if (!v8)
    goto LABEL_199;
LABEL_25:
  if (v8 == (void *)12 && *(_QWORD *)v87 == 0x5F72657474616373 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    v72 = mlir::mps::ScatterModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"padding_mode";
  v82 = 12;
  if (!v8)
    goto LABEL_201;
LABEL_31:
  if (v8 == (void *)12 && *(_QWORD *)v87 == 0x5F676E6964646170 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    v72 = mlir::mps::PaddingModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"sampling_mode";
  v82 = 13;
  if (!v8)
    goto LABEL_203;
LABEL_37:
  if (v8 == (void *)13 && *(_QWORD *)v87 == 0x676E696C706D6173 && *(_QWORD *)(v87 + 5) == 0x65646F6D5F676E69)
  {
    v72 = mlir::mps::SamplingModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"nearest_rounding_mode";
  v82 = 21;
  if (!v8)
    goto LABEL_205;
LABEL_43:
  if (v8 == (void *)21)
  {
    v16 = *(_QWORD *)v87 == 0x5F7473657261656ELL && *(_QWORD *)(v87 + 8) == 0x676E69646E756F72;
    if (v16 && *(_QWORD *)(v87 + 13) == 0x65646F6D5F676E69)
    {
      v72 = mlir::mps::NearestRoundingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"sparse_tensor_storage";
  v82 = 21;
  if (!v8)
    goto LABEL_207;
LABEL_52:
  if (v8 == (void *)21)
  {
    v18 = *(_QWORD *)v87 == 0x745F657372617073 && *(_QWORD *)(v87 + 8) == 0x74735F726F736E65;
    if (v18 && *(_QWORD *)(v87 + 13) == 0x656761726F74735FLL)
    {
      v72 = mlir::mps::SparseTensorStorageAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"texture_tensor_pixel_format";
  v82 = 27;
  if (!v8)
    goto LABEL_209;
LABEL_61:
  if (v8 == (void *)27)
  {
    v20 = *(_QWORD *)v87 == 0x5F65727574786574 && *(_QWORD *)(v87 + 8) == 0x705F726F736E6574;
    v21 = v20 && *(_QWORD *)(v87 + 16) == 0x726F665F6C657869;
    if (v21 && *(_QWORD *)(v87 + 19) == 0x74616D726F665F6CLL)
    {
      v72 = mlir::mps::MetalPixelFormatAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"random_normal_sampling_method";
  v82 = 29;
  if (!v8)
    goto LABEL_211;
LABEL_73:
  if (v8 == (void *)29)
  {
    v23 = *(_QWORD *)v87 == 0x6E5F6D6F646E6172 && *(_QWORD *)(v87 + 8) == 0x61735F6C616D726FLL;
    v24 = v23 && *(_QWORD *)(v87 + 16) == 0x6D5F676E696C706DLL;
    if (v24 && *(_QWORD *)(v87 + 21) == 0x646F6874656D5F67)
    {
      v72 = mlir::mps::NormalSamplingMethodAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"padding_style";
  v82 = 13;
  if (!v8)
    goto LABEL_213;
LABEL_85:
  if (v8 == (void *)13 && *(_QWORD *)v87 == 0x5F676E6964646170 && *(_QWORD *)(v87 + 5) == 0x656C7974735F676ELL)
  {
    v72 = mlir::mps::PaddingStyleAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"pooling_indices_mode";
  v82 = 20;
  if (!v8)
    goto LABEL_215;
LABEL_91:
  if (v8 == (void *)20)
  {
    v27 = *(_QWORD *)v87 == 0x5F676E696C6F6F70 && *(_QWORD *)(v87 + 8) == 0x5F73656369646E69;
    if (v27 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      v72 = mlir::mps::PoolIndicesModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"rnn_activation";
  v82 = 14;
  if (!v8)
    goto LABEL_217;
LABEL_100:
  if (v8 == (void *)14 && *(_QWORD *)v87 == 0x697463615F6E6E72 && *(_QWORD *)(v87 + 6) == 0x6E6F697461766974)
  {
    v72 = mlir::mps::RNNActivationAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"lstm_gate_layout";
  v82 = 16;
  if (!v8)
    goto LABEL_219;
LABEL_106:
  if (v8 == (void *)16 && *(_QWORD *)v87 == 0x7461675F6D74736CLL && *(_QWORD *)(v87 + 8) == 0x74756F79616C5F65)
  {
    v72 = mlir::mps::LSTMGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"gru_gate_layout";
  v82 = 15;
  if (!v8)
    goto LABEL_221;
LABEL_112:
  if (v8 == (void *)15 && *(_QWORD *)v87 == 0x657461675F757267 && *(_QWORD *)(v87 + 7) == 0x74756F79616C5F65)
  {
    v72 = mlir::mps::GRUGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"stencil_padding_mode";
  v82 = 20;
  if (!v8)
    goto LABEL_223;
LABEL_118:
  if (v8 == (void *)20)
  {
    v32 = *(_QWORD *)v87 == 0x5F6C69636E657473 && *(_QWORD *)(v87 + 8) == 0x5F676E6964646170;
    if (v32 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      v72 = mlir::mps::StencilPaddingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"crop_resize_alignment_mode";
  v82 = 26;
  if (!v8)
    goto LABEL_225;
LABEL_127:
  if (v8 == (void *)26)
  {
    v34 = *(_QWORD *)v87 == 0x7365725F706F7263 && *(_QWORD *)(v87 + 8) == 0x67696C615F657A69;
    v35 = v34 && *(_QWORD *)(v87 + 16) == 0x6F6D5F746E656D6ELL;
    if (v35 && *(_WORD *)(v87 + 24) == 25956)
    {
      v72 = mlir::mps::CropResizeAlignmentModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"crop_resize_coordinate_mode";
  v82 = 27;
  if (!v8)
    goto LABEL_227;
LABEL_139:
  if (v8 == (void *)27)
  {
    v37 = *(_QWORD *)v87 == 0x7365725F706F7263 && *(_QWORD *)(v87 + 8) == 0x726F6F635F657A69;
    v38 = v37 && *(_QWORD *)(v87 + 16) == 0x6D5F6574616E6964;
    if (v38 && *(_QWORD *)(v87 + 19) == 0x65646F6D5F657461)
    {
      v72 = mlir::mps::CropResizeCoordinateModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"pruning_metric";
  v82 = 14;
  if (v8)
  {
LABEL_151:
    if (v8 == (void *)14 && *(_QWORD *)v87 == 0x5F676E696E757270 && *(_QWORD *)(v87 + 6) == 0x63697274656D5F67)
    {
      v72 = mlir::mps::PruningMetricAttr::parse(a2);
      goto LABEL_301;
    }
    v81 = (const void **)"pruning_structure";
    v82 = 17;
    if (v8)
      goto LABEL_157;
    goto LABEL_231;
  }
LABEL_229:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
  v81 = (const void **)"pruning_structure";
  v82 = 17;
  if (BYTE2(v89))
    goto LABEL_238;
  v8 = v88;
  if (v88)
  {
LABEL_157:
    if (v8 != (void *)17
      || (*(_QWORD *)v87 == 0x5F676E696E757270 ? (v41 = *(_QWORD *)(v87 + 8) == 0x7275746375727473) : (v41 = 0),
          v41 ? (v42 = *(_BYTE *)(v87 + 16) == 101) : (v42 = 0),
          !v42))
    {
      v81 = (const void **)"similarity_type";
      v82 = 15;
      if (v8)
        goto LABEL_166;
LABEL_233:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"fft_scaling_mode";
      v82 = 16;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_172;
      goto LABEL_235;
    }
    v72 = mlir::mps::PruningStructureAttr::parse(a2);
LABEL_301:
    v47 = v72;
    LOBYTE(v89) = v72 != 0;
    *(_WORD *)((char *)&v89 + 1) = 257;
    goto LABEL_239;
  }
LABEL_231:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
  v81 = (const void **)"similarity_type";
  v82 = 15;
  if (BYTE2(v89))
    goto LABEL_238;
  v8 = v88;
  if (!v88)
    goto LABEL_233;
LABEL_166:
  if (v8 == (void *)15 && *(_QWORD *)v87 == 0x6972616C696D6973 && *(_QWORD *)(v87 + 7) == 0x657079745F797469)
  {
    v72 = mlir::mps::SimilarityTypeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"fft_scaling_mode";
  v82 = 16;
  if (!v8)
  {
LABEL_235:
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
    v81 = (const void **)"buffer_tensor";
    v82 = 13;
    if (!BYTE2(v89))
    {
      v8 = v88;
      if (v88)
        goto LABEL_178;
      goto LABEL_237;
    }
    goto LABEL_238;
  }
LABEL_172:
  if (v8 == (void *)16 && *(_QWORD *)v87 == 0x6C6163735F746666 && *(_QWORD *)(v87 + 8) == 0x65646F6D5F676E69)
  {
    v72 = mlir::mps::FFTScalingModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"buffer_tensor";
  v82 = 13;
  if (!v8)
  {
LABEL_237:
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
    v81 = (const void **)"call_inline_mode";
    v82 = 16;
    if (!BYTE2(v89))
    {
      v8 = v88;
      if (v88)
        goto LABEL_184;
      goto LABEL_303;
    }
    goto LABEL_238;
  }
LABEL_178:
  if (v8 == (void *)13 && *(_QWORD *)v87 == 0x745F726566667562 && *(_QWORD *)(v87 + 5) == 0x726F736E65745F72)
  {
    v72 = mlir::mps::MPSBufferTensorAttr::parse(a2, a3);
    goto LABEL_301;
  }
  v81 = (const void **)"call_inline_mode";
  v82 = 16;
  if (v8)
  {
LABEL_184:
    if (v8 == (void *)16 && *(_QWORD *)v87 == 0x6C6E695F6C6C6163 && *(_QWORD *)(v87 + 8) == 0x65646F6D5F656E69)
    {
      v47 = mlir::mps::CallInlineModeAttr::parse(a2);
      v8 = 0;
      v48 = 0;
      LOBYTE(v89) = v47 != 0;
      *(_WORD *)((char *)&v89 + 1) = 257;
      goto LABEL_240;
    }
    goto LABEL_306;
  }
LABEL_303:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
  if (BYTE2(v89))
  {
    v8 = 0;
    v48 = 0;
    v47 = 0;
    goto LABEL_240;
  }
  v8 = v88;
LABEL_306:
  v47 = 0;
  v48 = (const void **)v87;
  LOWORD(v89) = 0;
  BYTE2(v89) = 1;
LABEL_240:
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t *)&v85) <= 0xFFu)
  {
    v80 = 257;
    (*(void (**)(mlir::AsmParser **__return_ptr, mlir::AsmParser *, uint64_t, char *))(*(_QWORD *)a2 + 24))(&v85, a2, v6, v79);
    if (v85)
    {
      LODWORD(v81) = 3;
      v83 = 19;
      v49 = &v81;
      v50 = (char *)v88;
      if (v89 >= v90)
      {
        v73 = v89 + 1;
        if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
        {
          v76 = (char *)&v81 - (_BYTE *)v88;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          v50 = (char *)v88;
          v49 = (const void ***)((char *)v88 + v76);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          v49 = &v81;
          v50 = (char *)v88;
        }
      }
      v51 = &v50[24 * v89];
      v52 = *(_OWORD *)v49;
      *((_QWORD *)v51 + 2) = v49[2];
      *(_OWORD *)v51 = v52;
      ++v89;
      if (v85)
      {
        v84 = 261;
        v81 = v48;
        v82 = (uint64_t)v8;
        mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
        if (v85)
        {
          LODWORD(v81) = 3;
          v83 = 14;
          v53 = &v81;
          v54 = (char *)v88;
          if (v89 >= v90)
          {
            v74 = v89 + 1;
            if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
            {
              v77 = (char *)&v81 - (_BYTE *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              v54 = (char *)v88;
              v53 = (const void ***)((char *)v88 + v77);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              v53 = &v81;
              v54 = (char *)v88;
            }
          }
          v55 = &v54[24 * v89];
          v56 = *(_OWORD *)v53;
          *((_QWORD *)v55 + 2) = v53[2];
          *(_OWORD *)v55 = v56;
          ++v89;
          if (v85)
          {
            v57 = *(const void ***)(a1 + 8);
            v58 = *(_QWORD *)(a1 + 16);
            v84 = 261;
            v81 = v57;
            v82 = v58;
            mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
            if (v85)
            {
              LODWORD(v81) = 3;
              v83 = 1;
              v59 = &v81;
              v60 = (char *)v88;
              if (v89 >= v90)
              {
                v75 = v89 + 1;
                if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
                {
                  v78 = (char *)&v81 - (_BYTE *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  v60 = (char *)v88;
                  v59 = (const void ***)((char *)v88 + v78);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  v59 = &v81;
                  v60 = (char *)v88;
                }
              }
              v61 = &v60[24 * v89];
              v62 = *(_OWORD *)v59;
              *((_QWORD *)v61 + 2) = v59[2];
              *(_OWORD *)v61 = v62;
              ++v89;
              if (v85)
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v85);
            }
          }
        }
      }
    }
    if (v96)
    {
      v63 = __p;
      if (__p)
      {
        v64 = v95;
        v65 = __p;
        if (v95 != __p)
        {
          do
            v64 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v64 - 1);
          while (v64 != v63);
          v65 = __p;
        }
        v95 = v63;
        operator delete(v65);
      }
      v66 = v92;
      if (v92)
      {
        v67 = v93;
        v68 = v92;
        if (v93 != v92)
        {
          do
          {
            v70 = *--v67;
            v69 = v70;
            *v67 = 0;
            if (v70)
              MEMORY[0x20BD002D4](v69, 0x1000C8077774924);
          }
          while (v67 != v66);
          v68 = v92;
        }
        v93 = v66;
        operator delete(v68);
      }
      if (v88 != v91)
        free(v88);
    }
    return 0;
  }
  return v47;
}

void mlir::mps::MPSDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  void *v4;
  llvm::raw_ostream *v5;
  _OWORD *v6;
  llvm::raw_ostream *v7;
  uint64_t v8;
  llvm::raw_ostream *v9;
  void *v10;
  llvm::raw_ostream *v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  uint64_t v14;
  llvm::raw_ostream *v15;
  uint64_t v16;
  llvm::raw_ostream *v17;
  void *v18;
  llvm::raw_ostream *v19;
  void *v20;
  llvm::raw_ostream *v21;
  void *v22;
  llvm::raw_ostream *v23;
  void *v24;
  llvm::raw_ostream *v25;
  void *v26;
  llvm::raw_ostream *v27;
  void *v28;
  llvm::raw_ostream *v29;
  uint64_t v30;
  llvm::raw_ostream *v31;
  void *v32;
  llvm::raw_ostream *v33;
  _OWORD *v34;
  llvm::raw_ostream *v35;
  void *v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  llvm::raw_ostream *v39;
  void *v40;
  llvm::raw_ostream *v41;
  void *v42;
  llvm::raw_ostream *v43;
  void *v44;
  llvm::raw_ostream *v45;
  uint64_t v46;
  llvm::raw_ostream *v47;
  void *v48;
  llvm::raw_ostream *v49;
  _OWORD *v50;
  llvm::raw_ostream *v51;
  void *v52;
  uint64_t v53;

  v4 = *(void **)(*(_QWORD *)a2 + 136);
  if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    v53 = a2;
    v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v8 = *((_QWORD *)v7 + 4);
    if ((unint64_t)(*((_QWORD *)v7 + 3) - v8) > 0x11)
    {
      *(_WORD *)(v8 + 16) = 29813;
      *(_OWORD *)v8 = *(_OWORD *)"tensor_data_layout";
      *((_QWORD *)v7 + 4) += 18;
    }
    else
    {
      llvm::raw_ostream::write(v7, "tensor_data_layout", 0x12uLL);
    }
    mlir::mps::TensorDataLayoutAttr::print((mlir::mps::TensorDataLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id)
  {
    v53 = a2;
    v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v10 = (void *)*((_QWORD *)v9 + 4);
    if (*((_QWORD *)v9 + 3) - (_QWORD)v10 > 0xDuLL)
    {
      qmemcpy(v10, "reduction_mode", 14);
      *((_QWORD *)v9 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v9, "reduction_mode", 0xEuLL);
    }
    mlir::mps::ReductionModeAttr::print((mlir::mps::ReductionModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id)
  {
    v53 = a2;
    v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v12 = *((_QWORD *)v11 + 4);
    if ((unint64_t)(*((_QWORD *)v11 + 3) - v12) > 0xA)
    {
      *(_DWORD *)(v12 + 7) = 1953393000;
      *(_QWORD *)v12 = *(_QWORD *)"device_hint";
      *((_QWORD *)v11 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(v11, "device_hint", 0xBuLL);
    }
    mlir::mps::DeviceHintAttr::print((mlir::mps::DeviceHintAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id)
  {
    v53 = a2;
    v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v14 = *((_QWORD *)v13 + 4);
    if ((unint64_t)(*((_QWORD *)v13 + 3) - v14) > 0xB)
    {
      *(_DWORD *)(v14 + 8) = 1701080941;
      *(_QWORD *)v14 = *(_QWORD *)"scatter_mode";
      *((_QWORD *)v13 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v13, "scatter_mode", 0xCuLL);
    }
    mlir::mps::ScatterModeAttr::print((mlir::mps::ScatterModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
  {
    v53 = a2;
    v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v16 = *((_QWORD *)v15 + 4);
    if ((unint64_t)(*((_QWORD *)v15 + 3) - v16) > 0xB)
    {
      *(_DWORD *)(v16 + 8) = 1701080941;
      *(_QWORD *)v16 = *(_QWORD *)"padding_mode";
      *((_QWORD *)v15 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v15, "padding_mode", 0xCuLL);
    }
    mlir::mps::PaddingModeAttr::print((mlir::mps::PaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    v53 = a2;
    v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v18 = (void *)*((_QWORD *)v17 + 4);
    if (*((_QWORD *)v17 + 3) - (_QWORD)v18 > 0xCuLL)
    {
      qmemcpy(v18, "sampling_mode", 13);
      *((_QWORD *)v17 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v17, "sampling_mode", 0xDuLL);
    }
    mlir::mps::SamplingModeAttr::print((mlir::mps::SamplingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id)
  {
    v53 = a2;
    v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v20 = (void *)*((_QWORD *)v19 + 4);
    if (*((_QWORD *)v19 + 3) - (_QWORD)v20 > 0x14uLL)
    {
      qmemcpy(v20, "nearest_rounding_mode", 21);
      *((_QWORD *)v19 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v19, "nearest_rounding_mode", 0x15uLL);
    }
    mlir::mps::NearestRoundingModeAttr::print((mlir::mps::NearestRoundingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    v53 = a2;
    v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v22 = (void *)*((_QWORD *)v21 + 4);
    if (*((_QWORD *)v21 + 3) - (_QWORD)v22 > 0x14uLL)
    {
      qmemcpy(v22, "sparse_tensor_storage", 21);
      *((_QWORD *)v21 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v21, "sparse_tensor_storage", 0x15uLL);
    }
    mlir::mps::SparseTensorStorageAttr::print((mlir::mps::SparseTensorStorageAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    v53 = a2;
    v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v24 = (void *)*((_QWORD *)v23 + 4);
    if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 0x1AuLL)
    {
      qmemcpy(v24, "texture_tensor_pixel_format", 27);
      *((_QWORD *)v23 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v23, "texture_tensor_pixel_format", 0x1BuLL);
    }
    mlir::mps::MetalPixelFormatAttr::print((mlir::mps::MetalPixelFormatAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id)
  {
    v53 = a2;
    v25 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v26 = (void *)*((_QWORD *)v25 + 4);
    if (*((_QWORD *)v25 + 3) - (_QWORD)v26 > 0x1CuLL)
    {
      qmemcpy(v26, "random_normal_sampling_method", 29);
      *((_QWORD *)v25 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v25, "random_normal_sampling_method", 0x1DuLL);
    }
    mlir::mps::NormalSamplingMethodAttr::print((mlir::mps::NormalSamplingMethodAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    v53 = a2;
    v27 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v28 = (void *)*((_QWORD *)v27 + 4);
    if (*((_QWORD *)v27 + 3) - (_QWORD)v28 > 0xCuLL)
    {
      qmemcpy(v28, "padding_style", 13);
      *((_QWORD *)v27 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v27, "padding_style", 0xDuLL);
    }
    mlir::mps::PaddingStyleAttr::print((mlir::mps::PaddingStyleAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
  {
    v53 = a2;
    v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v30 = *((_QWORD *)v29 + 4);
    if ((unint64_t)(*((_QWORD *)v29 + 3) - v30) > 0x13)
    {
      *(_DWORD *)(v30 + 16) = 1701080941;
      *(_OWORD *)v30 = *(_OWORD *)"pooling_indices_mode";
      *((_QWORD *)v29 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v29, "pooling_indices_mode", 0x14uLL);
    }
    mlir::mps::PoolIndicesModeAttr::print((mlir::mps::PoolIndicesModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    v53 = a2;
    v31 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v32 = (void *)*((_QWORD *)v31 + 4);
    if (*((_QWORD *)v31 + 3) - (_QWORD)v32 > 0xDuLL)
    {
      qmemcpy(v32, "rnn_activation", 14);
      *((_QWORD *)v31 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v31, "rnn_activation", 0xEuLL);
    }
    mlir::mps::RNNActivationAttr::print((mlir::mps::RNNActivationAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    v53 = a2;
    v33 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v34 = (_OWORD *)*((_QWORD *)v33 + 4);
    if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0xFuLL)
    {
      *v34 = *(_OWORD *)"lstm_gate_layout";
      *((_QWORD *)v33 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v33, "lstm_gate_layout", 0x10uLL);
    }
    mlir::mps::LSTMGateLayoutAttr::print((mlir::mps::LSTMGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    v53 = a2;
    v35 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v36 = (void *)*((_QWORD *)v35 + 4);
    if (*((_QWORD *)v35 + 3) - (_QWORD)v36 > 0xEuLL)
    {
      qmemcpy(v36, "gru_gate_layout", 15);
      *((_QWORD *)v35 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v35, "gru_gate_layout", 0xFuLL);
    }
    mlir::mps::GRUGateLayoutAttr::print((mlir::mps::GRUGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id)
  {
    v53 = a2;
    v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v38 = *((_QWORD *)v37 + 4);
    if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 0x13)
    {
      *(_DWORD *)(v38 + 16) = 1701080941;
      *(_OWORD *)v38 = *(_OWORD *)"stencil_padding_mode";
      *((_QWORD *)v37 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v37, "stencil_padding_mode", 0x14uLL);
    }
    mlir::mps::StencilPaddingModeAttr::print((mlir::mps::StencilPaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    v53 = a2;
    v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v40 = (void *)*((_QWORD *)v39 + 4);
    if (*((_QWORD *)v39 + 3) - (_QWORD)v40 > 0x19uLL)
    {
      qmemcpy(v40, "crop_resize_alignment_mode", 26);
      *((_QWORD *)v39 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v39, "crop_resize_alignment_mode", 0x1AuLL);
    }
    mlir::mps::CropResizeAlignmentModeAttr::print((mlir::mps::CropResizeAlignmentModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    v53 = a2;
    v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v42 = (void *)*((_QWORD *)v41 + 4);
    if (*((_QWORD *)v41 + 3) - (_QWORD)v42 > 0x1AuLL)
    {
      qmemcpy(v42, "crop_resize_coordinate_mode", 27);
      *((_QWORD *)v41 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v41, "crop_resize_coordinate_mode", 0x1BuLL);
    }
    mlir::mps::CropResizeCoordinateModeAttr::print((mlir::mps::CropResizeCoordinateModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id)
  {
    v53 = a2;
    v43 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v44 = (void *)*((_QWORD *)v43 + 4);
    if (*((_QWORD *)v43 + 3) - (_QWORD)v44 > 0xDuLL)
    {
      qmemcpy(v44, "pruning_metric", 14);
      *((_QWORD *)v43 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v43, "pruning_metric", 0xEuLL);
    }
    mlir::mps::PruningMetricAttr::print((mlir::mps::PruningMetricAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id)
  {
    v53 = a2;
    v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v46 = *((_QWORD *)v45 + 4);
    if ((unint64_t)(*((_QWORD *)v45 + 3) - v46) > 0x10)
    {
      *(_BYTE *)(v46 + 16) = 101;
      *(_OWORD *)v46 = *(_OWORD *)"pruning_structure";
      *((_QWORD *)v45 + 4) += 17;
    }
    else
    {
      llvm::raw_ostream::write(v45, "pruning_structure", 0x11uLL);
    }
    mlir::mps::PruningStructureAttr::print((mlir::mps::PruningStructureAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    v53 = a2;
    v47 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v48 = (void *)*((_QWORD *)v47 + 4);
    if (*((_QWORD *)v47 + 3) - (_QWORD)v48 > 0xEuLL)
    {
      qmemcpy(v48, "similarity_type", 15);
      *((_QWORD *)v47 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v47, "similarity_type", 0xFuLL);
    }
    mlir::mps::SimilarityTypeAttr::print((mlir::mps::SimilarityTypeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    v53 = a2;
    v49 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v50 = (_OWORD *)*((_QWORD *)v49 + 4);
    if (*((_QWORD *)v49 + 3) - (_QWORD)v50 > 0xFuLL)
    {
      *v50 = *(_OWORD *)"fft_scaling_mode";
      *((_QWORD *)v49 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v49, "fft_scaling_mode", 0x10uLL);
    }
    mlir::mps::FFTScalingModeAttr::print((mlir::mps::FFTScalingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    v53 = a2;
    v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v52 = (void *)*((_QWORD *)v51 + 4);
    if (*((_QWORD *)v51 + 3) - (_QWORD)v52 > 0xCuLL)
    {
      qmemcpy(v52, "buffer_tensor", 13);
      *((_QWORD *)v51 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v51, "buffer_tensor", 0xDuLL);
    }
    mlir::mps::MPSBufferTensorAttr::print((mlir::mps::MPSBufferTensorAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    v53 = a2;
    v5 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v6 = (_OWORD *)*((_QWORD *)v5 + 4);
    if (*((_QWORD *)v5 + 3) - (_QWORD)v6 > 0xFuLL)
    {
      *v6 = *(_OWORD *)"call_inline_mode";
      *((_QWORD *)v5 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v5, "call_inline_mode", 0x10uLL);
    }
    mlir::mps::CallInlineModeAttr::print((mlir::mps::CallInlineModeAttr *)&v53, a3);
  }
}

uint64_t mlir::mps::detail::ACosOpGenericAdaptorBase::ACosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.acos", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v14;
  uint64_t *p_OperandRange;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  __int128 v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  const void **v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t Value;
  uint64_t v59;
  uint64_t OperandRange;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD *v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    v10 = *a2;
    v11 = (void *)*((_QWORD *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v54 = a2;
    v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v42 = v14;
      v59 = v14;
      OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange))
        return 1;
      v57 = v42;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v56 = 261;
  v54 = a3;
  v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    v61 = " #";
    v62 = 2;
    p_OperandRange = &OperandRange;
    v16 = (char *)v64;
    if (v65 >= v66)
    {
      v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        v50 = (char *)&OperandRange - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        v16 = (char *)v64;
        p_OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_OperandRange = &OperandRange;
        v16 = (char *)v64;
      }
    }
    v17 = &v16[24 * v65];
    v18 = *(_OWORD *)p_OperandRange;
    *((_QWORD *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      v61 = (const char *)a5;
      v20 = &OperandRange;
      v21 = (char *)v64;
      if (v19 >= v66)
      {
        v45 = v19 + 1;
        v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          v51 = (char *)&OperandRange - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v21 = (char *)v64;
          v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v20 = &OperandRange;
          v21 = (char *)v64;
        }
      }
      v22 = &v21[24 * v65];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        v61 = " must be tensor of mps native type values or tensor of complex values, but got ";
        v62 = 79;
        v25 = &OperandRange;
        v26 = (char *)v64;
        if (v24 >= v66)
        {
          v47 = v24 + 1;
          v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            v52 = (char *)&OperandRange - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v26 = (char *)v64;
            v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v25 = &OperandRange;
            v26 = (char *)v64;
          }
        }
        v27 = &v26[24 * v65];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v65;
        if (v63[0])
        {
          v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          v30 = (char *)v64;
          if (v65 >= v66)
          {
            v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              v53 = (char *)&OperandRange - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v30 = (char *)v64;
              v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v29 = &OperandRange;
              v30 = (char *)v64;
            }
          }
          v31 = &v30[24 * v65];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v65;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v37 = v68;
    if (v68)
    {
      v38 = v69;
      v39 = v68;
      if (v69 != v68)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v68;
      }
      v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67)
      free(v64);
  }
  return v33;
}

uint64_t mlir::mps::detail::ACoshOpGenericAdaptorBase::ACoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.acosh", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ASinOpGenericAdaptorBase::ASinOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.asin", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ASinhOpGenericAdaptorBase::ASinhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.asinh", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ATan2OpGenericAdaptorBase::ATan2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.atan2", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::ATan2Op::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::detail::ATanOpGenericAdaptorBase::ATanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.atan", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ATanhOpGenericAdaptorBase::ATanhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.atanh", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AbsoluteSquareOpGenericAdaptorBase::AbsoluteSquareOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute_square", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.add", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AndOpGenericAdaptorBase::AndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.and", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AssignVariableOpGenericAdaptorBase::AssignVariableOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.assign_variable", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AssignVariableOp::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t **v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;
  const char **v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  int v14;
  unsigned __int8 v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  const char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  const char *v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x24BDAC8D0];
  v3 = mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Write,mlir::MemoryEffects::Effect>::get();
  if ((v4 & 1) == 0)
  {
    v24 = v3;
    v3 = v24;
    if (v14)
    {
      if ((v15 & 1) == 0
      {
        v25 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SideEffects::DefaultResource]";
        v26 = 84;
        v17 = llvm::StringRef::find((uint64_t *)&v25, "DesiredTypeName = ", 0x12uLL, 0);
        if (v26 >= v17)
          v18 = v17;
        else
          v18 = v26;
        v19 = &v25[v18];
        v20 = v26 - v18;
        if (v26 - v18 >= 0x12)
          v21 = 18;
        else
          v21 = v26 - v18;
        v22 = v20 - v21;
        if (v22 >= v22 - 1)
          v23 = v22 - 1;
        else
          v23 = v22;
        mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v19[v21], v23);
      }
      mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance = (uint64_t)&unk_24C02E828;
      *(_QWORD *)algn_25451AC88 = mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id;
      v3 = v24;
    }
  }
  v5 = *(unsigned int *)(a2 + 8);
  if (v5 >= *(_DWORD *)(a2 + 12))
  {
    v25 = (const char *)v3;
    v26 = (unint64_t)&mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    v7 = v5 + 1;
    v27 = 0;
    v28[0] = 0;
    *(_QWORD *)((char *)v28 + 5) = 0;
    v8 = *(_QWORD *)a2 + 40 * (unint64_t)v5 > (unint64_t)&v25;
    if (*(_QWORD *)a2 <= (unint64_t)&v25 && v8)
    {
      v16 = (char *)&v25 - *(_QWORD *)a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v7, 40);
      v9 = *(_QWORD *)a2;
      v10 = (const char **)&v16[*(_QWORD *)a2];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v7, 40);
      v9 = *(_QWORD *)a2;
      v10 = &v25;
    }
    v11 = v9 + 40 * *(unsigned int *)(a2 + 8);
    v12 = *(_OWORD *)v10;
    v13 = *((_OWORD *)v10 + 1);
    *(_QWORD *)(v11 + 32) = v10[4];
    *(_OWORD *)v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
  }
  else
  {
    v6 = (uint64_t **)(*(_QWORD *)a2 + 40 * v5);
    *v6 = v3;
    v6[1] = &mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    v6[2] = 0;
    v6[3] = 0;
    *(uint64_t **)((char *)v6 + 29) = 0;
  }
  ++*(_DWORD *)(a2 + 8);
}

uint64_t mlir::mps::detail::BandPartOpGenericAdaptorBase::BandPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.band_part", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BandPartOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  _QWORD *v10;
  int ArgOperands;
  uint64_t v12;
  void *v13;
  uint64_t v15;
  uint64_t v16;
  _QWORD *Shape;
  uint64_t v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v49;
  unint64_t v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  int64_t v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  const void **v61;
  uint64_t v62;
  __int16 v63;
  _QWORD v64[2];
  _QWORD v65[2];
  _QWORD v66[2];
  uint64_t OperandRange;
  const void **v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[3];
  void *v72;
  unsigned int v73;
  unsigned int v74;
  _BYTE v75[96];
  void *v76;
  _QWORD *v77;
  void *__p;
  _QWORD *v79;
  char v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_4;
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  v10 = *a2;
  if (!ArgOperands)
    goto LABEL_4;
  v61 = a2;
  v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::ShapedType::getShape((mlir::ShapedType *)&v61);
  v10 = *a2;
  if (!v12)
  {
    v47 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v68 = a2;
    v69 = v47;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    v10 = *a2;
    v49 = (void *)*((_QWORD *)*a2 + 17);
    if (v49 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v49 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_4:
    v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v66[0] = a2;
  v66[1] = v15;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
  {
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v65[0] = a2;
    v65[1] = v16;
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)v65);
    v81 = 1;
    if (v18 == 1 && *Shape == v81)
      return 1;
  }
LABEL_13:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v46;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  v63 = 261;
  v61 = a3;
  v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    v69 = (uint64_t)" #";
    v70 = 2;
    v19 = &v68;
    v20 = (char *)v72;
    if (v73 >= v74)
    {
      v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        v57 = (char *)&v68 - (_BYTE *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        v20 = (char *)v72;
        v19 = (const void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        v19 = &v68;
        v20 = (char *)v72;
      }
    }
    v21 = &v20[24 * v73];
    v22 = *(_OWORD *)v19;
    *((_QWORD *)v21 + 2) = v19[2];
    *(_OWORD *)v21 = v22;
    v23 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      v69 = a5;
      v24 = &v68;
      v25 = (char *)v72;
      if (v23 >= v74)
      {
        v52 = v23 + 1;
        v53 = (char *)v72 + 24 * v23 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          v58 = (char *)&v68 - (_BYTE *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          v25 = (char *)v72;
          v24 = (const void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          v24 = &v68;
          v25 = (char *)v72;
        }
      }
      v26 = &v25[24 * v73];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      v28 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        v69 = (uint64_t)" must be 0D tensor of mps index type values or static-shape defined tensor with shape equal to [1"
                       "] or unranked tensor of mps index type values, but got ";
        v70 = 152;
        v29 = &v68;
        v30 = (char *)v72;
        if (v28 >= v74)
        {
          v54 = v28 + 1;
          v55 = (char *)v72 + 24 * v28 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            v59 = (char *)&v68 - (_BYTE *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            v30 = (char *)v72;
            v29 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            v29 = &v68;
            v30 = (char *)v72;
          }
        }
        v31 = &v30[24 * v73];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v73;
        if (v71[0])
        {
          v33 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          v34 = (char *)v72;
          if (v73 >= v74)
          {
            v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              v60 = (char *)&v68 - (_BYTE *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              v34 = (char *)v72;
              v33 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              v33 = &v68;
              v34 = (char *)v72;
            }
          }
          v35 = &v34[24 * v73];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v73;
        }
      }
    }
  }
  v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  if (v80)
  {
    v38 = __p;
    if (__p)
    {
      v39 = v79;
      v40 = __p;
      if (v79 != __p)
      {
        do
          v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        v40 = __p;
      }
      v79 = v38;
      operator delete(v40);
    }
    v41 = v76;
    if (v76)
    {
      v42 = v77;
      v43 = v76;
      if (v77 != v76)
      {
        do
        {
          v45 = *--v42;
          v44 = v45;
          *v42 = 0;
          if (v45)
            MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
        }
        while (v42 != v41);
        v43 = v76;
      }
      v77 = v41;
      operator delete(v43);
    }
    if (v72 != v75)
      free(v72);
  }
  return v37;
}

uint64_t mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.batch_to_space", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BatchToSpaceOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "pixel_shuffle", 0xDuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 58;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = __p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::BatchToSpaceOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"pixel_shuffle", 13, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties]";
        v15 = 113;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[92];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::BatchToSpaceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u)
    || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 3u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  _UNKNOWN **v10;
  int ArgOperands;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v48;
  unint64_t v49;
  BOOL v50;
  unint64_t v51;
  BOOL v52;
  unint64_t v53;
  int64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  const void **v58;
  uint64_t v59;
  __int16 v60;
  _QWORD v61[2];
  _QWORD v62[2];
  _QWORD v63[2];
  _QWORD v64[2];
  uint64_t OperandRange;
  const void **v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD v69[3];
  void *v70;
  unsigned int v71;
  unsigned int v72;
  _BYTE v73[96];
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD *v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v10 = (_UNKNOWN **)*a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_4;
  v69[0] = a2;
  v69[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v69);
  v10 = (_UNKNOWN **)*a2;
  if (!ArgOperands)
    goto LABEL_4;
  v58 = a2;
  v59 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
  v10 = (_UNKNOWN **)*a2;
  if (!v12)
  {
    v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v66 = a2;
    v67 = v18;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    v10 = (_UNKNOWN **)*a2;
    if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      goto LABEL_13;
  }
  else
  {
LABEL_4:
    if (v10[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      goto LABEL_13;
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v64[0] = a2;
  v64[1] = v13;
  v14 = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v64);
  v10 = (_UNKNOWN **)*a2;
  if (v14)
  {
    v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v63[0] = a2;
    v63[1] = v15;
    mlir::ShapedType::getShape((mlir::ShapedType *)v63);
    v10 = (_UNKNOWN **)*a2;
    if (v16 == 1)
    {
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
      v62[0] = a2;
      v62[1] = v17;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
      if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      {
        return 1;
      }
      v10 = (_UNKNOWN **)*a2;
    }
  }
LABEL_13:
  if (v10[17] == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v61[0] = a2;
    v61[1] = v46;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  v60 = 261;
  v58 = a3;
  v59 = a4;
  mlir::Operation::emitOpError(a1, &v58, (uint64_t)v69);
  if (v69[0])
  {
    LODWORD(v66) = 3;
    v67 = (uint64_t)" #";
    v68 = 2;
    v19 = &v66;
    v20 = (char *)v70;
    if (v71 >= v72)
    {
      v48 = v71 + 1;
      if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
      {
        v54 = (char *)&v66 - (_BYTE *)v70;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        v20 = (char *)v70;
        v19 = (const void ***)((char *)v70 + v54);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        v19 = &v66;
        v20 = (char *)v70;
      }
    }
    v21 = &v20[24 * v71];
    v22 = *(_OWORD *)v19;
    *((_QWORD *)v21 + 2) = v19[2];
    *(_OWORD *)v21 = v22;
    v23 = ++v71;
    if (v69[0])
    {
      LODWORD(v66) = 5;
      v67 = a5;
      v24 = &v66;
      v25 = (char *)v70;
      if (v23 >= v72)
      {
        v49 = v23 + 1;
        v50 = (char *)v70 + 24 * v23 > (char *)&v66;
        if (v70 <= &v66 && v50)
        {
          v55 = (char *)&v66 - (_BYTE *)v70;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          v25 = (char *)v70;
          v24 = (const void ***)((char *)v70 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          v24 = &v66;
          v25 = (char *)v70;
        }
      }
      v26 = &v25[24 * v71];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      v28 = ++v71;
      if (v69[0])
      {
        LODWORD(v66) = 3;
        v67 = (uint64_t)" must be 0D tensor of mps index type values or 1D tensor of mps index type values or unranked ten"
                       "sor of mps index type values, but got ";
        v68 = 135;
        v29 = &v66;
        v30 = (char *)v70;
        if (v28 >= v72)
        {
          v51 = v28 + 1;
          v52 = (char *)v70 + 24 * v28 > (char *)&v66;
          if (v70 <= &v66 && v52)
          {
            v56 = (char *)&v66 - (_BYTE *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            v30 = (char *)v70;
            v29 = (const void ***)((char *)v70 + v56);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            v29 = &v66;
            v30 = (char *)v70;
          }
        }
        v31 = &v30[24 * v71];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v71;
        if (v69[0])
        {
          v33 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, (uint64_t)a2);
          v34 = (char *)v70;
          if (v71 >= v72)
          {
            v53 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              v57 = (char *)&v66 - (_BYTE *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              v34 = (char *)v70;
              v33 = (const void ***)((char *)v70 + v57);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              v33 = &v66;
              v34 = (char *)v70;
            }
          }
          v35 = &v34[24 * v71];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v71;
        }
      }
    }
  }
  v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v69);
  if (v69[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
  if (v78)
  {
    v38 = __p;
    if (__p)
    {
      v39 = v77;
      v40 = __p;
      if (v77 != __p)
      {
        do
          v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        v40 = __p;
      }
      v77 = v38;
      operator delete(v40);
    }
    v41 = v74;
    if (v74)
    {
      v42 = v75;
      v43 = v74;
      if (v75 != v74)
      {
        do
        {
          v45 = *--v42;
          v44 = v45;
          *v42 = 0;
          if (v45)
            MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
        }
        while (v42 != v41);
        v43 = v74;
      }
      v75 = v41;
      operator delete(v43);
    }
    if (v70 != v73)
      free(v70);
  }
  return v37;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD *v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_24;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 1)
        goto LABEL_24;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      {
        goto LABEL_24;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_24:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of int values or 1D tensor of int values, but got ";
        v60 = 75;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::BiasAddGradOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "data_format", 0xBuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 56;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = __p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::BiasAddGradOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"data_format", 11, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is NHWC or NCHW";
        v31 = 70;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties]";
        v15 = 112;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[94];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  v41 = 81;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::mps::BiasAddGradOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (_DWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (const void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD *v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51))
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of floating point values, but got ";
        v55 = 50;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD *v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v13 = &v53;
    v14 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = (char *)v57;
        v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v13 = &v53;
        v14 = (char *)v57;
      }
    }
    v15 = &v14[24 * v58];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
    *(_OWORD *)v15 = v16;
    v17 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v18 = &v53;
      v19 = (char *)v57;
      if (v17 >= v59)
      {
        v42 = v17 + 1;
        v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = (char *)v57;
          v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v18 = &v53;
          v19 = (char *)v57;
        }
      }
      v20 = &v19[24 * v58];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      v22 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of mps native type values, but got ";
        v55 = 51;
        v23 = &v53;
        v24 = (char *)v57;
        if (v22 >= v59)
        {
          v44 = v22 + 1;
          v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = (char *)v57;
            v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v23 = &v53;
            v24 = (char *)v57;
          }
        }
        v25 = &v24[24 * v58];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v58;
        if (v56[0])
        {
          v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v28 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = (char *)v57;
              v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v27 = &v53;
              v28 = (char *)v57;
            }
          }
          v29 = &v28[24 * v58];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
          *(_OWORD *)v29 = v30;
          ++v58;
        }
      }
    }
  }
  v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v31;
}

uint64_t mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bias_add", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[96];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::BiasAddOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (_DWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (const void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::BitwiseAndOpGenericAdaptorBase::BitwiseAndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_and", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BitwiseAndOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD *v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64))
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of int values, but got ";
        v55 = 39;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::detail::BitwiseLeftShiftOpGenericAdaptorBase::BitwiseLeftShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_left_shift", 22, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseNotOpGenericAdaptorBase::BitwiseNotOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_not", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseOrOpGenericAdaptorBase::BitwiseOrOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_or", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwisePopcountOpGenericAdaptorBase::BitwisePopcountOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_popcount", 20, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseRightShiftOpGenericAdaptorBase::BitwiseRightShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_right_shift", 23, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseXorOpGenericAdaptorBase::BitwiseXorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_xor", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BroadcastGradientArgsOpGenericAdaptorBase::BroadcastGradientArgsOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_gradient_args", 27, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BroadcastGradientArgsOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_to", 16, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BroadcastToOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  char *v63;
  char *v64;
  __int128 v65;
  _QWORD *v66;
  _QWORD *v67;
  void *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  uint64_t v87;
  int v88;
  const char *v89;
  uint64_t v90;
  _QWORD v91[3];
  void *v92;
  unsigned int v93;
  unsigned int v94;
  _BYTE v95[96];
  void *v96;
  _QWORD *v97;
  void *__p;
  _QWORD *v99;
  char v100;
  uint64_t v101;

  v101 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v87 = v6;
  if (!v6)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v89 = "expected DictionaryAttr to set properties";
      v90 = 41;
      v26 = &v88;
      v27 = (char *)v92;
      if (v93 >= v94)
      {
        v73 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v80 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          v27 = (char *)v92;
          v26 = (int *)((char *)v92 + v80);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          v26 = &v88;
          v27 = (char *)v92;
        }
      }
      v28 = &v27[24 * v93];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
    if (!v100)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v99;
      v32 = __p;
      if (v99 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v99 = v30;
      operator delete(v32);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v33 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_93;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v87, "inlineMode", 0xAuLL);
  if (!v8)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v89 = "expected key entry for inlineMode in DictionaryAttr to set Properties.";
      v90 = 70;
      v36 = &v88;
      v37 = (char *)v92;
      if (v93 >= v94)
      {
        v75 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v82 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          v37 = (char *)v92;
          v36 = (int *)((char *)v92 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          v36 = &v88;
          v37 = (char *)v92;
        }
      }
      v38 = &v37[24 * v93];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
    if (!v100)
      return 0;
    v40 = __p;
    if (__p)
    {
      v41 = v99;
      v42 = __p;
      if (v99 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v99 = v40;
      operator delete(v42);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v43 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v45 = *--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
    }
    while (v43 != v21);
    goto LABEL_93;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v90 = 55;
      v10 = &v88;
      v11 = (char *)v92;
      if (v93 >= v94)
      {
        v74 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v81 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          v11 = (char *)v92;
          v10 = (int *)((char *)v92 + v81);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          v10 = &v88;
          v11 = (char *)v92;
        }
      }
      v12 = &v11[24 * v93];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v93;
      if (v91[0])
      {
        v14 = &v88;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v9);
        v15 = (char *)v92;
        if (v93 >= v94)
        {
          v76 = v93 + 1;
          if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
          {
            v83 = (char *)&v88 - (_BYTE *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            v15 = (char *)v92;
            v14 = (int *)((char *)v92 + v83);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            v14 = &v88;
            v15 = (char *)v92;
          }
        }
        v16 = &v15[24 * v93];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        ++v93;
        if (v91[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100)
      return 0;
    v18 = __p;
    if (__p)
    {
      v19 = v99;
      v20 = __p;
      if (v99 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v99 = v18;
      operator delete(v20);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v22 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
    goto LABEL_93;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v87, "symbolName", 0xAuLL);
  if (!v46)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v89 = "expected key entry for symbolName in DictionaryAttr to set Properties.";
      v90 = 70;
      v62 = &v88;
      v63 = (char *)v92;
      if (v93 >= v94)
      {
        v78 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v85 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          v63 = (char *)v92;
          v62 = (int *)((char *)v92 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          v62 = &v88;
          v63 = (char *)v92;
        }
      }
      v64 = &v63[24 * v93];
      v65 = *(_OWORD *)v62;
      *((_QWORD *)v64 + 2) = *((_QWORD *)v62 + 2);
      *(_OWORD *)v64 = v65;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
    if (!v100)
      return 0;
    v66 = __p;
    if (__p)
    {
      v67 = v99;
      v68 = __p;
      if (v99 != __p)
      {
        do
          v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        v68 = __p;
      }
      v99 = v66;
      operator delete(v68);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v69 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v71 = *--v69;
      v70 = v71;
      *v69 = 0;
      if (v71)
        MEMORY[0x20BD002D4](v70, 0x1000C8077774924);
    }
    while (v69 != v21);
    goto LABEL_93;
  }
  v47 = v46;
  if (*(_UNKNOWN **)(*(_QWORD *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v91, a4);
  if (v91[0])
  {
    v88 = 3;
    v90 = 55;
    v48 = &v88;
    v49 = (char *)v92;
    if (v93 >= v94)
    {
      v77 = v93 + 1;
      if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
      {
        v84 = (char *)&v88 - (_BYTE *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        v49 = (char *)v92;
        v48 = (int *)((char *)v92 + v84);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        v48 = &v88;
        v49 = (char *)v92;
      }
    }
    v50 = &v49[24 * v93];
    v51 = *(_OWORD *)v48;
    *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
    *(_OWORD *)v50 = v51;
    ++v93;
    if (v91[0])
    {
      v52 = &v88;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v47);
      v53 = (char *)v92;
      if (v93 >= v94)
      {
        v79 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v86 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          v53 = (char *)v92;
          v52 = (int *)((char *)v92 + v86);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          v52 = &v88;
          v53 = (char *)v92;
        }
      }
      v54 = &v53[24 * v93];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
  }
  if (v100)
  {
    v56 = __p;
    if (__p)
    {
      v57 = v99;
      v58 = __p;
      if (v99 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v99 = v56;
      operator delete(v58);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v59 = v97;
    v23 = v96;
    if (v97 == v96)
    {
LABEL_94:
      v97 = v21;
      operator delete(v23);
LABEL_95:
      if (v92 != v95)
        free(v92);
      return 0;
    }
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v21);
LABEL_93:
    v23 = v96;
    goto LABEL_94;
  }
  return 0;
}

uint64_t mlir::mps::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inlineMode", 10, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"symbolName", 10, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid CallInlineMode";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CallOpGenericAdaptorBase::Properties]";
        v15 = 105;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[98];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::CallInlineModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CallInlineModeAttr]";
  v41 = 79;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::mps::CallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t NextResultAtOffset;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  const void **v31[4];
  __int16 v32;
  _QWORD v33[3];
  void *v34;
  uint64_t v35;
  void *v36;
  _QWORD *v37;
  void *__p;
  _QWORD *v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (!*v3)
  {
    v31[0] = (const void **)"requires attribute 'inlineMode'";
    v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    if (!v40)
      return v15;
    v16 = __p;
    if (__p)
    {
      v17 = v39;
      v18 = __p;
      if (v39 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v39 = v16;
      operator delete(v18);
    }
    v19 = v36;
    if (v36)
    {
      v20 = v37;
      v21 = v36;
      if (v37 == v36)
        goto LABEL_52;
      do
      {
        v23 = *--v20;
        v22 = v23;
        *v20 = 0;
        if (v23)
          MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
      }
      while (v20 != v19);
LABEL_51:
      v21 = v36;
LABEL_52:
      v37 = v19;
      operator delete(v21);
    }
LABEL_53:
    if (v34 != &v35)
      free(v34);
    return v15;
  }
  v5 = v3[1];
  if (!v5)
  {
    v31[0] = (const void **)"requires attribute 'symbolName'";
    v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    if (!v40)
      return v15;
    v24 = __p;
    if (__p)
    {
      v25 = v39;
      v26 = __p;
      if (v39 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v39 = v24;
      operator delete(v26);
    }
    v19 = v36;
    if (v36)
    {
      v27 = v37;
      v21 = v36;
      if (v37 == v36)
        goto LABEL_52;
      do
      {
        v29 = *--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
      }
      while (v27 != v19);
      goto LABEL_51;
    }
    goto LABEL_53;
  }
  v33[0] = v2;
  if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(v5, (const void **)"symbolName", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0;
  v33[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(v4, (const void **)"inlineMode", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0;
  v6 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v7 = *((unsigned int *)v6 + 17);
    if ((_DWORD)v7)
    {
      v8 = 0;
      v9 = v6[9] + 24;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*this, *(_QWORD *)(*(_QWORD *)v9 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v8))
      {
        ++v8;
        v9 += 32;
        if (v7 == v8)
        {
          v6 = *this;
          goto LABEL_14;
        }
      }
      return 0;
    }
  }
LABEL_14:
  v10 = *((unsigned int *)v6 + 9);
  v11 = v6 - 2;
  if (v10)
    v12 = (uint64_t)v11;
  else
    v12 = 0;
  if ((_DWORD)v10)
  {
    v13 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, v13);
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v13))break;
      if (v10 == ++v13)
        return 1;
    }
    return 0;
  }
  return 1;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD *v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v13 = &v53;
    v14 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = (char *)v57;
        v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v13 = &v53;
        v14 = (char *)v57;
      }
    }
    v15 = &v14[24 * v58];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
    *(_OWORD *)v15 = v16;
    v17 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v18 = &v53;
      v19 = (char *)v57;
      if (v17 >= v59)
      {
        v42 = v17 + 1;
        v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = (char *)v57;
          v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v18 = &v53;
          v19 = (char *)v57;
        }
      }
      v20 = &v19[24 * v58];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      v22 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be variadic of tensor of mps native type values, but got ";
        v55 = 63;
        v23 = &v53;
        v24 = (char *)v57;
        if (v22 >= v59)
        {
          v44 = v22 + 1;
          v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = (char *)v57;
            v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v23 = &v53;
            v24 = (char *)v57;
          }
        }
        v25 = &v24[24 * v58];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v58;
        if (v56[0])
        {
          v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v28 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = (char *)v57;
              v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v27 = &v53;
              v28 = (char *)v57;
            }
          }
          v29 = &v28[24 * v58];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
          *(_OWORD *)v29 = v30;
          ++v58;
        }
      }
    }
  }
  v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v31;
}

uint64_t mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.cast", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(mlir::mps::detail::CastOpGenericAdaptorBase *this, unsigned int a2)
{
  return a2 | 0x100000000;
}

uint64_t mlir::mps::CastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD *v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected DictionaryAttr to set properties";
      v58 = 41;
      v26 = &v56;
      v27 = (char *)v60;
      if (v61 >= v62)
      {
        v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v51 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v27 = (char *)v60;
          v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v26 = &v56;
          v27 = (char *)v60;
        }
      }
      v28 = &v27[24 * v61];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v67;
      v32 = __p;
      if (v67 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v67 = v30;
      operator delete(v32);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v33 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "resultElementType", 0x11uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected key entry for resultElementType in DictionaryAttr to set Properties.";
      v58 = 77;
      v36 = &v56;
      v37 = (char *)v60;
      if (v61 >= v62)
      {
        v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v53 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v37 = (char *)v60;
          v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v36 = &v56;
          v37 = (char *)v60;
        }
      }
      v38 = &v37[24 * v61];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v40 = __p;
    if (__p)
    {
      v41 = v67;
      v42 = __p;
      if (v67 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v67 = v40;
      operator delete(v42);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v43 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v45 = *--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    v56 = 3;
    v58 = 62;
    v10 = &v56;
    v11 = (char *)v60;
    if (v61 >= v62)
    {
      v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v52 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v11 = (char *)v60;
        v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v10 = &v56;
        v11 = (char *)v60;
      }
    }
    v12 = &v11[24 * v61];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v61;
    if (v59[0])
    {
      v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      v15 = (char *)v60;
      if (v61 >= v62)
      {
        v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v54 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v15 = (char *)v60;
          v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v14 = &v56;
          v15 = (char *)v60;
        }
      }
      v16 = &v15[24 * v61];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
  }
  if (v68)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v67;
      v20 = __p;
      if (v67 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v67 = v18;
      operator delete(v20);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v22 = v65;
    v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63)
        free(v60);
      return 0;
    }
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
LABEL_57:
    v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::CastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"resultElementType", 17, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CastOpGenericAdaptorBase::Properties]";
        v15 = 105;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CastOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[100];
    return a1[32];
  }
  return result;
}

void mlir::mps::CastOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  mlir::UnknownLoc *v8;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v11;
  mlir::MLIRContext *v12;
  int v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20[2];
  unint64_t v21[2];
  void *__src;
  uint64_t v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x24BDAC8D0];
  v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  v7 = mlir::TypeAttr::get(a4);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v7;
  __src = v24;
  v23 = 0x200000000;
  v8 = *a1;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v11 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CastOp::inferReturnTypes(v8, v12, v13, v21[0], v21[1], Dictionary, v11, v14, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v15 = __src;
  v16 = v23;
  v17 = *(unsigned int *)(a2 + 72);
  v18 = v17 + v23;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v16)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v24)
    free(__src);
}

BOOL mlir::mps::CastOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v16 = (const void **)"requires attribute 'resultElementType'";
    v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    if (v25)
    {
      v7 = __p;
      if (__p)
      {
        v8 = v24;
        v9 = __p;
        if (v24 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v24 = v7;
        operator delete(v9);
      }
      v10 = v21;
      if (v21)
      {
        v11 = v22;
        v12 = v21;
        if (v22 != v21)
        {
          do
          {
            v14 = *--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              MEMORY[0x20BD002D4](v13, 0x1000C8077774924);
          }
          while (v11 != v10);
          v12 = v21;
        }
        v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20)
        free(v19);
    }
  }
  return v6;
}

uint64_t mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.ceil", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ClampOpGenericAdaptorBase::ClampOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.clamp", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::ClampOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::ColToImOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v55;
  char *v56;
  char *v57;
  __int128 v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  char *v66;
  char *v67;
  __int128 v68;
  uint64_t *v69;
  char *v70;
  char *v71;
  __int128 v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t *v79;
  char *v80;
  char *v81;
  __int128 v82;
  _QWORD *v83;
  _QWORD *v84;
  void *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  _QWORD v112[3];
  void *v113;
  unsigned int v114;
  unsigned int v115;
  _BYTE v116[96];
  void *v117;
  _QWORD *v118;
  void *__p;
  _QWORD *v120;
  char v121;
  uint64_t v122;

  v122 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected DictionaryAttr to set properties";
      v111 = 41;
      v26 = &v109;
      v27 = (char *)v113;
      if (v114 >= v115)
      {
        v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v99 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v27 = (char *)v113;
          v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v26 = &v109;
          v27 = (char *)v113;
        }
      }
      v28 = &v27[24 * v114];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v120;
      v32 = __p;
      if (v120 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v120 = v30;
      operator delete(v32);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v33 = v118;
    v23 = v117;
    if (v118 == v117)
    {
LABEL_117:
      v118 = v21;
      operator delete(v23);
LABEL_118:
      if (v113 != v116)
        free(v113);
      return 0;
    }
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
LABEL_116:
    v23 = v117;
    goto LABEL_117;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      v111 = 71;
      v36 = &v109;
      v37 = (char *)v113;
      if (v114 >= v115)
      {
        v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v101 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v37 = (char *)v113;
          v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v36 = &v109;
          v37 = (char *)v113;
        }
      }
      v38 = &v37[24 * v114];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = v36[2];
      *(_OWORD *)v38 = v39;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v40 = __p;
    if (__p)
    {
      v41 = v120;
      v42 = __p;
      if (v120 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v120 = v40;
      operator delete(v42);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v43 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v45 = *--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
    }
    while (v43 != v21);
    goto LABEL_116;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v111 = 56;
      v10 = &v109;
      v11 = (char *)v113;
      if (v114 >= v115)
      {
        v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v100 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v11 = (char *)v113;
          v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v10 = &v109;
          v11 = (char *)v113;
        }
      }
      v12 = &v11[24 * v114];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = v10[2];
      *(_OWORD *)v12 = v13;
      ++v114;
      if (v112[0])
      {
        v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        v15 = (char *)v113;
        if (v114 >= v115)
        {
          v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v102 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            v15 = (char *)v113;
            v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            v14 = &v109;
            v15 = (char *)v113;
          }
        }
        v16 = &v15[24 * v114];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v18 = __p;
    if (__p)
    {
      v19 = v120;
      v20 = __p;
      if (v120 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v120 = v18;
      operator delete(v20);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v22 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
    goto LABEL_116;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v111 = 74;
      v55 = &v109;
      v56 = (char *)v113;
      if (v114 >= v115)
      {
        v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v103 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v56 = (char *)v113;
          v55 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v55 = &v109;
          v56 = (char *)v113;
        }
      }
      v57 = &v56[24 * v114];
      v58 = *(_OWORD *)v55;
      *((_QWORD *)v57 + 2) = v55[2];
      *(_OWORD *)v57 = v58;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v59 = __p;
    if (__p)
    {
      v60 = v120;
      v61 = __p;
      if (v120 != __p)
      {
        do
          v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
        while (v60 != v59);
        v61 = __p;
      }
      v120 = v59;
      operator delete(v61);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v62 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v64 = *--v62;
      v63 = v64;
      *v62 = 0;
      if (v64)
        MEMORY[0x20BD002D4](v63, 0x1000C8077774924);
    }
    while (v62 != v21);
    goto LABEL_116;
  }
  v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v111 = 59;
      v65 = &v109;
      v66 = (char *)v113;
      if (v114 >= v115)
      {
        v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v104 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v66 = (char *)v113;
          v65 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v65 = &v109;
          v66 = (char *)v113;
        }
      }
      v67 = &v66[24 * v114];
      v68 = *(_OWORD *)v65;
      *((_QWORD *)v67 + 2) = v65[2];
      *(_OWORD *)v67 = v68;
      ++v114;
      if (v112[0])
      {
        v69 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        v70 = (char *)v113;
        if (v114 >= v115)
        {
          v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v105 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v70 = (char *)v113;
            v69 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v69 = &v109;
            v70 = (char *)v113;
          }
        }
        v71 = &v70[24 * v114];
        v72 = *(_OWORD *)v69;
        *((_QWORD *)v71 + 2) = v69[2];
        *(_OWORD *)v71 = v72;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v73 = __p;
    if (__p)
    {
      v74 = v120;
      v75 = __p;
      if (v120 != __p)
      {
        do
          v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
        while (v74 != v73);
        v75 = __p;
      }
      v120 = v73;
      operator delete(v75);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v76 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v78 = *--v76;
      v77 = v78;
      *v76 = 0;
      if (v78)
        MEMORY[0x20BD002D4](v77, 0x1000C8077774924);
    }
    while (v76 != v21);
    goto LABEL_116;
  }
  a1[1] = v47;
  v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      v111 = 76;
      v79 = &v109;
      v80 = (char *)v113;
      if (v114 >= v115)
      {
        v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v106 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          v80 = (char *)v113;
          v79 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          v79 = &v109;
          v80 = (char *)v113;
        }
      }
      v81 = &v80[24 * v114];
      v82 = *(_OWORD *)v79;
      *((_QWORD *)v81 + 2) = v79[2];
      *(_OWORD *)v81 = v82;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v83 = __p;
    if (__p)
    {
      v84 = v120;
      v85 = __p;
      if (v120 != __p)
      {
        do
          v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
        while (v84 != v83);
        v85 = __p;
      }
      v120 = v83;
      operator delete(v85);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v86 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v88 = *--v86;
      v87 = v88;
      *v86 = 0;
      if (v88)
        MEMORY[0x20BD002D4](v87, 0x1000C8077774924);
    }
    while (v86 != v21);
    goto LABEL_116;
  }
  v49 = v48;
  if ((mlir::DenseIntElementsAttr::classof(v48) & 1) != 0)
  {
    a1[2] = v49;
    v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "kernel_sizes", 0xCuLL);
    v109 = v50;
    if (v50)
    {
      v51 = v50;
      if ((mlir::DenseIntElementsAttr::classof(v50) & 1) == 0)
      {
        a3(v112, a4);
LABEL_127:
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v90, &v109);
        goto LABEL_128;
      }
      a1[3] = v51;
      v52 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
      v109 = v52;
      if (v52)
      {
        v53 = v52;
        if ((mlir::DenseIntElementsAttr::classof(v52) & 1) != 0)
        {
          a1[4] = v53;
          return 1;
        }
        a3(v112, a4);
        goto LABEL_127;
      }
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for kernel_sizes in DictionaryAttr to set Properties.");
    }
LABEL_128:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v89, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::ColToImOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  void *v33;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x24BDAC8D0];
  v36 = a1;
  v37 = v39;
  v38 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"data_layout", 11, *a2);
  v5 = v4;
  v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    v6 = v38;
  }
  v7 = (uint64_t *)((char *)v37 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v13 = v38;
    }
    v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    v18 = v17;
    v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v19 = v38;
    }
    v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"kernel_sizes", 12, v21);
    v24 = v23;
    v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v25 = v38;
    }
    v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    v30 = v29;
    v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v31 = v38;
    }
    v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v33 = v37;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v37 == v39)
      return DictionaryAttr;
    goto LABEL_24;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (mlir::MLIRContext *)v37, v8);
  v33 = v37;
  if (v37 != v39)
LABEL_24:
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::ColToImOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ColToImOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          *(_QWORD *)result = v7;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xCuLL:
      result = memcmp(__s1, "kernel_sizes", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::ColToImOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"kernel_sizes", 12, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
}

BOOL mlir::mps::ColToImOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(const void ***__return_ptr, uint64_t), uint64_t a4)
{
  _DWORD *v8;
  _QWORD *v9;
  const void **v10;
  _QWORD *v11;
  _QWORD *v12;
  _BOOL8 result;

  v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v8, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v9, (const void **)"dilation_rates", (const char *)0xE, a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v11, (const void **)"kernel_sizes", (const char *)0xC, a3, a4))
        {
          v12 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v12, (const void **)"strides", (const char *)7, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NCHW or NHWC";
        v31 = 77;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(_QWORD *a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *Shape;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t NumElements;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  _QWORD *v41;
  _QWORD v42[2];
  uint64_t OperandRange;
  _QWORD *v44;
  _QWORD v45[2];
  _QWORD v46[2];
  uint64_t *v47;
  unsigned int v48;
  const void **v49;
  const char *v50;
  uint64_t v51;
  __int16 v52;
  const void **v53;
  char v54[8];
  uint64_t v55;
  void *v56;
  unsigned int v57;
  unsigned int v58;
  _BYTE v59[96];
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_7;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46[0] = v12;
  v46[1] = Type;
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)v46);
  v65 = 2;
  if (v14 != 1 || *Shape != v65)
    goto LABEL_7;
  v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      v33 = *v47;
      MEMORY[0x20BD002D4]();
      if (!v33)
        goto LABEL_7;
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    return 1;
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    v50 = "attribute '";
    v51 = 11;
    v15 = &v49;
    v16 = (char *)v56;
    if (v57 >= v58)
    {
      v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        v39 = (char *)&v49 - (_BYTE *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v16 = (char *)v56;
        v15 = (const void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v15 = &v49;
        v16 = (char *)v56;
      }
    }
    v17 = &v16[24 * v57];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    ++v57;
    if (v53)
    {
      v52 = 261;
      v49 = a2;
      v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {2}";
        v51 = 77;
        v19 = &v49;
        v20 = (char *)v56;
        if (v57 >= v58)
        {
          v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            v40 = (char *)&v49 - (_BYTE *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v20 = (char *)v56;
            v19 = (const void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v19 = &v49;
            v20 = (char *)v56;
          }
        }
        v21 = &v20[24 * v57];
        v22 = *(_OWORD *)v19;
        *((_QWORD *)v21 + 2) = v19[2];
        *(_OWORD *)v21 = v22;
        ++v57;
      }
    }
  }
  v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  if (v64)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v63;
      v26 = __p;
      if (v63 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v63 = v24;
      operator delete(v26);
    }
    v27 = v60;
    if (v60)
    {
      v28 = v61;
      v29 = v60;
      if (v61 != v60)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v60;
      }
      v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59)
      free(v56);
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *Shape;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v35;
  unint64_t v36;
  int64_t v37;
  int64_t v38;
  const void **v39;
  _QWORD v40[2];
  uint64_t OperandRange;
  const void **v42;
  const char *v43;
  uint64_t v44;
  __int16 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_13;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v42 = a1;
  v43 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46 = v12;
  v47 = Type;
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
  v57 = xmmword_207A7D550;
  if (v14 == 2 && *Shape == (_QWORD)v57 && Shape[1] == *((_QWORD *)&v57 + 1))
  {
    v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    v43 = "attribute '";
    v44 = 11;
    v18 = &v42;
    v19 = (char *)v48;
    if (v49 >= v50)
    {
      v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        v37 = (char *)&v42 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v19 = (char *)v48;
        v18 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v18 = &v42;
        v19 = (char *)v48;
      }
    }
    v20 = &v19[24 * v49];
    v21 = *(_OWORD *)v18;
    *((_QWORD *)v20 + 2) = v18[2];
    *(_OWORD *)v20 = v21;
    ++v49;
    if (v46)
    {
      v45 = 261;
      v42 = a2;
      v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {4, 2}";
        v44 = 71;
        v22 = &v42;
        v23 = (char *)v48;
        if (v49 >= v50)
        {
          v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            v38 = (char *)&v42 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v23 = (char *)v48;
            v22 = (const void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v22 = &v42;
            v23 = (char *)v48;
          }
        }
        v24 = &v23[24 * v49];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = v22[2];
        *(_OWORD *)v24 = v25;
        ++v49;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  if (v56)
  {
    v26 = __p;
    if (__p)
    {
      v27 = v55;
      v28 = __p;
      if (v55 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v55 = v26;
      operator delete(v28);
    }
    v29 = v52;
    if (v52)
    {
      v30 = v53;
      v31 = v52;
      if (v53 != v52)
      {
        do
        {
          v33 = *--v30;
          v32 = v33;
          *v30 = 0;
          if (v33)
            MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
        }
        while (v30 != v29);
        v31 = v52;
      }
      v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51)
      free(v48);
  }
  return v17;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_QWORD *)(v3 + 32) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[102];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  v41 = 81;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::mps::ColToImOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t NextResultAtOffset;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  const void **v45[4];
  __int16 v46;
  _QWORD v47[3];
  void *v48;
  uint64_t v49;
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(_QWORD **)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
            {
              return 0;
            }
            if (*((_DWORD *)*this + 9))
              v9 = (uint64_t)(*this - 2);
            else
              v9 = 0;
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
          }
          v45[0] = (const void **)"requires attribute 'strides'";
          v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          if (v54)
          {
            v38 = __p;
            if (__p)
            {
              v39 = v53;
              v40 = __p;
              if (v53 != __p)
              {
                do
                  v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                v40 = __p;
              }
              v53 = v38;
              operator delete(v40);
            }
            v15 = v50;
            if (!v50)
              goto LABEL_93;
            v41 = v51;
            v17 = v50;
            if (v51 == v50)
            {
LABEL_92:
              v51 = v15;
              operator delete(v17);
LABEL_93:
              if (v48 != &v49)
                free(v48);
              return v11;
            }
            do
            {
              v43 = *--v41;
              v42 = v43;
              *v41 = 0;
              if (v43)
                MEMORY[0x20BD002D4](v42, 0x1000C8077774924);
            }
            while (v41 != v15);
LABEL_91:
            v17 = v50;
            goto LABEL_92;
          }
        }
        else
        {
          v45[0] = (const void **)"requires attribute 'kernel_sizes'";
          v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          if (v54)
          {
            v32 = __p;
            if (__p)
            {
              v33 = v53;
              v34 = __p;
              if (v53 != __p)
              {
                do
                  v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                v34 = __p;
              }
              v53 = v32;
              operator delete(v34);
            }
            v15 = v50;
            if (!v50)
              goto LABEL_93;
            v35 = v51;
            v17 = v50;
            if (v51 == v50)
              goto LABEL_92;
            do
            {
              v37 = *--v35;
              v36 = v37;
              *v35 = 0;
              if (v37)
                MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
            }
            while (v35 != v15);
            goto LABEL_91;
          }
        }
      }
      else
      {
        v45[0] = (const void **)"requires attribute 'explicit_padding'";
        v46 = 259;
        mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        if (v54)
        {
          v26 = __p;
          if (__p)
          {
            v27 = v53;
            v28 = __p;
            if (v53 != __p)
            {
              do
                v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              v28 = __p;
            }
            v53 = v26;
            operator delete(v28);
          }
          v15 = v50;
          if (!v50)
            goto LABEL_93;
          v29 = v51;
          v17 = v50;
          if (v51 == v50)
            goto LABEL_92;
          do
          {
            v31 = *--v29;
            v30 = v31;
            *v29 = 0;
            if (v31)
              MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
          }
          while (v29 != v15);
          goto LABEL_91;
        }
      }
    }
    else
    {
      v45[0] = (const void **)"requires attribute 'dilation_rates'";
      v46 = 259;
      mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
      v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      if (v54)
      {
        v20 = __p;
        if (__p)
        {
          v21 = v53;
          v22 = __p;
          if (v53 != __p)
          {
            do
              v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            v22 = __p;
          }
          v53 = v20;
          operator delete(v22);
        }
        v15 = v50;
        if (!v50)
          goto LABEL_93;
        v23 = v51;
        v17 = v50;
        if (v51 == v50)
          goto LABEL_92;
        do
        {
          v25 = *--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v23 != v15);
        goto LABEL_91;
      }
    }
  }
  else
  {
    v45[0] = (const void **)"requires attribute 'data_layout'";
    v46 = 259;
    mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    if (v54)
    {
      v12 = __p;
      if (__p)
      {
        v13 = v53;
        v14 = __p;
        if (v53 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v53 = v12;
        operator delete(v14);
      }
      v15 = v50;
      if (!v50)
        goto LABEL_93;
      v16 = v51;
      v17 = v50;
      if (v51 == v50)
        goto LABEL_92;
      do
      {
        v19 = *--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
      }
      while (v16 != v15);
      goto LABEL_91;
    }
  }
  return v11;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD *v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      return 1;
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_10;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 3)
        goto LABEL_10;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange))
        goto LABEL_10;
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 3D tensor of 32-bit float values, but got ";
        v60 = 93;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD *v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      return 1;
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_10;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 4)
        goto LABEL_10;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange))
        goto LABEL_10;
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 4D tensor of 32-bit float values, but got ";
        v60 = 93;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.concat", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ConcatOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "interleave", 0xAuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 55;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = __p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::ConcatOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"interleave", 10, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[104];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::ConcatOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;
  uint64_t NextResultAtOffset;
  uint64_t *v19;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v19 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"interleave", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v19))return 0;
  v4 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) == 0)
  {
    v7 = 0;
    v6 = 0xFFFFFFFFLL;
LABEL_5:
    v8 = 0;
    v9 = v7 + 24;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(*this, (const void **)(*(_QWORD *)(*(_QWORD *)v9 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v8))
    {
      ++v8;
      v9 += 32;
      if (v6 == v8)
      {
        v4 = *this;
        if ((*((_BYTE *)*this + 46) & 0x80) != 0)
          goto LABEL_11;
        v10 = 0;
        v11 = -2;
        goto LABEL_12;
      }
    }
    return 0;
  }
  v5 = *((_DWORD *)v4 + 17);
  v6 = (v5 - 1);
  if (v5 != 1)
  {
    v7 = v4[9];
    goto LABEL_5;
  }
  LODWORD(v8) = 0;
LABEL_11:
  v12 = *((_DWORD *)v4 + 17);
  v10 = v4[9];
  v11 = v12 - 2;
LABEL_12:
  v13 = (v11 + 1);
  v14 = (v11 + 2) - v13;
  for (i = v10 + 32 * v13 + 24;
        mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)i + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v8);
        i += 32)
  {
    LODWORD(v8) = v8 + 1;
    if (!--v14)
    {
      if (*((_DWORD *)*this + 9))
        v16 = (uint64_t)(*this - 2);
      else
        v16 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
  }
  return 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v14;
  uint64_t *p_OperandRange;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  __int128 v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  const void **v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t Value;
  uint64_t v59;
  uint64_t OperandRange;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD *v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    v10 = *a2;
    v11 = (void *)*((_QWORD *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v54 = a2;
    v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v42 = v14;
      v59 = v14;
      OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange))
        return 1;
      v57 = v42;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v56 = 261;
  v54 = a3;
  v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    v61 = " #";
    v62 = 2;
    p_OperandRange = &OperandRange;
    v16 = (char *)v64;
    if (v65 >= v66)
    {
      v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        v50 = (char *)&OperandRange - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        v16 = (char *)v64;
        p_OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_OperandRange = &OperandRange;
        v16 = (char *)v64;
      }
    }
    v17 = &v16[24 * v65];
    v18 = *(_OWORD *)p_OperandRange;
    *((_QWORD *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      v61 = (const char *)a5;
      v20 = &OperandRange;
      v21 = (char *)v64;
      if (v19 >= v66)
      {
        v45 = v19 + 1;
        v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          v51 = (char *)&OperandRange - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v21 = (char *)v64;
          v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v20 = &OperandRange;
          v21 = (char *)v64;
        }
      }
      v22 = &v21[24 * v65];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        v61 = " must be variadic of tensor of mps native type values or tensor of complex values, but got ";
        v62 = 91;
        v25 = &OperandRange;
        v26 = (char *)v64;
        if (v24 >= v66)
        {
          v47 = v24 + 1;
          v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            v52 = (char *)&OperandRange - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v26 = (char *)v64;
            v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v25 = &OperandRange;
            v26 = (char *)v64;
          }
        }
        v27 = &v26[24 * v65];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v65;
        if (v63[0])
        {
          v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          v30 = (char *)v64;
          if (v65 >= v66)
          {
            v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              v53 = (char *)&OperandRange - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v30 = (char *)v64;
              v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v29 = &OperandRange;
              v30 = (char *)v64;
            }
          }
          v31 = &v30[24 * v65];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v65;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v37 = v68;
    if (v68)
    {
      v38 = v69;
      v39 = v68;
      if (v69 != v68)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v68;
      }
      v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67)
      free(v64);
  }
  return v33;
}

uint64_t mlir::mps::detail::ConjugateOpGenericAdaptorBase::ConjugateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conjugate", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *this, uint64_t a2, _QWORD **a3, uint64_t a4, uint64_t a5)
{
  char *v8;
  _QWORD *v9;
  void *v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v17;
  pthread_rwlock_t **v18;
  uint64_t v19;
  _QWORD *v20;

  *(_QWORD *)this = a2;
  *((_BYTE *)this + 8) = 0;
  v8 = (char *)this + 8;
  *((_BYTE *)this + 16) = 0;
  v9 = *a3;
  *((_QWORD *)this + 3) = *a3;
  if (v9
    && ((v10 = *(void **)(*v9 + 136),
         v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id,
         v10 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      ? (v12 = 0)
      : (v12 = v9),
        v20 = v12,
        v11))
  {
    v15 = v9[2];
    Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
    v18 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v17) + 48);
    llvm::sys::RWMutexImpl::lock(v18);
    ++*(_QWORD *)(v15 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v18);
    v19 = *(_QWORD *)this;
    *((_QWORD *)this + 4) = a4;
    *((_QWORD *)this + 5) = a5;
    if (!v19)
      return this;
  }
  else
  {
    *((_QWORD *)this + 4) = a4;
    *((_QWORD *)this + 5) = a5;
    if (!a2)
      return this;
  }
  v13 = mlir::Attribute::getContext(this);
  if (*((_BYTE *)this + 16))
    *((_BYTE *)this + 16) = 0;
  mlir::OperationName::OperationName(v8, "mps.constant", 12, v13);
  *((_BYTE *)this + 16) = 1;
  return this;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD **v8;
  unint64_t v10[3];

  v10[2] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  if (BYTE3(v4))
    v8 = (_QWORD **)v5;
  else
    v8 = 0;
  mlir::ValueRange::ValueRange(v10, v7, v6);
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(a1, v3, v8, v10[0], v10[1]);
  return a1;
}

uint64_t mlir::mps::ConstantOp::setPropertiesFromAttr(_QWORD *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v15;
  pthread_rwlock_t **v16;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int64_t v42;
  int64_t v43;
  uint64_t v44;
  int v45;
  const char *v46;
  uint64_t v47;
  _QWORD v48[3];
  void *v49;
  unsigned int v50;
  unsigned int v51;
  _BYTE v52[96];
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v44 = v6;
  if (!v6)
  {
    a3(v48, a4);
    if (v48[0])
    {
      v45 = 3;
      v46 = "expected DictionaryAttr to set properties";
      v47 = 41;
      v18 = &v45;
      v19 = (char *)v49;
      if (v50 >= v51)
      {
        v40 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          v42 = (char *)&v45 - (_BYTE *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          v19 = (char *)v49;
          v18 = (int *)((char *)v49 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          v18 = &v45;
          v19 = (char *)v49;
        }
      }
      v20 = &v19[24 * v50];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      ++v50;
      if (v48[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (!v57)
      return 0;
    v22 = __p;
    if (__p)
    {
      v23 = v56;
      v24 = __p;
      if (v56 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v56 = v22;
      operator delete(v24);
    }
    v25 = v53;
    if (!v53)
      goto LABEL_47;
    v26 = v54;
    v27 = v53;
    if (v54 == v53)
      goto LABEL_46;
    do
    {
      v29 = *--v26;
      v28 = v29;
      *v26 = 0;
      if (v29)
        MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
    }
    while (v26 != v25);
    goto LABEL_45;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v44, "value", 5uLL);
  if (!v8)
  {
    a3(v48, a4);
    if (v48[0])
    {
      v45 = 3;
      v46 = "expected key entry for value in DictionaryAttr to set Properties.";
      v47 = 65;
      v30 = &v45;
      v31 = (char *)v49;
      if (v50 >= v51)
      {
        v41 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          v43 = (char *)&v45 - (_BYTE *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          v31 = (char *)v49;
          v30 = (int *)((char *)v49 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          v30 = &v45;
          v31 = (char *)v49;
        }
      }
      v32 = &v31[24 * v50];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      ++v50;
      if (v48[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (!v57)
      return 0;
    v34 = __p;
    if (__p)
    {
      v35 = v56;
      v36 = __p;
      if (v56 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v56 = v34;
      operator delete(v36);
    }
    v25 = v53;
    if (!v53)
    {
LABEL_47:
      if (v49 != v52)
        free(v49);
      return 0;
    }
    v37 = v54;
    v27 = v53;
    if (v54 == v53)
    {
LABEL_46:
      v54 = v25;
      operator delete(v27);
      goto LABEL_47;
    }
    do
    {
      v39 = *--v37;
      v38 = v39;
      *v37 = 0;
      if (v39)
        MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
    }
    while (v37 != v25);
LABEL_45:
    v27 = v53;
    goto LABEL_46;
  }
  v9 = v8;
  v10 = *(void **)(*v8 + 136);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    v12 = v8;
  else
    v12 = 0;
  v48[0] = v12;
  if (v11)
  {
    v13 = v8[2];
    Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)v48);
    v16 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v15) + 48);
    llvm::sys::RWMutexImpl::lock(v16);
    ++*(_QWORD *)(v13 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v16);
  }
  *a1 = v9;
  return 1;
}

uint64_t mlir::mps::ConstantOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, mlir::MLIRContext *a2)
{
  uint64_t v2;
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  void *v11;
  mlir::DictionaryAttr *v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[7];

  v16[6] = *MEMORY[0x24BDAC8D0];
  v13 = a1;
  v14 = v16;
  v15 = 0x300000000;
  v2 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    v2 = mlir::UnitAttr::get(a1, a2);
  NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"value", 5, v2);
  v5 = v4;
  v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    v6 = v15;
  }
  v7 = (uint64_t *)((char *)v14 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = __CFADD__((_DWORD)v15, 1);
  v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    v11 = v14;
    if (v14 == v16)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (mlir::MLIRContext *)v14, v9);
  v11 = v14;
  if (v14 != v16)
LABEL_10:
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::mps::ConstantOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int8 v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;

  v1 = *a1;
  if (*(_UNKNOWN **)(*(_QWORD *)*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    v27 = llvm::hash_value(**(_QWORD ***)(v1 + 16), *(_QWORD *)(*(_QWORD *)(v1 + 16) + 8));
    v6 = *(_QWORD *)(v1 + 40);
    if ((v7 & 1) == 0)
    {
      v24 = *(_QWORD *)(v1 + 40);
      v6 = v24;
      if (v21)
      {
        v22 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override)
          v22 = 0xFF51AFD7ED558CCDLL;
        llvm::hashing::detail::get_execution_seed(void)::seed = v22;
        v6 = v24;
      }
    }
    v8 = HIDWORD(v6);
    v9 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v6) ^ HIDWORD(v6));
    v26 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
    v10 = *(_QWORD *)(v1 + 8);
    if ((v9 & 1) == 0
    {
      v23 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v23 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v23;
    }
    v11 = 0x9DDFEA08EB382D69
        * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v10) ^ HIDWORD(v10));
    v12 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v11 >> 47) ^ v11);
    v25 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
    v5 = llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v27, (uint64_t *)&v26, (uint64_t *)&v25);
    if ((v13 & 1) == 0)
      goto LABEL_9;
  }
  else
  {
    if ((v2 & 1) == 0
    {
      v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v20 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
    }
    v3 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v1) ^ HIDWORD(v1));
    v4 = 0x9DDFEA08EB382D69 * (HIDWORD(v1) ^ (v3 >> 47) ^ v3);
    v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
    if ((v4 & 1) == 0)
    {
LABEL_9:
      v17 = v5;
      v5 = v17;
      if (v18)
      {
        v19 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override)
          v19 = 0xFF51AFD7ED558CCDLL;
        llvm::hashing::detail::get_execution_seed(void)::seed = v19;
        v5 = v17;
      }
    }
  }
  v14 = llvm::hashing::detail::get_execution_seed(void)::seed ^ HIDWORD(v5);
  v15 = 0x9DDFEA08EB382D69 * (v14 ^ (8 * v5 + 8));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
}

uint64_t mlir::mps::ConstantOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  BOOL v6;
  _QWORD *v7;
  uint64_t v8;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v10;
  pthread_rwlock_t **v11;
  _QWORD *v13;
  _QWORD *v14;

  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  v13 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD **))(*(_QWORD *)a1 + 48))(a1, &v13))
    return 0;
  v4 = v13;
  if (v13)
  {
    v5 = *(void **)(*v13 + 136);
    v6 = v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v7 = v13;
    else
      v7 = 0;
    v14 = v7;
    if (v6)
    {
      v8 = v13[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
      v11 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v10) + 48);
      llvm::sys::RWMutexImpl::lock(v11);
      ++*(_QWORD *)(v8 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v11);
    }
  }
  *v3 = v4;
  return 1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[106];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  void *v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t v9;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v11;
  pthread_rwlock_t **v12;
  _QWORD *Type;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v16[2];
  _QWORD *v17;

  v16[0] = a3;
  v16[1] = a4;
  if (a3)
  {
    v6 = *(void **)(*a3 + 136);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    v8 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a3 : 0;
    v17 = v8;
    if (v7)
    {
      v9 = a3[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      v12 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v11) + 48);
      llvm::sys::RWMutexImpl::lock(v12);
      ++*(_QWORD *)(v9 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v12);
    }
  }
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((_QWORD *)a2) = a3;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v16);
  v14 = Type;
  if (Type)
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v15 = *(unsigned int *)(a2 + 72);
  if (v15 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v15) = v14;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::ConstantProperty & mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::ConstantProperty & mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::ConstantProperty]";
        v15 = 77;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::ConstantProperty,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[108];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  void *v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v13;
  pthread_rwlock_t **v14;
  _QWORD *v15;

  if (a4)
  {
    v7 = *(void **)(*a4 + 136);
    v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a4 : 0;
    v15 = v9;
    if (v8)
    {
      v11 = a4[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
      v14 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v13) + 48);
      llvm::sys::RWMutexImpl::lock(v14);
      ++*(_QWORD *)(v11 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v14);
      *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((_QWORD *)a2) = a4;
      v10 = *(unsigned int *)(a2 + 72);
      if (v10 < *(_DWORD *)(a2 + 76))
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((_QWORD *)a2) = a4;
  v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
LABEL_7:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
LABEL_8:
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::mps::ConstantOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t *v4;
  const void **v5;
  const void *v6;
  void *v7;
  void *v9;
  uint64_t *p_OperandRange;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  const void **v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t Value;
  uint64_t OperandRange;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD *v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  v4 = *this;
  v5 = (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  v6 = *v5;
  v7 = (void *)*((_QWORD *)*v5 + 17);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v59[0] = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
    v59[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v59);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
      return 1;
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      return 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
      return 1;
    v9 = *(void **)(*(_QWORD *)OperandRange + 136);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      return 1;
    if (v9 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v54 = OperandRange;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v54);
      if (mlir::Type::isF16((mlir::Type *)&Value))
        return 1;
      v52 = OperandRange;
      v53 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v52);
      if (mlir::Type::isF32((mlir::Type *)&v53))
        return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      return 1;
    }
    v6 = *v5;
    v7 = (void *)*((_QWORD *)*v5 + 17);
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    goto LABEL_91;
  v49 = v5;
  v50 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v49);
  if (!mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isF16((mlir::Type *)&OperandRange)
    && !mlir::Type::isF32((mlir::Type *)&OperandRange)
    && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
  {
    v37 = *(void **)(*(_QWORD *)OperandRange + 136);
    if (v37 != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      if (v37 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
        || (v54 = OperandRange,
            Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v54),
            !mlir::Type::isF16((mlir::Type *)&Value))
        && (v52 = OperandRange,
            v53 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v52),
            !mlir::Type::isF32((mlir::Type *)&v53)))
      {
        if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          && *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
        {
LABEL_91:
          v51 = 261;
          v49 = (const void **)"result";
          v50 = 6;
          mlir::Operation::emitOpError(v4, &v49, (uint64_t)v59);
          if (v59[0])
          {
            LODWORD(OperandRange) = 3;
            v57 = " #";
            v58 = 2;
            p_OperandRange = &OperandRange;
            v11 = (char *)v60;
            if (v61 >= v62)
            {
              v39 = v61 + 1;
              if (v60 <= &OperandRange && (char *)v60 + 24 * v61 > (char *)&OperandRange)
              {
                v45 = (char *)&OperandRange - (_BYTE *)v60;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v39, 24);
                v11 = (char *)v60;
                p_OperandRange = (uint64_t *)((char *)v60 + v45);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v39, 24);
                p_OperandRange = &OperandRange;
                v11 = (char *)v60;
              }
            }
            v12 = &v11[24 * v61];
            v13 = *(_OWORD *)p_OperandRange;
            *((_QWORD *)v12 + 2) = p_OperandRange[2];
            *(_OWORD *)v12 = v13;
            v14 = ++v61;
            if (v59[0])
            {
              LODWORD(OperandRange) = 5;
              v57 = 0;
              v15 = &OperandRange;
              v16 = (char *)v60;
              if (v14 >= v62)
              {
                v40 = v14 + 1;
                v41 = (char *)v60 + 24 * v14 > (char *)&OperandRange;
                if (v60 <= &OperandRange && v41)
                {
                  v46 = (char *)&OperandRange - (_BYTE *)v60;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v40, 24);
                  v16 = (char *)v60;
                  v15 = (uint64_t *)((char *)v60 + v46);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v40, 24);
                  v15 = &OperandRange;
                  v16 = (char *)v60;
                }
              }
              v17 = &v16[24 * v61];
              v18 = *(_OWORD *)v15;
              *((_QWORD *)v17 + 2) = v15[2];
              *(_OWORD *)v17 = v18;
              v19 = ++v61;
              if (v59[0])
              {
                LODWORD(OperandRange) = 3;
                v57 = " must be tensor of mps native type or complex or quantized values or memref of mps native type or "
                      "complex or quantized values, but got ";
                v58 = 135;
                v20 = &OperandRange;
                v21 = (char *)v60;
                if (v19 >= v62)
                {
                  v42 = v19 + 1;
                  v43 = (char *)v60 + 24 * v19 > (char *)&OperandRange;
                  if (v60 <= &OperandRange && v43)
                  {
                    v47 = (char *)&OperandRange - (_BYTE *)v60;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v42, 24);
                    v21 = (char *)v60;
                    v20 = (uint64_t *)((char *)v60 + v47);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v42, 24);
                    v20 = &OperandRange;
                    v21 = (char *)v60;
                  }
                }
                v22 = &v21[24 * v61];
                v23 = *(_OWORD *)v20;
                *((_QWORD *)v22 + 2) = v20[2];
                *(_OWORD *)v22 = v23;
                ++v61;
                if (v59[0])
                {
                  v24 = &OperandRange;
                  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)v5);
                  v25 = (char *)v60;
                  if (v61 >= v62)
                  {
                    v44 = v61 + 1;
                    if (v60 <= &OperandRange && (char *)v60 + 24 * v61 > (char *)&OperandRange)
                    {
                      v48 = (char *)&OperandRange - (_BYTE *)v60;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v44, 24);
                      v25 = (char *)v60;
                      v24 = (uint64_t *)((char *)v60 + v48);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v44, 24);
                      v24 = &OperandRange;
                      v25 = (char *)v60;
                    }
                  }
                  v26 = &v25[24 * v61];
                  v27 = *(_OWORD *)v24;
                  *((_QWORD *)v26 + 2) = v24[2];
                  *(_OWORD *)v26 = v27;
                  ++v61;
                }
              }
            }
          }
          v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
          if (v59[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
          if (v68)
          {
            v29 = __p;
            if (__p)
            {
              v30 = v67;
              v31 = __p;
              if (v67 != __p)
              {
                do
                  v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
                while (v30 != v29);
                v31 = __p;
              }
              v67 = v29;
              operator delete(v31);
            }
            v32 = v64;
            if (v64)
            {
              v33 = v65;
              v34 = v64;
              if (v65 != v64)
              {
                do
                {
                  v36 = *--v33;
                  v35 = v36;
                  *v33 = 0;
                  if (v36)
                    MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
                }
                while (v33 != v32);
                v34 = v64;
              }
              v65 = v32;
              operator delete(v34);
            }
            if (v60 != v63)
              free(v60);
          }
          if (!v28)
            return 0;
        }
      }
    }
  }
  return 1;
}

uint64_t mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Conv2DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d_data_gradient", 25, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  char *v63;
  char *v64;
  __int128 v65;
  uint64_t *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  char *v77;
  char *v78;
  __int128 v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  const char *v111;
  uint64_t v112;
  _QWORD v113[3];
  void *v114;
  unsigned int v115;
  unsigned int v116;
  _BYTE v117[96];
  void *v118;
  _QWORD *v119;
  void *__p;
  _QWORD *v121;
  char v122;
  uint64_t v123;

  v123 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v109 = v6;
  if (!v6)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected DictionaryAttr to set properties";
      v112 = 41;
      v26 = &v110;
      v27 = (char *)v114;
      if (v115 >= v116)
      {
        v92 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v100 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          v27 = (char *)v114;
          v26 = (uint64_t *)((char *)v114 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          v26 = &v110;
          v27 = (char *)v114;
        }
      }
      v28 = &v27[24 * v115];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v121;
      v32 = __p;
      if (v121 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v121 = v30;
      operator delete(v32);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v33 = v119;
    v23 = v118;
    if (v119 == v118)
    {
LABEL_116:
      v119 = v21;
      operator delete(v23);
LABEL_117:
      if (v114 != v117)
        free(v114);
      return 0;
    }
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
LABEL_115:
    v23 = v118;
    goto LABEL_116;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v109, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      v112 = 71;
      v36 = &v110;
      v37 = (char *)v114;
      if (v115 >= v116)
      {
        v94 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v102 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          v37 = (char *)v114;
          v36 = (uint64_t *)((char *)v114 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          v36 = &v110;
          v37 = (char *)v114;
        }
      }
      v38 = &v37[24 * v115];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = v36[2];
      *(_OWORD *)v38 = v39;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v40 = __p;
    if (__p)
    {
      v41 = v121;
      v42 = __p;
      if (v121 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v121 = v40;
      operator delete(v42);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v43 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v45 = *--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v112 = 56;
      v10 = &v110;
      v11 = (char *)v114;
      if (v115 >= v116)
      {
        v93 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v101 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          v11 = (char *)v114;
          v10 = (uint64_t *)((char *)v114 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          v10 = &v110;
          v11 = (char *)v114;
        }
      }
      v12 = &v11[24 * v115];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = v10[2];
      *(_OWORD *)v12 = v13;
      ++v115;
      if (v113[0])
      {
        v14 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v9);
        v15 = (char *)v114;
        if (v115 >= v116)
        {
          v95 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            v103 = (char *)&v110 - (_BYTE *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            v15 = (char *)v114;
            v14 = (uint64_t *)((char *)v114 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            v14 = &v110;
            v15 = (char *)v114;
          }
        }
        v16 = &v15[24 * v115];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v115;
        if (v113[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122)
      return 0;
    v18 = __p;
    if (__p)
    {
      v19 = v121;
      v20 = __p;
      if (v121 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v121 = v18;
      operator delete(v20);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v22 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v109, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v112 = 74;
      v52 = &v110;
      v53 = (char *)v114;
      if (v115 >= v116)
      {
        v96 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v104 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          v53 = (char *)v114;
          v52 = (uint64_t *)((char *)v114 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          v52 = &v110;
          v53 = (char *)v114;
        }
      }
      v54 = &v53[24 * v115];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = v52[2];
      *(_OWORD *)v54 = v55;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v56 = __p;
    if (__p)
    {
      v57 = v121;
      v58 = __p;
      if (v121 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v121 = v56;
      operator delete(v58);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v59 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v112 = 59;
      v62 = &v110;
      v63 = (char *)v114;
      if (v115 >= v116)
      {
        v97 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v105 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          v63 = (char *)v114;
          v62 = (uint64_t *)((char *)v114 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          v62 = &v110;
          v63 = (char *)v114;
        }
      }
      v64 = &v63[24 * v115];
      v65 = *(_OWORD *)v62;
      *((_QWORD *)v64 + 2) = v62[2];
      *(_OWORD *)v64 = v65;
      ++v115;
      if (v113[0])
      {
        v66 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v47);
        v67 = (char *)v114;
        if (v115 >= v116)
        {
          v98 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            v106 = (char *)&v110 - (_BYTE *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            v67 = (char *)v114;
            v66 = (uint64_t *)((char *)v114 + v106);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            v66 = &v110;
            v67 = (char *)v114;
          }
        }
        v68 = &v67[24 * v115];
        v69 = *(_OWORD *)v66;
        *((_QWORD *)v68 + 2) = v66[2];
        *(_OWORD *)v68 = v69;
        ++v115;
        if (v113[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122)
      return 0;
    v70 = __p;
    if (__p)
    {
      v71 = v121;
      v72 = __p;
      if (v121 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v121 = v70;
      operator delete(v72);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v73 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v75 = *--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        MEMORY[0x20BD002D4](v74, 0x1000C8077774924);
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  v48 = mlir::DictionaryAttr::get((uint64_t)&v109, "explicit_padding", 0x10uLL);
  v108 = v48;
  if (!v48)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      v112 = 76;
      v76 = &v110;
      v77 = (char *)v114;
      if (v115 >= v116)
      {
        v99 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v107 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          v77 = (char *)v114;
          v76 = (uint64_t *)((char *)v114 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          v76 = &v110;
          v77 = (char *)v114;
        }
      }
      v78 = &v77[24 * v115];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = v76[2];
      *(_OWORD *)v78 = v79;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v80 = __p;
    if (__p)
    {
      v81 = v121;
      v82 = __p;
      if (v121 != __p)
      {
        do
          v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        v82 = __p;
      }
      v121 = v80;
      operator delete(v82);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v83 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v85 = *--v83;
      v84 = v85;
      *v83 = 0;
      if (v85)
        MEMORY[0x20BD002D4](v84, 0x1000C8077774924);
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  v49 = v48;
  if ((mlir::DenseIntElementsAttr::classof(v48) & 1) != 0)
  {
    a1[2] = v49;
    v50 = mlir::DictionaryAttr::get((uint64_t)&v109, "groups", 6uLL);
    v110 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a1[3] = v50;
        v88 = mlir::DictionaryAttr::get((uint64_t)&v109, "padding_style", 0xDuLL);
        v110 = v88;
        if (!v88)
        {
          a3(v113, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for padding_style in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        if (*(_UNKNOWN **)(*(_QWORD *)v88 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
        {
          a1[4] = v88;
          v89 = mlir::DictionaryAttr::get((uint64_t)&v109, "strides", 7uLL);
          v110 = v89;
          if (!v89)
          {
            a3(v113, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for strides in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          v90 = v89;
          if ((mlir::DenseIntElementsAttr::classof(v89) & 1) != 0)
          {
            a1[5] = v90;
            v91 = mlir::DictionaryAttr::get((uint64_t)&v109, "weights_layout", 0xEuLL);
            v110 = v91;
            if (!v91)
            {
              a3(v113, a4);
              mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
              goto LABEL_123;
            }
            if (*(_UNKNOWN **)(*(_QWORD *)v91 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            {
              a1[6] = v91;
              return 1;
            }
            a3(v113, a4);
          }
          else
          {
            a3(v113, a4);
          }
        }
        else
        {
          a3(v113, a4);
        }
      }
      else
      {
        a3(v113, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v110);
    }
    else
    {
      a3(v113, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for groups in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
    return 0;
  }
  a3(v113, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v108);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
  return 0;
}

uint64_t mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[7];

  v51[6] = *MEMORY[0x24BDAC8D0];
  v48 = a1;
  v49 = v51;
  v50 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, *a2);
  v5 = v4;
  v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    v6 = v50;
  }
  v7 = (uint64_t *)((char *)v49 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v13 = v50;
    }
    v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"explicit_padding", 16, v15);
    v18 = v17;
    v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v19 = v50;
    }
    v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"groups", 6, v21);
    v24 = v23;
    v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v25 = v50;
    }
    v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"padding_style", 13, v27);
    v30 = v29;
    v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v31 = v50;
    }
    v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"strides", 7, v33);
    v36 = v35;
    v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v37 = v50;
    }
    v38 = (uint64_t *)((char *)v49 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"weights_layout", 14, v39);
    v42 = v41;
    v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v43 = v50;
    }
    v44 = (uint64_t *)((char *)v49 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v45 = v49;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v49 == v51)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (mlir::MLIRContext *)v49, v8);
  v45 = v49;
  if (v49 != v51)
LABEL_32:
    free(v45);
  return DictionaryAttr;
}

unint64_t mlir::mps::Conv2DDataGradientOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v27;
  int v28;
  unint64_t v29;
  int v30;
  int v31;
  unint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  unint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  int v45;
  unint64_t v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t *v55;
  unint64_t *v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  _OWORD v82[4];
  _OWORD v83[3];
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v1 = *a1;
  v3 = &unk_254519000;
  if ((v2 & 1) == 0)
  {
    v54 = a1;
    v68 = *a1;
    v1 = v68;
    v3 = &unk_254519000;
    v28 = v27;
    a1 = v54;
    if (v28)
    {
      v29 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v29 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v29;
      v1 = v68;
      v3 = (_QWORD *)&unk_254519000;
      a1 = v54;
    }
  }
  v4 = v3[373];
  v5 = a1[1];
  if ((v6 & 1) == 0)
  {
    v55 = a1;
    v61 = v3[373];
    v69 = v1;
    v49 = a1[1];
    v4 = v61;
    v1 = v69;
    v3 = &unk_254519000;
    v31 = v30;
    v5 = v49;
    a1 = v55;
    if (v31)
    {
      v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v32 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v32;
      v5 = v49;
      a1 = v55;
      v4 = v61;
      v1 = v69;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v7 = HIDWORD(v5);
  v8 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v5) ^ HIDWORD(v5));
  v81 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v56 = a1;
    v62 = v4;
    v70 = v1;
    v50 = a1[2];
    v4 = v62;
    v1 = v70;
    v3 = &unk_254519000;
    v34 = v33;
    v9 = v50;
    a1 = v56;
    if (v34)
    {
      v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v35 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v35;
      v9 = v50;
      a1 = v56;
      v4 = v62;
      v1 = v70;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v9) ^ HIDWORD(v9));
  v80 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v57 = a1;
    v63 = v4;
    v71 = v1;
    v51 = a1[3];
    v4 = v63;
    v1 = v71;
    v3 = &unk_254519000;
    v37 = v36;
    v12 = v51;
    a1 = v57;
    if (v37)
    {
      v38 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v38 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v38;
      v12 = v51;
      a1 = v57;
      v4 = v63;
      v1 = v71;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v12) ^ HIDWORD(v12));
  v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v13 & 1) == 0)
  {
    v58 = a1;
    v64 = v4;
    v72 = v1;
    v52 = a1[4];
    v4 = v64;
    v1 = v72;
    v3 = &unk_254519000;
    v40 = v39;
    v15 = v52;
    a1 = v58;
    if (v40)
    {
      v41 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v41 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v41;
      v15 = v52;
      a1 = v58;
      v4 = v64;
      v1 = v72;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v16 = HIDWORD(v15);
  v17 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v15) ^ HIDWORD(v15));
  v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  v18 = a1[5];
  if ((v16 & 1) == 0)
  {
    v59 = a1;
    v65 = v4;
    v73 = v1;
    v53 = a1[5];
    v4 = v65;
    v1 = v73;
    v3 = &unk_254519000;
    v43 = v42;
    v18 = v53;
    a1 = v59;
    if (v43)
    {
      v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v44 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      v18 = v53;
      a1 = v59;
      v4 = v65;
      v1 = v73;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v19 = HIDWORD(v18);
  v20 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v18) ^ HIDWORD(v18));
  v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  v21 = a1[6];
  if ((v20 & 1) == 0)
  {
    v66 = v4;
    v74 = v1;
    v60 = a1[6];
    v21 = v60;
    v4 = v66;
    v1 = v74;
    v3 = &unk_254519000;
    if (v45)
    {
      v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v46 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      v21 = v60;
      v4 = v66;
      v1 = v74;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v22 = HIDWORD(v21);
  v23 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v21) ^ HIDWORD(v21));
  v76 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) ^ ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) >> 47));
  v84 = 0;
  memset(v83, 0, sizeof(v83));
  memset(v82, 0, sizeof(v82));
  if ((v23 & 1) == 0)
  {
    v67 = v4;
    v75 = v1;
    v4 = v67;
    v1 = v75;
    v3 = &unk_254519000;
    if (v47)
    {
      v48 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v48 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v48;
      v4 = v67;
      v1 = v75;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v24 = HIDWORD(v1);
  v25 = 0x9DDFEA08EB382D69 * ((v4 + 8 * v1) ^ HIDWORD(v1));
  v85 = v3[373];
  *(_QWORD *)&v82[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v24 ^ (v25 >> 47) ^ v25)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v82, 0, (_QWORD *)v82 + 1, (char *)v83, (uint64_t *)&v81, (uint64_t *)&v80, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77, (uint64_t *)&v76);
}

uint64_t mlir::mps::Conv2DDataGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"groups", 6, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v9);
  v10 = a2[6];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v10);
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  const void **v9;
  const void **v10;
  const void **v11;
  uint64_t v12;
  const void **v13;
  uint64_t v14;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (const void **)"groups", (const char *)6, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (const void **)"padding_style", (const char *)0xD, a3, a4))
          {
            v13 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v13, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
            {
              v14 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v14, (const void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout";
        v31 = 54;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *Shape;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  const void **v38;
  _QWORD v39[2];
  uint64_t OperandRange;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD *v54;
  char v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_9;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v41 = a1;
  v42 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v45 = v12;
  v46 = Type;
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  v56 = 4;
  if (v14 == 1 && *Shape == v56)
  {
    v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = "attribute '";
    v43 = 11;
    v17 = &v41;
    v18 = (char *)v47;
    if (v48 >= v49)
    {
      v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v18 = (char *)v47;
        v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v17 = &v41;
        v18 = (char *)v47;
      }
    }
    v19 = &v18[24 * v48];
    v20 = *(_OWORD *)v17;
    *((_QWORD *)v19 + 2) = v17[2];
    *(_OWORD *)v19 = v20;
    ++v48;
    if (v45)
    {
      v44 = 261;
      v41 = a2;
      v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        v43 = 68;
        v21 = &v41;
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = __p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = *--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD *v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 64-bit unsigned integer attribute";
        v33 = 65;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid padding_style";
        v31 = 51;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::mps::Conv2DDataGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[110];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PaddingStyleAttr]";
  v41 = 77;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t *mlir::mps::Conv2DDataGradientOp::getGroups(mlir::mps::Conv2DDataGradientOp *this)
{
  unint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  unsigned int v5;
  uint64_t v6;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  v6 = *(_QWORD *)(v1 + 24);
  mlir::IntegerAttr::getValue(&v6, (llvm::APInt *)&v4);
  if (v5 <= 0x40)
    return v4;
  v3 = *v4;
  MEMORY[0x20BD002D4]();
  return (uint64_t *)v3;
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t ODSOperands;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  uint64_t v62;
  uint64_t NextResultAtOffset;
  uint64_t v64;
  unsigned int v65;
  const void **v66[4];
  __int16 v67;
  _QWORD v68[3];
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (!*v3)
  {
    v66[0] = (const void **)"requires attribute 'data_layout'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v28 = __p;
    if (__p)
    {
      v29 = v74;
      v30 = __p;
      if (v74 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v74 = v28;
      operator delete(v30);
    }
    v31 = v71;
    if (v71)
    {
      v32 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
LABEL_96:
      v33 = v71;
LABEL_97:
      v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70)
      free(v69);
    return v27;
  }
  v5 = (const void **)v3[1];
  if (!v5)
  {
    v66[0] = (const void **)"requires attribute 'dilation_rates'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v36 = __p;
    if (__p)
    {
      v37 = v74;
      v38 = __p;
      if (v74 != __p)
      {
        do
          v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        v38 = __p;
      }
      v74 = v36;
      operator delete(v38);
    }
    v31 = v71;
    if (v71)
    {
      v39 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v41 = *--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v6 = (const void **)v3[2];
  if (!v6)
  {
    v66[0] = (const void **)"requires attribute 'explicit_padding'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v42 = __p;
    if (__p)
    {
      v43 = v74;
      v44 = __p;
      if (v74 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v74 = v42;
      operator delete(v44);
    }
    v31 = v71;
    if (v71)
    {
      v45 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v47 = *--v45;
        v46 = v47;
        *v45 = 0;
        if (v47)
          MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v7 = (const void **)v3[3];
  if (!v7)
  {
    v66[0] = (const void **)"requires attribute 'groups'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v48 = __p;
    if (__p)
    {
      v49 = v74;
      v50 = __p;
      if (v74 != __p)
      {
        do
          v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        v50 = __p;
      }
      v74 = v48;
      operator delete(v50);
    }
    v31 = v71;
    if (v71)
    {
      v51 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v53 = *--v51;
        v52 = v53;
        *v51 = 0;
        if (v53)
          MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v8 = v3[4];
  if (!v8)
  {
    v66[0] = (const void **)"requires attribute 'padding_style'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v54 = __p;
    if (__p)
    {
      v55 = v74;
      v56 = __p;
      if (v74 != __p)
      {
        do
          v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        v56 = __p;
      }
      v74 = v54;
      operator delete(v56);
    }
    v31 = v71;
    if (v71)
    {
      v57 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v59 = *--v57;
        v58 = v59;
        *v57 = 0;
        if (v59)
          MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v9 = (const void **)v3[5];
  if (!v9)
  {
    v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (const void **)v61;
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v26 = v68;
    goto LABEL_104;
  }
  v10 = v3[6];
  if (!v10)
  {
    v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v11 = *this;
  v12 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v11, v12, (const void **)"operand", (const void **)7, 0))return 0;
  v13 = 1;
  ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v15)
  {
    v16 = v15;
    v17 = 0;
    v18 = ODSOperands + 24;
    while (1)
    {
      v19 = *this;
      v20 = *(_QWORD *)(*(_QWORD *)v18 + 8) & 0xFFFFFFFFFFFFFFF8;
      v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v19, v20, (const void **)"operand", (const void **)7, (int)v17 + 1))return 0;
      ++v17;
      v18 += 32;
      if (v16 == v17)
      {
        v13 = v17 + 1;
        break;
      }
    }
  }
  v21 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (const void **)"operand group starting at #";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    v64 = v23;
    v26 = (_QWORD *)mlir::InFlightDiagnostic::operator<<<unsigned long>(v25, &v64);
LABEL_104:
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v13))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v62 = (uint64_t)(*this - 2);
  else
    v62 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::Conv2DOpGenericAdaptorBase::Conv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[112];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::Conv2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v7 = (const void **)v3[3];
        if (v7)
        {
          v8 = v3[4];
          if (v8)
          {
            v9 = (const void **)v3[5];
            if (v9)
            {
              v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = __p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = *--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
            }
            while (v43 != v17);
LABEL_94:
            v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = __p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_95;
            do
            {
              v39 = *--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = __p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_96;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_95;
          do
          {
            v33 = *--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = __p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_96;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_95;
        do
        {
          v27 = *--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_96;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_95;
      do
      {
        v21 = *--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DWeightsGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorB"
              "ase::Properties]";
        v15 = 122;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[114];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::Conv2DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v7 = (const void **)v3[3];
        if (v7)
        {
          v8 = v3[4];
          if (v8)
          {
            v9 = (const void **)v3[5];
            if (v9)
            {
              v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this,
                                         *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                         (const void **)"operand",
                                         (const void **)7,
                                         2u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = __p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = *--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
            }
            while (v43 != v17);
LABEL_95:
            v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = __p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_96;
            do
            {
              v39 = *--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = __p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_97;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_96;
          do
          {
            v33 = *--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = __p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_97;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_96;
        do
        {
          v27 = *--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_97;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_96;
      do
      {
        v21 = *--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Conv3DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d_data_gradient", 25, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>(uint64_t *a1)
{
  uint64_t v2;
  uint64_t NumElements;
  BOOL v4;
  uint64_t v5;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t *v13;
  unsigned int v14;

  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  v2 = *a1;
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if (!v13)
        return 0;
    }
    else
    {
      v5 = *v13;
      MEMORY[0x20BD002D4]();
      if (!v5)
        return 0;
    }
    ++v12;
  }
  return 1;
}

uint64_t mlir::mps::Conv3DDataGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _DWORD *v8;
  _QWORD *v9;
  const void **v10;
  const void **v11;
  uint64_t v12;
  _QWORD *v13;
  _DWORD *v14;
  _BOOL8 result;

  v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (const void **)"groups", (const char *)6, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (const void **)"padding_style", (const char *)0xD, a3, a4))
          {
            v13 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v13, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
            {
              v14 = (_DWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v14, (const void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 7) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NDHWC or NCDHW";
        v31 = 79;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(_QWORD *a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *Shape;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t NumElements;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  _QWORD *v41;
  _QWORD v42[2];
  uint64_t OperandRange;
  _QWORD *v44;
  _QWORD v45[2];
  _QWORD v46[2];
  uint64_t *v47;
  unsigned int v48;
  const void **v49;
  const char *v50;
  uint64_t v51;
  __int16 v52;
  const void **v53;
  char v54[8];
  uint64_t v55;
  void *v56;
  unsigned int v57;
  unsigned int v58;
  _BYTE v59[96];
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_7;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46[0] = v12;
  v46[1] = Type;
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)v46);
  v65 = 5;
  if (v14 != 1 || *Shape != v65)
    goto LABEL_7;
  v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      v33 = *v47;
      MEMORY[0x20BD002D4]();
      if (!v33)
        goto LABEL_7;
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    return 1;
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    v50 = "attribute '";
    v51 = 11;
    v15 = &v49;
    v16 = (char *)v56;
    if (v57 >= v58)
    {
      v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        v39 = (char *)&v49 - (_BYTE *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v16 = (char *)v56;
        v15 = (const void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v15 = &v49;
        v16 = (char *)v56;
      }
    }
    v17 = &v16[24 * v57];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    ++v57;
    if (v53)
    {
      v52 = 261;
      v49 = a2;
      v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {5}";
        v51 = 77;
        v19 = &v49;
        v20 = (char *)v56;
        if (v57 >= v58)
        {
          v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            v40 = (char *)&v49 - (_BYTE *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v20 = (char *)v56;
            v19 = (const void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v19 = &v49;
            v20 = (char *)v56;
          }
        }
        v21 = &v20[24 * v57];
        v22 = *(_OWORD *)v19;
        *((_QWORD *)v21 + 2) = v19[2];
        *(_OWORD *)v21 = v22;
        ++v57;
      }
    }
  }
  v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  if (v64)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v63;
      v26 = __p;
      if (v63 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v63 = v24;
      operator delete(v26);
    }
    v27 = v60;
    if (v60)
    {
      v28 = v61;
      v29 = v60;
      if (v61 != v60)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v60;
      }
      v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59)
      free(v56);
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *Shape;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v35;
  unint64_t v36;
  int64_t v37;
  int64_t v38;
  const void **v39;
  _QWORD v40[2];
  uint64_t OperandRange;
  const void **v42;
  const char *v43;
  uint64_t v44;
  __int16 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_13;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v42 = a1;
  v43 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46 = v12;
  v47 = Type;
  Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
  v57 = xmmword_207AB5440;
  if (v14 == 2 && *Shape == (_QWORD)v57 && Shape[1] == *((_QWORD *)&v57 + 1))
  {
    v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    v43 = "attribute '";
    v44 = 11;
    v18 = &v42;
    v19 = (char *)v48;
    if (v49 >= v50)
    {
      v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        v37 = (char *)&v42 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v19 = (char *)v48;
        v18 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v18 = &v42;
        v19 = (char *)v48;
      }
    }
    v20 = &v19[24 * v49];
    v21 = *(_OWORD *)v18;
    *((_QWORD *)v20 + 2) = v18[2];
    *(_OWORD *)v20 = v21;
    ++v49;
    if (v46)
    {
      v45 = 261;
      v42 = a2;
      v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {5, 2}";
        v44 = 71;
        v22 = &v42;
        v23 = (char *)v48;
        if (v49 >= v50)
        {
          v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            v38 = (char *)&v42 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v23 = (char *)v48;
            v22 = (const void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v22 = &v42;
            v23 = (char *)v48;
          }
        }
        v24 = &v23[24 * v49];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = v22[2];
        *(_OWORD *)v24 = v25;
        ++v49;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  if (v56)
  {
    v26 = __p;
    if (__p)
    {
      v27 = v55;
      v28 = __p;
      if (v55 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v55 = v26;
      operator delete(v28);
    }
    v29 = v52;
    if (v52)
    {
      v30 = v53;
      v31 = v52;
      if (v53 != v52)
      {
        do
        {
          v33 = *--v30;
          v32 = v33;
          *v30 = 0;
          if (v33)
            MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
        }
        while (v30 != v29);
        v31 = v52;
      }
      v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51)
      free(v48);
  }
  return v17;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 9) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of DHWIO or OIDHW";
        v31 = 79;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

BOOL mlir::mps::Conv3DDataGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[116];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  uint64_t *v11;
  const void **v12;
  unsigned int v13;
  uint64_t ODSOperands;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  const void **v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v61;
  uint64_t v62;
  uint64_t NextResultAtOffset;
  uint64_t v64;
  unsigned int v65;
  const void **v66[4];
  __int16 v67;
  _QWORD v68[3];
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD *v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (!*(_QWORD *)v3)
  {
    v66[0] = (const void **)"requires attribute 'data_layout'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v28 = __p;
    if (__p)
    {
      v29 = v74;
      v30 = __p;
      if (v74 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v74 = v28;
      operator delete(v30);
    }
    v31 = v71;
    if (v71)
    {
      v32 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
LABEL_96:
      v33 = v71;
LABEL_97:
      v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70)
      free(v69);
    return v27;
  }
  v5 = *(_QWORD **)(v3 + 8);
  if (!v5)
  {
    v66[0] = (const void **)"requires attribute 'dilation_rates'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v36 = __p;
    if (__p)
    {
      v37 = v74;
      v38 = __p;
      if (v74 != __p)
      {
        do
          v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        v38 = __p;
      }
      v74 = v36;
      operator delete(v38);
    }
    v31 = v71;
    if (v71)
    {
      v39 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v41 = *--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v6 = *(const void ***)(v3 + 16);
  if (!v6)
  {
    v66[0] = (const void **)"requires attribute 'explicit_padding'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v42 = __p;
    if (__p)
    {
      v43 = v74;
      v44 = __p;
      if (v74 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v74 = v42;
      operator delete(v44);
    }
    v31 = v71;
    if (v71)
    {
      v45 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v47 = *--v45;
        v46 = v47;
        *v45 = 0;
        if (v47)
          MEMORY[0x20BD002D4](v46, 0x1000C8077774924);
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v7 = *(const void ***)(v3 + 24);
  if (!v7)
  {
    v66[0] = (const void **)"requires attribute 'groups'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v48 = __p;
    if (__p)
    {
      v49 = v74;
      v50 = __p;
      if (v74 != __p)
      {
        do
          v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        v50 = __p;
      }
      v74 = v48;
      operator delete(v50);
    }
    v31 = v71;
    if (v71)
    {
      v51 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v53 = *--v51;
        v52 = v53;
        *v51 = 0;
        if (v53)
          MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v8 = *(_QWORD *)(v3 + 32);
  if (!v8)
  {
    v66[0] = (const void **)"requires attribute 'padding_style'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v54 = __p;
    if (__p)
    {
      v55 = v74;
      v56 = __p;
      if (v74 != __p)
      {
        do
          v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        v56 = __p;
      }
      v74 = v54;
      operator delete(v56);
    }
    v31 = v71;
    if (v71)
    {
      v57 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v59 = *--v57;
        v58 = v59;
        *v57 = 0;
        if (v59)
          MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v9 = *(_QWORD **)(v3 + 40);
  if (!v9)
  {
    v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (const void **)v61;
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v26 = v68;
    goto LABEL_104;
  }
  v10 = *(_DWORD **)(v3 + 48);
  if (!v10)
  {
    v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v11 = *this;
  v12 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(v11, v12, (const void **)"operand", 7, 0))return 0;
  v13 = 1;
  ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v15)
  {
    v16 = v15;
    v17 = 0;
    v18 = ODSOperands + 24;
    while (1)
    {
      v19 = *this;
      v20 = (const void **)(*(_QWORD *)(*(_QWORD *)v18 + 8) & 0xFFFFFFFFFFFFFFF8);
      v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(v19, v20, (const void **)"operand", 7, (int)v17 + 1))return 0;
      ++v17;
      v18 += 32;
      if (v16 == v17)
      {
        v13 = v17 + 1;
        break;
      }
    }
  }
  v21 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (const void **)"operand group starting at #";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    v64 = v23;
    v26 = (_QWORD *)mlir::InFlightDiagnostic::operator<<<unsigned long>(v25, &v64);
LABEL_104:
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(*this, (const void **)(*(_QWORD *)(*(_QWORD *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v13))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v62 = (uint64_t)(*this - 2);
  else
    v62 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v13;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  unint64_t v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  BOOL v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  const void **v55;
  uint64_t v56;
  __int16 v57;
  uint64_t OperandRange;
  const void **v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[3];
  void *v63;
  unsigned int v64;
  unsigned int v65;
  _BYTE v66[96];
  void *v67;
  _QWORD *v68;
  void *__p;
  _QWORD *v70;
  char v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v62[0] = a2;
    v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    v10 = *a2;
    v42 = (void *)*((_QWORD *)*a2 + 17);
    if (v42 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v42 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_21;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_21;
  }
  v55 = a2;
  v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v59 = a2;
    v60 = v13;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v59);
    if (v14 >= 5)
      return 1;
  }
LABEL_21:
  v57 = 261;
  v55 = a3;
  v56 = a4;
  mlir::Operation::emitOpError(a1, &v55, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    v60 = (uint64_t)" #";
    v61 = 2;
    v15 = &v59;
    v16 = (char *)v63;
    if (v64 >= v65)
    {
      v45 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        v51 = (char *)&v59 - (_BYTE *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        v16 = (char *)v63;
        v15 = (const void ***)((char *)v63 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        v15 = &v59;
        v16 = (char *)v63;
      }
    }
    v17 = &v16[24 * v64];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      v60 = a5;
      v20 = &v59;
      v21 = (char *)v63;
      if (v19 >= v65)
      {
        v46 = v19 + 1;
        v47 = (char *)v63 + 24 * v19 > (char *)&v59;
        if (v63 <= &v59 && v47)
        {
          v52 = (char *)&v59 - (_BYTE *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          v21 = (char *)v63;
          v20 = (const void ***)((char *)v63 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          v20 = &v59;
          v21 = (char *)v63;
        }
      }
      v22 = &v21[24 * v64];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        v60 = (uint64_t)" must be unranked tensor of mps native type values or ranked tensor type with rank equal to or gr"
                       "eater than 5, but got ";
        v61 = 119;
        v25 = &v59;
        v26 = (char *)v63;
        if (v24 >= v65)
        {
          v48 = v24 + 1;
          v49 = (char *)v63 + 24 * v24 > (char *)&v59;
          if (v63 <= &v59 && v49)
          {
            v53 = (char *)&v59 - (_BYTE *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            v26 = (char *)v63;
            v25 = (const void ***)((char *)v63 + v53);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            v25 = &v59;
            v26 = (char *)v63;
          }
        }
        v27 = &v26[24 * v64];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v64;
        if (v62[0])
        {
          v29 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          v30 = (char *)v63;
          if (v64 >= v65)
          {
            v50 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              v54 = (char *)&v59 - (_BYTE *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              v30 = (char *)v63;
              v29 = (const void ***)((char *)v63 + v54);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              v29 = &v59;
              v30 = (char *)v63;
            }
          }
          v31 = &v30[24 * v64];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v64;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  if (v71)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v70;
      v36 = __p;
      if (v70 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v70 = v34;
      operator delete(v36);
    }
    v37 = v67;
    if (v67)
    {
      v38 = v68;
      v39 = v67;
      if (v68 != v67)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v67;
      }
      v68 = v37;
      operator delete(v39);
    }
    if (v63 != v66)
      free(v63);
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD *v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      goto LABEL_33;
    goto LABEL_3;
  }
  v61[0] = a2;
  v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    return 1;
  }
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_3:
    v53 = a2;
    v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
    {
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 == 5)
      {
        v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
        v56[0] = a2;
        v56[1] = v14;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          return 1;
        }
      }
    }
  }
LABEL_33:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v15 = &v58;
    v16 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = (char *)v62;
        v15 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v15 = &v58;
        v16 = (char *)v62;
      }
    }
    v17 = &v16[24 * v63];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v20 = &v58;
      v21 = (char *)v62;
      if (v19 >= v64)
      {
        v44 = v19 + 1;
        v45 = (char *)v62 + 24 * v19 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = (char *)v62;
          v20 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v20 = &v58;
          v21 = (char *)v62;
        }
      }
      v22 = &v21[24 * v63];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of mps native type values or 5D tensor of mps native type values, but got ";
        v60 = 99;
        v25 = &v58;
        v26 = (char *)v62;
        if (v24 >= v64)
        {
          v46 = v24 + 1;
          v47 = (char *)v62 + 24 * v24 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = (char *)v62;
            v25 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v25 = &v58;
            v26 = (char *)v62;
          }
        }
        v27 = &v26[24 * v63];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v63;
        if (v61[0])
        {
          v29 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v30 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = (char *)v62;
              v29 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v29 = &v58;
              v30 = (char *)v62;
            }
          }
          v31 = &v30[24 * v63];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v63;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD *v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_10;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 1)
        goto LABEL_10;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
        goto LABEL_10;
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or 1D tensor of 32-bit signed integer values, but got ";
        v60 = 111;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::Conv3DOpGenericAdaptorBase::Conv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv3DOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[118];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::Conv3DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(const void ***)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD *)(v3 + 32);
          if (v8)
          {
            v9 = *(_QWORD **)(v3 + 40);
            if (v9)
            {
              v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = __p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = *--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
            }
            while (v43 != v17);
LABEL_94:
            v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = __p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_95;
            do
            {
              v39 = *--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = __p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_96;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_95;
          do
          {
            v33 = *--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = __p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_96;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_95;
        do
        {
          v27 = *--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_96;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_95;
      do
      {
        v21 = *--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DWeightsGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorB"
              "ase::Properties]";
        v15 = 122;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[120];
    return a1[32];
  }
  return result;
}

BOOL mlir::mps::Conv3DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(const void ***)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD *)(v3 + 32);
          if (v8)
          {
            v9 = *(_QWORD **)(v3 + 40);
            if (v9)
            {
              v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(*this,
                                         (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                                         (const void **)"operand",
                                         7,
                                         2u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = __p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = *--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
            }
            while (v43 != v17);
LABEL_95:
            v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = __p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_96;
            do
            {
              v39 = *--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = __p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_97;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_96;
          do
          {
            v33 = *--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = __p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_97;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_96;
        do
        {
          v27 = *--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_97;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_96;
      do
      {
        v21 = *--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v13;
  _QWORD *Shape;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  BOOL v50;
  unint64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  int64_t v55;
  const void **v56;
  uint64_t v57;
  __int16 v58;
  uint64_t OperandRange;
  const void **v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD *v71;
  char v72;
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    v10 = *a2;
    v17 = (void *)*((_QWORD *)*a2 + 17);
    if (v17 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v17 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_17;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_17;
  }
  v56 = a2;
  v57 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v56);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
  {
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v60 = a2;
    v61 = v13;
    Shape = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
    v73 = 5;
    if (v15 == 1 && *Shape == v73)
      return 1;
  }
LABEL_17:
  v58 = 261;
  v56 = a3;
  v57 = a4;
  mlir::Operation::emitOpError(a1, &v56, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(v60) = 3;
    v61 = (uint64_t)" #";
    v62 = 2;
    v19 = &v60;
    v20 = (char *)v64;
    if (v65 >= v66)
    {
      v46 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        v52 = (char *)&v60 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        v20 = (char *)v64;
        v19 = (const void ***)((char *)v64 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        v19 = &v60;
        v20 = (char *)v64;
      }
    }
    v21 = &v20[24 * v65];
    v22 = *(_OWORD *)v19;
    *((_QWORD *)v21 + 2) = v19[2];
    *(_OWORD *)v21 = v22;
    v23 = ++v65;
    if (v63[0])
    {
      LODWORD(v60) = 5;
      v61 = a5;
      v24 = &v60;
      v25 = (char *)v64;
      if (v23 >= v66)
      {
        v47 = v23 + 1;
        v48 = (char *)v64 + 24 * v23 > (char *)&v60;
        if (v64 <= &v60 && v48)
        {
          v53 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          v25 = (char *)v64;
          v24 = (const void ***)((char *)v64 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          v24 = &v60;
          v25 = (char *)v64;
        }
      }
      v26 = &v25[24 * v65];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      v28 = ++v65;
      if (v63[0])
      {
        LODWORD(v60) = 3;
        v61 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or static-shape defined tensor with shap"
                       "e equal to [5], but got ";
        v62 = 121;
        v29 = &v60;
        v30 = (char *)v64;
        if (v28 >= v66)
        {
          v49 = v28 + 1;
          v50 = (char *)v64 + 24 * v28 > (char *)&v60;
          if (v64 <= &v60 && v50)
          {
            v54 = (char *)&v60 - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            v30 = (char *)v64;
            v29 = (const void ***)((char *)v64 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            v29 = &v60;
            v30 = (char *)v64;
          }
        }
        v31 = &v30[24 * v65];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v65;
        if (v63[0])
        {
          v33 = &v60;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, (uint64_t)a2);
          v34 = (char *)v64;
          if (v65 >= v66)
          {
            v51 = v65 + 1;
            if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
            {
              v55 = (char *)&v60 - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              v34 = (char *)v64;
              v33 = (const void ***)((char *)v64 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              v33 = &v60;
              v34 = (char *)v64;
            }
          }
          v35 = &v34[24 * v65];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v65;
        }
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v37 = __p;
    if (__p)
    {
      v38 = v71;
      v39 = __p;
      if (v71 != __p)
      {
        do
          v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        v39 = __p;
      }
      v71 = v37;
      operator delete(v39);
    }
    v40 = v68;
    if (v68)
    {
      v41 = v69;
      v42 = v68;
      if (v69 != v68)
      {
        do
        {
          v44 = *--v41;
          v43 = v44;
          *v41 = 0;
          if (v44)
            MEMORY[0x20BD002D4](v43, 0x1000C8077774924);
        }
        while (v41 != v40);
        v42 = v68;
      }
      v69 = v40;
      operator delete(v42);
    }
    if (v64 != v67)
      free(v64);
  }
  return v16;
}

uint64_t mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.cos", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::CoshOpGenericAdaptorBase::CoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.cosh", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CostVolumeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  int64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  uint64_t v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  _QWORD v73[3];
  void *v74;
  unsigned int v75;
  unsigned int v76;
  _BYTE v77[96];
  void *v78;
  _QWORD *v79;
  void *__p;
  _QWORD *v81;
  char v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v69 = v6;
  if (!v6)
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      v71 = "expected DictionaryAttr to set properties";
      v72 = 41;
      v28 = &v70;
      v29 = (char *)v74;
      if (v75 >= v76)
      {
        v59 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          v64 = (char *)&v70 - (_BYTE *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          v29 = (char *)v74;
          v28 = (uint64_t *)((char *)v74 + v64);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          v28 = &v70;
          v29 = (char *)v74;
        }
      }
      v30 = &v29[24 * v75];
      v31 = *(_OWORD *)v28;
      *((_QWORD *)v30 + 2) = v28[2];
      *(_OWORD *)v30 = v31;
      ++v75;
      if (v73[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
    }
    if (!v82)
      return 0;
    v32 = __p;
    if (__p)
    {
      v33 = v81;
      v34 = __p;
      if (v81 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v81 = v32;
      operator delete(v34);
    }
    v23 = v78;
    if (!v78)
      goto LABEL_64;
    v35 = v79;
    v25 = v78;
    if (v79 == v78)
    {
LABEL_63:
      v79 = v23;
      operator delete(v25);
LABEL_64:
      if (v74 != v77)
        free(v74);
      return 0;
    }
    do
    {
      v37 = *--v35;
      v36 = v37;
      *v35 = 0;
      if (v37)
        MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
    }
    while (v35 != v23);
LABEL_62:
    v25 = v78;
    goto LABEL_63;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v69, "coord_is_x_only", 0xFuLL);
  if (!v8)
    goto LABEL_8;
  v9 = (uint64_t)v8;
  if (!mlir::BoolAttr::classof(v8))
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      v72 = 60;
      v38 = &v70;
      v39 = (char *)v74;
      if (v75 >= v76)
      {
        v60 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          v65 = (char *)&v70 - (_BYTE *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          v39 = (char *)v74;
          v38 = (uint64_t *)((char *)v74 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          v38 = &v70;
          v39 = (char *)v74;
        }
      }
      v40 = &v39[24 * v75];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = v38[2];
      *(_OWORD *)v40 = v41;
      ++v75;
      if (v73[0])
      {
        v42 = &v70;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v9);
        v43 = (char *)v74;
        if (v75 >= v76)
        {
          v62 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            v67 = (char *)&v70 - (_BYTE *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            v43 = (char *)v74;
            v42 = (uint64_t *)((char *)v74 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            v42 = &v70;
            v43 = (char *)v74;
          }
        }
        v44 = &v43[24 * v75];
        v45 = *(_OWORD *)v42;
        *((_QWORD *)v44 + 2) = v42[2];
        *(_OWORD *)v44 = v45;
        ++v75;
        if (v73[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
      }
    }
    if (!v82)
      return 0;
    v46 = __p;
    if (__p)
    {
      v47 = v81;
      v48 = __p;
      if (v81 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v81 = v46;
      operator delete(v48);
    }
    v23 = v78;
    if (!v78)
      goto LABEL_64;
    v49 = v79;
    v25 = v78;
    if (v79 == v78)
      goto LABEL_63;
    do
    {
      v51 = *--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
    }
    while (v49 != v23);
    goto LABEL_62;
  }
  *a1 = v9;
LABEL_8:
  v10 = mlir::DictionaryAttr::get((uint64_t)&v69, "data_layout", 0xBuLL);
  if (v10)
  {
    v11 = v10;
    if (*(_UNKNOWN **)(*(_QWORD *)v10 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    {
      a3(v73, a4);
      if (v73[0])
      {
        LODWORD(v70) = 3;
        v72 = 56;
        v12 = &v70;
        v13 = (char *)v74;
        if (v75 >= v76)
        {
          v61 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            v66 = (char *)&v70 - (_BYTE *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            v13 = (char *)v74;
            v12 = (uint64_t *)((char *)v74 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            v12 = &v70;
            v13 = (char *)v74;
          }
        }
        v14 = &v13[24 * v75];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v75;
        if (v73[0])
        {
          v16 = &v70;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v11);
          v17 = (char *)v74;
          if (v75 >= v76)
          {
            v63 = v75 + 1;
            if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
            {
              v68 = (char *)&v70 - (_BYTE *)v74;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              v17 = (char *)v74;
              v16 = (uint64_t *)((char *)v74 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              v16 = &v70;
              v17 = (char *)v74;
            }
          }
          v18 = &v17[24 * v75];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = v16[2];
          *(_OWORD *)v18 = v19;
          ++v75;
          if (v73[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
        }
      }
      if (!v82)
        return 0;
      v20 = __p;
      if (__p)
      {
        v21 = v81;
        v22 = __p;
        if (v81 != __p)
        {
          do
            v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          v22 = __p;
        }
        v81 = v20;
        operator delete(v22);
      }
      v23 = v78;
      if (!v78)
        goto LABEL_64;
      v24 = v79;
      v25 = v78;
      if (v79 == v78)
        goto LABEL_63;
      do
      {
        v27 = *--v24;
        v26 = v27;
        *v24 = 0;
        if (v27)
          MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
      }
      while (v24 != v23);
      goto LABEL_62;
    }
    a1[1] = v10;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v69, "normalize_coordinates", 0x15uLL);
  v70 = v52;
  if (!v52)
  {
LABEL_71:
    v54 = mlir::DictionaryAttr::get((uint64_t)&v69, "relative_coordinates", 0x14uLL);
    v70 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[3] = v54;
    }
    v55 = mlir::DictionaryAttr::get((uint64_t)&v69, "similarity_type", 0xFuLL);
    v70 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[4] = v55;
    }
    v56 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_height", 0xDuLL);
    v70 = v56;
    if (v56)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[5] = v56;
    }
    v57 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_width", 0xCuLL);
    v70 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[6] = v57;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v73, a4);
LABEL_86:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v70);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v73);
  return 0;
}

uint64_t mlir::mps::CostVolumeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[7];

  v51[6] = *MEMORY[0x24BDAC8D0];
  v48 = a1;
  v49 = v51;
  v50 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coord_is_x_only", 15, *a2);
  v5 = v4;
  v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    v6 = v50;
  }
  v7 = (uint64_t *)((char *)v49 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, v9);
    v12 = v11;
    v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v13 = v50;
    }
    v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v15);
    v18 = v17;
    v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v19 = v50;
    }
    v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"relative_coordinates", 20, v21);
    v24 = v23;
    v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v25 = v50;
    }
    v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"similarity_type", 15, v27);
    v30 = v29;
    v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v31 = v50;
    }
    v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_height", 13, v33);
    v36 = v35;
    v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v37 = v50;
    }
    v38 = (uint64_t *)((char *)v49 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_width", 12, v39);
    v42 = v41;
    v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v43 = v50;
    }
    v44 = (uint64_t *)((char *)v49 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v45 = v49;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v49 == v51)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (mlir::MLIRContext *)v49, v8);
  v45 = v49;
  if (v49 != v51)
LABEL_32:
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CostVolumeOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "data_layout", __n))
        return 0;
      return a2[1];
    case 0xCuLL:
      if (memcmp(__s1, "window_width", __n))
        return 0;
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "window_height", __n))
        return 0;
      return a2[5];
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
      return 0;
    case 0xFuLL:
      if (*(_QWORD *)__s1 == 0x73695F64726F6F63 && *(_QWORD *)(__s1 + 7) == 0x796C6E6F5F785F73)
        return *a2;
      if (memcmp(__s1, "similarity_type", __n))
        return 0;
      return a2[4];
    case 0x14uLL:
      if (memcmp(__s1, "relative_coordinates", __n))
        return 0;
      return a2[3];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CostVolumeOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 0xBuLL:
      result = memcmp(__s1, "data_layout", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v12 = a4;
          else
            v12 = 0;
          v5[1] = v12;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xCuLL:
      result = memcmp(__s1, "window_width", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v6 = a4;
          else
            v6 = 0;
          v5[6] = v6;
        }
        else
        {
          v5[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "window_height", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          v5[5] = v7;
        }
        else
        {
          v5[5] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(_QWORD *)__s1 == 0x73695F64726F6F63 && *(_QWORD *)(__s1 + 7) == 0x796C6E6F5F785F73)
      {
        if (a4)
        {
          result = mlir::BoolAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          *v5 = v13;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "similarity_type", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
              v9 = a4;
            else
              v9 = 0;
            v5[4] = v9;
          }
          else
          {
            v5[4] = 0;
          }
        }
      }
      break;
    case 0x14uLL:
      result = memcmp(__s1, "relative_coordinates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0x15uLL:
      result = memcmp(__s1, "normalize_coordinates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v5[2] = v11;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CostVolumeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"coord_is_x_only", 15, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"relative_coordinates", 20, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"similarity_type", 15, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"window_height", 13, v9);
  v10 = a2[6];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"window_width", 12, v10);
}

BOOL mlir::mps::CostVolumeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _QWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void **v13;
  const void **v14;
  _BOOL8 result;

  v8 = (_QWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v8, (const void **)"coord_is_x_only", (const char *)0xF, a3, a4))
  {
    v9 = (_DWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v9, (const void **)"data_layout", (const char *)0xB, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"normalize_coordinates", (const char *)0x15, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"relative_coordinates", (const char *)0x14, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v12, (const void **)"similarity_type", (const char *)0xF, a3, a4))
          {
            v13 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v13, (const void **)"window_height", (const char *)0xD, a3, a4))
            {
              v14 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v14, (const void **)"window_width", (const char *)0xC, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid SimilarityType";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::mps::CostVolumeOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::BoolAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties]";
        v15 = 111;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[122];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SimilarityTypeAttr]";
  v41 = 79;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

mlir::MLIRContext *mlir::mps::CostVolumeOp::populateDefaultProperties(uint64_t a1, _QWORD *a2)
{
  mlir::MLIRContext *result;
  uint64_t IntegerType;
  uint64_t v5;
  mlir::MLIRContext *v6;
  unsigned __int8 **v7;
  mlir::MLIRContext *v8;
  unsigned __int8 **AttributeUniquer;
  mlir::MLIRContext *v10;
  unsigned int v11;
  void *v12;
  mlir::MLIRContext *v13;

  v12 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v10 = result;
  if (a2[5])
  {
    if (a2[6])
      goto LABEL_3;
  }
  else
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
    result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, IntegerType, 1);
    a2[5] = result;
    if (a2[6])
    {
LABEL_3:
      if (a2[4])
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  v5 = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
  result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, v5, 1);
  a2[6] = result;
  if (a2[4])
  {
LABEL_4:
    if (a2[1])
      return result;
LABEL_9:
    v8 = v10;
    v11 = 0;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
    v12 = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    v13 = v8;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v11);
    a2[1] = result;
    return result;
  }
LABEL_8:
  v6 = v10;
  v11 = 0;
  v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v13 = v6;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v11);
  a2[4] = result;
  if (!a2[1])
    goto LABEL_9;
  return result;
}

BOOL mlir::mps::CostVolumeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void **v9;
  const void **v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t *v14;

  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  v5 = *(_DWORD **)(v3 + 8);
  v6 = *(_QWORD *)(v3 + 16);
  v7 = *(_QWORD *)(v3 + 24);
  v8 = *(_QWORD *)(v3 + 32);
  v9 = *(const void ***)(v3 + 40);
  v10 = *(const void ***)(v3 + 48);
  v14 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"relative_coordinates", (const char *)0x14, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v9, (const void **)"window_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v10, (const void **)"window_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v8, (const void **)"similarity_type", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v5, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v4, (const void **)"coord_is_x_only", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v11 = (uint64_t)(*this - 2);
  else
    v11 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD *v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_14;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 4)
        goto LABEL_14;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF16((mlir::Type *)&OperandRange)
        && !mlir::Type::isF32((mlir::Type *)&OperandRange)
        && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
      {
        goto LABEL_14;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_14:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of floating point values or 4D tensor of floating point values, but got ";
        v60 = 97;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = __p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::CreateComplexOpGenericAdaptorBase::CreateComplexOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.create_complex", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CreateComplexOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t ElementTypeOrSelf;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24));
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 56)))
  {
    v5 = mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 56));
    if (v5 == mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24)))
      return 1;
  }
  v16 = (const void **)"failed to verify that all of {real, imag} have same element type";
  v17 = 259;
  mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
  if (v18[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
  if (v25)
  {
    v7 = __p;
    if (__p)
    {
      v8 = v24;
      v9 = __p;
      if (v24 != __p)
      {
        do
          v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
        while (v8 != v7);
        v9 = __p;
      }
      v24 = v7;
      operator delete(v9);
    }
    v10 = v21;
    if (v21)
    {
      v11 = v22;
      v12 = v21;
      if (v22 != v21)
      {
        do
        {
          v14 = *--v11;
          v13 = v14;
          *v11 = 0;
          if (v14)
            MEMORY[0x20BD002D4](v13, 0x1000C8077774924);
        }
        while (v11 != v10);
        v12 = v21;
      }
      v22 = v10;
      operator delete(v12);
    }
    if (v19 != &v20)
      free(v19);
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD *v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51) || mlir::Type::isF32((mlir::Type *)v51))
      return 1;
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of 16-bit float or 32-bit float values, but got ";
        v55 = 64;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = __p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = *--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t OperandRange;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53[4];
  __int16 v54;
  uint64_t v55;
  uint64_t Value;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  _QWORD v60[3];
  void *v61;
  unsigned int v62;
  unsigned int v63;
  _BYTE v64[96];
  void *v65;
  _QWORD *v66;
  void *__p;
  _QWORD *v68;
  char v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v60[0] = a2;
    v60[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60);
    if (*(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v41 = OperandRange;
      v57 = OperandRange;
      v53[0] = (const void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF16((mlir::Type *)v53))
        return 1;
      v55 = v41;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v54 = 261;
  v53[0] = a3;
  v53[1] = a4;
  mlir::Operation::emitOpError(a1, v53, (uint64_t)v60);
  if (v60[0])
  {
    LODWORD(v57) = 3;
    v58 = " #";
    v59 = 2;
    v14 = &v57;
    v15 = (char *)v61;
    if (v62 >= v63)
    {
      v43 = v62 + 1;
      if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
      {
        v49 = (char *)&v57 - (_BYTE *)v61;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        v15 = (char *)v61;
        v14 = (uint64_t *)((char *)v61 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        v14 = &v57;
        v15 = (char *)v61;
      }
    }
    v16 = &v15[24 * v62];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = v14[2];
    *(_OWORD *)v16 = v17;
    v18 = ++v62;
    if (v60[0])
    {
      LODWORD(v57) = 5;
      v58 = (const char *)a5;
      v19 = &v57;
      v20 = (char *)v61;
      if (v18 >= v63)
      {
        v44 = v18 + 1;
        v45 = (char *)v61 + 24 * v18 > (char *)&v57;
        if (v61 <= &v57 && v45)
        {
          v50 = (char *)&v57 - (_BYTE *)v61;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          v20 = (char *)v61;
          v19 = (uint64_t *)((char *)v61 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          v19 = &v57;
          v20 = (char *)v61;
        }
      }
      v21 = &v20[24 * v62];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = v19[2];
      *(_OWORD *)v21 = v22;
      v23 = ++v62;
      if (v60[0])
      {
        LODWORD(v57) = 3;
        v58 = " must be tensor of complex values, but got ";
        v59 = 43;
        v24 = &v57;
        v25 = (char *)v61;
        if (v23 >= v63)
        {
          v46 = v23 + 1;
          v47 = (char *)v61 + 24 * v23 > (char *)&v57;
          if (v61 <= &v57 && v47)
          {
            v51 = (char *)&v57 - (_BYTE *)v61;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            v25 = (char *)v61;
            v24 = (uint64_t *)((char *)v61 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            v24 = &v57;
            v25 = (char *)v61;
          }
        }
        v26 = &v25[24 * v62];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = v24[2];
        *(_OWORD *)v26 = v27;
        ++v62;
        if (v60[0])
        {
          v28 = &v57;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v57, a2);
          v29 = (char *)v61;
          if (v62 >= v63)
          {
            v48 = v62 + 1;
            if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
            {
              v52 = (char *)&v57 - (_BYTE *)v61;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              v29 = (char *)v61;
              v28 = (uint64_t *)((char *)v61 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              v28 = &v57;
              v29 = (char *)v61;
            }
          }
          v30 = &v29[24 * v62];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = v28[2];
          *(_OWORD *)v30 = v31;
          ++v62;
        }
      }
    }
  }
  v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v60);
  if (v60[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
  if (v69)
  {
    v33 = __p;
    if (__p)
    {
      v34 = v68;
      v35 = __p;
      if (v68 != __p)
      {
        do
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        v35 = __p;
      }
      v68 = v33;
      operator delete(v35);
    }
    v36 = v65;
    if (v65)
    {
      v37 = v66;
      v38 = v65;
      if (v66 != v65)
      {
        do
        {
          v40 = *--v37;
          v39 = v40;
          *v37 = 0;
          if (v40)
            MEMORY[0x20BD002D4](v39, 0x1000C8077774924);
        }
        while (v37 != v36);
        v38 = v65;
      }
      v66 = v36;
      operator delete(v38);
    }
    if (v61 != v64)
      free(v61);
  }
  return v32;
}

uint64_t mlir::mps::CreateTextureTensorOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD *v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v26 = &v76;
      v27 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v27 = (char *)v80;
          v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v26 = &v76;
          v27 = (char *)v80;
        }
      }
      v28 = &v27[24 * v81];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v87;
      v32 = __p;
      if (v87 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v87 = v30;
      operator delete(v32);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v33 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "compressed", 0xAuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        v76 = 3;
        v78 = 55;
        v10 = &v76;
        v11 = (char *)v80;
        if (v81 >= v82)
        {
          v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v70 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v11 = (char *)v80;
            v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v10 = &v76;
            v11 = (char *)v80;
          }
        }
        v12 = &v11[24 * v81];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v81;
        if (v79[0])
        {
          v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          v15 = (char *)v80;
          if (v81 >= v82)
          {
            v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              v71 = (char *)&v76 - (_BYTE *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v15 = (char *)v80;
              v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v14 = &v76;
              v15 = (char *)v80;
            }
          }
          v16 = &v15[24 * v81];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v81;
          if (v79[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
      if (!v88)
        return 0;
      v18 = __p;
      if (__p)
      {
        v19 = v87;
        v20 = __p;
        if (v87 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v87 = v18;
        operator delete(v20);
      }
      v21 = v84;
      if (!v84)
        goto LABEL_80;
      v22 = v85;
      v23 = v84;
      if (v85 == v84)
        goto LABEL_79;
      do
      {
        v25 = *--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_format", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for pixel_format in DictionaryAttr to set Properties.";
      v78 = 72;
      v52 = &v76;
      v53 = (char *)v80;
      if (v81 >= v82)
      {
        v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v73 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v53 = (char *)v80;
          v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v52 = &v76;
          v53 = (char *)v80;
        }
      }
      v54 = &v53[24 * v81];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v56 = __p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v59 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 57;
    v38 = &v76;
    v39 = (char *)v80;
    if (v81 >= v82)
    {
      v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v72 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v39 = (char *)v80;
        v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v38 = &v76;
        v39 = (char *)v80;
      }
    }
    v40 = &v39[24 * v81];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    ++v81;
    if (v79[0])
    {
      v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      v43 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v43 = (char *)v80;
          v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v42 = &v76;
          v43 = (char *)v80;
        }
      }
      v44 = &v43[24 * v81];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v46 = __p;
    if (__p)
    {
      v47 = v87;
      v48 = __p;
      if (v87 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v87 = v46;
      operator delete(v48);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v49 = v85;
    v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v51 = *--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
    }
    while (v49 != v21);
LABEL_78:
    v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::CreateTextureTensorOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"compressed", 10, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_format", 12, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid MetalPixelFormat";
        v31 = 54;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451E000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties]";
        v15 = 120;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v5[124];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::MetalPixelFormatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MetalPixelFormatAttr]";
  v41 = 81;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::mps::CreateTextureTensorOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  const void **v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void ***v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  const void ***v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  const void ***v37;
  char *v38;
  char *v39;
  __int128 v40;
  char v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t NextResultAtOffset;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  int64_t v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  const void **v63;
  uint64_t v64;
  __int16 v65;
  _QWORD v66[2];
  uint64_t OperandRange;
  const void **v68;
  const char *v69;
  uint64_t v70;
  _QWORD v71[3];
  void *v72;
  unsigned int v73;
  unsigned int v74;
  _BYTE v75[96];
  void *v76;
  _QWORD *v77;
  void *__p;
  _QWORD *v79;
  char v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = v3[1];
  if (v4)
  {
    v5 = *v3;
    v71[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(v4, (const void **)"pixel_format", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0;
    v71[0] = *this;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"compressed", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0;
    v6 = *this;
    v7 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v8 = *v7;
    v9 = (void *)*((_QWORD *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      v71[0] = v7;
      v71[1] = v22;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_85:
        if (*((_DWORD *)*this + 9))
          v50 = (uint64_t)(*this - 2);
        else
          v50 = 0;
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v50, 0);
        return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
      }
      v8 = *v7;
      if (*((_UNKNOWN **)*v7 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        goto LABEL_53;
    }
    else if (v9 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_53:
      v65 = 261;
      v63 = (const void **)"operand";
      v64 = 7;
      mlir::Operation::emitOpError(v6, &v63, (uint64_t)v71);
      if (v71[0])
      {
        LODWORD(v68) = 3;
        v69 = " #";
        v70 = 2;
        v23 = &v68;
        v24 = (char *)v72;
        if (v73 >= v74)
        {
          v53 = v73 + 1;
          if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
          {
            v59 = (char *)&v68 - (_BYTE *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            v24 = (char *)v72;
            v23 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            v23 = &v68;
            v24 = (char *)v72;
          }
        }
        v25 = &v24[24 * v73];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = v23[2];
        *(_OWORD *)v25 = v26;
        v27 = ++v73;
        if (v71[0])
        {
          LODWORD(v68) = 5;
          v69 = 0;
          v28 = &v68;
          v29 = (char *)v72;
          if (v27 >= v74)
          {
            v54 = v27 + 1;
            v55 = (char *)v72 + 24 * v27 > (char *)&v68;
            if (v72 <= &v68 && v55)
            {
              v60 = (char *)&v68 - (_BYTE *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              v29 = (char *)v72;
              v28 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              v28 = &v68;
              v29 = (char *)v72;
            }
          }
          v30 = &v29[24 * v73];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = v28[2];
          *(_OWORD *)v30 = v31;
          v32 = ++v73;
          if (v71[0])
          {
            LODWORD(v68) = 3;
            v69 = " must be unranked tensor of mps native type values or 4D tensor of mps native type values, but got ";
            v70 = 99;
            v33 = &v68;
            v34 = (char *)v72;
            if (v32 >= v74)
            {
              v56 = v32 + 1;
              v57 = (char *)v72 + 24 * v32 > (char *)&v68;
              if (v72 <= &v68 && v57)
              {
                v61 = (char *)&v68 - (_BYTE *)v72;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                v34 = (char *)v72;
                v33 = (const void ***)((char *)v72 + v61);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                v33 = &v68;
                v34 = (char *)v72;
              }
            }
            v35 = &v34[24 * v73];
            v36 = *(_OWORD *)v33;
            *((_QWORD *)v35 + 2) = v33[2];
            *(_OWORD *)v35 = v36;
            ++v73;
            if (v71[0])
            {
              v37 = &v68;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)v7);
              v38 = (char *)v72;
              if (v73 >= v74)
              {
                v58 = v73 + 1;
                if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
                {
                  v62 = (char *)&v68 - (_BYTE *)v72;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  v38 = (char *)v72;
                  v37 = (const void ***)((char *)v72 + v62);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  v37 = &v68;
                  v38 = (char *)v72;
                }
              }
              v39 = &v38[24 * v73];
              v40 = *(_OWORD *)v37;
              *((_QWORD *)v39 + 2) = v37[2];
              *(_OWORD *)v39 = v40;
              ++v73;
            }
          }
        }
      }
      v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
      if (v71[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
      if (v80)
      {
        v42 = __p;
        if (__p)
        {
          v43 = v79;
          v44 = __p;
          if (v79 != __p)
          {
            do
              v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            v44 = __p;
          }
          v79 = v42;
          operator delete(v44);
        }
        v45 = v76;
        if (v76)
        {
          v46 = v77;
          v47 = v76;
          if (v77 != v76)
          {
            do
            {
              v49 = *--v46;
              v48 = v49;
              *v46 = 0;
              if (v49)
                MEMORY[0x20BD002D4](v48, 0x1000C8077774924);
            }
            while (v46 != v45);
            v47 = v76;
          }
          v77 = v45;
          operator delete(v47);
        }
        if (v72 != v75)
          free(v72);
      }
      if (v41)
        goto LABEL_85;
      return 0;
    }
    v63 = v7;
    v64 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v63))
    {
      v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
      v68 = v7;
      v69 = (const char *)v10;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v68);
      if (v11 == 4)
      {
        v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
        v66[0] = v7;
        v66[1] = v12;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_85;
        }
      }
    }
    goto LABEL_53;
  }
  v63 = (const void **)"requires attribute 'pixel_format'";
  v65 = 259;
  mlir::OpState::emitOpError(this, &v63, (uint64_t)v71);
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  if (v80)
  {
    v14 = __p;
    if (__p)
    {
      v15 = v79;
      v16 = __p;
      if (v79 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v79 = v14;
      operator delete(v16);
    }
    v17 = v76;
    if (v76)
    {
      v18 = v77;
      v19 = v76;
      if (v77 != v76)
      {
        do
        {
          v21 = *--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
            MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
        }
        while (v18 != v17);
        v19 = v76;
      }
      v77 = v17;
      operator delete(v19);
    }
    if (v72 != v75)
      free(v72);
  }
  return v13;
}

uint64_t mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.crop", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CropOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t ElementTypeOrSelf;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v18;
  uint64_t v19;
  const void **v20;
  __int16 v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           3u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0))return 0;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24));
  if (*((_DWORD *)*this + 9))
    v5 = (uint64_t)(*this - 2);
  else
    v5 = 0;
  v6 = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(v6))
  {
    v7 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
    v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
    v9 = mlir::getElementTypeOrSelf(v8);
    if (v9 == mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24)))
      return 1;
  }
  v20 = (const void **)"failed to verify that all of {input, result} have same element type";
  v21 = 259;
  mlir::OpState::emitOpError(this, &v20, (uint64_t)v22);
  v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
  if (v22[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
  if (v29)
  {
    v11 = __p;
    if (__p)
    {
      v12 = v28;
      v13 = __p;
      if (v28 != __p)
      {
        do
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        v13 = __p;
      }
      v28 = v11;
      operator delete(v13);
    }
    v14 = v25;
    if (v25)
    {
      v15 = v26;
      v16 = v25;
      if (v26 != v25)
      {
        do
        {
          v19 = *--v15;
          v18 = v19;
          *v15 = 0;
          if (v19)
            MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
        }
        while (v15 != v14);
        v16 = v25;
      }
      v26 = v14;
      operator delete(v16);
    }
    if (v23 != &v24)
      free(v23);
  }
  return v10;
}

uint64_t mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.crop_resize", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CropResizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  _QWORD v74[3];
  void *v75;
  unsigned int v76;
  unsigned int v77;
  _BYTE v78[96];
  void *v79;
  _QWORD *v80;
  void *__p;
  _QWORD *v82;
  char v83;
  uint64_t v84;

  v84 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      v72 = "expected DictionaryAttr to set properties";
      v73 = 41;
      v26 = &v71;
      v27 = (char *)v75;
      if (v76 >= v77)
      {
        v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          v65 = (char *)&v71 - (_BYTE *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v27 = (char *)v75;
          v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v26 = &v71;
          v27 = (char *)v75;
        }
      }
      v28 = &v27[24 * v76];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v76;
      if (v74[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
    }
    if (!v83)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v82;
      v32 = __p;
      if (v82 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v82 = v30;
      operator delete(v32);
    }
    v21 = v79;
    if (!v79)
      goto LABEL_64;
    v33 = v80;
    v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78)
        free(v75);
      return 0;
    }
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
LABEL_62:
    v23 = v79;
    goto LABEL_63;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "alignment_mode", 0xEuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 59;
        v10 = &v71;
        v11 = (char *)v75;
        if (v76 >= v77)
        {
          v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v66 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v11 = (char *)v75;
            v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v10 = &v71;
            v11 = (char *)v75;
          }
        }
        v12 = &v11[24 * v76];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v76;
        if (v74[0])
        {
          v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          v15 = (char *)v75;
          if (v76 >= v77)
          {
            v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v67 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v15 = (char *)v75;
              v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v14 = &v71;
              v15 = (char *)v75;
            }
          }
          v16 = &v15[24 * v76];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v18 = __p;
      if (__p)
      {
        v19 = v82;
        v20 = __p;
        if (v82 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v82 = v18;
        operator delete(v20);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v22 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v25 = *--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "coordinate_mode", 0xFuLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 60;
        v38 = &v71;
        v39 = (char *)v75;
        if (v76 >= v77)
        {
          v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v68 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v39 = (char *)v75;
            v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v38 = &v71;
            v39 = (char *)v75;
          }
        }
        v40 = &v39[24 * v76];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = v38[2];
        *(_OWORD *)v40 = v41;
        ++v76;
        if (v74[0])
        {
          v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          v43 = (char *)v75;
          if (v76 >= v77)
          {
            v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v69 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v43 = (char *)v75;
              v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v42 = &v71;
              v43 = (char *)v75;
            }
          }
          v44 = &v43[24 * v76];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = v42[2];
          *(_OWORD *)v44 = v45;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v46 = __p;
      if (__p)
      {
        v47 = v82;
        v48 = __p;
        if (v82 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v82 = v46;
        operator delete(v48);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v49 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v51 = *--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "interpolation_mode", 0x12uLL);
  v71 = v52;
  if (!v52)
  {
LABEL_71:
    v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "normalize_coordinates", 0x15uLL);
    v71 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[3] = v54;
    }
    v55 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_height", 0xDuLL);
    v71 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
LABEL_86:
        v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v56);
        goto LABEL_87;
      }
      a1[4] = v55;
    }
    v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_width", 0xCuLL);
    v71 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[5] = v57;
    }
    v58 = mlir::DictionaryAttr::get((uint64_t)&v70, "spatial_scale", 0xDuLL);
    v71 = v58;
    if (v58)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_86;
      }
      a1[6] = v58;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v74, a4);
LABEL_87:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
  return 0;
}

uint64_t mlir::mps::CropResizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[7];

  v51[6] = *MEMORY[0x24BDAC8D0];
  v48 = a1;
  v49 = v51;
  v50 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"alignment_mode", 14, *a2);
  v5 = v4;
  v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    v6 = v50;
  }
  v7 = (uint64_t *)((char *)v49 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coordinate_mode", 15, v9);
    v12 = v11;
    v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v13 = v50;
    }
    v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"interpolation_mode", 18, v15);
    v18 = v17;
    v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v19 = v50;
    }
    v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v21);
    v24 = v23;
    v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v25 = v50;
    }
    v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_height", 13, v27);
    v30 = v29;
    v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v31 = v50;
    }
    v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_width", 12, v33);
    v36 = v35;
    v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v37 = v50;
    }
    v38 = (uint64_t *)((char *)v49 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"spatial_scale", 13, v39);
    v42 = v41;
    v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v43 = v50;
    }
    v44 = (uint64_t *)((char *)v49 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v45 = v49;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v49 == v51)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (mlir::MLIRContext *)v49, v8);
  v45 = v49;
  if (v49 != v51)
LABEL_32:
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CropResizeOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "resize_width", __n))
        return 0;
      return a2[5];
    case 0xDuLL:
      if (!memcmp(__s1, "resize_height", __n))
        return a2[4];
      if (memcmp(__s1, "spatial_scale", __n))
        return 0;
      return a2[6];
    case 0xEuLL:
      if (*(_QWORD *)__s1 != 0x6E656D6E67696C61 || *(_QWORD *)(__s1 + 6) != 0x65646F6D5F746E65)
        return 0;
      return *a2;
    case 0xFuLL:
      if (memcmp(__s1, "coordinate_mode", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
    case 0x11uLL:
    case 0x13uLL:
    case 0x14uLL:
      return 0;
    case 0x12uLL:
      if (memcmp(__s1, "interpolation_mode", __n))
        return 0;
      return a2[2];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n))
        return 0;
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CropResizeOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 0xCuLL:
      result = memcmp(__s1, "resize_width", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[5] = v14;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "resize_height", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "spatial_scale", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
              v8 = a4;
            else
              v8 = 0;
            v7[6] = v8;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          v15 = a4;
        else
          v15 = 0;
        v7[4] = v15;
      }
      else
      {
        v7[4] = 0;
      }
      break;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6E656D6E67696C61 && *(_QWORD *)(__s1 + 6) == 0x65646F6D5F746E65)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xFuLL:
      result = memcmp(__s1, "coordinate_mode", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[1] = v11;
        }
        else
        {
          v7[1] = 0;
        }
      }
      break;
    case 0x12uLL:
      result = memcmp(__s1, "interpolation_mode", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
            v12 = a4;
          else
            v12 = 0;
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0x15uLL:
      result = memcmp(__s1, "normalize_coordinates", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v13 = a4;
          else
            v13 = 0;
          v7[3] = v13;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CropResizeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"alignment_mode", 14, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"coordinate_mode", 15, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"interpolation_mode", 18, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_height", 13, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_width", 12, v9);
  v10 = a2[6];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"spatial_scale", 13, v10);
}

BOOL mlir::mps::CropResizeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void **v12;
  const void **v13;
  const void **v14;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v8, (const void **)"alignment_mode", (const char *)0xE, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v9, (const void **)"coordinate_mode", (const char *)0xF, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v10, (const void **)"interpolation_mode", (const char *)0x12, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"normalize_coordinates", (const char *)0x15, a3, a4))
        {
          v12 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v12, (const void **)"resize_height", (const char *)0xD, a3, a4))
          {
            v13 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v13, (const void **)"resize_width", (const char *)0xC, a3, a4))
            {
              v14 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v14, (const void **)"spatial_scale", (const char *)0xD, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid CropResizeAlignmentMode";
        v31 = 61;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid CropResizeCoordinateMode";
        v31 = 62;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid sampling modes";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD *v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 32))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 32-bit unsigned integer attribute";
        v33 = 65;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD *v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isF32((mlir::Type *)&Value))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 32-bit float attribute";
        v33 = 54;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

BOOL mlir::mps::CropResizeOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451E000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451E000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties]";
        v15 = 111;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451E000;
      }
    }
    a1[33] = v4[126];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeAlignmentModeAttr]";
  v41 = 88;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeCoordinateModeAttr]";
  v41 = 89;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SamplingModeAttr]";
  v41 = 77;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FloatAttr]";
  v41 = 65;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t *mlir::mps::CropResizeOp::getResizeHeight(mlir::mps::CropResizeOp *this)
{
  unint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  unsigned int v5;
  uint64_t v6;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  v6 = *(_QWORD *)(v1 + 32);
  mlir::IntegerAttr::getValue(&v6, (llvm::APInt *)&v4);
  if (v5 <= 0x40)
    return v4;
  v3 = *v4;
  MEMORY[0x20BD002D4]();
  return (uint64_t *)v3;
}

uint64_t *mlir::mps::CropResizeOp::getResizeWidth(mlir::mps::CropResizeOp *this)
{
  unint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  unsigned int v5;
  uint64_t v6;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  v6 = *(_QWORD *)(v1 + 40);
  mlir::IntegerAttr::getValue(&v6, (llvm::APInt *)&v4);
  if (v5 <= 0x40)
    return v4;
  v3 = *v4;
  MEMORY[0x20BD002D4]();
  return (uint64_t *)v3;
}

BOOL mlir::mps::CropResizeOp::getNormalizeCoordinates(mlir::mps::CropResizeOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(_QWORD *)(v1 + 24) != 0;
}

_QWORD *mlir::mps::CropResizeOp::getSpatialScale@<X0>(mlir::mps::CropResizeOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = 0;
  v4 = *(_QWORD *)(v2 + 48);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v4, a2);
}

uint64_t mlir::mps::CropResizeOp::getInterpolationMode(mlir::mps::CropResizeOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(unsigned int *)(*(_QWORD *)(v1 + 16) + 8);
}

uint64_t mlir::mps::CropResizeOp::getCoordinateMode(mlir::mps::CropResizeOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(unsigned int *)(*(_QWORD *)(v1 + 8) + 8);
}

mlir::MLIRContext *mlir::mps::CropResizeOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext *v4;
  uint64_t IntegerType;
  uint64_t v6;
  uint64_t F32Type;
  mlir::MLIRContext *v8;
  unsigned __int8 **AttributeUniquer;
  mlir::MLIRContext *v10;
  unsigned __int8 **v11;
  mlir::MLIRContext *v12;
  unsigned __int8 **v13;
  mlir::MLIRContext *v14;
  unsigned int v15;
  void *v16;
  mlir::MLIRContext *v17;

  v16 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v14 = result;
  if (a2[4])
  {
    if (a2[5])
      goto LABEL_3;
  }
  else
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
    result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, IntegerType, 1);
    a2[4] = result;
    if (a2[5])
    {
LABEL_3:
      if (a2[6])
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  v6 = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
  result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, v6, 1);
  a2[5] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[2])
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  F32Type = mlir::Builder::getF32Type(&v14, v4);
  result = mlir::Builder::getFloatAttr(1.0, (uint64_t)&v14, F32Type);
  a2[6] = result;
  if (a2[2])
  {
LABEL_5:
    if (*a2)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  v8 = v14;
  v15 = 1;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  v16 = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v17 = v8;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v15);
  a2[2] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[1])
      return result;
LABEL_13:
    v12 = v14;
    v15 = 0;
    v13 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
    v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
    v17 = v12;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(v13, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v15);
    a2[1] = result;
    return result;
  }
LABEL_12:
  v10 = v14;
  v15 = 0;
  v11 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v17 = v10;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(v11, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v15);
  *a2 = result;
  if (!a2[1])
    goto LABEL_13;
  return result;
}

