uint64_t llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>::insertFrom(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  _QWORD *v17;
  unsigned __int8 *v18;
  _QWORD *v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  BOOL v44;
  BOOL v45;
  BOOL v46;
  BOOL v47;
  BOOL v48;
  BOOL v49;
  BOOL v50;
  BOOL v51;
  BOOL v52;
  BOOL v53;
  BOOL v54;
  BOOL v55;
  BOOL v56;
  BOOL v57;
  BOOL v58;
  BOOL v59;
  BOOL v60;
  BOOL v61;
  BOOL v62;
  BOOL v63;
  BOOL v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  const double *v71;
  const double *v72;
  const double *v73;
  double *v74;
  double *v75;
  double *v76;
  double *v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  const double *v81;
  const double *v82;
  const double *v83;
  const double *v84;
  const double *v85;
  const double *v86;
  const double *v87;
  double *v88;
  double *v89;
  double *v90;
  double *v91;
  double *v92;
  double *v93;
  double *v94;
  double *v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  BOOL v113;
  BOOL v115;
  BOOL v117;
  BOOL v119;
  BOOL v121;
  BOOL v123;
  BOOL v125;
  BOOL v127;
  BOOL v129;
  BOOL v131;
  BOOL v133;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  uint64_t v138;
  __int128 *v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  uint64_t v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  _OWORD *v157;
  unsigned int v158;
  unsigned int v159;
  uint64_t v160;
  __int128 *v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  _OWORD *v170;
  BOOL v171;
  float64x2x2_t v172;
  float64x2x2_t v173;
  float64x2x2_t v174;
  float64x2x2_t v175;
  float64x2x2_t v176;
  float64x2x2_t v177;
  float64x2x2_t v178;
  float64x2x2_t v179;
  float64x2x2_t v180;
  float64x2x2_t v181;
  float64x2x2_t v182;
  float64x2x2_t v183;

  v7 = *a2;
  if (!(_DWORD)v7)
    goto LABEL_11;
  v8 = (v7 - 1);
  if (*(unsigned __int8 *)(a1 + v8 + 176) != a6
    || (v9 = a1 + 16 * v8, v11 = *(_QWORD *)(v9 + 8), v10 = (_QWORD *)(v9 + 8), v11 + 1 != a4))
  {
    if ((_DWORD)v7 == 11)
      return 12;
LABEL_11:
    v16 = a3 - v7;
    if ((_DWORD)a3 == (_DWORD)v7)
    {
      v17 = (_QWORD *)(a1 + 16 * a3);
      *v17 = a4;
      v17[1] = a5;
      *(_BYTE *)(a1 + a3 + 176) = a6;
      return (a3 + 1);
    }
    v18 = (unsigned __int8 *)(a1 + v7 + 176);
    if (*v18 == a6)
    {
      v19 = (_QWORD *)(a1 + 16 * v7);
      if (a5 + 1 == *v19)
      {
        *v19 = a4;
        return a3;
      }
    }
    if ((_DWORD)a3 == 11)
      return 12;
    v20 = (~(_DWORD)v7 + a3);
    if (v20 >= 7 && (int)v7 + 1 <= a3)
    {
      v25 = (a3 - 1);
      if (v20 <= v25)
      {
        v26 = (16 * a3) | 8;
        v27 = a1 + v26;
        v28 = 16 * v20;
        if (a1 + v26 - 16 * v20 <= (unint64_t)(a1 + v26))
        {
          v29 = 16 * a3;
          if (a1 + v29 - v28 <= (unint64_t)(a1 + v29))
          {
            v30 = (16 * (a3 - 1)) | 8;
            v31 = a1 + v30;
            if (a1 + v30 - v28 <= (unint64_t)(a1 + v30))
            {
              v32 = 16 * (a3 - 1);
              if (a1 + v32 - v28 <= (unint64_t)(a1 + v32)
                && a1 + (unint64_t)a3 + 176 - v20 <= a1 + (unint64_t)a3 + 176
                && a1 + v25 + 176 - v20 <= (unint64_t)(a1 + v25 + 176))
              {
                v33 = a1 + v29 - v28;
                v34 = a1 + v26 - v28;
                v35 = v29 + a1 + 16;
                v36 = a1 + v32 - v28;
                v37 = a1 + v30 - v28;
                v38 = v32 + a1 + 16;
                v39 = a1 + a3 + 176 - v20;
                v40 = a3 + a1 + 177;
                v41 = a1 + v25 + 176 - v20;
                v42 = v25 + a1 + 177;
                v43 = v33 >= v31 || v36 >= v27;
                v44 = !v43;
                v171 = v44;
                v45 = v33 >= v38 || v37 >= v27;
                v46 = !v45;
                v47 = v33 >= v40 || v39 >= v27;
                v48 = !v47;
                v49 = v33 >= v42 || v41 >= v27;
                v50 = !v49;
                v51 = v34 >= v31 || v36 >= v35;
                v52 = !v51;
                v53 = v34 >= v38 || v37 >= v35;
                v54 = !v53;
                v55 = v34 >= v40 || v39 >= v35;
                v56 = !v55;
                v57 = v34 >= v42 || v41 >= v35;
                v58 = !v57;
                v59 = v36 >= v40 || v39 >= v31;
                v60 = !v59;
                v61 = v37 >= v40 || v39 >= v38;
                v62 = !v61;
                v63 = v39 >= v42 || v41 >= v40;
                v64 = !v63;
                v65 = v34 >= v27 || v33 >= v35;
                if (v65 && !v171 && !v46 && !v48 && !v50 && !v52 && !v54 && !v56 && !v58 && !v60 && !v62 && !v64)
                {
                  v66 = v20 + 1;
                  if (v20 < 0xF)
                  {
                    v67 = 0;
                    goto LABEL_117;
                  }
                  v67 = v66 & 0x1FFFFFFF0;
                  v78 = v66 & 0x1FFFFFFF0;
                  v79 = a3;
                  do
                  {
                    v80 = v79 - 1;
                    v81 = (const double *)(a1 - 240 + 16 * v80);
                    v82 = v81;
                    v173 = vld2q_f64(v82);
                    v82 += 4;
                    v175 = vld2q_f64(v82);
                    v83 = v81 + 8;
                    v177 = vld2q_f64(v83);
                    v84 = v81 + 12;
                    v179 = vld2q_f64(v84);
                    v85 = v81 + 16;
                    v180 = vld2q_f64(v85);
                    v86 = v81 + 20;
                    v181 = vld2q_f64(v86);
                    v87 = v81 + 24;
                    v182 = vld2q_f64(v87);
                    v81 += 28;
                    v183 = vld2q_f64(v81);
                    v88 = (double *)(a1 - 248 + 16 * v79);
                    v89 = v88 + 1;
                    vst2q_f64(v89, v173);
                    v90 = v88 + 5;
                    vst2q_f64(v90, v175);
                    v91 = v88 + 9;
                    vst2q_f64(v91, v177);
                    v92 = v88 + 13;
                    vst2q_f64(v92, v179);
                    v93 = v88 + 17;
                    vst2q_f64(v93, v180);
                    v94 = v88 + 21;
                    vst2q_f64(v94, v181);
                    v95 = v88 + 25;
                    vst2q_f64(v95, v182);
                    v88 += 29;
                    vst2q_f64(v88, v183);
                    *(_OWORD *)(a1 + 161 + v79) = *(_OWORD *)(a1 + 161 + v80);
                    v79 -= 16;
                    v78 -= 16;
                  }
                  while (v78);
                  if (v66 == v67)
                    goto LABEL_22;
                  if ((v66 & 8) != 0)
                  {
LABEL_117:
                    v16 -= v66 & 0xFFFFFFF8;
                    v68 = a3 - v67;
                    v69 = v67 - (v66 & 0x1FFFFFFF8);
                    do
                    {
                      v70 = v68 - 1;
                      v71 = (const double *)(a1 - 112 + 16 * v70);
                      v72 = v71;
                      v172 = vld2q_f64(v72);
                      v72 += 4;
                      v174 = vld2q_f64(v72);
                      v73 = v71 + 8;
                      v176 = vld2q_f64(v73);
                      v71 += 12;
                      v178 = vld2q_f64(v71);
                      v74 = (double *)(a1 - 120 + 16 * v68);
                      v75 = v74 + 1;
                      vst2q_f64(v75, v172);
                      v76 = v74 + 5;
                      vst2q_f64(v76, v174);
                      v77 = v74 + 9;
                      vst2q_f64(v77, v176);
                      v74 += 13;
                      vst2q_f64(v74, v178);
                      *(_QWORD *)(a1 + 169 + v68) = *(_QWORD *)(a1 + 169 + v70);
                      v68 -= 8;
                      v69 += 8;
                    }
                    while (v69);
                    if (v66 == (v66 & 0x1FFFFFFF8))
                      goto LABEL_22;
                    goto LABEL_20;
                  }
                  v16 -= v67;
                }
              }
            }
          }
        }
      }
    }
LABEL_20:
    v21 = v7 + v16;
    do
    {
      v22 = v21 - 1;
      *(_OWORD *)(a1 + 16 * v21) = *(_OWORD *)(a1 + 16 * v22);
      *(_BYTE *)(a1 + 176 + v21--) = *(_BYTE *)(a1 + 176 + v22);
      --v16;
    }
    while (v16);
LABEL_22:
    v23 = (_QWORD *)(a1 + 16 * v7);
    *v23 = a4;
    v23[1] = a5;
    *v18 = a6;
    return (a3 + 1);
  }
  *a2 = v8;
  if ((_DWORD)a3 != (_DWORD)v7 && *(unsigned __int8 *)(a1 + v7 + 176) == a6)
  {
    v12 = 16 * v7;
    if (a5 + 1 == *(_QWORD *)(a1 + 16 * v7))
    {
      *v10 = *(_QWORD *)(a1 + 16 * v7 + 8);
      v13 = (v7 + 1);
      if ((_DWORD)v13 == (_DWORD)a3)
        return (a3 - 1);
      v14 = ~(_DWORD)v7 + a3;
      if (v14 < 8)
      {
        v15 = v7;
        goto LABEL_242;
      }
      v96 = (a3 - 2 - v7);
      if ((int)a3 - 2 < v7)
      {
        v15 = v7;
      }
      else if ((int)a3 - 1 < v13)
      {
        v15 = v7;
      }
      else
      {
        v97 = a1 + v12;
        v98 = a1 + v12 + 8;
        v99 = 16 * (a3 - 2 - v7);
        if (v98 + v99 < v98)
        {
          v15 = v7;
        }
        else if (v97 + v99 < v97)
        {
          v15 = v7;
        }
        else
        {
          v100 = 16 * (v7 + 1);
          v101 = a1 + v100;
          v102 = a1 + v100 + 8;
          if (v102 + v99 < v102)
          {
            v15 = v7;
          }
          else if (v101 + v99 < v101)
          {
            v15 = v7;
          }
          else
          {
            v103 = v12 + v99;
            v104 = a1 + (v103 | 8);
            v105 = v103 + a1 + 16;
            v106 = v7 + a1 + 176;
            v107 = v7 + a1 + v96 + 177;
            v108 = a1 + ((v99 + v100) | 8);
            v109 = v99 + v100 + a1 + 16;
            v110 = v13 + a1 + 176;
            v111 = v13 + a1 + v96 + 177;
            v113 = v97 < v107 && v106 < v104;
            v115 = v97 < v108 && v101 < v104;
            v117 = v97 < v109 && v102 < v104;
            v119 = v97 < v111 && v110 < v104;
            v121 = v98 < v107 && v106 < v105;
            v123 = v98 < v108 && v101 < v105;
            v125 = v98 < v109 && v102 < v105;
            v127 = v98 < v111 && v110 < v105;
            v129 = v106 < v108 && v101 < v107;
            v131 = v106 < v109 && v102 < v107;
            v133 = v106 < v111 && v110 < v107;
            if (v98 < v104 && v97 < v105)
            {
              v15 = v7;
              goto LABEL_242;
            }
            if (v113)
            {
              v15 = v7;
            }
            else if (v115)
            {
              v15 = v7;
            }
            else if (v117)
            {
              v15 = v7;
            }
            else if (v119)
            {
              v15 = v7;
            }
            else if (v121)
            {
              v15 = v7;
            }
            else if (v123)
            {
              v15 = v7;
            }
            else if (v125)
            {
              v15 = v7;
            }
            else if (v127)
            {
              v15 = v7;
            }
            else if (v129)
            {
              v15 = v7;
            }
            else if (v131)
            {
              v15 = v7;
            }
            else if (v133)
            {
              v15 = v7;
            }
            else
            {
              if (v14 < 0x10)
              {
                v135 = 0;
                goto LABEL_224;
              }
              v135 = v14 & 0xFFFFFFF0;
              v136 = v7;
              v137 = v14 & 0xFFFFFFF0;
              do
              {
                v138 = v136 + 1;
                v139 = (__int128 *)(a1 + 16 * v138);
                v141 = *v139;
                v140 = v139[1];
                v143 = v139[2];
                v142 = v139[3];
                v144 = v136;
                v146 = v139[4];
                v145 = v139[5];
                v148 = v139[6];
                v147 = v139[7];
                v150 = v139[8];
                v149 = v139[9];
                v152 = v139[10];
                v151 = v139[11];
                v154 = v139[12];
                v153 = v139[13];
                v156 = v139[14];
                v155 = v139[15];
                v157 = (_OWORD *)(a1 + 16 * v136);
                v157[14] = v156;
                v157[15] = v155;
                v157[12] = v154;
                v157[13] = v153;
                v157[10] = v152;
                v157[11] = v151;
                v157[8] = v150;
                v157[9] = v149;
                v157[6] = v148;
                v157[7] = v147;
                v157[4] = v146;
                v157[5] = v145;
                v157[2] = v143;
                v157[3] = v142;
                *v157 = v141;
                v157[1] = v140;
                v136 += 16;
                *(_OWORD *)(a1 + 176 + v144) = *(_OWORD *)(a1 + 176 + v138);
                v137 -= 16;
              }
              while (v137);
              if (v14 == v135)
                return (a3 - 1);
              if ((v14 & 8) != 0)
              {
LABEL_224:
                LODWORD(v13) = v13 + (v14 & 0xFFFFFFF8);
                v15 = v7 + (v14 & 0xFFFFFFF8);
                v158 = v135 - (v14 & 0xFFFFFFF8);
                v159 = v135 + v7;
                do
                {
                  v160 = v159 + 1;
                  v161 = (__int128 *)(a1 + 16 * v160);
                  v163 = *v161;
                  v162 = v161[1];
                  v165 = v161[2];
                  v164 = v161[3];
                  v167 = v161[4];
                  v166 = v161[5];
                  v169 = v161[6];
                  v168 = v161[7];
                  v170 = (_OWORD *)(a1 + 16 * v159);
                  v170[6] = v169;
                  v170[7] = v168;
                  v170[4] = v167;
                  v170[5] = v166;
                  v170[2] = v165;
                  v170[3] = v164;
                  *v170 = v163;
                  v170[1] = v162;
                  *(_QWORD *)(a1 + 176 + v159) = *(_QWORD *)(a1 + 176 + v160);
                  v159 += 8;
                  v158 += 8;
                }
                while (v158);
                if (v14 == (v14 & 0xFFFFFFF8))
                  return (a3 - 1);
                goto LABEL_242;
              }
              v15 = v7 + v135;
              LODWORD(v13) = v13 + v135;
            }
          }
        }
      }
      do
      {
LABEL_242:
        *(_OWORD *)(a1 + 16 * v15) = *(_OWORD *)(a1 + 16 * v13);
        *(_BYTE *)(a1 + 176 + v15) = *(_BYTE *)(a1 + 176 + v13);
        LODWORD(v13) = v13 + 1;
        ++v15;
      }
      while ((_DWORD)a3 != (_DWORD)v13);
      return (a3 - 1);
    }
  }
  *v10 = a5;
  return a3;
}

uint64_t *llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::overflow<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(llvm::IntervalMapImpl::Path *this, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  llvm::IntervalMapImpl::Path *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t LeftSibling;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t RightSibling;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t *inserted;
  int v32;
  uint64_t *result;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  __int128 v67;
  __int128 v68;
  _DWORD v69[4];
  uint64_t v70;

  v2 = a2;
  v70 = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::IntervalMapImpl::Path *)((char *)this + 8);
  v3 = *((_QWORD *)this + 1);
  v67 = 0u;
  v68 = 0u;
  v5 = a2;
  v6 = *(unsigned int *)(v3 + 16 * a2 + 12);
  LeftSibling = llvm::IntervalMapImpl::Path::getLeftSibling((llvm::IntervalMapImpl::Path *)((char *)this + 8), a2);
  v8 = LeftSibling;
  if (LeftSibling)
  {
    v9 = (LeftSibling & 0x3F) + 1;
    v69[0] = v9;
    v6 = (v9 + v6);
    *(_QWORD *)&v67 = LeftSibling & 0xFFFFFFFFFFFFFFC0;
    v10 = 1;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v11 = *(_QWORD *)v4 + 16 * v5;
  v12 = *(_DWORD *)(v11 + 8);
  v69[v10] = v12;
  v13 = v12 + v9;
  v14 = v10 + 1;
  *(_QWORD *)((unint64_t)&v67 | (8 * v10)) = *(_QWORD *)v11;
  RightSibling = llvm::IntervalMapImpl::Path::getRightSibling(v4, v2);
  if (RightSibling)
  {
    v16 = (RightSibling & 0x3F) + 1;
    v69[v14] = v16;
    v13 += v16;
    *((_QWORD *)&v67 + v14) = RightSibling & 0xFFFFFFFFFFFFFFC0;
    v14 = v10 | 2;
  }
  if (v13 + 1 <= (11 * v14))
  {
    v17 = 0;
  }
  else
  {
    if ((_DWORD)v14 == 1)
      v17 = 1;
    else
      v17 = v14 - 1;
    v18 = v17;
    v69[v14] = v69[v18];
    v19 = 8 * v17;
    *((_QWORD *)&v67 + v14) = *(_QWORD *)((char *)&v67 + v19);
    v69[v18] = 0;
    v20 = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,char,192ul,64ul>::Allocate<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(*(_QWORD *)(*(_QWORD *)this + 280));
    *v20 = 0u;
    v20[1] = 0u;
    v20[2] = 0u;
    v20[3] = 0u;
    v20[4] = 0u;
    v20[5] = 0u;
    v20[6] = 0u;
    v20[7] = 0u;
    v20[8] = 0u;
    v20[9] = 0u;
    v14 = (v14 + 1);
    v20[10] = 0u;
    v20[11] = 0u;
    *(_QWORD *)((char *)&v67 + v19) = v20;
  }
  v21 = llvm::IntervalMapImpl::distribute((llvm::IntervalMapImpl *)v14, v13, 0xBu, v69, &v63, (unsigned int *)v6, 1);
  llvm::IntervalMapImpl::adjustSiblingSizes<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>((uint64_t)&v67, v14, (uint64_t)v69, (uint64_t)&v63);
  if (v8)
    llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
  v22 = v63 - 1;
  v23 = *(_QWORD *)(v67 + 16 * v22 + 8);
  v24 = *(_QWORD *)v4;
  *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v63;
  if (!v2)
  {
LABEL_18:
    if ((_DWORD)v14 != 1)
      goto LABEL_24;
LABEL_19:
    inserted = 0;
    v32 = v21;
    if ((_DWORD)v21)
      goto LABEL_20;
    goto LABEL_22;
  }
  *(_QWORD *)(*(_QWORD *)(v24 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v24 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v24 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v24 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v22;
  v25 = *(_QWORD *)v4;
  v26 = 16 * v5;
  while (1)
  {
    v27 = v26 - 16;
    if (v26 == 16)
      break;
    v28 = v25 + v26;
    v29 = *(unsigned int *)(v28 - 4);
    *(_QWORD *)(*(_QWORD *)(v28 - 16) + 8 * v29 + 96) = v23;
    v30 = *(_DWORD *)(v28 - 8) - 1;
    v26 = v27;
    if ((_DWORD)v29 != v30)
      goto LABEL_18;
  }
  *(_QWORD *)(*(_QWORD *)v25 + 8 * *(unsigned int *)(v25 + 12) + 128) = v23;
  if ((_DWORD)v14 == 1)
    goto LABEL_19;
LABEL_24:
  llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  v35 = (v64 - 1);
  v36 = *(_QWORD *)(*((_QWORD *)&v67 + 1) + 16 * v35 + 8);
  if (v17 != 1)
  {
    v37 = *(_QWORD *)v4;
    *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v64;
    if (v2)
    {
      *(_QWORD *)(*(_QWORD *)(v37 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v37 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v37 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v37 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v35;
      v38 = *(_QWORD *)v4;
      v39 = 16 * v2;
      while (1)
      {
        v40 = v39 - 16;
        if (v39 == 16)
          break;
        v41 = v38 + v39;
        v42 = *(unsigned int *)(v41 - 4);
        *(_QWORD *)(*(_QWORD *)(v41 - 16) + 8 * v42 + 96) = v36;
        v43 = *(_DWORD *)(v41 - 8) - 1;
        v39 = v40;
        if ((_DWORD)v42 != v43)
          goto LABEL_32;
      }
      inserted = 0;
      *(_QWORD *)(*(_QWORD *)v38 + 8 * *(unsigned int *)(v38 + 12) + 128) = v36;
      if ((_DWORD)v14 != 2)
        goto LABEL_33;
    }
    else
    {
LABEL_32:
      inserted = 0;
      if ((_DWORD)v14 != 2)
        goto LABEL_33;
    }
LABEL_26:
    v32 = v21 - 1;
    if ((_DWORD)v21 == 1)
      goto LABEL_22;
    do
LABEL_20:
      llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
    while (!__CFADD__(v32++, 1));
    goto LABEL_22;
  }
  inserted = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode((uint64_t)this, v2, *((_QWORD *)&v67 + 1) & 0xFFFFFFFFFFFFFFC0 | v35, v36);
  v2 += inserted;
  if ((_DWORD)v14 == 2)
    goto LABEL_26;
LABEL_33:
  llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  v44 = (v65 - 1);
  v45 = *(_QWORD *)(v68 + 16 * v44 + 8);
  if (v17 == 2)
  {
    inserted = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode((uint64_t)this, v2, v68 & 0xFFFFFFFFFFFFFFC0 | v44, v45);
    v2 += inserted;
    if ((_DWORD)v14 != 3)
      goto LABEL_35;
    goto LABEL_42;
  }
  v48 = *(_QWORD *)v4;
  *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v65;
  if (!v2)
  {
LABEL_41:
    if ((_DWORD)v14 != 3)
      goto LABEL_35;
LABEL_42:
    v32 = v21 - 2;
    if ((_DWORD)v21 != 2)
      goto LABEL_20;
LABEL_22:
    *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 12) = HIDWORD(v21);
    return inserted;
  }
  *(_QWORD *)(*(_QWORD *)(v48 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v48 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v48 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v48 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v44;
  v49 = *(_QWORD *)v4;
  v50 = 16 * v2;
  while (1)
  {
    v51 = v50 - 16;
    if (v50 == 16)
      break;
    v52 = v49 + v50;
    v53 = *(unsigned int *)(v52 - 4);
    *(_QWORD *)(*(_QWORD *)(v52 - 16) + 8 * v53 + 96) = v45;
    v54 = *(_DWORD *)(v52 - 8) - 1;
    v50 = v51;
    if ((_DWORD)v53 != v54)
      goto LABEL_41;
  }
  *(_QWORD *)(*(_QWORD *)v49 + 8 * *(unsigned int *)(v49 + 12) + 128) = v45;
  if ((_DWORD)v14 == 3)
    goto LABEL_42;
LABEL_35:
  llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  v46 = (v66 - 1);
  v47 = *(_QWORD *)(*((_QWORD *)&v68 + 1) + 16 * v46 + 8);
  if (v17 == 3)
  {
    inserted = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode((uint64_t)this, v2, *((_QWORD *)&v68 + 1) & 0xFFFFFFFFFFFFFFC0 | v46, v47);
    v2 += inserted;
  }
  else
  {
    v55 = *(_QWORD *)v4;
    *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v66;
    if (v2)
    {
      *(_QWORD *)(*(_QWORD *)(v55 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v55 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v55 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v55 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v46;
      v56 = *(_QWORD *)v4;
      v57 = 16 * v2;
      while (1)
      {
        v58 = v57 - 16;
        if (v57 == 16)
          break;
        v59 = v56 + v57;
        v60 = *(unsigned int *)(v59 - 4);
        *(_QWORD *)(*(_QWORD *)(v59 - 16) + 8 * v60 + 96) = v47;
        v61 = *(_DWORD *)(v59 - 8) - 1;
        v57 = v58;
        if ((_DWORD)v60 != v61)
          goto LABEL_54;
      }
      *(_QWORD *)(*(_QWORD *)v56 + 8 * *(unsigned int *)(v56 + 12) + 128) = v47;
    }
  }
LABEL_54:
  if ((_DWORD)v14 == 4)
  {
    v32 = v21 - 3;
    if ((_DWORD)v21 == 3)
      goto LABEL_22;
    goto LABEL_20;
  }
  result = llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  __break(1u);
  return result;
}

void llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::eraseNode(uint64_t *a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v35;
  char *v36;
  char *v37;
  unint64_t v38;
  char *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  _DWORD *v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _DWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v4 = *a1;
  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a2 - 1;
  if (a2 != 1)
  {
    v8 = v5 + 16 * v7;
    v9 = *(_QWORD **)v8;
    v10 = *(_DWORD *)(v8 + 8);
    if (v10 == 1)
    {
      v11 = *(_QWORD **)(v4 + 280);
      *v9 = *v11;
      *v11 = v9;
      llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::eraseNode(a1, a2 - 1);
      goto LABEL_69;
    }
    v18 = *(unsigned int *)(v5 + 16 * v7 + 12);
    v19 = v18 + 1;
    if ((_DWORD)v18 + 1 == v10)
    {
LABEL_62:
      v64 = v10 - 1;
      *(_DWORD *)(v5 + 16 * v7 + 8) = v10 - 1;
      v65 = (v10 - 2);
      *(_QWORD *)(*(_QWORD *)(v5 + 16 * (a2 - 2)) + 8 * *(unsigned int *)(v5 + 16 * (a2 - 2) + 12)) = *(_QWORD *)(*(_QWORD *)(v5 + 16 * (a2 - 2)) + 8 * *(unsigned int *)(v5 + 16 * (a2 - 2) + 12)) & 0xFFFFFFFFFFFFFFC0 | v65;
      v66 = *v6;
      if (*(_DWORD *)(*v6 + 16 * v7 + 12) == v64)
      {
        v67 = v9[v65 + 12];
        v68 = (_DWORD *)(v66 + 16 * v7 - 8);
        v69 = a2 - 1;
        while (--v69)
        {
          v70 = *((_QWORD *)v68 - 1);
          v72 = *v68;
          v71 = v68[1];
          v68 -= 4;
          *(_QWORD *)(v70 + 8 * v71 + 96) = v67;
          if ((_DWORD)v71 != v72 - 1)
            goto LABEL_68;
        }
        *(_QWORD *)(*(_QWORD *)v66 + 8 * *(unsigned int *)(v66 + 12) + 128) = v67;
LABEL_68:
        llvm::IntervalMapImpl::Path::moveRight(v6, a2 - 1);
      }
      goto LABEL_69;
    }
    v20 = v10 + ~(_DWORD)v18;
    if (v20 >= 0x16)
    {
      if (v10 - 2 >= v18 && v10 - 1 >= v19)
      {
        v35 = (char *)&v9[v18];
        v36 = v35 + 96;
        v37 = (char *)&v9[v19];
        v38 = v35 - v37;
        v39 = v37 + 96;
        v40 = v37 + 96 - v35;
        v41 = v36 - v37;
        v42 = v36 - v39;
        if (v38 >= 0x10 && v40 >= 0x10 && v41 >= 0x10 && v42 >= 0x10)
        {
          v19 += v20 & 0xFFFFFFFE;
          v21 = v18 + (v20 & 0xFFFFFFFE);
          v59 = v20 & 0xFFFFFFFE;
          do
          {
            v60 = (v18 + 1);
            v61 = v18;
            *(_OWORD *)&v9[v61] = *(_OWORD *)&v9[v60];
            *(_OWORD *)&v9[v61 + 12] = *(_OWORD *)&v9[v60 + 12];
            LODWORD(v18) = v18 + 2;
            v59 -= 2;
          }
          while (v59);
          if (v20 == (v20 & 0xFFFFFFFE))
            goto LABEL_61;
        }
        else
        {
          v21 = v18;
        }
      }
      else
      {
        v21 = *(_DWORD *)(v5 + 16 * v7 + 12);
      }
    }
    else
    {
      v21 = *(_DWORD *)(v5 + 16 * v7 + 12);
    }
    do
    {
      v62 = v19;
      v63 = v21;
      v9[v63] = v9[v62];
      v9[v63 + 12] = v9[v62 + 12];
      ++v19;
      ++v21;
    }
    while (v10 != v19);
LABEL_61:
    v5 = *v6;
    v10 = *(_DWORD *)(*v6 + 16 * v7 + 8);
    goto LABEL_62;
  }
  v12 = *(unsigned int *)(v5 + 12);
  v13 = *(_DWORD *)(v4 + 276);
  v14 = v12 + 1;
  if ((_DWORD)v12 + 1 != v13)
  {
    v15 = v4 + 8;
    v16 = v13 + ~(_DWORD)v12;
    if (v16 >= 0x18)
    {
      if (v13 - 2 >= v12 && v13 - 1 >= v14)
      {
        v24 = v4 + 8 * v12;
        v25 = v24 + 136;
        v24 += 8;
        v26 = v4 + 8 * v14;
        v27 = v26 + 8;
        v28 = v24 - (v26 + 8);
        v26 += 136;
        v29 = v26 - v24;
        v30 = v25 - v27;
        v31 = v25 - v26;
        if (v28 >= 0x10 && v29 >= 0x10 && v30 >= 0x10 && v31 >= 0x10)
        {
          v14 += v16 & 0xFFFFFFFE;
          v17 = v12 + (v16 & 0xFFFFFFFE);
          v46 = v16 & 0xFFFFFFFE;
          do
          {
            v47 = 8 * (v12 + 1);
            v48 = 8 * v12;
            *(_OWORD *)(v15 + v48) = *(_OWORD *)(v15 + v47);
            *(_OWORD *)(v4 + 136 + v48) = *(_OWORD *)(v4 + 136 + v47);
            LODWORD(v12) = v12 + 2;
            v46 -= 2;
          }
          while (v46);
          if (v16 == (v16 & 0xFFFFFFFE))
            goto LABEL_46;
        }
        else
        {
          v17 = v12;
        }
      }
      else
      {
        v17 = v12;
      }
    }
    else
    {
      v17 = v12;
    }
    do
    {
      v49 = 8 * v14;
      v50 = 8 * v17;
      *(_QWORD *)(v15 + v50) = *(_QWORD *)(v15 + v49);
      *(_QWORD *)(v4 + 136 + v50) = *(_QWORD *)(v4 + 136 + v49);
      ++v14;
      ++v17;
    }
    while (v13 != v14);
LABEL_46:
    v13 = *(_DWORD *)(v4 + 276);
    v5 = *v6;
  }
  v51 = v13 - 1;
  *(_DWORD *)(v4 + 276) = v51;
  *(_DWORD *)(v5 + 8) = v51;
  if (v51)
  {
LABEL_69:
    if (*((_DWORD *)a1 + 4))
    {
      v73 = *v6;
      if (*(_DWORD *)(*v6 + 12) < *(_DWORD *)(*v6 + 8))
      {
        v74 = *(_QWORD *)(*(_QWORD *)(v73 + 16 * v7)
                        + 8 * *(unsigned int *)(v73 + 16 * v7 + 12));
        v75 = 16 * a2;
        v76 = v73 + v75;
        *(_QWORD *)v76 = v74 & 0xFFFFFFFFFFFFFFC0;
        *(_DWORD *)(v76 + 8) = (v74 & 0x3F) + 1;
        *(_DWORD *)(*v6 + v75 + 12) = 0;
      }
    }
    return;
  }
  *(_DWORD *)(v4 + 272) = 0;
  *(_OWORD *)(v4 + 240) = 0u;
  *(_OWORD *)(v4 + 256) = 0u;
  *(_OWORD *)(v4 + 208) = 0u;
  *(_OWORD *)(v4 + 224) = 0u;
  *(_OWORD *)(v4 + 176) = 0u;
  *(_OWORD *)(v4 + 192) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)v4 = 0u;
  v52 = *a1;
  if (*(_DWORD *)(*a1 + 272))
  {
    v53 = v52 + 8;
    v54 = *(_DWORD *)(v52 + 276);
    *((_DWORD *)a1 + 4) = 0;
    v55 = a1 + 2;
    if (*((_DWORD *)a1 + 5))
    {
      v56 = 0;
    }
    else
    {
      v77 = v52 + 8;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, a1 + 3, 1uLL, 16);
      v53 = v77;
      v56 = *((unsigned int *)a1 + 4);
    }
    v57 = (_QWORD *)(*v6 + 16 * v56);
    *v57 = v53;
  }
  else
  {
    v54 = *(_DWORD *)(v52 + 276);
    *((_DWORD *)a1 + 4) = 0;
    v55 = a1 + 2;
    if (*((_DWORD *)a1 + 5))
    {
      v58 = 0;
    }
    else
    {
      v78 = v52;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, a1 + 3, 1uLL, 16);
      v52 = v78;
      v58 = *((unsigned int *)a1 + 4);
    }
    v57 = (_QWORD *)(*v6 + 16 * v58);
    *v57 = v52;
  }
  v57[1] = v54;
  ++*v55;
}

uint64_t llvm::IntervalMapImpl::adjustSiblingSizes<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t j;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  BOOL v44;
  char v45;
  BOOL v47;
  BOOL v49;
  BOOL v51;
  BOOL v53;
  BOOL v55;
  BOOL v57;
  BOOL v59;
  BOOL v61;
  BOOL v63;
  BOOL v65;
  uint64_t v67;
  uint64_t v68;
  int v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  unint64_t v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  unint64_t v90;
  unint64_t v91;
  BOOL v93;
  BOOL v95;
  BOOL v97;
  BOOL v99;
  BOOL v101;
  BOOL v103;
  BOOL v105;
  BOOL v107;
  BOOL v109;
  BOOL v111;
  BOOL v113;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  char *v118;
  uint64_t v119;
  unsigned int v120;
  __int128 *v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  const double *v132;
  const double *v133;
  const double *v134;
  const double *v135;
  const double *v136;
  const double *v137;
  const double *v138;
  uint64_t v139;
  double *v140;
  double *v141;
  double *v142;
  double *v143;
  double *v144;
  double *v145;
  double *v146;
  double *v147;
  unsigned int v148;
  uint64_t v149;
  uint64_t v150;
  const double *v151;
  const double *v152;
  const double *v153;
  double *v154;
  double *v155;
  double *v156;
  double *v157;
  _OWORD *v158;
  unsigned int v159;
  uint64_t v160;
  char *v161;
  __int128 *v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  char *v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int v181;
  unsigned int v182;
  uint64_t v183;
  int v184;
  char *v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unsigned int v190;
  int v191;
  unsigned int v192;
  unsigned int v193;
  uint64_t v194;
  uint64_t i;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  unsigned int v199;
  uint64_t v200;
  uint64_t v201;
  char *v202;
  uint64_t v203;
  unint64_t v204;
  uint64_t v205;
  unint64_t v206;
  unint64_t v207;
  char *v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  char *v219;
  BOOL v221;
  BOOL v223;
  BOOL v225;
  BOOL v227;
  BOOL v229;
  BOOL v231;
  BOOL v233;
  BOOL v235;
  BOOL v237;
  BOOL v239;
  BOOL v241;
  uint64_t v243;
  unsigned int v244;
  uint64_t v245;
  uint64_t v246;
  const double *v247;
  const double *v248;
  const double *v249;
  double *v250;
  double *v251;
  double *v252;
  double *v253;
  unint64_t v254;
  uint64_t v255;
  unint64_t v256;
  uint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  unint64_t v261;
  unint64_t v262;
  char *v263;
  uint64_t v264;
  unint64_t v265;
  char *v266;
  unint64_t v267;
  unint64_t v268;
  BOOL v270;
  BOOL v272;
  BOOL v274;
  BOOL v276;
  BOOL v278;
  BOOL v280;
  BOOL v282;
  BOOL v284;
  BOOL v286;
  BOOL v288;
  BOOL v290;
  uint64_t v292;
  uint64_t v293;
  char *v294;
  char *v295;
  uint64_t v296;
  unsigned int v297;
  __int128 *v298;
  __int128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  const double *v309;
  const double *v310;
  const double *v311;
  const double *v312;
  const double *v313;
  const double *v314;
  const double *v315;
  uint64_t v316;
  double *v317;
  double *v318;
  double *v319;
  double *v320;
  double *v321;
  double *v322;
  double *v323;
  double *v324;
  uint64_t v325;
  int v326;
  unint64_t v327;
  int v328;
  uint64_t v329;
  uint64_t v330;
  unsigned int v331;
  unint64_t v332;
  int v333;
  uint64_t v334;
  _OWORD *v335;
  unsigned int v336;
  uint64_t v337;
  char *v338;
  __int128 *v339;
  __int128 v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  __int128 v344;
  __int128 v345;
  __int128 v346;
  __int128 v347;
  __int128 v348;
  __int128 v349;
  __int128 v350;
  __int128 v351;
  __int128 v352;
  __int128 v353;
  __int128 v354;
  char *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  unsigned int v360;
  uint64_t v361;
  uint64_t v362;
  float64x2x2_t v363;
  float64x2x2_t v364;
  float64x2x2_t v365;
  float64x2x2_t v366;
  float64x2x2_t v367;
  float64x2x2_t v368;
  float64x2x2_t v369;
  float64x2x2_t v370;
  float64x2x2_t v371;
  float64x2x2_t v372;
  float64x2x2_t v373;
  float64x2x2_t v374;
  float64x2x2_t v375;
  float64x2x2_t v376;
  float64x2x2_t v377;
  float64x2x2_t v378;
  float64x2x2_t v379;
  float64x2x2_t v380;
  float64x2x2_t v381;
  float64x2x2_t v382;
  float64x2x2_t v383;
  float64x2x2_t v384;
  float64x2x2_t v385;
  float64x2x2_t v386;

  v356 = a2 - 1;
  if (a2 != 1)
  {
    v4 = (int)v356;
    v358 = a4;
    v359 = result;
    v360 = a2;
    while (1)
    {
      v5 = 4 * v4;
      v6 = *(_DWORD *)(a3 + 4 * v4);
      v7 = *(_DWORD *)(a4 + 4 * v4);
      if (v6 != v7)
        break;
LABEL_3:
      if (!(_DWORD)--v4)
      {
        if (a2 < 2)
          return result;
        v179 = 0;
        while (1)
        {
          v180 = 4 * v179;
          v181 = *(_DWORD *)(a3 + 4 * v179);
          v182 = *(_DWORD *)(a4 + 4 * v179);
          if (v181 != v182)
            break;
LABEL_270:
          if (++v179 == v356)
            return result;
        }
        LODWORD(v183) = v179;
        v362 = v179;
        while (2)
        {
          v183 = (v183 + 1);
          if ((_DWORD)v183 == a2)
            goto LABEL_270;
          v185 = *(char **)(result + 8 * v183);
          v186 = *(unsigned int *)(a3 + 4 * v183);
          v187 = *(_QWORD *)(result + 8 * v179);
          v188 = v181 - v182;
          if ((int)v188 >= 1)
          {
            v189 = (11 - v186);
            if (v181 >= v188)
              v190 = v181 - v182;
            else
              v190 = v181;
            if (v189 >= v190)
              v184 = v190;
            else
              v184 = 11 - v186;
            if (!(_DWORD)v186)
              goto LABEL_508;
            if (v186 >= 8)
            {
              v200 = (v186 - 1);
              v201 = (v200 + v184);
              if (!__CFADD__((_DWORD)v200, v184))
              {
                v202 = v185 + 8;
                v203 = 16 * (v200 + v184);
                v204 = (unint64_t)&v185[v203 + 8];
                v205 = 16 * (v186 - 1);
                v206 = (unint64_t)&v185[v205 + 8];
                v207 = (unint64_t)(v185 + 176);
                if (v204 - v205 > v204
                  || &v185[v203 - v205] > &v185[v203]
                  || (unint64_t)v202 > v206
                  || v185 > &v185[v205]
                  || &v185[v201 + 176 - v200] > &v185[v201 + 176]
                  || v207 > (unint64_t)&v185[v200 + 176])
                {
                  v191 = *(_DWORD *)(a3 + 4 * v183);
                  result = v359;
                  goto LABEL_501;
                }
                v213 = &v185[v203 - v205];
                v214 = (unint64_t)&v202[v203 - v205];
                v215 = (unint64_t)&v185[v203 + 16];
                v216 = (unint64_t)&v185[v205 + 16];
                v217 = v207 + v201 - v200;
                v218 = (unint64_t)&v185[v201 + 177];
                v219 = &v185[v200 + 177];
                v221 = (unint64_t)v213 < v206 && (unint64_t)v185 < v204;
                v223 = (unint64_t)v213 < v216 && (unint64_t)v202 < v204;
                v225 = (unint64_t)v213 < v218 && v217 < v204;
                v227 = v213 < v219 && v207 < v204;
                v229 = v214 < v206 && (unint64_t)v185 < v215;
                v231 = v214 < v216 && (unint64_t)v202 < v215;
                v233 = v214 < v218 && v217 < v215;
                v235 = v214 < (unint64_t)v219 && v207 < v215;
                v237 = (unint64_t)v185 < v218 && v217 < v206;
                v239 = (unint64_t)v202 < v218 && v217 < v216;
                v241 = v217 < (unint64_t)v219 && v207 < v218;
                if (v214 < v204 && (unint64_t)v213 < v215)
                {
                  v191 = *(_DWORD *)(a3 + 4 * v183);
                  a4 = v358;
                  result = v359;
                  a2 = v360;
                  v179 = v362;
                  goto LABEL_501;
                }
                a2 = v360;
                result = v359;
                if (v221 || v223 || v225 || v227 || v229 || v231 || v233 || v235 || v237 || v239)
                {
                  v191 = *(_DWORD *)(a3 + 4 * v183);
                  a4 = v358;
                  v179 = v362;
                  goto LABEL_501;
                }
                a4 = v358;
                v179 = v362;
                if (!v241)
                {
                  if (v186 >= 0x10)
                  {
                    v243 = v186 & 0xFFFFFFF0;
                    v306 = v243;
                    v307 = *(unsigned int *)(a3 + 4 * v183);
                    do
                    {
                      v308 = (v307 - 1);
                      v309 = (const double *)&v185[16 * v308 - 240];
                      v310 = v309;
                      v366 = vld2q_f64(v310);
                      v310 += 4;
                      v370 = vld2q_f64(v310);
                      v311 = v309 + 8;
                      v374 = vld2q_f64(v311);
                      v312 = v309 + 12;
                      v378 = vld2q_f64(v312);
                      v313 = v309 + 16;
                      v380 = vld2q_f64(v313);
                      v314 = v309 + 20;
                      v382 = vld2q_f64(v314);
                      v315 = v309 + 24;
                      v384 = vld2q_f64(v315);
                      v309 += 28;
                      v316 = (v184 - 1 + v307);
                      v386 = vld2q_f64(v309);
                      v317 = (double *)&v185[16 * v316 - 248];
                      v318 = v317 + 1;
                      vst2q_f64(v318, v366);
                      v319 = v317 + 5;
                      vst2q_f64(v319, v370);
                      v320 = v317 + 9;
                      vst2q_f64(v320, v374);
                      v321 = v317 + 13;
                      vst2q_f64(v321, v378);
                      v322 = v317 + 17;
                      vst2q_f64(v322, v380);
                      v323 = v317 + 21;
                      vst2q_f64(v323, v382);
                      v324 = v317 + 25;
                      vst2q_f64(v324, v384);
                      v317 += 29;
                      vst2q_f64(v317, v386);
                      *(_OWORD *)&v185[v316 + 161] = *(_OWORD *)&v185[v308 + 161];
                      v307 -= 16;
                      v306 -= 16;
                    }
                    while (v306);
                    if (v243 == v186)
                      goto LABEL_508;
                    if ((v186 & 8) != 0)
                      goto LABEL_399;
                    v191 = v186 & 0xF;
                  }
                  else
                  {
                    v243 = 0;
LABEL_399:
                    v191 = v186 & 7;
                    v244 = ~(_DWORD)v243 + v186 + v184;
                    v245 = ~v243 + v186;
                    v246 = v243 - (v186 & 0xFFFFFFF8);
                    do
                    {
                      v247 = (const double *)&v185[16 * v245 - 112];
                      v248 = v247;
                      v365 = vld2q_f64(v248);
                      v248 += 4;
                      v369 = vld2q_f64(v248);
                      v249 = v247 + 8;
                      v373 = vld2q_f64(v249);
                      v247 += 12;
                      v377 = vld2q_f64(v247);
                      v250 = (double *)&v185[16 * v244 - 120];
                      v251 = v250 + 1;
                      vst2q_f64(v251, v365);
                      v252 = v250 + 5;
                      vst2q_f64(v252, v369);
                      v253 = v250 + 9;
                      vst2q_f64(v253, v373);
                      v250 += 13;
                      vst2q_f64(v250, v377);
                      *(_QWORD *)&v185[v244 + 169] = *(_QWORD *)&v185[v245 + 169];
                      v244 -= 8;
                      v245 -= 8;
                      v246 += 8;
                    }
                    while (v246);
                    if ((v186 & 0xFFFFFFF8) == v186)
                    {
LABEL_508:
                      if (v184)
                      {
                        v330 = 0;
                        v331 = v181 - v184;
                        v332 = v181;
                        if (v181 >= v188)
                          v332 = v188;
                        if (v332 >= v189)
                          v333 = v189;
                        else
                          v333 = v332;
                        do
                        {
                          v334 = v331 + v330;
                          *(_OWORD *)&v185[16 * v330] = *(_OWORD *)(v187 + 16 * v334);
                          v185[v330++ + 176] = *(_BYTE *)(v187 + v334 + 176);
                        }
                        while (v333 != (_DWORD)v330);
                      }
LABEL_274:
                      *(_DWORD *)(a3 + 4 * v183) += v184;
                      v181 = *(_DWORD *)(a3 + v180) - v184;
                      *(_DWORD *)(a3 + v180) = v181;
                      v182 = *(_DWORD *)(a4 + v180);
                      if (v181 >= v182)
                        goto LABEL_270;
                      continue;
                    }
                  }
LABEL_501:
                  v325 = (v191 - 1);
                  v326 = -v191;
                  v327 = v181;
                  if (v181 >= v188)
                    v327 = v188;
                  if (v327 >= v189)
                    v328 = v189;
                  else
                    v328 = v327;
                  do
                  {
                    v329 = (v328 + v325);
                    *(_OWORD *)&v185[16 * v329] = *(_OWORD *)&v185[16 * v325];
                    v185[v329 + 176] = v185[v325-- + 176];
                    v44 = __CFADD__(v326++, 1);
                  }
                  while (!v44);
                  goto LABEL_508;
                }
              }
            }
            v191 = *(_DWORD *)(a3 + 4 * v183);
            goto LABEL_501;
          }
          break;
        }
        v192 = 11 - v181;
        if (v182 - v181 < v186)
          v193 = v182 - v181;
        else
          v193 = *(_DWORD *)(a3 + 4 * v183);
        if (v192 >= v193)
          v194 = v193;
        else
          v194 = v192;
        if ((_DWORD)v194)
        {
          for (i = 0; i != v194; ++i)
          {
            v196 = v181 + i;
            *(_OWORD *)(v187 + 16 * v196) = *(_OWORD *)&v185[16 * i];
            *(_BYTE *)(v187 + v196 + 176) = v185[i + 176];
          }
        }
        if ((_DWORD)v194 != (_DWORD)v186)
        {
          v197 = (v186 + ~(_DWORD)v194);
          if (v197 < 7)
          {
            v198 = 0;
            v199 = v194;
            goto LABEL_533;
          }
          v198 = 0;
          if ((int)v186 - 1 < v194)
          {
            v199 = v194;
            goto LABEL_533;
          }
          v254 = (unint64_t)(v185 + 8);
          v255 = 16 * v194;
          v256 = (unint64_t)&v185[v255 + 8];
          v257 = 16 * (v186 - 1 - v194);
          if (v256 + v257 < v256)
          {
            v199 = v194;
            goto LABEL_533;
          }
          v258 = (unint64_t)&v185[v255];
          if (&v185[v255 + v257] < &v185[v255])
          {
            v199 = v194;
            goto LABEL_533;
          }
          v259 = v179;
          v198 = 0;
          v260 = v254 + 16 * v197;
          v261 = (unint64_t)&v185[16 * v197 + 16];
          v262 = (unint64_t)(v185 + 176);
          v263 = &v185[v197 + 177];
          v264 = v255 + 16 * v197;
          v265 = v254 + v264;
          v266 = &v185[v264 + 16];
          v267 = (unint64_t)&v185[v194 + 176];
          v268 = (unint64_t)&v185[v194 + 177 + v197];
          v270 = v185 < v263 && v262 < v260;
          v272 = (unint64_t)v185 < v265 && v258 < v260;
          v274 = v185 < v266 && v256 < v260;
          v276 = (unint64_t)v185 < v268 && v267 < v260;
          v278 = v254 < (unint64_t)v263 && v262 < v261;
          v280 = v254 < v265 && v258 < v261;
          v282 = v254 < (unint64_t)v266 && v256 < v261;
          v284 = v254 < v268 && v267 < v261;
          v286 = v262 < v265 && v258 < (unint64_t)v263;
          v288 = v262 < (unint64_t)v266 && v256 < (unint64_t)v263;
          v290 = v262 < v268 && v267 < (unint64_t)v263;
          if (v254 < v260 && (unint64_t)v185 < v261)
          {
            v199 = v194;
            result = v359;
            v179 = v259;
            a2 = v360;
            goto LABEL_533;
          }
          result = v359;
          v179 = v259;
          if (v270 || v272 || v274)
          {
            v199 = v194;
            a2 = v360;
            goto LABEL_533;
          }
          a2 = v360;
          if (v276)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v278)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v280)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v282)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v284)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v286)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v288)
          {
            v199 = v194;
            goto LABEL_533;
          }
          if (v290)
          {
            v199 = v194;
            goto LABEL_533;
          }
          v292 = v197 + 1;
          if (v197 >= 0xF)
          {
            v198 = v292 & 0x1FFFFFFF0;
            v335 = v185 + 176;
            v336 = v194;
            v337 = v292 & 0x1FFFFFFF0;
            v338 = v185;
            do
            {
              v339 = (__int128 *)&v185[16 * v336];
              v341 = *v339;
              v340 = v339[1];
              v343 = v339[2];
              v342 = v339[3];
              v345 = v339[4];
              v344 = v339[5];
              v347 = v339[6];
              v346 = v339[7];
              v349 = v339[8];
              v348 = v339[9];
              v351 = v339[10];
              v350 = v339[11];
              v353 = v339[12];
              v352 = v339[13];
              v354 = v339[15];
              *((_OWORD *)v338 + 14) = v339[14];
              *((_OWORD *)v338 + 15) = v354;
              *((_OWORD *)v338 + 12) = v353;
              *((_OWORD *)v338 + 13) = v352;
              *((_OWORD *)v338 + 10) = v351;
              *((_OWORD *)v338 + 11) = v350;
              *((_OWORD *)v338 + 8) = v349;
              *((_OWORD *)v338 + 9) = v348;
              *((_OWORD *)v338 + 6) = v347;
              *((_OWORD *)v338 + 7) = v346;
              *((_OWORD *)v338 + 4) = v345;
              *((_OWORD *)v338 + 5) = v344;
              *((_OWORD *)v338 + 2) = v343;
              *((_OWORD *)v338 + 3) = v342;
              *(_OWORD *)v338 = v341;
              *((_OWORD *)v338 + 1) = v340;
              v338 += 256;
              v355 = &v185[v336];
              v336 += 16;
              *v335++ = *((_OWORD *)v355 + 11);
              v337 -= 16;
            }
            while (v337);
            if (v292 != v198)
            {
              if ((v292 & 8) == 0)
              {
                v199 = v194 + v198;
                goto LABEL_533;
              }
              goto LABEL_491;
            }
          }
          else
          {
            v198 = 0;
LABEL_491:
            v293 = v198;
            v198 = v292 & 0x1FFFFFFF8;
            v199 = v194 + (v292 & 0xFFFFFFF8);
            v294 = &v185[16 * v293];
            v295 = &v185[v293 + 176];
            v296 = v293 - (v292 & 0x1FFFFFFF8);
            v297 = v194 + v293;
            do
            {
              v298 = (__int128 *)&v185[16 * v297];
              v300 = *v298;
              v299 = v298[1];
              v302 = v298[2];
              v301 = v298[3];
              v304 = v298[4];
              v303 = v298[5];
              v305 = v298[7];
              *((_OWORD *)v294 + 6) = v298[6];
              *((_OWORD *)v294 + 7) = v305;
              *((_OWORD *)v294 + 4) = v304;
              *((_OWORD *)v294 + 5) = v303;
              *((_OWORD *)v294 + 2) = v302;
              *((_OWORD *)v294 + 3) = v301;
              *(_OWORD *)v294 = v300;
              *((_OWORD *)v294 + 1) = v299;
              v294 += 128;
              *(_QWORD *)v295 = *(_QWORD *)&v185[v297 + 176];
              v295 += 8;
              v297 += 8;
              v296 += 8;
            }
            while (v296);
            if (v292 != v198)
            {
              do
              {
LABEL_533:
                *(_OWORD *)&v185[16 * v198] = *(_OWORD *)&v185[16 * v199];
                v185[v198++ + 176] = v185[v199++ + 176];
              }
              while ((_DWORD)v186 != v199);
            }
          }
        }
        v184 = -(int)v194;
        goto LABEL_274;
      }
    }
    v8 = v4;
    v361 = v4;
    while (1)
    {
      if (!v8)
        goto LABEL_3;
      --v8;
      v10 = *(char **)(result + 8 * v4);
      v11 = *(_QWORD *)(result + 8 * v8);
      v12 = *(unsigned int *)(a3 + 4 * v8);
      v13 = v7 - v6;
      if ((int)v13 >= 1)
      {
        v14 = 11 - v6;
        if (v12 >= v13)
          v9 = v7 - v6;
        else
          v9 = *(_DWORD *)(a3 + 4 * v8);
        if (v14 < v9)
          v9 = 11 - v6;
        if (!v6)
          goto LABEL_142;
        if (v6 >= 8)
        {
          v24 = v6 - 1;
          v25 = v24 + v9;
          if (!__CFADD__((_DWORD)v24, v9))
          {
            v26 = v10 + 8;
            v27 = 16 * (v24 + v9);
            v28 = (unint64_t)&v10[v27 + 8];
            v29 = 16 * (v6 - 1);
            v30 = (unint64_t)&v10[v29 + 8];
            v31 = (unint64_t)(v10 + 176);
            if (v28 - v29 > v28
              || &v10[v27 - v29] > &v10[v27]
              || (unint64_t)v26 > v30
              || v10 > &v10[v29]
              || &v10[v25 + 176 - v24] > &v10[v25 + 176]
              || v31 > (unint64_t)&v10[v24 + 176])
            {
              v15 = v6;
            }
            else
            {
              v357 = v6;
              v37 = &v10[v27 - v29];
              v38 = (unint64_t)&v26[v27 - v29];
              v39 = (unint64_t)&v10[v27 + 16];
              v40 = (unint64_t)&v10[v29 + 16];
              v41 = v31 + v25 - v24;
              v42 = (unint64_t)&v10[v25 + 177];
              v43 = &v10[v24 + 177];
              v44 = (unint64_t)v37 >= v30 || (unint64_t)v10 >= v28;
              v45 = !v44;
              v47 = (unint64_t)v37 < v40 && (unint64_t)v26 < v28;
              v49 = (unint64_t)v37 < v42 && v41 < v28;
              v51 = v37 < v43 && v31 < v28;
              v53 = v38 < v30 && (unint64_t)v10 < v39;
              v55 = v38 < v40 && (unint64_t)v26 < v39;
              v57 = v38 < v42 && v41 < v39;
              v59 = v38 < (unint64_t)v43 && v31 < v39;
              v61 = (unint64_t)v10 < v42 && v41 < v30;
              v63 = (unint64_t)v26 < v42 && v41 < v40;
              v65 = v41 < (unint64_t)v43 && v31 < v42;
              if (v38 < v28 && (unint64_t)v37 < v39)
              {
                v15 = v6;
                a4 = v358;
                a2 = v360;
                result = v359;
                goto LABEL_133;
              }
              result = v359;
              if ((v45 & 1) == 0 && !v47 && !v49 && !v51 && !v53 && !v55)
              {
                v4 = v361;
                if (v57 || v59)
                {
                  v15 = v6;
                  a4 = v358;
                }
                else
                {
                  a4 = v358;
                  if (!v61 && !v63)
                  {
                    a2 = v360;
                    if (v65)
                    {
                      v15 = v6;
                    }
                    else if (v6 >= 0x10)
                    {
                      v67 = v6 & 0xFFFFFFF0;
                      v129 = v67;
                      v130 = v6;
                      do
                      {
                        v131 = (v130 - 1);
                        v132 = (const double *)&v10[16 * v131 - 240];
                        v133 = v132;
                        v363 = vld2q_f64(v133);
                        v133 += 4;
                        v367 = vld2q_f64(v133);
                        v134 = v132 + 8;
                        v371 = vld2q_f64(v134);
                        v135 = v132 + 12;
                        v375 = vld2q_f64(v135);
                        v136 = v132 + 16;
                        v379 = vld2q_f64(v136);
                        v137 = v132 + 20;
                        v381 = vld2q_f64(v137);
                        v138 = v132 + 24;
                        v383 = vld2q_f64(v138);
                        v132 += 28;
                        v139 = v9 - 1 + v130;
                        v385 = vld2q_f64(v132);
                        v140 = (double *)&v10[16 * v139 - 248];
                        v141 = v140 + 1;
                        vst2q_f64(v141, v363);
                        v142 = v140 + 5;
                        vst2q_f64(v142, v367);
                        v143 = v140 + 9;
                        vst2q_f64(v143, v371);
                        v144 = v140 + 13;
                        vst2q_f64(v144, v375);
                        v145 = v140 + 17;
                        vst2q_f64(v145, v379);
                        v146 = v140 + 21;
                        vst2q_f64(v146, v381);
                        v147 = v140 + 25;
                        vst2q_f64(v147, v383);
                        v140 += 29;
                        vst2q_f64(v140, v385);
                        *(_OWORD *)&v10[v139 + 161] = *(_OWORD *)&v10[v131 + 161];
                        v130 -= 16;
                        v129 -= 16;
                      }
                      while (v129);
                      if (v67 == v6)
                        goto LABEL_142;
                      if ((v6 & 8) != 0)
                        goto LABEL_248;
                      v15 = v6 & 0xF;
                    }
                    else
                    {
                      v67 = 0;
LABEL_248:
                      v15 = v6 & 7;
                      v148 = ~(_DWORD)v67 + v6 + v9;
                      v149 = ~v67 + v357;
                      v150 = v67 - (v357 & 0xFFFFFFF8);
                      do
                      {
                        v151 = (const double *)&v10[16 * v149 - 112];
                        v152 = v151;
                        v364 = vld2q_f64(v152);
                        v152 += 4;
                        v368 = vld2q_f64(v152);
                        v153 = v151 + 8;
                        v372 = vld2q_f64(v153);
                        v151 += 12;
                        v376 = vld2q_f64(v151);
                        v154 = (double *)&v10[16 * v148 - 120];
                        v155 = v154 + 1;
                        vst2q_f64(v155, v364);
                        v156 = v154 + 5;
                        vst2q_f64(v156, v368);
                        v157 = v154 + 9;
                        vst2q_f64(v157, v372);
                        v154 += 13;
                        vst2q_f64(v154, v376);
                        *(_QWORD *)&v10[v148 + 169] = *(_QWORD *)&v10[v149 + 169];
                        v148 -= 8;
                        v149 -= 8;
                        v150 += 8;
                      }
                      while (v150);
                      if ((v357 & 0xFFFFFFF8) == v357)
                      {
LABEL_142:
                        if (v9)
                        {
                          v73 = 0;
                          v74 = v12 - v9;
                          if (v12 >= v13)
                            v75 = v13;
                          else
                            v75 = v12;
                          if (v75 >= v14)
                            v76 = v14;
                          else
                            v76 = v75;
                          do
                          {
                            v77 = (v74 + v73);
                            *(_OWORD *)&v10[16 * v73] = *(_OWORD *)(v11 + 16 * v77);
                            v10[v73++ + 176] = *(_BYTE *)(v11 + v77 + 176);
                          }
                          while (v76 != (_DWORD)v73);
                        }
                        goto LABEL_7;
                      }
                    }
LABEL_134:
                    v68 = (v15 - 1);
                    v69 = -v15;
                    if (v12 >= v13)
                      v70 = v13;
                    else
                      v70 = v12;
                    if (v70 >= v14)
                      v71 = v14;
                    else
                      v71 = v70;
                    do
                    {
                      v72 = (v71 + v68);
                      *(_OWORD *)&v10[16 * v72] = *(_OWORD *)&v10[16 * v68];
                      v10[v72 + 176] = v10[v68-- + 176];
                      v44 = __CFADD__(v69++, 1);
                    }
                    while (!v44);
                    goto LABEL_142;
                  }
                  v15 = v6;
                }
                a2 = v360;
                goto LABEL_134;
              }
              v15 = v6;
            }
            a4 = v358;
            a2 = v360;
LABEL_133:
            v4 = v361;
            goto LABEL_134;
          }
        }
        v15 = v6;
        goto LABEL_134;
      }
      v16 = 11 - v12;
      if (v6 - v7 < v6)
        v17 = v6 - v7;
      else
        v17 = v6;
      if (v16 >= v17)
        v18 = v17;
      else
        v18 = v16;
      if ((_DWORD)v18)
      {
        for (j = 0; j != v18; ++j)
        {
          v20 = (v12 + j);
          *(_OWORD *)(v11 + 16 * v20) = *(_OWORD *)&v10[16 * j];
          *(_BYTE *)(v11 + v20 + 176) = v10[j + 176];
        }
      }
      if ((_DWORD)v18 != v6)
        break;
LABEL_6:
      v9 = -(int)v18;
LABEL_7:
      *(_DWORD *)(a3 + 4 * v8) -= v9;
      v6 = *(_DWORD *)(a3 + v5) + v9;
      *(_DWORD *)(a3 + v5) = v6;
      v7 = *(_DWORD *)(a4 + v5);
      if (v6 >= v7)
        goto LABEL_3;
    }
    v21 = v6 + ~(_DWORD)v18;
    if (v21 < 7)
    {
      v22 = 0;
      v23 = v18;
      goto LABEL_258;
    }
    v22 = 0;
    if (v6 - 1 < v18)
    {
      v23 = v18;
    }
    else
    {
      v78 = (unint64_t)(v10 + 8);
      v79 = 16 * v18;
      v80 = (unint64_t)&v10[v79 + 8];
      v81 = 16 * (v6 - 1 - v18);
      if (v80 + v81 < v80)
      {
        v23 = v18;
      }
      else
      {
        v82 = (unint64_t)&v10[v79];
        if (&v10[v79 + v81] < &v10[v79])
        {
          v23 = v18;
        }
        else
        {
          v22 = 0;
          v83 = v78 + 16 * v21;
          v84 = (unint64_t)&v10[16 * v21 + 16];
          v85 = (unint64_t)(v10 + 176);
          v86 = &v10[v21 + 177];
          v87 = v79 + 16 * v21;
          v88 = v78 + v87;
          v89 = &v10[v87 + 16];
          v90 = (unint64_t)&v10[v18 + 176];
          v91 = (unint64_t)&v10[v18 + 177 + v21];
          v93 = v10 < v86 && v85 < v83;
          v95 = (unint64_t)v10 < v88 && v82 < v83;
          v97 = v10 < v89 && v80 < v83;
          v99 = (unint64_t)v10 < v91 && v90 < v83;
          v101 = v78 < (unint64_t)v86 && v85 < v84;
          v103 = v78 < v88 && v82 < v84;
          v105 = v78 < (unint64_t)v89 && v80 < v84;
          v107 = v78 < v91 && v90 < v84;
          v109 = v85 < v88 && v82 < (unint64_t)v86;
          v111 = v85 < (unint64_t)v89 && v80 < (unint64_t)v86;
          v113 = v85 < v91 && v90 < (unint64_t)v86;
          if (v78 < v83 && (unint64_t)v10 < v84)
          {
            v23 = v18;
            result = v359;
            v4 = v361;
            goto LABEL_258;
          }
          result = v359;
          if (v93 || v95 || v97 || v99 || v101 || v103 || v105 || v107 || v109 || v111 || v113)
          {
            v23 = v18;
            v4 = v361;
          }
          else
          {
            v115 = v21 + 1;
            if (v21 < 0xF)
            {
              v22 = 0;
              v4 = v361;
              goto LABEL_238;
            }
            v22 = v115 & 0x1FFFFFFF0;
            v158 = v10 + 176;
            v159 = v18;
            v160 = v115 & 0x1FFFFFFF0;
            v161 = v10;
            do
            {
              v162 = (__int128 *)&v10[16 * v159];
              v164 = *v162;
              v163 = v162[1];
              v166 = v162[2];
              v165 = v162[3];
              v168 = v162[4];
              v167 = v162[5];
              v170 = v162[6];
              v169 = v162[7];
              v172 = v162[8];
              v171 = v162[9];
              v174 = v162[10];
              v173 = v162[11];
              v176 = v162[12];
              v175 = v162[13];
              v177 = v162[15];
              *((_OWORD *)v161 + 14) = v162[14];
              *((_OWORD *)v161 + 15) = v177;
              *((_OWORD *)v161 + 12) = v176;
              *((_OWORD *)v161 + 13) = v175;
              *((_OWORD *)v161 + 10) = v174;
              *((_OWORD *)v161 + 11) = v173;
              *((_OWORD *)v161 + 8) = v172;
              *((_OWORD *)v161 + 9) = v171;
              *((_OWORD *)v161 + 6) = v170;
              *((_OWORD *)v161 + 7) = v169;
              *((_OWORD *)v161 + 4) = v168;
              *((_OWORD *)v161 + 5) = v167;
              *((_OWORD *)v161 + 2) = v166;
              *((_OWORD *)v161 + 3) = v165;
              *(_OWORD *)v161 = v164;
              *((_OWORD *)v161 + 1) = v163;
              v161 += 256;
              v178 = &v10[v159];
              v159 += 16;
              *v158++ = *((_OWORD *)v178 + 11);
              v160 -= 16;
            }
            while (v160);
            v4 = v361;
            if (v115 == v22)
              goto LABEL_6;
            if ((v115 & 8) != 0)
            {
LABEL_238:
              v116 = v22;
              v22 = v115 & 0x1FFFFFFF8;
              v23 = v18 + (v115 & 0xFFFFFFF8);
              v117 = &v10[16 * v116];
              v118 = &v10[v116 + 176];
              v119 = v116 - (v115 & 0x1FFFFFFF8);
              v120 = v18 + v116;
              do
              {
                v121 = (__int128 *)&v10[16 * v120];
                v123 = *v121;
                v122 = v121[1];
                v125 = v121[2];
                v124 = v121[3];
                v127 = v121[4];
                v126 = v121[5];
                v128 = v121[7];
                *((_OWORD *)v117 + 6) = v121[6];
                *((_OWORD *)v117 + 7) = v128;
                *((_OWORD *)v117 + 4) = v127;
                *((_OWORD *)v117 + 5) = v126;
                *((_OWORD *)v117 + 2) = v125;
                *((_OWORD *)v117 + 3) = v124;
                *(_OWORD *)v117 = v123;
                *((_OWORD *)v117 + 1) = v122;
                v117 += 128;
                *(_QWORD *)v118 = *(_QWORD *)&v10[v120 + 176];
                v118 += 8;
                v120 += 8;
                v119 += 8;
              }
              while (v119);
              if (v115 == v22)
                goto LABEL_6;
              goto LABEL_258;
            }
            v23 = v18 + v22;
          }
        }
      }
    }
    do
    {
LABEL_258:
      *(_OWORD *)&v10[16 * v22] = *(_OWORD *)&v10[16 * v23];
      v10[v22++ + 176] = v10[v23++ + 176];
    }
    while (v6 != v23);
    goto LABEL_6;
  }
  return result;
}

uint64_t *llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  BOOL v55;
  BOOL v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  _DWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;

  v7 = (unsigned int *)(a1 + 8);
  v8 = *(_QWORD *)a1;
  v9 = (uint64_t *)(a2 == 1);
  if (a2 == 1)
  {
    v10 = *(unsigned int *)(v8 + 276);
    if (v10 <= 0xF)
    {
      v11 = v8 + 8;
      v12 = *(unsigned int *)(*(_QWORD *)v7 + 12);
      if ((_DWORD)v10 != (_DWORD)v12)
      {
        v13 = v10 - v12;
        v14 = (v10 + ~(_DWORD)v12);
        if (v14 < 0x39 || (int)v12 + 1 > v10)
          goto LABEL_26;
        v15 = 8 * v10 + v8;
        v16 = v15 + 8;
        v17 = v15 + 8 - 8 * v14;
        v18 = v15 + 136;
        v19 = v15 + 136 - 8 * v14;
        v20 = 8 * (v10 - 1);
        v21 = v14 > (int)v10 - 1 || v17 > v16;
        v22 = v21 || v19 > v18;
        v23 = v22 || v20 + v8 + 8 - 8 * v14 > (unint64_t)(v20 + v8 + 8);
        if (v23 || v20 + v8 + 136 - 8 * v14 > (unint64_t)(v20 + v8 + 136))
          goto LABEL_26;
        v25 = 8 * v10 + v8;
        v26 = v20 + v8;
        v27 = v20 + v8 + 8;
        if ((unint64_t)(v27 - (v25 + 8)) < 0x10)
          goto LABEL_26;
        v28 = v26 + 136;
        if ((unint64_t)(v25 + 8 - v28) < 0x10)
          goto LABEL_26;
        v29 = v25 + 136;
        if ((unint64_t)(v27 - v29) < 0x10)
          goto LABEL_26;
        if ((unint64_t)(v28 - v29) < 0x10)
          goto LABEL_26;
        v30 = v14 + 1;
        v13 -= v30 & 0xFFFFFFFE;
        v31 = v30 & 0x1FFFFFFFELL;
        do
        {
          v32 = 8 * (v10 - 1);
          v33 = 8 * v10;
          *(_OWORD *)(v8 + v33) = *(_OWORD *)(v8 + v32);
          *(_OWORD *)(v8 + 128 + v33) = *(_OWORD *)(v8 + 128 + v32);
          LODWORD(v10) = v10 - 2;
          v31 -= 2;
        }
        while (v31);
        if (v30 != (v30 & 0x1FFFFFFFELL))
        {
LABEL_26:
          v34 = v12 + v13;
          do
          {
            v35 = 8 * v34--;
            v36 = 8 * v34;
            *(_QWORD *)(v11 + v35) = *(_QWORD *)(v11 + v36);
            *(_QWORD *)(v8 + 136 + v35) = *(_QWORD *)(v8 + 136 + v36);
            --v13;
          }
          while (v13);
        }
      }
      v37 = (_QWORD *)(v11 + 8 * v12);
      *v37 = a3;
      v37[16] = a4;
      LODWORD(v37) = *(_DWORD *)(v8 + 276) + 1;
      *(_DWORD *)(v8 + 276) = (_DWORD)v37;
      v38 = *(_QWORD *)v7;
      *(_DWORD *)(v38 + 8) = (_DWORD)v37;
      v39 = *(_QWORD *)(*(_QWORD *)v38 + 8 * *(unsigned int *)(v38 + 12));
      *(_QWORD *)(v38 + 16) = v39 & 0xFFFFFFFFFFFFFFC0;
      *(_DWORD *)(v38 + 24) = (v39 & 0x3F) + 1;
      return 0;
    }
    v41 = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::splitRoot(*(_QWORD *)a1, (unsigned int *)*(unsigned int *)(*(_QWORD *)v7 + 12));
    llvm::IntervalMapImpl::Path::replaceRoot(v7, v8 + 8, *(_DWORD *)(v8 + 276), v41);
    a2 = 2;
  }
  v42 = (a2 - 1);
  if (*(_DWORD *)(a1 + 16)
    && (v43 = *(_QWORD *)v7, *(_DWORD *)(*(_QWORD *)v7 + 12) < *(_DWORD *)(*(_QWORD *)v7 + 8)))
  {
    v44 = *(_DWORD *)(v43 + 16 * v42 + 8);
    if (v44 != 12)
      goto LABEL_33;
  }
  else
  {
    llvm::IntervalMapImpl::Path::moveLeft((llvm::IntervalMapImpl::Path *)v7, a2 - 1);
    v43 = *(_QWORD *)v7;
    ++*(_DWORD *)(*(_QWORD *)v7 + 16 * v42 + 12);
    v44 = *(_DWORD *)(v43 + 16 * v42 + 8);
    if (v44 != 12)
    {
LABEL_33:
      v45 = (uint64_t *)(v43 + 16 * v42);
      v46 = *v45;
      v47 = *((unsigned int *)v45 + 3);
      if (v44 == (_DWORD)v47)
        goto LABEL_61;
LABEL_37:
      v50 = v44 - v47;
      v51 = v44 + ~(_DWORD)v47;
      if (v51 < 0x35 || (int)v47 + 1 > v44)
        goto LABEL_59;
      v52 = 8 * v44;
      v53 = 8 * (v44 - 1);
      v54 = v51 > v44 - 1 || v46 + v52 - 8 * v51 > (unint64_t)(v46 + v52);
      v55 = v54 || v46 + v52 + 96 - 8 * v51 > (unint64_t)(v46 + v52 + 96);
      v56 = v55 || v46 + v53 - 8 * v51 > (unint64_t)(v46 + v53);
      if (v56 || v46 + v53 + 96 - 8 * v51 > (unint64_t)(v46 + v53 + 96))
        goto LABEL_59;
      v58 = v52 + v46;
      v59 = v53 + v46;
      if ((unint64_t)(v59 - v58) < 0x10)
        goto LABEL_59;
      if ((unint64_t)(v58 - (v59 + 96)) < 0x10)
        goto LABEL_59;
      v60 = v58 + 96;
      if ((unint64_t)(v59 - v60) < 0x10)
        goto LABEL_59;
      if ((unint64_t)(v59 + 96 - v60) < 0x10)
        goto LABEL_59;
      v61 = v51 + 1;
      v50 -= v61 & 0xFFFFFFFE;
      v62 = v61 & 0x1FFFFFFFELL;
      do
      {
        v63 = 8 * (v44 - 1);
        v64 = 8 * v44;
        *(_OWORD *)(v46 - 8 + v64) = *(_OWORD *)(v46 - 8 + v63);
        *(_OWORD *)(v46 + 88 + v64) = *(_OWORD *)(v46 + 88 + v63);
        v44 -= 2;
        v62 -= 2;
      }
      while (v62);
      if (v61 != (v61 & 0x1FFFFFFFELL))
      {
LABEL_59:
        v65 = v47 + v50;
        do
        {
          v66 = 8 * v65--;
          v67 = 8 * v65;
          *(_QWORD *)(v46 + v66) = *(_QWORD *)(v46 + v67);
          *(_QWORD *)(v46 + 96 + v66) = *(_QWORD *)(v46 + 96 + v67);
          --v50;
        }
        while (v50);
      }
      goto LABEL_61;
    }
  }
  v9 = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::overflow<llvm::IntervalMapImpl::BranchNode<unsigned long long,char,12u,llvm::IntervalMapInfo<unsigned long long>>>((llvm::IntervalMapImpl::Path *)a1, v42);
  v42 = (v42 + (_DWORD)v9);
  v48 = *(_QWORD *)(a1 + 8);
  v44 = *(_DWORD *)(v48 + 16 * v42 + 8);
  v49 = (uint64_t *)(v48 + 16 * v42);
  v46 = *v49;
  v47 = *((unsigned int *)v49 + 3);
  if (v44 != (_DWORD)v47)
    goto LABEL_37;
LABEL_61:
  v68 = (_QWORD *)(v46 + 8 * v47);
  *v68 = a3;
  v68[12] = a4;
  v69 = *(_QWORD *)v7;
  v70 = *(_QWORD *)v7 + 16 * v42;
  v71 = *(unsigned int *)(v70 + 8);
  *(_DWORD *)(v70 + 8) = v71 + 1;
  if ((_DWORD)v42)
  {
    *(_QWORD *)(*(_QWORD *)(v69 + 16 * (v42 - 1))
              + 8 * *(unsigned int *)(v69 + 16 * (v42 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v69 + 16 * (v42 - 1))
                                                                                                + 8
                                                                                                * *(unsigned int *)(v69 + 16 * (v42 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v71;
    v69 = *(_QWORD *)v7;
    v72 = *(_QWORD *)v7 + 16 * v42;
    v73 = *(_DWORD *)(v72 + 12);
    if (v73 == *(_DWORD *)(v72 + 8) - 1)
    {
      v74 = (_DWORD *)(v72 - 8);
      v75 = v42;
      while (--v75)
      {
        v76 = *((_QWORD *)v74 - 1);
        v78 = *v74;
        v77 = v74[1];
        v74 -= 4;
        *(_QWORD *)(v76 + 8 * v77 + 96) = a4;
        if ((_DWORD)v77 != v78 - 1)
          goto LABEL_69;
      }
      *(_QWORD *)(*(_QWORD *)v69 + 8 * *(unsigned int *)(v69 + 12) + 128) = a4;
    }
  }
  else
  {
    v73 = *(_DWORD *)(v70 + 12);
  }
LABEL_69:
  v79 = *(_QWORD *)(*(_QWORD *)(v69 + 16 * v42) + 8 * v73);
  v80 = v69 + 16 * (v42 + 1);
  *(_QWORD *)v80 = v79 & 0xFFFFFFFFFFFFFFC0;
  *(_DWORD *)(v80 + 8) = (v79 & 0x3F) + 1;
  return v9;
}

_QWORD *llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,char,192ul,64ul>::Allocate<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  BOOL v4;
  unsigned int v5;
  uint64_t v6;
  char *buffer;
  uint64_t v8;
  char *v9;
  char *v10;

  result = *(_QWORD **)a1;
  if (result)
  {
    *(_QWORD *)a1 = *result;
  }
  else
  {
    *(_QWORD *)(a1 + 88) += 192;
    v3 = *(_QWORD *)(a1 + 8);
    if (v3)
      v4 = ((v3 + 63) & 0xFFFFFFFFFFFFFFC0) - v3 + 192 > *(_QWORD *)(a1 + 16) - v3;
    else
      v4 = 1;
    if (v4)
    {
      v5 = *(_DWORD *)(a1 + 32) >> 7;
      if (v5 >= 0x1E)
        LOBYTE(v5) = 30;
      v6 = 4096 << v5;
      buffer = (char *)llvm::allocate_buffer(4096 << v5, (std::align_val_t)8uLL);
      v8 = *(unsigned int *)(a1 + 32);
      if (v8 >= *(_DWORD *)(a1 + 36))
      {
        v10 = buffer;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8 + 1, 8);
        buffer = v10;
        LODWORD(v8) = *(_DWORD *)(a1 + 32);
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v8) = buffer;
      ++*(_DWORD *)(a1 + 32);
      v9 = &buffer[v6];
      result = (_QWORD *)((unint64_t)(buffer + 63) & 0xFFFFFFFFFFFFFFC0);
      *(_QWORD *)(a1 + 8) = result + 24;
      *(_QWORD *)(a1 + 16) = v9;
    }
    else
    {
      result = (_QWORD *)((v3 + 63) & 0xFFFFFFFFFFFFFFC0);
      *(_QWORD *)(a1 + 8) = result + 24;
    }
  }
  return result;
}

unint64_t llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::splitRoot(uint64_t a1, unsigned int *a2)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  __int128 *v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  unsigned int v31;
  uint64_t v32;
  _OWORD *v33;
  _OWORD *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v3 = llvm::IntervalMapImpl::distribute((llvm::IntervalMapImpl *)2, *(_DWORD *)(a1 + 276), 0xBu, 0, &v35, a2, 1);
  v4 = a1 + 8;
  v5 = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,char,192ul,64ul>::Allocate<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(*(_QWORD *)(a1 + 280));
  v6 = (unint64_t)v5;
  *v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v7 = v35;
  if (v35)
  {
    if (v35 >= 6
      && ((unint64_t)v5 < 8 * (unint64_t)v35 + a1 + 136
        ? (v8 = v4 >= (unint64_t)v5 + 8 * v35 + 96)
        : (v8 = 1),
          v8))
    {
      v9 = v35 & 0xFFFFFFFE;
      v10 = (__int128 *)(a1 + 136);
      v11 = v9;
      v12 = v5;
      do
      {
        *v12 = *(v10 - 8);
        v13 = *v10++;
        v12[6] = v13;
        ++v12;
        v11 -= 2;
      }
      while (v11);
      if (v9 == v7)
        goto LABEL_15;
    }
    else
    {
      v9 = 0;
    }
    v14 = v7 - v9;
    v15 = 8 * v9;
    v16 = (uint64_t *)(8 * v9 + a1 + 136);
    v17 = (_QWORD *)((char *)v5 + v15);
    do
    {
      *v17 = *(v16 - 16);
      v18 = *v16++;
      v17[12] = v18;
      ++v17;
      --v14;
    }
    while (v14);
LABEL_15:
    v19 = v35;
    goto LABEL_17;
  }
  v19 = 0;
LABEL_17:
  v20 = (unint64_t)llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,char,192ul,64ul>::Allocate<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(*(_QWORD *)(a1 + 280));
  *(_OWORD *)v20 = 0u;
  *(_OWORD *)(v20 + 16) = 0u;
  *(_OWORD *)(v20 + 32) = 0u;
  *(_OWORD *)(v20 + 48) = 0u;
  *(_OWORD *)(v20 + 64) = 0u;
  *(_OWORD *)(v20 + 80) = 0u;
  *(_OWORD *)(v20 + 96) = 0u;
  *(_OWORD *)(v20 + 112) = 0u;
  *(_OWORD *)(v20 + 128) = 0u;
  *(_OWORD *)(v20 + 144) = 0u;
  *(_OWORD *)(v20 + 160) = 0u;
  *(_OWORD *)(v20 + 176) = 0u;
  v21 = v36;
  if (!v36)
  {
    v29 = 0xFFFFFFFFLL;
    goto LABEL_27;
  }
  if (v36 < 0xC
    || __CFADD__(v19, v36 - 1)
    || (v22 = 8 * (v36 - 1), v23 = a1 + 8 * v19, v20 < v23 + v22 + 144) && v23 + 8 < v22 + v20 + 104)
  {
    v24 = 0;
    v25 = v19;
  }
  else
  {
    v24 = v36 & 0xFFFFFFFE;
    v25 = v19 + (v36 & 0xFFFFFFFE);
    v31 = v19;
    v32 = v24;
    v33 = (_OWORD *)v20;
    do
    {
      v34 = (_OWORD *)(v4 + 8 * v31);
      *v33 = *v34;
      v33[6] = v34[8];
      ++v33;
      v31 += 2;
      v32 -= 2;
    }
    while (v32);
    if (v24 == v21)
      goto LABEL_25;
  }
  v26 = v21 + v19;
  v27 = (_QWORD *)(v20 + 8 * v24);
  do
  {
    v28 = (_QWORD *)(v4 + 8 * v25);
    *v27 = *v28;
    v27[12] = v28[16];
    ++v25;
    ++v27;
  }
  while (v26 != v25);
LABEL_25:
  v29 = v36 - 1;
LABEL_27:
  *(_QWORD *)(a1 + 136) = *(_QWORD *)((v6 & 0xFFFFFFFFFFFFFFC0 | (v19 - 1) & 0xFFFFFFC0) + 8 * (v35 - 1) + 0x60);
  *(_QWORD *)(a1 + 8) = v6 & 0xFFFFFFFFFFFFFFC0 | (v19 - 1);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)((v20 & 0xFFFFFFFFFFFFFFC0 | v29 & 0xFFFFFFFFFFFFFFC0) + 8 * v29 + 0x60);
  *(_QWORD *)(a1 + 16) = v20 & 0xFFFFFFFFFFFFFFC0 | v29;
  *(_DWORD *)(a1 + 276) = 2;
  ++*(_DWORD *)(a1 + 272);
  return v3;
}

uint64_t *llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::overflow<llvm::IntervalMapImpl::BranchNode<unsigned long long,char,12u,llvm::IntervalMapInfo<unsigned long long>>>(llvm::IntervalMapImpl::Path *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  llvm::IntervalMapImpl::Path *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t LeftSibling;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t RightSibling;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t inserted;
  int v32;
  uint64_t *result;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  __int128 v67;
  __int128 v68;
  _DWORD v69[4];
  uint64_t v70;

  v2 = a2;
  v70 = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::IntervalMapImpl::Path *)((char *)this + 8);
  v3 = *((_QWORD *)this + 1);
  v67 = 0u;
  v68 = 0u;
  v5 = a2;
  v6 = *(unsigned int *)(v3 + 16 * a2 + 12);
  LeftSibling = llvm::IntervalMapImpl::Path::getLeftSibling((llvm::IntervalMapImpl::Path *)((char *)this + 8), a2);
  v8 = LeftSibling;
  if (LeftSibling)
  {
    v9 = (LeftSibling & 0x3F) + 1;
    v69[0] = v9;
    v6 = (v9 + v6);
    *(_QWORD *)&v67 = LeftSibling & 0xFFFFFFFFFFFFFFC0;
    v10 = 1;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v11 = *(_QWORD *)v4 + 16 * v5;
  v12 = *(_DWORD *)(v11 + 8);
  v69[v10] = v12;
  v13 = v12 + v9;
  v14 = v10 + 1;
  *(_QWORD *)((unint64_t)&v67 | (8 * v10)) = *(_QWORD *)v11;
  RightSibling = llvm::IntervalMapImpl::Path::getRightSibling(v4, v2);
  if (RightSibling)
  {
    v16 = (RightSibling & 0x3F) + 1;
    v69[v14] = v16;
    v13 += v16;
    *((_QWORD *)&v67 + v14) = RightSibling & 0xFFFFFFFFFFFFFFC0;
    v14 = v10 | 2;
  }
  if (v13 + 1 <= (12 * v14))
  {
    v17 = 0;
  }
  else
  {
    if ((_DWORD)v14 == 1)
      v17 = 1;
    else
      v17 = v14 - 1;
    v18 = v17;
    v69[v14] = v69[v18];
    v19 = 8 * v17;
    *((_QWORD *)&v67 + v14) = *(_QWORD *)((char *)&v67 + v19);
    v69[v18] = 0;
    v20 = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>,char,192ul,64ul>::Allocate<llvm::IntervalMapImpl::LeafNode<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>>(*(_QWORD *)(*(_QWORD *)this + 280));
    *v20 = 0u;
    v20[1] = 0u;
    v20[2] = 0u;
    v20[3] = 0u;
    v20[4] = 0u;
    v20[5] = 0u;
    v20[6] = 0u;
    v20[7] = 0u;
    v20[8] = 0u;
    v20[9] = 0u;
    v14 = (v14 + 1);
    v20[10] = 0u;
    v20[11] = 0u;
    *(_QWORD *)((char *)&v67 + v19) = v20;
  }
  v21 = llvm::IntervalMapImpl::distribute((llvm::IntervalMapImpl *)v14, v13, 0xCu, v69, &v63, (unsigned int *)v6, 1);
  llvm::IntervalMapImpl::adjustSiblingSizes<llvm::IntervalMapImpl::BranchNode<unsigned long long,char,12u,llvm::IntervalMapInfo<unsigned long long>>>((uint64_t)&v67, v14, (uint64_t)v69, (uint64_t)&v63);
  if (v8)
    llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
  v22 = v63 - 1;
  v23 = *(_QWORD *)(v67 + 8 * v22 + 96);
  v24 = *(_QWORD *)v4;
  *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v63;
  if (!(_DWORD)v2)
  {
LABEL_18:
    if ((_DWORD)v14 != 1)
      goto LABEL_24;
LABEL_19:
    inserted = 0;
    v32 = v21;
    if ((_DWORD)v21)
      goto LABEL_20;
    goto LABEL_22;
  }
  *(_QWORD *)(*(_QWORD *)(v24 + 16 * (v2 - 1))
            + 8 * *(unsigned int *)(v24 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v24 + 16 * (v2 - 1))
                                                                                             + 8
                                                                                             * *(unsigned int *)(v24 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v22;
  v25 = *(_QWORD *)v4;
  v26 = 16 * v5;
  while (1)
  {
    v27 = v26 - 16;
    if (v26 == 16)
      break;
    v28 = v25 + v26;
    v29 = *(unsigned int *)(v28 - 4);
    *(_QWORD *)(*(_QWORD *)(v28 - 16) + 8 * v29 + 96) = v23;
    v30 = *(_DWORD *)(v28 - 8) - 1;
    v26 = v27;
    if ((_DWORD)v29 != v30)
      goto LABEL_18;
  }
  *(_QWORD *)(*(_QWORD *)v25 + 8 * *(unsigned int *)(v25 + 12) + 128) = v23;
  if ((_DWORD)v14 == 1)
    goto LABEL_19;
LABEL_24:
  llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  v35 = (v64 - 1);
  v36 = *(_QWORD *)(*((_QWORD *)&v67 + 1) + 8 * v35 + 96);
  if (v17 != 1)
  {
    v37 = *(_QWORD *)v4;
    *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v64;
    if ((_DWORD)v2)
    {
      *(_QWORD *)(*(_QWORD *)(v37 + 16 * (v2 - 1))
                + 8 * *(unsigned int *)(v37 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v37 + 16 * (v2 - 1))
                                                                                                 + 8
                                                                                                 * *(unsigned int *)(v37 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v35;
      v38 = *(_QWORD *)v4;
      v39 = 16 * v2;
      while (1)
      {
        v40 = v39 - 16;
        if (v39 == 16)
          break;
        v41 = v38 + v39;
        v42 = *(unsigned int *)(v41 - 4);
        *(_QWORD *)(*(_QWORD *)(v41 - 16) + 8 * v42 + 96) = v36;
        v43 = *(_DWORD *)(v41 - 8) - 1;
        v39 = v40;
        if ((_DWORD)v42 != v43)
          goto LABEL_32;
      }
      inserted = 0;
      *(_QWORD *)(*(_QWORD *)v38 + 8 * *(unsigned int *)(v38 + 12) + 128) = v36;
      if ((_DWORD)v14 != 2)
        goto LABEL_33;
    }
    else
    {
LABEL_32:
      inserted = 0;
      if ((_DWORD)v14 != 2)
        goto LABEL_33;
    }
LABEL_26:
    v32 = v21 - 1;
    if ((_DWORD)v21 == 1)
      goto LABEL_22;
    do
LABEL_20:
      llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
    while (!__CFADD__(v32++, 1));
    goto LABEL_22;
  }
  inserted = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode(this, v2, *((_QWORD *)&v67 + 1) & 0xFFFFFFFFFFFFFFC0 | v35, v36);
  v2 = (v2 + inserted);
  if ((_DWORD)v14 == 2)
    goto LABEL_26;
LABEL_33:
  llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  v44 = (v65 - 1);
  v45 = *(_QWORD *)(v68 + 8 * v44 + 96);
  if (v17 == 2)
  {
    inserted = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode(this, v2, v68 & 0xFFFFFFFFFFFFFFC0 | v44, v45);
    v2 = (v2 + inserted);
    if ((_DWORD)v14 != 3)
      goto LABEL_35;
    goto LABEL_42;
  }
  v48 = *(_QWORD *)v4;
  *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v65;
  if (!(_DWORD)v2)
  {
LABEL_41:
    if ((_DWORD)v14 != 3)
      goto LABEL_35;
LABEL_42:
    v32 = v21 - 2;
    if ((_DWORD)v21 != 2)
      goto LABEL_20;
LABEL_22:
    *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 12) = HIDWORD(v21);
    return (uint64_t *)inserted;
  }
  *(_QWORD *)(*(_QWORD *)(v48 + 16 * (v2 - 1))
            + 8 * *(unsigned int *)(v48 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v48 + 16 * (v2 - 1))
                                                                                             + 8
                                                                                             * *(unsigned int *)(v48 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v44;
  v49 = *(_QWORD *)v4;
  v50 = 16 * v2;
  while (1)
  {
    v51 = v50 - 16;
    if (v50 == 16)
      break;
    v52 = v49 + v50;
    v53 = *(unsigned int *)(v52 - 4);
    *(_QWORD *)(*(_QWORD *)(v52 - 16) + 8 * v53 + 96) = v45;
    v54 = *(_DWORD *)(v52 - 8) - 1;
    v50 = v51;
    if ((_DWORD)v53 != v54)
      goto LABEL_41;
  }
  *(_QWORD *)(*(_QWORD *)v49 + 8 * *(unsigned int *)(v49 + 12) + 128) = v45;
  if ((_DWORD)v14 == 3)
    goto LABEL_42;
LABEL_35:
  llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  v46 = (v66 - 1);
  v47 = *(_QWORD *)(*((_QWORD *)&v68 + 1) + 8 * v46 + 96);
  if (v17 == 3)
  {
    inserted = llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::iterator::insertNode(this, v2, *((_QWORD *)&v68 + 1) & 0xFFFFFFFFFFFFFFC0 | v46, v47);
    LODWORD(v2) = v2 + inserted;
  }
  else
  {
    v55 = *(_QWORD *)v4;
    *(_DWORD *)(*(_QWORD *)v4 + 16 * v2 + 8) = v66;
    if ((_DWORD)v2)
    {
      *(_QWORD *)(*(_QWORD *)(v55 + 16 * (v2 - 1))
                + 8 * *(unsigned int *)(v55 + 16 * (v2 - 1) + 12)) = *(_QWORD *)(*(_QWORD *)(v55 + 16 * (v2 - 1))
                                                                                                 + 8
                                                                                                 * *(unsigned int *)(v55 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v46;
      v56 = *(_QWORD *)v4;
      v57 = 16 * v2;
      while (1)
      {
        v58 = v57 - 16;
        if (v57 == 16)
          break;
        v59 = v56 + v57;
        v60 = *(unsigned int *)(v59 - 4);
        *(_QWORD *)(*(_QWORD *)(v59 - 16) + 8 * v60 + 96) = v47;
        v61 = *(_DWORD *)(v59 - 8) - 1;
        v57 = v58;
        if ((_DWORD)v60 != v61)
          goto LABEL_54;
      }
      *(_QWORD *)(*(_QWORD *)v56 + 8 * *(unsigned int *)(v56 + 12) + 128) = v47;
    }
  }
LABEL_54:
  if ((_DWORD)v14 == 4)
  {
    v32 = v21 - 3;
    if ((_DWORD)v21 == 3)
      goto LABEL_22;
    goto LABEL_20;
  }
  result = llvm::IntervalMapImpl::Path::moveRight((uint64_t *)v4, v2);
  __break(1u);
  return result;
}

uint64_t llvm::IntervalMapImpl::adjustSiblingSizes<llvm::IntervalMapImpl::BranchNode<unsigned long long,char,12u,llvm::IntervalMapInfo<unsigned long long>>>(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  BOOL v21;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  BOOL v31;
  BOOL v32;
  int v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  _QWORD *v42;
  _QWORD *v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  BOOL v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  _OWORD *v51;
  _OWORD *v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  _OWORD *v63;
  _OWORD *v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  _OWORD *v68;
  _OWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  unsigned int v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  BOOL v86;
  BOOL v87;
  BOOL v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  unint64_t v99;
  BOOL v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  _OWORD *v104;
  _OWORD *v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v108;
  unsigned int v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  _OWORD *v125;
  _OWORD *v126;
  _QWORD *v127;
  _QWORD *v128;
  uint64_t v129;
  _OWORD *v130;
  _OWORD *v131;

  v4 = a2 - 1;
  if (a2 != 1)
  {
    v5 = (int)v4;
    while (1)
    {
      v6 = *(_DWORD *)(a3 + 4 * v5);
      v7 = *(_DWORD *)(a4 + 4 * v5);
      if (v6 != v7)
        break;
LABEL_3:
      if (!(_DWORD)--v5)
      {
        if (a2 < 2)
          return result;
        v74 = 0;
        while (1)
        {
          v75 = *(_DWORD *)(a3 + 4 * v74);
          v76 = *(_DWORD *)(a4 + 4 * v74);
          if (v75 != v76)
            break;
LABEL_102:
          if (++v74 == v4)
            return result;
        }
        LODWORD(v77) = v74;
        while (2)
        {
          v77 = (v77 + 1);
          if ((_DWORD)v77 == a2)
            goto LABEL_102;
          v79 = *(_QWORD *)(result + 8 * v77);
          v80 = *(unsigned int *)(a3 + 4 * v77);
          v81 = *(_QWORD *)(result + 8 * v74);
          v82 = v75 - v76;
          if ((int)(v75 - v76) >= 1)
          {
            LODWORD(v83) = 12 - v80;
            if (v75 >= v82)
              v78 = v75 - v76;
            else
              v78 = v75;
            if (v83 < v78)
              v78 = 12 - v80;
            if ((_DWORD)v80)
            {
              if (v80 < 0x32 || __CFADD__(v80 - 1, v78))
                goto LABEL_153;
              v84 = 8 * ((_DWORD)v80 - 1 + v78);
              v85 = 8 * (v80 - 1);
              v86 = v79 + v84 - v85 > v79 + v84 || v79 + 96 + v84 - v85 > v79 + 96 + v84;
              v87 = v86 || v79 > v79 + v85;
              v88 = v87 || v79 + 96 > v79 + 96 + v85;
              if (v88
                || (v89 = v85 + v79, (unint64_t)(v85 - v84) < 0x10)
                || (v90 = v79 + 96 + v85, v84 + v79 - v90 < 0x10)
                || (v91 = v79 + 96 + v84, v89 - v91 < 0x10)
                || v90 - v91 < 0x10)
              {
LABEL_153:
                v92 = *(_DWORD *)(a3 + 4 * v77);
              }
              else
              {
                v92 = *(_DWORD *)(a3 + 4 * v77) & 1;
                v93 = v80 & 0xFFFFFFFE;
                v94 = *(unsigned int *)(a3 + 4 * v77);
                do
                {
                  v95 = 8 * (v94 - 1);
                  v96 = 8 * (v78 - 1 + v94);
                  *(_OWORD *)(v79 - 8 + v96) = *(_OWORD *)(v79 - 8 + v95);
                  *(_OWORD *)(v79 + 88 + v96) = *(_OWORD *)(v79 + 88 + v95);
                  v94 -= 2;
                  v93 -= 2;
                }
                while (v93);
                if ((v80 & 0xFFFFFFFE) == v80)
                  goto LABEL_156;
              }
              v106 = (_QWORD *)(v79 + 8 * (v92 - 1));
              do
              {
                v107 = (_QWORD *)(v79 + 8 * (v78 - 1 + v92));
                *v107 = *v106;
                v107[12] = v106[12];
                --v106;
                --v92;
              }
              while (v92);
            }
LABEL_156:
            if (v78)
            {
              v108 = 0;
              v109 = v75 - v78;
              if (v75 < v82)
                v82 = v75;
              if (v82 >= v83)
                v83 = v83;
              else
                v83 = v82;
              if (v83 < 0xA || v75 - 1 < v109)
              {
LABEL_167:
                v112 = v75 - v78;
                goto LABEL_168;
              }
              v110 = 8 * (v78 - 1);
              v111 = 8 * (v75 - v78);
              if (v79 < v81 + v111 + v110 + 104 && v81 + v111 < v79 + v110 + 104)
              {
                v108 = 0;
                goto LABEL_167;
              }
              v108 = v83 & 0xFFFFFFFE;
              v112 = v109 + (v83 & 0xFFFFFFFE);
              v129 = v108;
              v130 = (_OWORD *)v79;
              do
              {
                v131 = (_OWORD *)(v81 + 8 * v109);
                *v130 = *v131;
                v130[6] = v131[6];
                ++v130;
                v109 += 2;
                v129 -= 2;
              }
              while (v129);
              if (v108 != v83)
              {
LABEL_168:
                v113 = (_QWORD *)(v79 + 8 * v108);
                do
                {
                  v114 = (_QWORD *)(v81 + 8 * v112);
                  *v113 = *v114;
                  v113[12] = v114[12];
                  ++v112;
                  ++v113;
                }
                while (v75 != v112);
              }
            }
LABEL_106:
            *(_DWORD *)(a3 + 4 * v77) += v78;
            v75 = *(_DWORD *)(a3 + 4 * v74) - v78;
            *(_DWORD *)(a3 + 4 * v74) = v75;
            v76 = *(_DWORD *)(a4 + 4 * v74);
            if (v75 >= v76)
              goto LABEL_102;
            continue;
          }
          break;
        }
        v97 = 12 - v75;
        if (v76 - v75 < v80)
          LODWORD(v98) = v76 - v75;
        else
          LODWORD(v98) = *(_DWORD *)(a3 + 4 * v77);
        if (v97 >= v98)
          v98 = v98;
        else
          v98 = v97;
        if ((_DWORD)v98)
        {
          if (v98 < 0xA
            || __CFADD__(v75, v98 - 1)
            || ((v99 = v81 + 8 * v75, v79 < v99 + 8 * v98 + 96) ? (v100 = v99 >= v79 + 8 * v98 + 96) : (v100 = 1),
                !v100))
          {
            v101 = 0;
            v102 = v75;
            goto LABEL_172;
          }
          v101 = v98 & 0xFFFFFFFE;
          v102 = v75 + (v98 & 0xFFFFFFFE);
          v103 = v101;
          v104 = *(_OWORD **)(result + 8 * v77);
          do
          {
            v105 = (_OWORD *)(v81 + 8 * v75);
            *v105 = *v104;
            v105[6] = v104[6];
            ++v104;
            v75 += 2;
            v103 -= 2;
          }
          while (v103);
          if (v101 != v98)
          {
LABEL_172:
            v115 = v98 - v101;
            v116 = (_QWORD *)(v79 + 8 * v101);
            do
            {
              v117 = (_QWORD *)(v81 + 8 * v102);
              *v117 = *v116;
              v117[12] = v116[12];
              ++v102;
              ++v116;
              --v115;
            }
            while (v115);
          }
        }
        if ((_DWORD)v98 != (_DWORD)v80)
        {
          v118 = 0;
          v119 = (v80 + ~(_DWORD)v98);
          if (v119 < 0x15
            || (int)v80 - 1 < v98
            || (v118 = 0, v120 = 8 * v98, (unint64_t)(v120 + 96) < 0x10)
            || (unint64_t)(96 - v120) < 0x10
            || !(_DWORD)v98)
          {
            v122 = v98;
            goto LABEL_185;
          }
          v121 = v119 + 1;
          v118 = (v119 + 1) & 0x1FFFFFFFELL;
          v122 = v98 + v118;
          v123 = v98;
          v124 = v118;
          v125 = (_OWORD *)v79;
          do
          {
            v126 = (_OWORD *)(v79 + 8 * v123);
            *v125 = *v126;
            v125[6] = v126[6];
            ++v125;
            v123 += 2;
            v124 -= 2;
          }
          while (v124);
          if (v121 != v118)
          {
LABEL_185:
            v127 = (_QWORD *)(v79 + 8 * v118);
            do
            {
              v128 = (_QWORD *)(v79 + 8 * v122);
              *v127 = *v128;
              v127[12] = v128[12];
              ++v122;
              ++v127;
            }
            while ((_DWORD)v80 != v122);
          }
        }
        v78 = -(int)v98;
        goto LABEL_106;
      }
    }
    v8 = v5;
    while (1)
    {
      if (!v8)
        goto LABEL_3;
      --v8;
      v10 = *(_QWORD *)(result + 8 * v5);
      v11 = *(_QWORD *)(result + 8 * v8);
      v12 = *(unsigned int *)(a3 + 4 * v8);
      v13 = v7 - v6;
      if ((int)(v7 - v6) < 1)
      {
        v44 = 12 - v12;
        if (v6 - v7 < v6)
          LODWORD(v45) = v6 - v7;
        else
          LODWORD(v45) = v6;
        if (v44 >= v45)
          v45 = v45;
        else
          v45 = v44;
        if ((_DWORD)v45)
        {
          if (v45 < 0xA
            || __CFADD__((_DWORD)v12, v45 - 1)
            || ((v46 = v11 + 8 * v12, v10 < v46 + 8 * v45 + 96) ? (v47 = v46 >= v10 + 8 * v45 + 96) : (v47 = 1), !v47))
          {
            v48 = 0;
            v49 = *(_DWORD *)(a3 + 4 * v8);
            goto LABEL_75;
          }
          v48 = v45 & 0xFFFFFFFE;
          v49 = v12 + (v45 & 0xFFFFFFFE);
          v50 = v48;
          v51 = *(_OWORD **)(result + 8 * v5);
          do
          {
            v52 = (_OWORD *)(v11 + 8 * v12);
            *v52 = *v51;
            v52[6] = v51[6];
            ++v51;
            LODWORD(v12) = v12 + 2;
            v50 -= 2;
          }
          while (v50);
          if (v48 != v45)
          {
LABEL_75:
            v53 = v45 - v48;
            v54 = (_QWORD *)(v10 + 8 * v48);
            do
            {
              v55 = (_QWORD *)(v11 + 8 * v49);
              *v55 = *v54;
              v55[12] = v54[12];
              ++v49;
              ++v54;
              --v53;
            }
            while (v53);
          }
        }
        if ((_DWORD)v45 != v6)
        {
          v56 = 0;
          v57 = v6 + ~(_DWORD)v45;
          if (v57 < 0x15
            || v6 - 1 < v45
            || (v56 = 0, v58 = 8 * v45, (unint64_t)(v58 + 96) < 0x10)
            || (unint64_t)(96 - v58) < 0x10
            || !(_DWORD)v45)
          {
            v60 = v45;
            goto LABEL_88;
          }
          v59 = v57 + 1;
          v56 = (v57 + 1) & 0x1FFFFFFFELL;
          v60 = v45 + v56;
          v61 = v45;
          v62 = v56;
          v63 = (_OWORD *)v10;
          do
          {
            v64 = (_OWORD *)(v10 + 8 * v61);
            *v63 = *v64;
            v63[6] = v64[6];
            ++v63;
            v61 += 2;
            v62 -= 2;
          }
          while (v62);
          if (v59 != v56)
          {
LABEL_88:
            v65 = (_QWORD *)(v10 + 8 * v56);
            do
            {
              v66 = (_QWORD *)(v10 + 8 * v60);
              *v65 = *v66;
              v65[12] = v66[12];
              ++v60;
              ++v65;
            }
            while (v6 != v60);
          }
        }
        v9 = -(int)v45;
        goto LABEL_7;
      }
      LODWORD(v14) = 12 - v6;
      if (v12 >= v13)
        v9 = v7 - v6;
      else
        v9 = *(_DWORD *)(a3 + 4 * v8);
      if (v14 < v9)
        v9 = 12 - v6;
      if (v6)
      {
        v15 = v6;
        if (v6 < 0x32)
          goto LABEL_38;
        v16 = v6 - 1;
        v17 = v6 - 1 + v9;
        if (__CFADD__(v16, v9))
          goto LABEL_38;
        v18 = 8 * v17;
        v19 = 8 * v16;
        v20 = v10 + v18 - v19 > v10 + v18 || v10 + 96 + v18 - v19 > v10 + 96 + v18;
        v21 = v20 || v10 > v10 + v19;
        if (v21 || v10 + 96 > v10 + 96 + v19)
          goto LABEL_38;
        v23 = v18 + v10;
        v24 = v10 + 96 + v18;
        v25 = v19 + v10;
        v26 = v19 + v10 - v23;
        v27 = v10 + 96 + v19;
        v28 = v23 - v27;
        v29 = v25 - v24;
        v30 = v27 - v24;
        v31 = v26 >= 0x10 && v28 >= 0x10;
        v32 = v31 && v29 >= 0x10;
        if (!v32 || v30 < 0x10)
        {
LABEL_38:
          v34 = v15;
LABEL_39:
          v35 = (_QWORD *)(v10 + 8 * (v34 - 1));
          do
          {
            v36 = (_QWORD *)(v10 + 8 * (v9 - 1 + v34));
            *v36 = *v35;
            v36[12] = v35[12];
            --v35;
            --v34;
          }
          while (v34);
          goto LABEL_41;
        }
        v34 = v15 & 1;
        v70 = v15 & 0xFFFFFFFE;
        v71 = v15;
        do
        {
          v72 = 8 * (v71 - 1);
          v73 = 8 * (v9 - 1 + v71);
          *(_OWORD *)(v10 - 8 + v73) = *(_OWORD *)(v10 - 8 + v72);
          *(_OWORD *)(v10 + 88 + v73) = *(_OWORD *)(v10 + 88 + v72);
          v71 -= 2;
          v70 -= 2;
        }
        while (v70);
        if ((v15 & 0xFFFFFFFE) != v15)
          goto LABEL_39;
      }
LABEL_41:
      if (v9)
      {
        v37 = 0;
        v38 = v12 - v9;
        if (v12 < v13)
          v13 = v12;
        if (v13 >= v14)
          v14 = v14;
        else
          v14 = v13;
        if (v14 < 0xA || (int)v12 - 1 < v38)
        {
LABEL_52:
          v41 = v12 - v9;
        }
        else
        {
          v39 = 8 * (v9 - 1);
          v40 = 8 * (v12 - v9);
          if (v10 < v11 + v40 + v39 + 104 && v11 + v40 < v10 + v39 + 104)
          {
            v37 = 0;
            goto LABEL_52;
          }
          v37 = v14 & 0xFFFFFFFE;
          v41 = v38 + (v14 & 0xFFFFFFFE);
          v67 = v37;
          v68 = (_OWORD *)v10;
          do
          {
            v69 = (_OWORD *)(v11 + 8 * v38);
            *v68 = *v69;
            v68[6] = v69[6];
            ++v68;
            v38 += 2;
            v67 -= 2;
          }
          while (v67);
          if (v37 == v14)
            goto LABEL_7;
        }
        v42 = (_QWORD *)(v10 + 8 * v37);
        do
        {
          v43 = (_QWORD *)(v11 + 8 * v41);
          *v42 = *v43;
          v42[12] = v43[12];
          ++v41;
          ++v42;
        }
        while ((_DWORD)v12 != v41);
      }
LABEL_7:
      *(_DWORD *)(a3 + 4 * v8) -= v9;
      v6 = *(_DWORD *)(a3 + 4 * v5) + v9;
      *(_DWORD *)(a3 + 4 * v5) = v6;
      v7 = *(_DWORD *)(a4 + 4 * v5);
      if (v6 >= v7)
        goto LABEL_3;
    }
  }
  return result;
}

void llvm::IntervalMapOverlaps<llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>,llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>>::advance(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v1 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    if (*(_DWORD *)(v3 + 12) < *(_DWORD *)(v3 + 8))
    {
      v4 = *(unsigned int *)(a1 + 104);
      if ((_DWORD)v4)
      {
        v5 = *(_QWORD *)(a1 + 96);
        if (*(_DWORD *)(v5 + 12) < *(_DWORD *)(v5 + 8))
        {
          v6 = v3 + 16 * v1;
          v7 = *(_QWORD *)(v6 - 16);
          v8 = *(unsigned int *)(v6 - 4);
          v9 = a1 + 88;
          v10 = v5 + 16 * v4;
          v11 = *(_QWORD *)(v10 - 16);
          v12 = *(unsigned int *)(v10 - 4);
          v13 = *(_QWORD *)(v11 + 16 * v12);
          if (*(_QWORD *)(v7 + 16 * v8 + 8) >= v13)
          {
            v15 = *(_QWORD *)(v7 + 16 * v8);
            if (*(_QWORD *)(v11 + 16 * v12 + 8) < v15)
            {
              v16 = *(_QWORD *)v9;
              if (!*(_DWORD *)(*(_QWORD *)v9 + 272))
              {
                v17 = *(_DWORD *)(v16 + 276);
                if ((_DWORD)v12 == v17)
                  goto LABEL_25;
                do
                {
                  if (*(_QWORD *)(v16 + 16 * v12 + 8) >= v15)
                    goto LABEL_25;
                  LODWORD(v12) = v12 + 1;
                }
                while (v17 != (_DWORD)v12);
LABEL_24:
                LODWORD(v12) = v17;
                goto LABEL_25;
              }
              goto LABEL_23;
            }
          }
          else
          {
            v14 = *(_QWORD *)a1;
            if (*(_DWORD *)(*(_QWORD *)a1 + 272))
            {
              llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::const_iterator::treeAdvanceTo(a1, v13);
            }
            else
            {
              v18 = *(_DWORD *)(v14 + 276);
              if ((_DWORD)v8 != v18)
              {
                while (*(_QWORD *)(v14 + 16 * v8 + 8) < v13)
                {
                  LODWORD(v8) = v8 + 1;
                  if (v18 == (_DWORD)v8)
                  {
                    LODWORD(v8) = *(_DWORD *)(v14 + 276);
                    break;
                  }
                }
              }
              *(_DWORD *)(v6 - 4) = v8;
            }
            v19 = *(unsigned int *)(a1 + 16);
            if ((_DWORD)v19)
            {
              v20 = *(_QWORD *)(a1 + 8);
              if (*(_DWORD *)(v20 + 12) < *(_DWORD *)(v20 + 8))
              {
                v21 = *(_QWORD *)(a1 + 96) + 16 * *(unsigned int *)(a1 + 104);
                v22 = *(_QWORD *)(v21 - 16);
                v23 = *(unsigned int *)(v21 - 4);
                if (*(_QWORD *)(v22 + 16 * v23 + 8) < *(_QWORD *)(*(_QWORD *)(v20 + 16 * v19 - 16)
                                                                 + 16 * *(unsigned int *)(v20 + 16 * v19 - 4)))
                {
                  v24 = *(_QWORD *)(v22 + 16 * v23);
                  do
                  {
                    if (!v19)
                      break;
                    if (*(_DWORD *)(v20 + 12) < *(_DWORD *)(v20 + 8))
                    {
                      v27 = *(_QWORD *)a1;
                      if (*(_DWORD *)(*(_QWORD *)a1 + 272))
                      {
                        llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::const_iterator::treeAdvanceTo(a1, v24);
                      }
                      else
                      {
                        v28 = v20 + 16 * v19;
                        v29 = *(_DWORD *)(v28 - 4);
                        v30 = *(_DWORD *)(v27 + 276);
                        if (v29 != v30)
                        {
                          while (*(_QWORD *)(v27 + 16 * v29 + 8) < v24)
                          {
                            if (v30 == ++v29)
                            {
                              v29 = *(_DWORD *)(v27 + 276);
                              break;
                            }
                          }
                        }
                        *(_DWORD *)(v28 - 4) = v29;
                      }
                    }
                    v31 = *(unsigned int *)(a1 + 16);
                    if (!(_DWORD)v31)
                      break;
                    v32 = *(_QWORD *)(a1 + 8);
                    if (*(_DWORD *)(v32 + 12) >= *(_DWORD *)(v32 + 8))
                      break;
                    v33 = *(_QWORD *)(a1 + 96);
                    v34 = *(unsigned int *)(a1 + 104);
                    v10 = v33 + 16 * v34;
                    v12 = *(unsigned int *)(v10 - 4);
                    v15 = *(_QWORD *)(*(_QWORD *)(v32 + 16 * v31 - 16) + 16 * *(unsigned int *)(v32 + 16 * v31 - 4));
                    if (*(_QWORD *)(*(_QWORD *)(v10 - 16) + 16 * v12 + 8) >= v15)
                      break;
                    if ((_DWORD)v34 && *(_DWORD *)(v33 + 12) < *(_DWORD *)(v33 + 8))
                    {
                      v35 = *(_QWORD *)v9;
                      if (*(_DWORD *)(*(_QWORD *)v9 + 272))
                      {
LABEL_23:
                        llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::const_iterator::treeAdvanceTo(a1 + 88, v15);
                      }
                      else
                      {
                        v17 = *(_DWORD *)(v35 + 276);
                        if ((_DWORD)v12 != v17)
                        {
                          while (*(_QWORD *)(v35 + 16 * v12 + 8) < v15)
                          {
                            LODWORD(v12) = v12 + 1;
                            if (v17 == (_DWORD)v12)
                              goto LABEL_24;
                          }
                        }
LABEL_25:
                        *(_DWORD *)(v10 - 4) = v12;
                      }
                    }
                    v25 = *(unsigned int *)(a1 + 104);
                    if (!(_DWORD)v25)
                      break;
                    v26 = *(_QWORD *)(a1 + 96);
                    if (*(_DWORD *)(v26 + 12) >= *(_DWORD *)(v26 + 8))
                      break;
                    v20 = *(_QWORD *)(a1 + 8);
                    v19 = *(unsigned int *)(a1 + 16);
                    v24 = *(_QWORD *)(*(_QWORD *)(v26 + 16 * v25 - 16) + 16 * *(unsigned int *)(v26 + 16 * v25 - 4));
                  }
                  while (*(_QWORD *)(*(_QWORD *)(v20 + 16 * v19 - 16) + 16 * *(unsigned int *)(v20 + 16 * v19 - 4) + 8) < v24);
                }
              }
            }
          }
        }
      }
    }
  }
}

void llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::const_iterator::treeAdvanceTo(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  _DWORD *v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  _QWORD *v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(unsigned int *)(a1 + 16);
  v5 = v3 + 16 * v4;
  v6 = *(_QWORD *)(v5 - 16);
  if (*(_QWORD *)(v6 + 16 * (*(_DWORD *)(v5 - 8) - 1) + 8) >= a2)
  {
    v16 = *(_DWORD *)(v5 - 4);
    do
      v17 = *(_QWORD *)(v6 + 16 * v16++ + 8);
    while (v17 < a2);
    *(_DWORD *)(v5 - 4) = v16 - 1;
    return;
  }
  *(_DWORD *)(a1 + 16) = v4 - 1;
  v7 = v4 - 2;
  if ((_DWORD)v4 == 2)
  {
    v18 = *(_QWORD *)a1;
    v19 = *(unsigned int *)(v3 + 12);
    v20 = *(_QWORD *)a1 + 8;
    v21 = *(unsigned int *)(*(_QWORD *)a1 + 276);
    if ((_DWORD)v19 != (_DWORD)v21)
      goto LABEL_20;
  }
  else
  {
    if ((_DWORD)v4 != 3)
    {
      if (*(_QWORD *)(*(_QWORD *)(v3 + 16 * (v4 - 3))
                     + 8 * *(unsigned int *)(v3 + 16 * (v4 - 3) + 12)
                     + 96) >= a2)
      {
LABEL_9:
        v10 = (uint64_t *)(v3 + 16 * v7);
        v11 = *v10;
        v14 = *((_DWORD *)v10 + 3);
        v12 = (_DWORD *)v10 + 3;
        v13 = v14;
        do
          v15 = *(_QWORD *)(v11 + 8 * v13++ + 96);
        while (v15 < a2);
        *v12 = v13 - 1;
        goto LABEL_12;
      }
      v8 = v4 - 4;
      while (1)
      {
        *(_DWORD *)(a1 + 16) = v8 + 2;
        if (!v8)
          break;
        v9 = *(_QWORD *)(*(_QWORD *)(v3 + 16 * v8) + 8 * *(unsigned int *)(v3 + 16 * v8 + 12) + 96);
        --v8;
        if (v9 >= a2)
        {
          v7 = v8 + 2;
          goto LABEL_9;
        }
      }
    }
    v18 = *(_QWORD *)a1;
    v19 = *(unsigned int *)(v3 + 12);
    if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v19 + 136) >= a2)
    {
      v28 = *(_DWORD *)(v3 + 28);
      do
        v29 = *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8 * v28++ + 96);
      while (v29 < a2);
      *(_DWORD *)(v3 + 28) = v28 - 1;
      goto LABEL_12;
    }
    v20 = v18 + 8;
    v21 = *(unsigned int *)(v18 + 276);
    if ((_DWORD)v19 != (_DWORD)v21)
    {
LABEL_20:
      while (*(_QWORD *)(v20 + 8 * v19 + 128) < a2)
      {
        v19 = (v19 + 1);
        if ((_DWORD)v21 == (_DWORD)v19)
        {
          v19 = v21;
          break;
        }
      }
    }
  }
  v22 = *(_DWORD *)(v18 + 272);
  *(_DWORD *)(a1 + 16) = 0;
  v23 = *(_DWORD *)(a1 + 20);
  if (v22)
  {
    if (v23)
    {
      v24 = 0;
    }
    else
    {
      v38 = a2;
      v40 = a1;
      v34 = v21;
      v36 = a1 + 8;
      v30 = v20;
      v32 = v19;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 8, (void *)(a1 + 24), 1uLL, 16);
      v20 = v30;
      v19 = v32;
      v21 = v34;
      v2 = v36;
      a2 = v38;
      a1 = v40;
      v24 = *(unsigned int *)(v40 + 16);
      v3 = *(_QWORD *)(v40 + 8);
    }
    v25 = (uint64_t *)(v3 + 16 * v24);
    *v25 = v20;
    v25[1] = v21 | (v19 << 32);
    LODWORD(v25) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = (_DWORD)v25 + 1;
    if ((_DWORD)v25 == -1)
      return;
    goto LABEL_31;
  }
  if (v23)
  {
    v26 = 0;
  }
  else
  {
    v39 = a2;
    v41 = a1;
    v35 = v21;
    v37 = a1 + 8;
    v31 = v18;
    v33 = v19;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 8, (void *)(a1 + 24), 1uLL, 16);
    v18 = v31;
    v19 = v33;
    v21 = v35;
    v2 = v37;
    a2 = v39;
    a1 = v41;
    v26 = *(unsigned int *)(v41 + 16);
    v3 = *(_QWORD *)(v41 + 8);
  }
  v27 = (_QWORD *)(v3 + 16 * v26);
  *v27 = v18;
  v27[1] = v21 | (v19 << 32);
  LODWORD(v27) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = (_DWORD)v27 + 1;
  if ((_DWORD)v27 != -1)
  {
LABEL_31:
    if (*(_DWORD *)(*(_QWORD *)v2 + 12) >= *(_DWORD *)(*(_QWORD *)v2 + 8))
      return;
LABEL_12:
    llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::const_iterator::pathFillFind(a1, a2);
  }
}

void llvm::IntervalMap<unsigned long long,char,16u,llvm::IntervalMapInfo<unsigned long long>>::const_iterator::goToBegin(uint64_t *a1)
{
  _QWORD *v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;

  v2 = a1 + 1;
  v3 = *a1;
  if (*(_DWORD *)(*a1 + 272))
  {
    v4 = *(_DWORD *)(v3 + 276);
    *((_DWORD *)a1 + 4) = 0;
    if (*((_DWORD *)a1 + 5))
    {
      v5 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 1), a1 + 3, 1uLL, 16);
      v5 = *((unsigned int *)a1 + 4);
    }
    v6 = (_QWORD *)(*v2 + 16 * v5);
    *v6 = v3 + 8;
  }
  else
  {
    v4 = *(_DWORD *)(v3 + 276);
    *((_DWORD *)a1 + 4) = 0;
    if (*((_DWORD *)a1 + 5))
    {
      v7 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 1), a1 + 3, 1uLL, 16);
      v7 = *((unsigned int *)a1 + 4);
    }
    v6 = (_QWORD *)(*v2 + 16 * v7);
    *v6 = v3;
  }
  v6[1] = v4;
  v8 = *((_DWORD *)a1 + 4);
  v9 = v8 + 1;
  *((_DWORD *)a1 + 4) = v8 + 1;
  v10 = *(_DWORD *)(*a1 + 272);
  if (v10)
    v11 = v8 >= v10;
  else
    v11 = 1;
  if (!v11)
  {
    do
    {
      v12 = a1[1];
      v13 = *(_QWORD *)(*(_QWORD *)(v12 + 16 * v8) + 8 * *(unsigned int *)(v12 + 16 * v8 + 12));
      if (v9 >= *((_DWORD *)a1 + 5))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v2, a1 + 3, v9 + 1, 16);
        v9 = *((_DWORD *)a1 + 4);
        v12 = a1[1];
      }
      v14 = (unint64_t *)(v12 + 16 * v9);
      *v14 = v13 & 0xFFFFFFFFFFFFFFC0;
      v14[1] = (v13 & 0x3F) + 1;
      v8 = *((_DWORD *)a1 + 4);
      v9 = v8 + 1;
      *((_DWORD *)a1 + 4) = v8 + 1;
    }
    while (v8 < v10);
  }
}

double mlir::Region::getOps<mlir::pdl_interp::FuncOp>@<D0>(mlir::Region *a1@<X0>, uint64_t a2@<X8>)
{
  ZinIrHalH13g *v4;
  uint64_t (*v5)(void);
  __int128 v6;
  double result;
  _BYTE v8[32];
  __int128 v9;
  ZinIrHalH13g *v10;
  __int128 v11;
  _BYTE v12[32];
  BOOL (*i)(uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL (*v17)(uint64_t);
  __int128 v18;
  uint64_t v19;

  mlir::Region::OpIterator::OpIterator(&v18, a1, 1);
  mlir::Region::OpIterator::OpIterator(&v9, a1, 0);
  *(_OWORD *)&v12[8] = v18;
  v4 = v10;
  *(_QWORD *)v12 = v10;
  v11 = v9;
  *(_QWORD *)&v12[24] = v19;
  for (i = mlir::detail::op_filter_iterator<mlir::pdl_interp::FuncOp,mlir::Region::OpIterator>::filter;
        *(_QWORD *)v12 != *(_QWORD *)&v12[24];
        v4 = *(ZinIrHalH13g **)v12)
  {
    v5 = (uint64_t (*)(void))i;
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    if ((v5() & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v11);
  }
  v14 = v11;
  v15 = *(_OWORD *)v12;
  v16 = *(_OWORD *)&v12[16];
  v17 = i;
  *(_QWORD *)v8 = v19;
  *(_OWORD *)&v8[8] = v18;
  *(_QWORD *)&v8[24] = v19;
  *(_OWORD *)(a2 + 64) = v18;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)v8;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)&v8[16];
  v6 = v15;
  *(_OWORD *)a2 = v14;
  *(_OWORD *)(a2 + 16) = v6;
  result = *(double *)&v16;
  *(_OWORD *)(a2 + 32) = v16;
  *(_QWORD *)(a2 + 48) = v17;
  *(_QWORD *)(a2 + 56) = mlir::detail::op_iterator<mlir::pdl_interp::FuncOp,mlir::Region::OpIterator>::unwrap;
  *(_QWORD *)(a2 + 112) = mlir::detail::op_filter_iterator<mlir::pdl_interp::FuncOp,mlir::Region::OpIterator>::filter;
  *(_QWORD *)(a2 + 120) = mlir::detail::op_iterator<mlir::pdl_interp::FuncOp,mlir::Region::OpIterator>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::pdl_interp::FuncOp,mlir::Region::OpIterator>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::pdl_interp::FuncOp,void>::id;
}

uint64_t *llvm::StringMap<unsigned short,llvm::MallocAllocator>::try_emplace<>(uint64_t a1, int8x16_t *a2, const unsigned __int8 *a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  _WORD *buffer;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;

  v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * v6);
  v8 = *v7;
  if (*v7 == -8)
  {
    --*(_DWORD *)(a1 + 16);
    buffer = llvm::allocate_buffer((size_t)(a3 + 17), (std::align_val_t)8uLL);
    v10 = buffer + 8;
    if (a3)
LABEL_4:
      memcpy(v10, a2, (size_t)a3);
  }
  else
  {
    if (v8)
    {
      while (!v8 || v8 == -8)
      {
        v15 = v7[1];
        ++v7;
        v8 = v15;
      }
      return v7;
    }
    buffer = llvm::allocate_buffer((size_t)(a3 + 17), (std::align_val_t)8uLL);
    v10 = buffer + 8;
    if (a3)
      goto LABEL_4;
  }
  a3[(_QWORD)v10] = 0;
  *(_QWORD *)buffer = a3;
  buffer[4] = 0;
  *v7 = (uint64_t)buffer;
  ++*(_DWORD *)(a1 + 12);
  v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
  if (*v7)
    v11 = *v7 == -8;
  else
    v11 = 1;
  if (v11)
  {
    do
    {
      v13 = v7[1];
      ++v7;
      v12 = v13;
      if (v13)
        v14 = v12 == -8;
      else
        v14 = 1;
    }
    while (v14);
  }
  return v7;
}

void `anonymous namespace'::ByteCodeWriter::appendPDLValue(uint64_t a1, unint64_t a2)
{
  void *v4;
  __int16 v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  __int16 v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;

  v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
  if (v4 == &mlir::detail::TypeIDResolver<mlir::pdl::AttributeType,void>::id)
  {
    v5 = 0;
    v6 = *(_QWORD **)(a1 + 24);
    v7 = v6[1];
    v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) <= v6[2])
      goto LABEL_12;
    goto LABEL_22;
  }
  if (v4 == &mlir::detail::TypeIDResolver<mlir::pdl::OperationType,void>::id)
  {
    v5 = 1;
    v6 = *(_QWORD **)(a1 + 24);
    v7 = v6[1];
    v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) <= v6[2])
      goto LABEL_12;
    goto LABEL_22;
  }
  if (v4 == &mlir::detail::TypeIDResolver<mlir::pdl::RangeType,void>::id)
  {
    v15 = (_QWORD *)(*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v15) + 136) == &mlir::detail::TypeIDResolver<mlir::pdl::TypeType,void>::id)
      v5 = 3;
    else
      v5 = 5;
    v6 = *(_QWORD **)(a1 + 24);
    v7 = v6[1];
    v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) > v6[2])
      goto LABEL_22;
  }
  else
  {
    if (v4 == &mlir::detail::TypeIDResolver<mlir::pdl::TypeType,void>::id)
      v5 = 2;
    else
      v5 = 4 * (v4 == &mlir::detail::TypeIDResolver<mlir::pdl::ValueType,void>::id);
    v6 = *(_QWORD **)(a1 + 24);
    v7 = v6[1];
    v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) > v6[2])
    {
LABEL_22:
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v6, v6 + 3, v8, 2);
      v7 = v6[1];
    }
  }
LABEL_12:
  *(_WORD *)(*v6 + 2 * v7) = v5;
  ++v6[1];
  v10 = *(_QWORD **)(a1 + 24);
  v9 = *(uint64_t **)(a1 + 32);
  v14 = a2;
  v15 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v9, &v14, &v15))
  {
    v11 = *((_WORD *)v15 + 4);
  }
  else
  {
    v12 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v9, (uint64_t)&v14, &v14, v15);
    v11 = 0;
    *v12 = v14;
    *((_WORD *)v12 + 4) = 0;
  }
  v13 = v10[1];
  if ((unint64_t)(v13 + 1) > v10[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v10, v10 + 3, v13 + 1, 2);
    v13 = v10[1];
  }
  *(_WORD *)(*v10 + 2 * v13) = v11;
  ++v10[1];
}

void `anonymous namespace'::ByteCodeWriter::append(_anonymous_namespace_::ByteCodeWriter *this, mlir::Block *a2)
{
  int v3;
  int v4;
  unsigned int v5;
  uint64_t *v6;
  mlir::Block *v7;
  uint64_t *v8;
  int v9;
  BOOL v10;
  unsigned int v11;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  mlir::Block *v17;

  v17 = a2;
  v3 = *((_DWORD *)this + 4);
  if (v3)
  {
    v4 = v3 - 1;
    v5 = v4 & ((a2 >> 4) ^ (a2 >> 9));
    v6 = (uint64_t *)(*(_QWORD *)this + 40 * v5);
    v7 = (mlir::Block *)*v6;
    if ((mlir::Block *)*v6 == a2)
      goto LABEL_14;
    v8 = 0;
    v9 = 1;
    while (v7 != (mlir::Block *)-4096)
    {
      if (v8)
        v10 = 0;
      else
        v10 = v7 == (mlir::Block *)-8192;
      if (v10)
        v8 = v6;
      v11 = v5 + v9++;
      v5 = v11 & v4;
      v6 = (uint64_t *)(*(_QWORD *)this + 40 * v5);
      v7 = (mlir::Block *)*v6;
      if ((mlir::Block *)*v6 == a2)
        goto LABEL_14;
    }
    if (v8)
      v12 = v8;
    else
      v12 = v6;
  }
  else
  {
    v12 = 0;
  }
  v6 = llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>,mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>::InsertIntoBucket<mlir::Block * const&>((uint64_t)this, v12, (uint64_t *)&v17);
LABEL_14:
  v13 = *(_DWORD *)(*((_QWORD *)this + 3) + 8);
  v14 = *((unsigned int *)v6 + 4);
  if (v14 >= *((_DWORD *)v6 + 5))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v6 + 1), v6 + 3, v14 + 1, 4);
    LODWORD(v14) = *((_DWORD *)v6 + 4);
  }
  *(_DWORD *)(v6[1] + 4 * v14) = v13;
  ++*((_DWORD *)v6 + 4);
  v15 = (_QWORD *)*((_QWORD *)this + 3);
  v16 = v15[1];
  if (v15[2] < (unint64_t)(v16 + 2))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v15, v15 + 3, v16 + 2, 2);
    v16 = v15[1];
  }
  *(_DWORD *)(*v15 + 2 * v16) = 0;
  v15[1] += 2;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>,mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>::InsertIntoBucket<mlir::Block * const&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unsigned int v14;
  _QWORD *buffer;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  BOOL v28;
  unsigned int v29;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(unsigned int *)(a1 + 16);
  if (4 * v5 + 4 >= (3 * v6))
  {
    v9 = 2 * v6;
  }
  else
  {
    if ((int)v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      v7 = *a2;
      goto LABEL_4;
    }
    v9 = *(_DWORD *)(a1 + 16);
  }
  v10 = *(uint64_t **)a1;
  v11 = (v9 - 1) | ((unint64_t)(v9 - 1) >> 1);
  v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
  v13 = ((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8);
  if ((v13 + 1) > 0x40)
    v14 = v13 + 1;
  else
    v14 = 64;
  *(_DWORD *)(a1 + 16) = v14;
  buffer = llvm::allocate_buffer(40 * v14, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = buffer;
  if (v10)
  {
    v16 = 5 * v6;
    llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>,mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>::moveFromOldBuckets(a1, v10, &v10[v16]);
    llvm::deallocate_buffer((llvm *)v10, (void *)(v16 * 8));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v17 = *(unsigned int *)(a1 + 16);
  v18 = 40 * v17 - 40;
  v19 = buffer;
  if (v18 < 0x28)
    goto LABEL_34;
  v20 = v18 / 0x28 + 1;
  v19 = &buffer[5 * (v20 & 0xFFFFFFFFFFFFFFELL)];
  v21 = v20 & 0xFFFFFFFFFFFFFFELL;
  v22 = buffer;
  do
  {
    *v22 = -4096;
    v22[5] = -4096;
    v22 += 10;
    v21 -= 2;
  }
  while (v21);
  if (v20 != (v20 & 0xFFFFFFFFFFFFFFELL))
  {
LABEL_34:
    do
    {
      *v19 = -4096;
      v19 += 5;
    }
    while (v19 != &buffer[5 * v17]);
  }
  v7 = *a3;
  v23 = v17 - 1;
  v24 = ((*a3 >> 4) ^ (*a3 >> 9)) & v23;
  a2 = &buffer[5 * v24];
  v25 = *a2;
  if (*a3 != *a2)
  {
    v26 = 0;
    v27 = 1;
    while (v25 != -4096)
    {
      if (v26)
        v28 = 0;
      else
        v28 = v25 == -8192;
      if (v28)
        v26 = a2;
      v29 = v24 + v27++;
      v24 = v29 & v23;
      a2 = &buffer[5 * v24];
      v25 = *a2;
      if (v7 == *a2)
        goto LABEL_4;
    }
    if (v26)
      a2 = v26;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096)
    --*(_DWORD *)(a1 + 12);
  *a2 = *a3;
  a2[1] = (uint64_t)(a2 + 3);
  a2[2] = 0x400000000;
  return a2;
}

void llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>,mlir::Block *,llvm::SmallVector<unsigned int,4u>,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SmallVector<unsigned int,4u>>>::moveFromOldBuckets(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  unsigned int v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  _QWORD *v20;
  int v21;
  BOOL v22;
  unsigned int v23;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 40 * v6 - 40;
    if (v8 < 0x28)
    {
      v9 = *(_QWORD **)a1;
LABEL_7:
      v13 = &v7[5 * v6];
      do
      {
        *v9 = -4096;
        v9 += 5;
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    v10 = v8 / 0x28 + 1;
    v9 = &v7[5 * (v10 & 0xFFFFFFFFFFFFFFELL)];
    v11 = v10 & 0xFFFFFFFFFFFFFFELL;
    v12 = *(_QWORD **)a1;
    do
    {
      *v12 = -4096;
      v12[5] = -4096;
      v12 += 10;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0xFFFFFFFFFFFFFFELL))
      goto LABEL_7;
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      v14 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v15 = *(_DWORD *)(a1 + 16) - 1;
        v16 = v15 & ((v14 >> 4) ^ (v14 >> 9));
        v17 = (_QWORD *)(*(_QWORD *)a1 + 40 * v16);
        v18 = *v17;
        if (v14 != *v17)
        {
          v20 = 0;
          v21 = 1;
          while (v18 != -4096)
          {
            if (v20)
              v22 = 0;
            else
              v22 = v18 == -8192;
            if (v22)
              v20 = v17;
            v23 = v16 + v21++;
            v16 = v23 & v15;
            v17 = (_QWORD *)(*(_QWORD *)a1 + 40 * (v23 & v15));
            v18 = *v17;
            if (v14 == *v17)
              goto LABEL_14;
          }
          if (v20)
            v17 = v20;
        }
LABEL_14:
        *v17 = v14;
        v17[1] = v17 + 3;
        v17[2] = 0x400000000;
        if (*((_DWORD *)v4 + 4))
          llvm::SmallVectorImpl<unsigned int>::operator=((uint64_t)(v17 + 1), (uint64_t)(v4 + 1));
        ++*(_DWORD *)(a1 + 8);
        v19 = (uint64_t *)v4[1];
        if (v19 != v4 + 3)
          free(v19);
      }
      v4 += 5;
    }
    while (v4 != a3);
  }
}

void `anonymous namespace'::ByteCodeWriter::append<mlir::detail::TypedValue<mlir::pdl::PDLType>,mlir::SuccessorRange>(_anonymous_namespace_::ByteCodeWriter *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t *v8;
  __int16 v9;
  _QWORD *v10;
  uint64_t v11;
  mlir::Block **v12;
  mlir::Block *v13;
  unint64_t v14;
  _QWORD *v15;

  v7 = (_QWORD *)*((_QWORD *)a1 + 3);
  v8 = (uint64_t *)*((_QWORD *)a1 + 4);
  v14 = a2;
  v15 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v8, &v14, &v15))
  {
    v9 = *((_WORD *)v15 + 4);
  }
  else
  {
    v10 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v8, (uint64_t)&v14, &v14, v15);
    v9 = 0;
    *v10 = v14;
    *((_WORD *)v10 + 4) = 0;
  }
  v11 = v7[1];
  if ((unint64_t)(v11 + 1) > v7[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v7, v7 + 3, v11 + 1, 2);
    *(_WORD *)(*v7 + 2 * v7[1]++) = v9;
    if (!a4)
      return;
  }
  else
  {
    *(_WORD *)(*v7 + 2 * v11) = v9;
    ++v7[1];
    if (!a4)
      return;
  }
  v12 = (mlir::Block **)(a3 + 24);
  do
  {
    v13 = *v12;
    v12 += 4;
    --a4;
  }
  while (a4);
}

uint64_t *`anonymous namespace'::Generator::getMemIndex<mlir::Attribute>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  char **v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _BYTE *v29;
  char *v30;
  char *v31;
  char *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  _OWORD *v37;
  char *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v43;
  int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t *v47;
  int v48;
  BOOL v49;
  unsigned int v50;

  v6 = *(_QWORD *)(a1 + 120);
  v4 = a1 + 120;
  v5 = v6;
  v7 = **(_WORD **)(v4 + 96);
  v8 = *(_DWORD *)(v4 + 16);
  if (!v8)
  {
    v10 = 0;
    goto LABEL_13;
  }
  v9 = (v8 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v10 = (uint64_t *)(v5 + 16 * v9);
  v11 = *v10;
  if (*v10 != a2)
  {
    v12 = 0;
    v13 = 1;
    while (v11 != -4096)
    {
      if (v12)
        v14 = 0;
      else
        v14 = v11 == -8192;
      if (v14)
        v12 = v10;
      v15 = v9 + v13++;
      v9 = v15 & (v8 - 1);
      v10 = (uint64_t *)(v5 + 16 * v9);
      v11 = *v10;
      if (*v10 == a2)
        return v10 + 1;
    }
    if (v12)
      v10 = v12;
LABEL_13:
    v16 = *(_QWORD *)(*(_QWORD *)(v4 + 64) + 8) - **(_QWORD **)(v4 + 64);
    v17 = *(_DWORD *)(a1 + 128);
    if (4 * v17 + 4 >= 3 * v8)
    {
      v8 *= 2;
    }
    else if (v8 + ~v17 - *(_DWORD *)(a1 + 132) > v8 >> 3)
    {
      goto LABEL_15;
    }
    llvm::DenseMap<void const*,unsigned short,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned short>>::grow(v4, v8);
    v43 = *(_QWORD *)(a1 + 120);
    v44 = *(_DWORD *)(a1 + 136) - 1;
    v45 = v44 & ((a2 >> 4) ^ (a2 >> 9));
    v10 = (uint64_t *)(v43 + 16 * v45);
    v46 = *v10;
    if (*v10 == a2)
    {
      v18 = a2;
LABEL_16:
      ++*(_DWORD *)(a1 + 128);
      if (v18 != -4096)
        --*(_DWORD *)(a1 + 132);
      *v10 = a2;
      *((_WORD *)v10 + 4) = v7 + (v16 >> 3);
      v19 = *(char ***)(a1 + 184);
      v21 = v19[1];
      v20 = (unint64_t)v19[2];
      if ((unint64_t)v21 < v20)
      {
        *(_QWORD *)v21 = a2;
        v22 = (uint64_t)(v21 + 8);
LABEL_40:
        v19[1] = (char *)v22;
        return v10 + 1;
      }
      v23 = *v19;
      v24 = v21 - *v19;
      v25 = v24 >> 3;
      v26 = (v24 >> 3) + 1;
      if (v26 >> 61)
        abort();
      v27 = v20 - (_QWORD)v23;
      if (v27 >> 2 > v26)
        v26 = v27 >> 2;
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
        v28 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v28 = v26;
      if (v28)
      {
        if (v28 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v29 = operator new(8 * v28);
        v30 = &v29[8 * v25];
        v31 = &v29[8 * v28];
        *(_QWORD *)v30 = a2;
        v22 = (uint64_t)(v30 + 8);
        v32 = (char *)(v21 - v23);
        if (v21 == v23)
          goto LABEL_38;
      }
      else
      {
        v29 = 0;
        v30 = (char *)(8 * v25);
        v31 = 0;
        *(_QWORD *)(8 * v25) = a2;
        v22 = 8 * v25 + 8;
        v32 = (char *)(v21 - v23);
        if (v21 == v23)
        {
LABEL_38:
          *v19 = v30;
          v19[1] = (char *)v22;
          v19[2] = v31;
          if (v21)
            operator delete(v21);
          goto LABEL_40;
        }
      }
      v33 = (unint64_t)(v32 - 8);
      if (v33 < 0x58)
        goto LABEL_64;
      if ((unint64_t)(v21 - v29 - v24) < 0x20)
        goto LABEL_64;
      v34 = (v33 >> 3) + 1;
      v35 = 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL);
      v36 = &v21[-v35];
      v30 -= v35;
      v37 = &v29[8 * v25 - 16];
      v38 = v21 - 16;
      v39 = v34 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v40 = *(_OWORD *)v38;
        *(v37 - 1) = *((_OWORD *)v38 - 1);
        *v37 = v40;
        v37 -= 2;
        v38 -= 32;
        v39 -= 4;
      }
      while (v39);
      v21 = v36;
      if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_64:
        do
        {
          v41 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *((_QWORD *)v30 - 1) = v41;
          v30 -= 8;
        }
        while (v21 != v23);
      }
      v21 = *v19;
      goto LABEL_38;
    }
    v47 = 0;
    v48 = 1;
    while (v46 != -4096)
    {
      if (v47)
        v49 = 0;
      else
        v49 = v46 == -8192;
      if (v49)
        v47 = v10;
      v50 = v45 + v48++;
      v45 = v50 & v44;
      v10 = (uint64_t *)(v43 + 16 * v45);
      v46 = *v10;
      v18 = a2;
      if (*v10 == a2)
        goto LABEL_16;
    }
    if (v47)
      v10 = v47;
LABEL_15:
    v18 = *v10;
    goto LABEL_16;
  }
  return v10 + 1;
}

_QWORD *llvm::DenseMap<void const*,unsigned short,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned short>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  int v16;
  llvm *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  unsigned int v30;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_39;
      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 2;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_39:
        do
        {
          *v10 = -4096;
          v10 += 2;
        }
        while (v10 != &result[2 * v11]);
      }
    }
    if ((_DWORD)v3)
    {
      v15 = 0;
      v16 = v11 - 1;
      v17 = v4;
      do
      {
        v24 = *(_QWORD *)v17;
        if ((*(_QWORD *)v17 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v25 = ((v24 >> 4) ^ (v24 >> 9)) & v16;
          v23 = *(_QWORD *)a1 + 16 * v25;
          v26 = *(_QWORD *)v23;
          if (v24 != *(_QWORD *)v23)
          {
            v27 = 0;
            v28 = 1;
            while (v26 != -4096)
            {
              if (v27)
                v29 = 0;
              else
                v29 = v26 == -8192;
              if (v29)
                v27 = v23;
              v30 = v25 + v28++;
              v25 = v30 & v16;
              v23 = *(_QWORD *)a1 + 16 * (v30 & v16);
              v26 = *(_QWORD *)v23;
              if (v24 == *(_QWORD *)v23)
                goto LABEL_23;
            }
            if (v27)
              v23 = v27;
          }
LABEL_23:
          *(_QWORD *)v23 = v24;
          *(_WORD *)(v23 + 8) = *((_WORD *)v17 + 4);
          *(_DWORD *)(a1 + 8) = ++v15;
        }
        v17 = (llvm *)((char *)v17 + 16);
      }
      while (v17 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v18 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v18)
  {
    if (((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_18;
    v19 = ((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[2 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    v20 = result + 2;
    v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v20 - 2) = -4096;
      *v20 = -4096;
      v20 += 4;
      v21 -= 2;
    }
    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_18:
      v22 = &result[2 * v18];
      do
      {
        *v10 = -4096;
        v10 += 2;
      }
      while (v10 != v22);
    }
  }
  return result;
}

void `anonymous namespace'::ByteCodeWriter::append<`anonymous namespace'::OpCode,mlir::detail::TypedValue<mlir::pdl::OperationType>,unsigned int,unsigned short,mlir::SuccessorRange>(uint64_t *a1, __int16 a2, unint64_t a3, int a4, __int16 a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  __int16 v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  mlir::Block **v25;
  mlir::Block *v26;
  unint64_t v27;
  _QWORD *v28;

  v14 = (_QWORD *)a1[3];
  v15 = v14[1];
  if ((unint64_t)(v15 + 1) > v14[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a1[3], v14 + 3, v15 + 1, 2);
    v15 = v14[1];
  }
  *(_WORD *)(*v14 + 2 * v15) = a2;
  ++v14[1];
  v16 = (_QWORD *)a1[3];
  v17 = (uint64_t *)a1[4];
  v27 = a3;
  v28 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v17, &v27, &v28))
  {
    v18 = *((_WORD *)v28 + 4);
  }
  else
  {
    v19 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v17, (uint64_t)&v27, &v27, v28);
    v18 = 0;
    *v19 = v27;
    *((_WORD *)v19 + 4) = 0;
  }
  v20 = v16[1];
  if ((unint64_t)(v20 + 1) > v16[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v16, v16 + 3, v20 + 1, 2);
    v20 = v16[1];
  }
  *(_WORD *)(*v16 + 2 * v20) = v18;
  ++v16[1];
  v21 = (_QWORD *)a1[3];
  v22 = v21[1];
  if (v21[2] < (unint64_t)(v22 + 2))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a1[3], v21 + 3, v22 + 2, 2);
    v22 = v21[1];
  }
  *(_DWORD *)(*v21 + 2 * v22) = a4;
  v21[1] += 2;
  v23 = (_QWORD *)a1[3];
  v24 = v23[1];
  if ((unint64_t)(v24 + 1) > v23[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a1[3], v23 + 3, v24 + 1, 2);
    *(_WORD *)(*v23 + 2 * v23[1]++) = a5;
    if (!a7)
      return;
  }
  else
  {
    *(_WORD *)(*v23 + 2 * v24) = a5;
    ++v23[1];
    if (!a7)
      return;
  }
  v25 = (mlir::Block **)(a6 + 24);
  do
  {
    v26 = *v25;
    v25 += 4;
    --a7;
  }
  while (a7);
}

void `anonymous namespace'::ByteCodeWriter::append<mlir::OperationName>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  char **v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _BYTE *v32;
  char *v33;
  char *v34;
  char *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  _OWORD *v40;
  char *v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t *v51;
  int v52;
  BOOL v53;
  unsigned int v54;

  v6 = a2 + 120;
  v7 = *(_QWORD *)(a2 + 120);
  v8 = **(_WORD **)(a2 + 216);
  v10 = **(_QWORD **)(a2 + 184);
  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 184) + 8);
  v11 = *(_DWORD *)(a2 + 136);
  if (v11)
  {
    v12 = (v11 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    v13 = (uint64_t *)(v7 + 16 * v12);
    v14 = *v13;
    if (*v13 == a3)
      goto LABEL_41;
    v15 = 0;
    v16 = 1;
    while (v14 != -4096)
    {
      if (v15)
        v17 = 0;
      else
        v17 = v14 == -8192;
      if (v17)
        v15 = v13;
      v18 = v12 + v16++;
      v12 = v18 & (v11 - 1);
      v13 = (uint64_t *)(v7 + 16 * v12);
      v14 = *v13;
      if (*v13 == a3)
        goto LABEL_41;
    }
    if (v15)
      v13 = v15;
  }
  else
  {
    v13 = 0;
  }
  v19 = v9 - v10;
  v20 = *(_DWORD *)(a2 + 128);
  if (4 * v20 + 4 >= 3 * v11)
  {
    v11 *= 2;
  }
  else if (v11 + ~v20 - *(_DWORD *)(a2 + 132) > v11 >> 3)
  {
LABEL_15:
    v21 = *v13;
    goto LABEL_16;
  }
  llvm::DenseMap<void const*,unsigned short,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned short>>::grow(v6, v11);
  v47 = *(_QWORD *)(a2 + 120);
  v48 = *(_DWORD *)(a2 + 136) - 1;
  v49 = v48 & ((a3 >> 4) ^ (a3 >> 9));
  v13 = (uint64_t *)(v47 + 16 * v49);
  v50 = *v13;
  if (*v13 != a3)
  {
    v51 = 0;
    v52 = 1;
    while (v50 != -4096)
    {
      if (v51)
        v53 = 0;
      else
        v53 = v50 == -8192;
      if (v53)
        v51 = v13;
      v54 = v49 + v52++;
      v49 = v54 & v48;
      v13 = (uint64_t *)(v47 + 16 * v49);
      v50 = *v13;
      v21 = a3;
      if (*v13 == a3)
        goto LABEL_16;
    }
    if (v51)
      v13 = v51;
    goto LABEL_15;
  }
  v21 = a3;
LABEL_16:
  ++*(_DWORD *)(a2 + 128);
  if (v21 != -4096)
    --*(_DWORD *)(a2 + 132);
  *v13 = a3;
  *((_WORD *)v13 + 4) = v8 + (v19 >> 3);
  v22 = *(char ***)(a2 + 184);
  v24 = v22[1];
  v23 = (unint64_t)v22[2];
  if ((unint64_t)v24 >= v23)
  {
    v26 = *v22;
    v27 = v24 - *v22;
    v28 = v27 >> 3;
    v29 = (v27 >> 3) + 1;
    if (v29 >> 61)
      abort();
    v30 = v23 - (_QWORD)v26;
    if (v30 >> 2 > v29)
      v29 = v30 >> 2;
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
      v31 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v31 = v29;
    if (v31)
    {
      if (v31 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v32 = operator new(8 * v31);
      v33 = &v32[8 * v28];
      v34 = &v32[8 * v31];
      *(_QWORD *)v33 = a3;
      v25 = (uint64_t)(v33 + 8);
      v35 = (char *)(v24 - v26);
      if (v24 == v26)
        goto LABEL_38;
    }
    else
    {
      v32 = 0;
      v33 = (char *)(8 * v28);
      v34 = 0;
      *(_QWORD *)(8 * v28) = a3;
      v25 = 8 * v28 + 8;
      v35 = (char *)(v24 - v26);
      if (v24 == v26)
      {
LABEL_38:
        *v22 = v33;
        v22[1] = (char *)v25;
        v22[2] = v34;
        if (v24)
          operator delete(v24);
        goto LABEL_40;
      }
    }
    v36 = (unint64_t)(v35 - 8);
    if (v36 < 0x58)
      goto LABEL_66;
    if ((unint64_t)(v24 - v32 - v27) < 0x20)
      goto LABEL_66;
    v37 = (v36 >> 3) + 1;
    v38 = 8 * (v37 & 0x3FFFFFFFFFFFFFFCLL);
    v39 = &v24[-v38];
    v33 -= v38;
    v40 = &v32[8 * v28 - 16];
    v41 = v24 - 16;
    v42 = v37 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v43 = *(_OWORD *)v41;
      *(v40 - 1) = *((_OWORD *)v41 - 1);
      *v40 = v43;
      v40 -= 2;
      v41 -= 32;
      v42 -= 4;
    }
    while (v42);
    v24 = v39;
    if (v37 != (v37 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_66:
      do
      {
        v44 = *((_QWORD *)v24 - 1);
        v24 -= 8;
        *((_QWORD *)v33 - 1) = v44;
        v33 -= 8;
      }
      while (v24 != v26);
    }
    v24 = *v22;
    goto LABEL_38;
  }
  *(_QWORD *)v24 = a3;
  v25 = (uint64_t)(v24 + 8);
LABEL_40:
  v22[1] = (char *)v25;
LABEL_41:
  v45 = *((_WORD *)v13 + 4);
  v46 = a1[1];
  if ((unint64_t)(v46 + 1) > a1[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v46 + 1, 2);
    v46 = a1[1];
  }
  *(_WORD *)(*a1 + 2 * v46) = v45;
  ++a1[1];
}

void `anonymous namespace'::ByteCodeWriter::append<`anonymous namespace'::OpCode,mlir::detail::TypedValue<mlir::pdl::RangeType>,mlir::ArrayAttr,mlir::SuccessorRange>(uint64_t *a1, __int16 a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  __int16 v16;
  _QWORD *v17;
  uint64_t v18;
  mlir::Block **v19;
  mlir::Block *v20;
  unint64_t v21;
  _QWORD *v22;

  v12 = (_QWORD *)a1[3];
  v13 = v12[1];
  if ((unint64_t)(v13 + 1) > v12[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a1[3], v12 + 3, v13 + 1, 2);
    v13 = v12[1];
  }
  *(_WORD *)(*v12 + 2 * v13) = a2;
  ++v12[1];
  v14 = (_QWORD *)a1[3];
  v15 = (uint64_t *)a1[4];
  v21 = a3;
  v22 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v15, &v21, &v22))
  {
    v16 = *((_WORD *)v22 + 4);
  }
  else
  {
    v17 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v15, (uint64_t)&v21, &v21, v22);
    v16 = 0;
    *v17 = v21;
    *((_WORD *)v17 + 4) = 0;
  }
  v18 = v14[1];
  if ((unint64_t)(v18 + 1) > v14[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v14, v14 + 3, v18 + 1, 2);
    v18 = v14[1];
  }
  *(_WORD *)(*v14 + 2 * v18) = v16;
  ++v14[1];
  if (a6)
  {
    v19 = (mlir::Block **)(a5 + 24);
    do
    {
      v20 = *v19;
      v19 += 4;
      --a6;
    }
    while (a6);
  }
}

void `anonymous namespace'::ByteCodeWriter::append<`anonymous namespace'::OpCode,mlir::detail::TypedValue<mlir::pdl::OperationType>>(uint64_t a1, __int16 a2, unint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  __int16 v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;

  v6 = *(_QWORD **)(a1 + 24);
  v7 = v6[1];
  if ((unint64_t)(v7 + 1) > v6[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(*(_QWORD *)(a1 + 24), v6 + 3, v7 + 1, 2);
    v7 = v6[1];
  }
  *(_WORD *)(*v6 + 2 * v7) = a2;
  ++v6[1];
  v8 = *(_QWORD **)(a1 + 24);
  v9 = *(uint64_t **)(a1 + 32);
  v13 = a3;
  v14 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v9, &v13, &v14))
  {
    v10 = *((_WORD *)v14 + 4);
  }
  else
  {
    v11 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v9, (uint64_t)&v13, &v13, v14);
    v10 = 0;
    *v11 = v13;
    *((_WORD *)v11 + 4) = 0;
  }
  v12 = v8[1];
  if ((unint64_t)(v12 + 1) > v8[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v8, v8 + 3, v12 + 1, 2);
    v12 = v8[1];
  }
  *(_WORD *)(*v8 + 2 * v12) = v10;
  ++v8[1];
}

void `anonymous namespace'::ByteCodeWriter::append<mlir::detail::TypedValue<mlir::pdl::OperationType>,mlir::detail::TypedValue<mlir::pdl::ValueType>>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  _QWORD *v5;
  uint64_t *v6;
  __int16 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  __int16 v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;

  v5 = *(_QWORD **)(a1 + 24);
  v6 = *(uint64_t **)(a1 + 32);
  v15 = a2;
  v16 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v6, &v15, &v16))
  {
    v7 = *((_WORD *)v16 + 4);
  }
  else
  {
    v8 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v6, (uint64_t)&v15, &v15, v16);
    v7 = 0;
    *v8 = v15;
    *((_WORD *)v8 + 4) = 0;
  }
  v9 = v5[1];
  if ((unint64_t)(v9 + 1) > v5[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v5, v5 + 3, v9 + 1, 2);
    v9 = v5[1];
  }
  *(_WORD *)(*v5 + 2 * v9) = v7;
  ++v5[1];
  v11 = *(_QWORD **)(a1 + 24);
  v10 = *(uint64_t **)(a1 + 32);
  v15 = a3;
  v16 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v10, &v15, &v16))
  {
    v12 = *((_WORD *)v16 + 4);
  }
  else
  {
    v13 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v10, (uint64_t)&v15, &v15, v16);
    v12 = 0;
    *v13 = v15;
    *((_WORD *)v13 + 4) = 0;
  }
  v14 = v11[1];
  if ((unint64_t)(v14 + 1) > v11[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v11, v11 + 3, v14 + 1, 2);
    v14 = v11[1];
  }
  *(_WORD *)(*v11 + 2 * v14) = v12;
  ++v11[1];
}

void `anonymous namespace'::ByteCodeWriter::append<`anonymous namespace'::OpCode,unsigned int,mlir::detail::TypedValue<mlir::pdl::OperationType>>(uint64_t a1, __int16 a2, int a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t *v13;
  __int16 v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;

  v8 = *(_QWORD **)(a1 + 24);
  v9 = v8[1];
  if ((unint64_t)(v9 + 1) > v8[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(*(_QWORD *)(a1 + 24), v8 + 3, v9 + 1, 2);
    v9 = v8[1];
  }
  *(_WORD *)(*v8 + 2 * v9) = a2;
  ++v8[1];
  v10 = *(_QWORD **)(a1 + 24);
  v11 = v10[1];
  if (v10[2] < (unint64_t)(v11 + 2))
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(*(_QWORD *)(a1 + 24), v10 + 3, v11 + 2, 2);
    v11 = v10[1];
  }
  *(_DWORD *)(*v10 + 2 * v11) = a3;
  v10[1] += 2;
  v12 = *(_QWORD **)(a1 + 24);
  v13 = *(uint64_t **)(a1 + 32);
  v17 = a4;
  v18 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v13, &v17, &v18))
  {
    v14 = *((_WORD *)v18 + 4);
  }
  else
  {
    v15 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v13, (uint64_t)&v17, &v17, v18);
    v14 = 0;
    *v15 = v17;
    *((_WORD *)v15 + 4) = 0;
  }
  v16 = v12[1];
  if ((unint64_t)(v16 + 1) > v12[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v12, v12 + 3, v16 + 1, 2);
    v16 = v12[1];
  }
  *(_WORD *)(*v12 + 2 * v16) = v14;
  ++v12[1];
}

uint64_t llvm::SmallVectorTemplateBase<mlir::detail::PDLByteCodePattern,false>::growAndEmplaceBack<mlir::detail::PDLByteCodePattern>(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  __int128 v7;
  __int128 v8;
  _OWORD *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unint64_t v14;

  v14 = 0;
  v4 = a1 + 16;
  v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 104, &v14);
  v6 = &v5[104 * *(unsigned int *)(a1 + 8)];
  v7 = *a2;
  *((_QWORD *)v6 + 2) = *((_QWORD *)a2 + 2);
  *(_OWORD *)v6 = v7;
  *((_QWORD *)v6 + 3) = v6 + 40;
  *((_QWORD *)v6 + 4) = 0x200000000;
  if (*((_DWORD *)a2 + 8))
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(v6 + 24), (uint64_t)a2 + 24);
  v8 = *(__int128 *)((char *)a2 + 56);
  v9 = v6 + 88;
  *((_QWORD *)v6 + 9) = v6 + 88;
  v10 = (uint64_t)(v6 + 72);
  *(_OWORD *)(v10 - 16) = v8;
  *(_QWORD *)(v10 + 8) = 0;
  if (*((_DWORD *)a2 + 20))
    llvm::SmallVectorImpl<llvm::SMRange>::operator=(v10, (uint64_t)a2 + 72);
  *v9 = *(__int128 *)((char *)a2 + 88);
  llvm::SmallVectorTemplateBase<mlir::detail::PDLByteCodePattern,false>::moveElementsForGrow((uint64_t *)a1, (uint64_t)v5);
  v11 = v14;
  if (*(_QWORD *)a1 != v4)
    free(*(void **)a1);
  *(_QWORD *)a1 = v5;
  v12 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v12;
  *(_DWORD *)(a1 + 12) = v11;
  return (uint64_t)&v5[104 * v12 - 104];
}

void llvm::SmallVectorTemplateBase<mlir::detail::PDLByteCodePattern,false>::moveElementsForGrow(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  _OWORD *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v5 = 0;
    v6 = *a1;
    v7 = *a1 + 104 * v2;
    do
    {
      v8 = v6 + v5;
      v9 = a2 + v5;
      v10 = *(_OWORD *)(v6 + v5);
      *(_QWORD *)(v9 + 16) = *(_QWORD *)(v6 + v5 + 16);
      *(_OWORD *)v9 = v10;
      *(_QWORD *)(a2 + v5 + 24) = a2 + v5 + 40;
      *(_QWORD *)(v9 + 32) = 0x200000000;
      if (*(_DWORD *)(v6 + v5 + 32))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(a2 + v5 + 24, v8 + 24);
      v11 = *(_OWORD *)(v8 + 56);
      v12 = (_OWORD *)(v9 + 88);
      *(_QWORD *)(v9 + 72) = v9 + 88;
      v13 = v9 + 72;
      *(_OWORD *)(v13 - 16) = v11;
      *(_QWORD *)(v13 + 8) = 0;
      if (*(_DWORD *)(v8 + 80))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=(v13, v6 + v5 + 72);
      *v12 = *(_OWORD *)(v8 + 88);
      v5 += 104;
    }
    while (v8 + 104 != v7);
    v14 = *((_DWORD *)a1 + 2);
    if (v14)
    {
      v15 = *a1;
      v16 = 104 * v14;
      do
      {
        v17 = v15 + v16;
        v18 = *(void **)(v15 + v16 - 32);
        if ((void *)(v15 + v16 - 16) != v18)
          free(v18);
        v19 = *(void **)(v17 - 80);
        if ((void *)(v17 - 64) != v19)
          free(v19);
        v16 -= 104;
      }
      while (v16);
    }
  }
}

void `anonymous namespace'::ByteCodeWriter::append<`anonymous namespace'::OpCode,mlir::detail::TypedValue<mlir::pdl::OperationType>,mlir::DenseIntElementsAttr,mlir::SuccessorRange>(uint64_t *a1, __int16 a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  __int16 v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  int v28;
  BOOL v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  char **v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  _BYTE *v44;
  char *v45;
  char *v46;
  char *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  _OWORD *v52;
  char *v53;
  uint64_t v54;
  __int128 v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  mlir::Block **v59;
  mlir::Block *v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t *v65;
  int v66;
  BOOL v67;
  unsigned int v68;
  char *v69;
  uint64_t v70;
  unint64_t v71;
  _QWORD *v72;

  v12 = (_QWORD *)a1[3];
  v13 = v12[1];
  if ((unint64_t)(v13 + 1) > v12[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod(a1[3], v12 + 3, v13 + 1, 2);
    v13 = v12[1];
  }
  *(_WORD *)(*v12 + 2 * v13) = a2;
  ++v12[1];
  v14 = (_QWORD *)a1[3];
  v15 = (uint64_t *)a1[4];
  v71 = a3;
  v72 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>(v15, &v71, &v72))
  {
    v16 = *((_WORD *)v72 + 4);
  }
  else
  {
    v17 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>,mlir::Value,unsigned short,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned short>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v15, (uint64_t)&v71, &v71, v72);
    v16 = 0;
    *v17 = v71;
    *((_WORD *)v17 + 4) = 0;
  }
  v18 = v14[1];
  if ((unint64_t)(v18 + 1) > v14[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v14, v14 + 3, v18 + 1, 2);
    v18 = v14[1];
  }
  *(_WORD *)(*v14 + 2 * v18) = v16;
  ++v14[1];
  v19 = (_QWORD *)a1[3];
  v20 = a1[4];
  v21 = *(_QWORD *)(v20 + 120);
  v22 = **(_WORD **)(v20 + 216);
  v23 = *(_DWORD *)(v20 + 136);
  if (v23)
  {
    v24 = (v23 - 1) & ((a4 >> 4) ^ (a4 >> 9));
    v25 = (uint64_t *)(v21 + 16 * v24);
    v26 = *v25;
    if (*v25 == a4)
      goto LABEL_48;
    v27 = 0;
    v28 = 1;
    while (v26 != -4096)
    {
      if (v27)
        v29 = 0;
      else
        v29 = v26 == -8192;
      if (v29)
        v27 = v25;
      v30 = v24 + v28++;
      v24 = v30 & (v23 - 1);
      v25 = (uint64_t *)(v21 + 16 * v24);
      v26 = *v25;
      if (*v25 == a4)
        goto LABEL_48;
    }
    v70 = a5;
    if (v27)
      v25 = v27;
  }
  else
  {
    v70 = a5;
    v25 = 0;
  }
  v31 = *(_QWORD *)(*(_QWORD *)(v20 + 184) + 8) - **(_QWORD **)(v20 + 184);
  v32 = *(_DWORD *)(v20 + 128);
  if (4 * v32 + 4 >= 3 * v23)
  {
    v23 *= 2;
  }
  else if (v23 + ~v32 - *(_DWORD *)(v20 + 132) > v23 >> 3)
  {
LABEL_22:
    v33 = *v25;
    goto LABEL_23;
  }
  llvm::DenseMap<void const*,unsigned short,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned short>>::grow(v20 + 120, v23);
  v61 = *(_QWORD *)(v20 + 120);
  v62 = *(_DWORD *)(v20 + 136) - 1;
  v63 = v62 & ((a4 >> 4) ^ (a4 >> 9));
  v25 = (uint64_t *)(v61 + 16 * v63);
  v64 = *v25;
  if (*v25 != a4)
  {
    v65 = 0;
    v66 = 1;
    while (v64 != -4096)
    {
      if (v65)
        v67 = 0;
      else
        v67 = v64 == -8192;
      if (v67)
        v65 = v25;
      v68 = v63 + v66++;
      v63 = v68 & v62;
      v25 = (uint64_t *)(v61 + 16 * v63);
      v64 = *v25;
      v33 = a4;
      if (*v25 == a4)
        goto LABEL_23;
    }
    if (v65)
      v25 = v65;
    goto LABEL_22;
  }
  v33 = a4;
LABEL_23:
  ++*(_DWORD *)(v20 + 128);
  if (v33 != -4096)
    --*(_DWORD *)(v20 + 132);
  *v25 = a4;
  *((_WORD *)v25 + 4) = v22 + (v31 >> 3);
  v34 = *(char ***)(v20 + 184);
  v36 = v34[1];
  v35 = (unint64_t)v34[2];
  if ((unint64_t)v36 >= v35)
  {
    v38 = *v34;
    v39 = v36 - *v34;
    v40 = v39 >> 3;
    v41 = (v39 >> 3) + 1;
    if (v41 >> 61)
      abort();
    v42 = v35 - (_QWORD)v38;
    if (v42 >> 2 > v41)
      v41 = v42 >> 2;
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
      v43 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v43 = v41;
    if (v43)
    {
      v69 = (char *)(v36 - *v34);
      if (v43 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v44 = operator new(8 * v43);
      v39 = (uint64_t)v69;
      v45 = &v44[8 * v40];
      v46 = &v44[8 * v43];
      *(_QWORD *)v45 = a4;
      v37 = (uint64_t)(v45 + 8);
      v47 = (char *)(v36 - v38);
      if (v36 == v38)
        goto LABEL_45;
    }
    else
    {
      v44 = 0;
      v45 = (char *)(8 * v40);
      v46 = 0;
      *(_QWORD *)(8 * v40) = a4;
      v37 = 8 * v40 + 8;
      v47 = (char *)(v36 - v38);
      if (v36 == v38)
      {
LABEL_45:
        *v34 = v45;
        v34[1] = (char *)v37;
        v34[2] = v46;
        a5 = v70;
        if (v36)
          operator delete(v36);
        goto LABEL_47;
      }
    }
    v48 = (unint64_t)(v47 - 8);
    if (v48 < 0x58)
      goto LABEL_77;
    if ((unint64_t)(v36 - v44 - v39) < 0x20)
      goto LABEL_77;
    v49 = (v48 >> 3) + 1;
    v50 = 8 * (v49 & 0x3FFFFFFFFFFFFFFCLL);
    v51 = &v36[-v50];
    v45 -= v50;
    v52 = &v44[8 * v40 - 16];
    v53 = v36 - 16;
    v54 = v49 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v55 = *(_OWORD *)v53;
      *(v52 - 1) = *((_OWORD *)v53 - 1);
      *v52 = v55;
      v52 -= 2;
      v53 -= 32;
      v54 -= 4;
    }
    while (v54);
    v36 = v51;
    if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_77:
      do
      {
        v56 = *((_QWORD *)v36 - 1);
        v36 -= 8;
        *((_QWORD *)v45 - 1) = v56;
        v45 -= 8;
      }
      while (v36 != v38);
    }
    v36 = *v34;
    goto LABEL_45;
  }
  *(_QWORD *)v36 = a4;
  v37 = (uint64_t)(v36 + 8);
  a5 = v70;
LABEL_47:
  v34[1] = (char *)v37;
LABEL_48:
  v57 = *((_WORD *)v25 + 4);
  v58 = v19[1];
  if ((unint64_t)(v58 + 1) > v19[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v19, v19 + 3, v58 + 1, 2);
    *(_WORD *)(*v19 + 2 * v19[1]++) = v57;
    if (!a6)
      return;
  }
  else
  {
    *(_WORD *)(*v19 + 2 * v58) = v57;
    ++v19[1];
    if (!a6)
      return;
  }
  v59 = (mlir::Block **)(a5 + 24);
  do
  {
    v60 = *v59;
    v59 += 4;
    --a6;
  }
  while (a6);
}

void llvm::ReversePostOrderTraversal<mlir::Region *,llvm::GraphTraits<mlir::Region *>>::Initialize(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  mlir::Block *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _OWORD v8[4];
  void *v9[2];
  _OWORD v10[20];
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  _QWORD v15[41];

  v15[40] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(*(_QWORD *)a2 + 8);
  if (v3)
    v4 = (mlir::Block *)(v3 - 8);
  else
    v4 = 0;
  llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>::po_iterator((uint64_t)&v12, v4);
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9[0] = 0;
  memset(v8, 0, sizeof(v8));
  v5 = (char *)v8 + 8;
  v6 = (char *)v8 + 8;
  v7 = 8;
  v9[1] = (char *)v10 + 8;
  DWORD1(v10[0]) = 8;
  std::copy[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>((const void **)&v12, (uint64_t)&v5, a1);
  if (v9[1] != (char *)v10 + 8)
    free(v9[1]);
  if (v6 != v5)
    free(v6);
  if (v14 != v15)
    free(v14);
  if (v13 != v12)
    free(v13);
}

uint64_t std::copy[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>(const void **a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6;
  unsigned int v7;
  _QWORD *v8;
  unsigned int v9;
  unsigned int v10;
  _BYTE *v11;
  uint64_t v12;
  void *v14;
  void *v15;
  const void *v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[320];
  void *v20;
  void *v21;
  const void *v22;
  void *v23;
  uint64_t v24;
  _QWORD v25[41];
  void *v26;
  void *v27;
  _QWORD v28[42];

  v28[41] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v20, &v22, (const llvm::SmallPtrSetImplBase *)a1);
  v23 = v25;
  v24 = 0x800000000;
  if (&v20 != (void **)a1)
  {
    v6 = *((_DWORD *)a1 + 26);
    if (v6)
    {
      if (v6 < 9)
      {
        v8 = v25;
        v7 = *((_DWORD *)a1 + 26);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v25, *((unsigned int *)a1 + 26), 40);
        v7 = *((_DWORD *)a1 + 26);
        if (!v7)
        {
LABEL_8:
          LODWORD(v24) = v6;
          goto LABEL_9;
        }
        v8 = v23;
      }
      memcpy(v8, a1[12], 40 * v7);
      goto LABEL_8;
    }
  }
LABEL_9:
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v14, &v16, (const llvm::SmallPtrSetImplBase *)a2);
  v17 = v19;
  v18 = 0x800000000;
  if (&v14 != (void **)a2)
  {
    v9 = *(_DWORD *)(a2 + 104);
    if (v9)
    {
      if (v9 < 9)
      {
        v11 = v19;
        v10 = *(_DWORD *)(a2 + 104);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, *(unsigned int *)(a2 + 104), 40);
        v10 = *(_DWORD *)(a2 + 104);
        if (!v10)
        {
LABEL_16:
          LODWORD(v18) = v9;
          goto LABEL_17;
        }
        v11 = v17;
      }
      memcpy(v11, *(const void **)(a2 + 96), 40 * v10);
      goto LABEL_16;
    }
  }
LABEL_17:
  std::__copy[abi:nn180100]<std::_ClassicAlgPolicy,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>((uint64_t)&v20, (uint64_t)&v14, a3);
  v12 = v28[40];
  if (v27 != v28)
    free(v27);
  if (v26 != (void *)v25[40])
    free(v26);
  if (v17 != v19)
    free(v17);
  if (v15 != v14)
    free(v15);
  if (v23 != v25)
    free(v23);
  if (v21 != v20)
    free(v21);
  return v12;
}

void std::__copy[abi:nn180100]<std::_ClassicAlgPolicy,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9[2];
  _BYTE v10[320];
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14[2];
  _QWORD v15[41];

  v15[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v11, &v13, 8, (uint64_t *)a1);
  v14[0] = v15;
  v14[1] = (void *)0x800000000;
  if (*(_DWORD *)(a1 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v14, (uint64_t *)(a1 + 96));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v6, &v8, 8, (uint64_t *)a2);
  v9[0] = v10;
  v9[1] = (void *)0x800000000;
  if (*(_DWORD *)(a2 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v9, (uint64_t *)(a2 + 96));
  std::__dispatch_copy_or_move[abi:nn180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>((uint64_t)&v11, (uint64_t)&v6, a3);
  if (v9[0] != v10)
    free(v9[0]);
  if (v7 != v6)
    free(v7);
  if (v14[0] != v15)
    free(v14[0]);
  if (v12 != v11)
    free(v12);
}

void std::__dispatch_copy_or_move[abi:nn180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11[2];
  _BYTE v12[320];
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16[2];
  _QWORD v17[41];

  v17[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v13, &v15, 8, (uint64_t *)a1);
  v16[0] = v17;
  v16[1] = (void *)0x800000000;
  if (*(_DWORD *)(a1 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v16, (uint64_t *)(a1 + 96));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v8, &v10, 8, (uint64_t *)a2);
  v11[0] = v12;
  v11[1] = (void *)0x800000000;
  if (*(_DWORD *)(a2 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v11, (uint64_t *)(a2 + 96));
  std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>,0>((uint64_t)&v13, (uint64_t)&v8, a3, v6, v7);
  if (v11[0] != v12)
    free(v11[0]);
  if (v9 != v8)
    free(v9);
  if (v16[0] != v17)
    free(v16[0]);
  if (v14 != v13)
    free(v14);
}

void std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const llvm::SmallPtrSetImplBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const llvm::SmallPtrSetImplBase *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22[2];
  _BYTE v23[320];
  void *v24;
  void *v25;
  uint64_t v26;
  void *v27[2];
  _BYTE v28[320];
  void *v29;
  void *v30;
  void *v31;
  int v32;
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37[2];
  _BYTE v38[320];
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42[2];
  _BYTE v43[320];
  void *v44;
  void *v45;
  void *v46;
  int v47;
  _QWORD v48[41];
  void *v49;
  void *v50;
  uint64_t v51;
  void *v52[2];
  _BYTE v53[320];
  void *v54;
  void *v55;
  const void *v56;
  void *v57;
  uint64_t v58;
  _BYTE v59[320];
  void *v60;
  void *v61;
  void *v62;
  int v63;
  uint64_t v64;
  void *v65;
  void *v66;
  void *v67;
  int v68;
  _QWORD v69[41];

  v5 = (const llvm::SmallPtrSetImplBase *)MEMORY[0x24BDAC7A8](a1, a2, a3, a4, a5);
  v7 = v6;
  v9 = v8;
  v10 = v5;
  v12 = v11;
  v69[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v54, &v56, v5);
  v57 = v59;
  v58 = 0x800000000;
  if (&v54 != (void **)v10)
  {
    v13 = *((_DWORD *)v10 + 26);
    if (v13)
    {
      if (v13 < 9)
      {
        v15 = v59;
        v14 = *((_DWORD *)v10 + 26);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, *((unsigned int *)v10 + 26), 40);
        v14 = *((_DWORD *)v10 + 26);
        if (!v14)
        {
LABEL_8:
          LODWORD(v58) = v13;
          goto LABEL_9;
        }
        v15 = v57;
      }
      memcpy(v15, *((const void **)v10 + 12), 40 * v14);
      goto LABEL_8;
    }
  }
LABEL_9:
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v49, &v51, 8, (uint64_t *)v9);
  v52[0] = v53;
  v52[1] = (void *)0x800000000;
  if (*(_DWORD *)(v9 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v52, (uint64_t *)(v9 + 96));
  std::__unwrap_range[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>>((uint64_t)&v54, (uint64_t)&v49, &v60);
  if (v52[0] != v53)
    free(v52[0]);
  if (v50 != v49)
    free(v50);
  if (v57 != v59)
    free(v57);
  if (v55 != v54)
    free(v55);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v39, &v41, 8, (uint64_t *)&v60);
  v42[0] = v43;
  v42[1] = (void *)0x800000000;
  if (v63)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v42, (uint64_t *)&v62);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v34, &v36, 8, (uint64_t *)&v65);
  v37[0] = v38;
  v37[1] = (void *)0x800000000;
  if (v68)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v37, (uint64_t *)&v67);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>((llvm::SmallPtrSetImplBase *)&v39, (uint64_t)&v34, v7, (uint64_t)&v44);
  if (v37[0] != v38)
    free(v37[0]);
  if (v35 != v34)
    free(v35);
  if (v42[0] != v43)
    free(v42[0]);
  if (v40 != v39)
    free(v40);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v24, &v26, 8, (uint64_t *)v10);
  v27[0] = v28;
  v27[1] = (void *)0x800000000;
  if (*((_DWORD *)v10 + 26))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v27, (uint64_t *)v10 + 12);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v19, &v21, 8, (uint64_t *)&v44);
  v22[0] = v23;
  v22[1] = (void *)0x800000000;
  if (v47)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v22, (uint64_t *)&v46);
  std::__rewrap_range[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>>((uint64_t)&v24, (uint64_t)&v19, (uint64_t)&v29);
  v16 = v48[40];
  v17 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(v12, (void *)(v12 + 32), 8, (uint64_t *)&v29);
  *(_QWORD *)(v17 + 96) = v12 + 112;
  v18 = v17 + 96;
  *(_QWORD *)(v18 + 8) = 0x800000000;
  if (v32)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=(v18, (uint64_t *)&v31);
  *(_QWORD *)(v12 + 432) = v16;
  if (v31 != &v33)
    free(v31);
  if (v30 != v29)
    free(v30);
  if (v22[0] != v23)
    free(v22[0]);
  if (v20 != v19)
    free(v20);
  if (v27[0] != v28)
    free(v27[0]);
  if (v25 != v24)
    free(v25);
  if (v46 != v48)
    free(v46);
  if (v45 != v44)
    free(v45);
  if (v67 != v69)
    free(v67);
  if (v66 != v65)
    free(v66);
  if (v62 != &v64)
    free(v62);
  if (v61 != v60)
    free(v61);
}

void std::__unwrap_range[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11[2];
  _BYTE v12[320];
  void *v13;
  void *v14;
  void *v15;
  int v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21[2];
  _BYTE v22[320];
  void *v23;
  void *v24;
  void *v25;
  int v26;
  _QWORD v27[41];

  v27[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v18, &v20, 8, (uint64_t *)a1);
  v21[0] = v22;
  v21[1] = (void *)0x800000000;
  if (*(_DWORD *)(a1 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v21, (uint64_t *)(a1 + 96));
  std::__unwrap_iter[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::__unwrap_iter_impl<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,false>,0>((const void **)&v18, (uint64_t)&v23);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v8, &v10, 8, (uint64_t *)a2);
  v11[0] = v12;
  v11[1] = (void *)0x800000000;
  if (*(_DWORD *)(a2 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v11, (uint64_t *)(a2 + 96));
  std::__unwrap_iter[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::__unwrap_iter_impl<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,false>,0>((const void **)&v8, (uint64_t)&v13);
  v6 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)a3, a3 + 4, 8, (uint64_t *)&v23);
  *(_QWORD *)(v6 + 96) = a3 + 14;
  v7 = v6 + 96;
  *(_QWORD *)(v7 + 8) = 0x800000000;
  if (v26)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=(v7, (uint64_t *)&v25);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(a3 + 54), a3 + 58, 8, (uint64_t *)&v13);
  a3[66] = a3 + 68;
  a3[67] = 0x800000000;
  if (v16)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)(a3 + 66), (uint64_t *)&v15);
  if (v15 != &v17)
    free(v15);
  if (v14 != v13)
    free(v14);
  if (v11[0] != v12)
    free(v11[0]);
  if (v9 != v8)
    free(v9);
  if (v25 != v27)
    free(v25);
  if (v24 != v23)
    free(v24);
  if (v21[0] != v22)
    free(v21[0]);
  if (v19 != v18)
    free(v19);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::back_insert_iterator<llvm::SmallVector<mlir::Block *,8u>>>@<X0>(llvm::SmallPtrSetImplBase *this@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  void *v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t result;

  v8 = (uint64_t *)((char *)this + 96);
  v9 = (void *)(a3 + 16);
  while (1)
  {
    v10 = *((_DWORD *)this + 26);
    v11 = *((_QWORD *)this + 12);
    if (v10 != *(_DWORD *)(a2 + 104))
      goto LABEL_12;
    if (!v10)
      break;
    v12 = *(_QWORD **)(a2 + 96);
    v13 = (_QWORD *)*((_QWORD *)this + 12);
    while (*v13 == *v12 && v13[1] == v12[1] && v13[2] == v12[2] && v13[3] == v12[3] && v13[4] == v12[4])
    {
      v13 += 5;
      v12 += 5;
      if (v13 == (_QWORD *)(v11 + 40 * v10))
        goto LABEL_16;
    }
LABEL_12:
    v14 = *(_QWORD *)(v11 + 40 * v10 - 40);
    v15 = *(unsigned int *)(a3 + 8);
    if (v15 >= *(unsigned int *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v9, v15 + 1, 8);
      v15 = *(unsigned int *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v15) = v14;
    ++*(_DWORD *)(a3 + 8);
    v16 = *((_DWORD *)this + 26) - 1;
    *((_DWORD *)this + 26) = v16;
    if (v16)
      llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>::traverseChild(this);
  }
LABEL_16:
  v17 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a4, (void *)(a4 + 32), 8, (uint64_t *)this);
  *(_QWORD *)(v17 + 96) = a4 + 112;
  result = v17 + 96;
  *(_QWORD *)(result + 8) = 0x800000000;
  if (*((_DWORD *)this + 26))
    result = llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=(result, v8);
  *(_QWORD *)(a4 + 432) = a3;
  return result;
}

void std::__rewrap_range[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9[2];
  _BYTE v10[320];
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14[2];
  _QWORD v15[41];

  v15[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v11, &v13, 8, (uint64_t *)a1);
  v14[0] = v15;
  v14[1] = (void *)0x800000000;
  if (*(_DWORD *)(a1 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v14, (uint64_t *)(a1 + 96));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v6, &v8, 8, (uint64_t *)a2);
  v9[0] = v10;
  v9[1] = (void *)0x800000000;
  if (*(_DWORD *)(a2 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v9, (uint64_t *)(a2 + 96));
  std::__rewrap_iter[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::__unwrap_iter_impl<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,false>>((uint64_t)&v11, (uint64_t)&v6, a3);
  if (v9[0] != v10)
    free(v9[0]);
  if (v7 != v6)
    free(v7);
  if (v14[0] != v15)
    free(v14[0]);
  if (v12 != v11)
    free(v12);
}

void std::__unwrap_iter[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::__unwrap_iter_impl<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,false>,0>(const void **a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  const void *v10;
  void *v11;
  uint64_t v12;
  _QWORD v13[41];

  v13[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v8, &v10, (const llvm::SmallPtrSetImplBase *)a1);
  v11 = v13;
  v12 = 0x800000000;
  if (&v8 != (void **)a1)
  {
    v4 = *((_DWORD *)a1 + 26);
    if (v4)
    {
      if (v4 < 9)
      {
        v6 = v13;
        v5 = *((_DWORD *)a1 + 26);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v11, v13, *((unsigned int *)a1 + 26), 40);
        v5 = *((_DWORD *)a1 + 26);
        if (!v5)
        {
LABEL_8:
          LODWORD(v12) = v4;
          goto LABEL_9;
        }
        v6 = v11;
      }
      memcpy(v6, a1[12], 40 * v5);
      goto LABEL_8;
    }
  }
LABEL_9:
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a2, (void *)(a2 + 32), 8, (uint64_t *)&v8);
  *(_QWORD *)(a2 + 96) = a2 + 112;
  v7 = a2 + 96;
  *(_QWORD *)(v7 + 8) = 0x800000000;
  if ((_DWORD)v12)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=(v7, (uint64_t *)&v11);
  if (v11 != v13)
    free(v11);
  if (v9 != v8)
    free(v9);
}

void std::__rewrap_iter[abi:nn180100]<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,std::__unwrap_iter_impl<llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>,false>>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _BYTE v12[320];
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16[2];
  _QWORD v17[41];

  v17[40] = *MEMORY[0x24BDAC8D0];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v13, &v15, 8, (uint64_t *)a1);
  v16[0] = v17;
  v16[1] = (void *)0x800000000;
  if (*(_DWORD *)(a1 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)v16, (uint64_t *)(a1 + 96));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v7, &v9, 8, (uint64_t *)a2);
  v10 = v12;
  v11 = 0x800000000;
  if (*(_DWORD *)(a2 + 104))
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=((uint64_t)&v10, (uint64_t *)(a2 + 96));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a3, (void *)(a3 + 32), 8, (uint64_t *)&v7);
  *(_QWORD *)(a3 + 96) = a3 + 112;
  v6 = a3 + 96;
  *(_QWORD *)(v6 + 8) = 0x800000000;
  if ((_DWORD)v11)
    llvm::SmallVectorImpl<std::tuple<mlir::Block *,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>>::operator=(v6, (uint64_t *)&v10);
  if (v10 != v12)
    free(v10);
  if (v8 != v7)
    free(v8);
  if (v16[0] != v17)
    free(v16[0]);
  if (v14 != v13)
    free(v14);
}

uint64_t llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>::po_iterator(uint64_t a1, mlir::Block *a2)
{
  void *v4;
  uint64_t *v5;
  mlir::Block *v6;
  mlir::Block *v7;
  mlir::Block *v8;
  uint64_t v9;
  mlir::Block **v10;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  char *v19;
  mlir::Block *v20;
  mlir::Block *v21;
  uint64_t v22;
  mlir::Block *v23;
  mlir::Block *v24;

  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  v4 = (void *)(a1 + 112);
  *(_QWORD *)(a1 + 96) = a1 + 112;
  v5 = (uint64_t *)(a1 + 96);
  *(_QWORD *)(a1 + 104) = 0x800000000;
  *(_QWORD *)(a1 + 16) = 0x100000008;
  mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)&v20, a2);
  v6 = v20;
  mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)&v20, a2);
  v8 = v20;
  v7 = v21;
  v9 = *(unsigned int *)(a1 + 104);
  if (v9 >= *(_DWORD *)(a1 + 108))
  {
    v20 = a2;
    v21 = v6;
    v22 = 0;
    v23 = v8;
    v24 = v7;
    v12 = v9 + 1;
    v13 = *v5 + 40 * (unint64_t)v9 > (unint64_t)&v20;
    if (*v5 <= (unint64_t)&v20 && v13)
    {
      v19 = (char *)&v20 - *v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v5, v4, v12, 40);
      v14 = *v5;
      v15 = &v19[*v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v5, v4, v12, 40);
      v14 = *v5;
      v15 = (char *)&v20;
    }
    v16 = v14 + 40 * *(unsigned int *)(a1 + 104);
    v17 = *(_OWORD *)v15;
    v18 = *((_OWORD *)v15 + 1);
    *(_QWORD *)(v16 + 32) = *((_QWORD *)v15 + 4);
    *(_OWORD *)v16 = v17;
    *(_OWORD *)(v16 + 16) = v18;
  }
  else
  {
    v10 = (mlir::Block **)(*(_QWORD *)(a1 + 96) + 40 * v9);
    *v10 = a2;
    v10[1] = v6;
    v10[2] = 0;
    v10[3] = v8;
    v10[4] = v7;
  }
  ++*(_DWORD *)(a1 + 104);
  llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>::traverseChild((llvm::SmallPtrSetImplBase *)a1);
  return a1;
}

_QWORD *`anonymous namespace'::ByteCodeExecutor::readList<mlir::PDLValue,mlir::PDLValue>(_QWORD *result, uint64_t a2)
{
  int v2;

  *(_DWORD *)(a2 + 8) = 0;
  v2 = *(unsigned __int16 *)*result;
  *result += 2;
  if (v2)
    __asm { BR              X11 }
  return result;
}

_OWORD *std::vector<llvm::OwningArrayRef<mlir::Type>>::__push_back_slow_path<llvm::OwningArrayRef<mlir::Type>>(void **a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  _OWORD *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;

  v2 = ((_BYTE *)a1[1] - (_BYTE *)*a1) >> 4;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 60)
    abort();
  v6 = (_BYTE *)a1[2] - (_BYTE *)*a1;
  if (v6 >> 3 > v3)
    v3 = v6 >> 3;
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF0)
    v7 = 0xFFFFFFFFFFFFFFFLL;
  else
    v7 = v3;
  if (v7)
  {
    if (v7 >> 60)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v8 = (char *)operator new(16 * v7);
  }
  else
  {
    v8 = 0;
  }
  v9 = &v8[16 * v2];
  v10 = &v8[16 * v7];
  *(_OWORD *)v9 = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v11 = v9 + 16;
  v12 = (char *)*a1;
  v13 = (char *)a1[1];
  if (v13 == *a1)
  {
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
  }
  else
  {
    do
    {
      *((_OWORD *)v9 - 1) = *((_OWORD *)v13 - 1);
      v9 -= 16;
      *((_QWORD *)v13 - 2) = 0;
      *((_QWORD *)v13 - 1) = 0;
      v13 -= 16;
    }
    while (v13 != v12);
    v13 = (char *)*a1;
    v14 = (char *)a1[1];
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
    while (v14 != v13)
    {
      v16 = *((_QWORD *)v14 - 2);
      v14 -= 16;
      v15 = v16;
      if (v16)
        MEMORY[0x20BD002D4](v15, 0x20C8093837F09);
    }
  }
  if (v13)
    operator delete(v13);
  return v11;
}

void mlir::PDLResultList::~PDLResultList(mlir::PDLResultList *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;

  v2 = (char *)*((_QWORD *)this + 32);
  v3 = *((unsigned int *)this + 66);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 - 16;
    do
    {
      v6 = *(_QWORD *)&v5[v4];
      if (v6)
        MEMORY[0x20BD002D4](v6, 0x20C8093837F09);
      v4 -= 16;
    }
    while (v4);
    v2 = (char *)*((_QWORD *)this + 32);
  }
  if (v2 != (char *)this + 272)
    free(v2);
  v7 = (char *)*((_QWORD *)this + 24);
  v8 = *((unsigned int *)this + 50);
  if ((_DWORD)v8)
  {
    v9 = 16 * v8;
    v10 = v7 - 16;
    do
    {
      v11 = *(_QWORD *)&v10[v9];
      if (v11)
        MEMORY[0x20BD002D4](v11, 0x20C8093837F09);
      v9 -= 16;
    }
    while (v9);
    v7 = (char *)*((_QWORD *)this + 24);
  }
  if (v7 != (char *)this + 208)
    free(v7);
  v12 = (char *)*((_QWORD *)this + 16);
  if (v12 != (char *)this + 144)
    free(v12);
  v13 = (char *)*((_QWORD *)this + 8);
  if (v13 != (char *)this + 80)
    free(v13);
  if (*(mlir::PDLResultList **)this != (mlir::PDLResultList *)((char *)this + 16))
    free(*(void **)this);
}

void `anonymous namespace'::ByteCodeExecutor::readList(unsigned __int16 **a1, uint64_t a2)
{
  int v2;
  int v5;
  void *v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(*a1)++;
  if (v2)
  {
    v5 = 0;
    v6 = (void *)(a2 + 16);
    do
    {
      while (1)
      {
        v7 = (uint64_t)*a1;
        v8 = **a1;
        *a1 += 2;
        v9 = *(uint64_t **)&a1[9][4 * *(unsigned __int16 *)(v7 + 2)];
        if (v8 != 4)
          break;
        v10 = *(unsigned int *)(a2 + 8);
        if (v10 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v6, v10 + 1, 8);
          v10 = *(unsigned int *)(a2 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a2 + 8 * v10) = v9;
        ++*(_DWORD *)(a2 + 8);
        if (++v5 == v2)
          return;
      }
      v12 = *v9;
      v11 = v9[1];
      v13 = *(unsigned int *)(a2 + 8);
      if (v11 + v13 > (unint64_t)*(unsigned int *)(a2 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v6, v11 + v13, 8);
        v13 = *(unsigned int *)(a2 + 8);
      }
      v14 = *(_QWORD *)a2;
      v18 = v12;
      v19 = 0;
      if (v11)
      {
        v15 = 0;
        v16 = (uint64_t *)(v14 + 8 * v13);
        do
        {
          *v16++ = mlir::ValueRange::dereference_iterator(&v18, v15);
          v15 = ++v19;
        }
        while (v18 != v12 || v15 != v11);
        LODWORD(v13) = *(_DWORD *)(a2 + 8);
      }
      *(_DWORD *)(a2 + 8) = v13 + v11;
      ++v5;
    }
    while (v5 != v2);
  }
}

uint64_t mlir::OperationName::hasTrait<mlir::OpTrait::AttrSizedOperandSegments>(_QWORD *a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = &unk_25451B000;
  if ((v1 & 1) == 0)
  {
    v13 = a1;
    v2 = (_QWORD *)&unk_25451B000;
    v5 = v4;
    a1 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v15 = 96;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v2 = (_QWORD *)&unk_25451B000;
      a1 = v13;
    }
  }
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v2[37]);
}

uint64_t mlir::OperationName::hasTrait<mlir::OpTrait::AttrSizedResultSegments>(_QWORD *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v13 = a1;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v5 = v4;
    a1 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedResultSegments<Empty>]";
      v15 = 95;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedResultSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedResultSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a1 = v13;
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*a1 + 32))(*a1, v2[112]);
}

uint64_t llvm::SmallVectorTemplateBase<mlir::detail::PDLByteCode::MatchResult,false>::growAndEmplaceBack<mlir::Location &,mlir::detail::PDLByteCodePattern const&,mlir::PatternBenefit &>(uint64_t a1, _QWORD *a2, uint64_t a3, __int16 *a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  __int16 v11;
  int v12;
  unsigned int v13;
  unint64_t v15;

  v15 = 0;
  v8 = a1 + 16;
  v9 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 120, &v15);
  v10 = &v9[120 * *(unsigned int *)(a1 + 8)];
  v11 = *a4;
  *(_QWORD *)v10 = *a2;
  *((_QWORD *)v10 + 1) = v10 + 24;
  *((_QWORD *)v10 + 13) = a3;
  *((_QWORD *)v10 + 11) = v10 + 104;
  *((_QWORD *)v10 + 2) = 0x600000000;
  *((_QWORD *)v10 + 9) = v10 + 88;
  *((_QWORD *)v10 + 10) = 0;
  *((_QWORD *)v10 + 12) = 0;
  *((_WORD *)v10 + 56) = v11;
  llvm::SmallVectorTemplateBase<mlir::detail::PDLByteCode::MatchResult,false>::moveElementsForGrow((uint64_t *)a1, (uint64_t)v9);
  v12 = v15;
  if (*(_QWORD *)a1 != v8)
    free(*(void **)a1);
  *(_QWORD *)a1 = v9;
  v13 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v13;
  *(_DWORD *)(a1 + 12) = v12;
  return (uint64_t)&v9[120 * v13 - 120];
}

void llvm::SmallVectorTemplateBase<mlir::detail::PDLByteCode::MatchResult,false>::moveElementsForGrow(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v5 = 0;
    v6 = *a1;
    v7 = *a1 + 120 * v2;
    do
    {
      v9 = v6 + v5;
      v10 = (_QWORD *)(a2 + v5);
      *v10 = *(_QWORD *)(v6 + v5);
      *(_QWORD *)(a2 + v5 + 8) = a2 + v5 + 24;
      v10[2] = 0x600000000;
      if (*(_DWORD *)(v6 + v5 + 16))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(a2 + v5 + 8, v9 + 8);
      v11 = v10 + 11;
      v10[9] = v10 + 11;
      v10[10] = 0;
      v12 = (uint64_t)(v10 + 9);
      if (*(_DWORD *)(v9 + 80))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=(v12, v6 + v5 + 72);
      v13 = (_QWORD *)(a2 + v5 + 104);
      *v11 = v13;
      *(_QWORD *)(a2 + v5 + 96) = 0;
      if (*(_DWORD *)(v9 + 96))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v11, v6 + v5 + 88);
      v8 = *(_QWORD *)(v9 + 104);
      *(_WORD *)(a2 + v5 + 112) = *(_WORD *)(v9 + 112);
      *v13 = v8;
      v5 += 120;
    }
    while (v9 + 120 != v7);
    v14 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v14)
    {
      v15 = *a1;
      v16 = 120 * v14;
      do
      {
        v17 = *(void **)(v15 + v16 - 32);
        if ((void *)(v15 + v16 - 16) != v17)
          free(v17);
        v18 = *(void **)(v15 + v16 - 48);
        if ((void *)(v15 + v16 - 32) != v18)
          free(v18);
        v19 = *(void **)(v15 + v16 - 112);
        if ((void *)(v15 + v16 - 96) != v19)
          free(v19);
        v16 -= 120;
      }
      while (v16);
    }
  }
}

double llvm::SmallVectorImpl<std::unique_ptr<mlir::PDLPatternConfigSet>>::assignRemote(char **a1, char **a2)
{
  char *v4;
  uint64_t v5;
  char *v6;
  char **v7;
  char **v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  double result;

  v4 = *a1;
  v5 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v5)
  {
    v6 = &v4[8 * v5];
    do
    {
      v8 = (char **)*((_QWORD *)v6 - 1);
      v6 -= 8;
      v7 = v8;
      *(_QWORD *)v6 = 0;
      if (v8)
      {
        v9 = *v7;
        v10 = *((unsigned int *)v7 + 2);
        if ((_DWORD)v10)
        {
          v11 = 8 * v10;
          v12 = v9 - 8;
          do
          {
            v13 = *(_QWORD *)&v12[v11];
            *(_QWORD *)&v12[v11] = 0;
            if (v13)
              (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
            v11 -= 8;
          }
          while (v11);
          v9 = *v7;
        }
        if (v9 != (char *)(v7 + 2))
          free(v9);
        MEMORY[0x20BD002F8](v7, 0x1080C407559D7D1);
      }
    }
    while (v6 != v4);
    v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2))
    free(v4);
  *a1 = *a2;
  result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

void std::vector<void const*>::__append(unint64_t *a1, unint64_t a2, const double *a3)
{
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  float64x2_t v18;
  float64x2_t *v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  unint64_t v23;
  char *v24;
  unint64_t v25;
  float64x2_t v26;
  float64x2_t *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  __int128 *v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;

  v7 = a1[1];
  v6 = a1[2];
  v8 = (_QWORD *)v7;
  if (a2 <= (uint64_t)(v6 - v7) >> 3)
  {
    if (a2)
    {
      v16 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v16 < 0xF || v7 < (unint64_t)(a3 + 1) && v7 + 8 * a2 > (unint64_t)a3)
        goto LABEL_44;
      v17 = v16 + 1;
      v8 = (_QWORD *)(v7 + 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL));
      v18 = vld1q_dup_f64(a3);
      v19 = (float64x2_t *)(v7 + 16);
      v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v19[-1] = v18;
        *v19 = v18;
        v19 += 2;
        v20 -= 4;
      }
      while (v20);
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
          *v8++ = *(_QWORD *)a3;
        while (v8 != (_QWORD *)(v7 + 8 * a2));
      }
      v8 = (_QWORD *)(v7 + 8 * a2);
    }
    a1[1] = (unint64_t)v8;
  }
  else
  {
    v9 = v7 - *a1;
    v10 = v9 >> 3;
    v11 = (v9 >> 3) + a2;
    if (v11 >> 61)
      abort();
    v12 = v6 - *a1;
    v13 = v12 >> 2;
    if (v12 >> 2 <= v11)
      v13 = (v9 >> 3) + a2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
    {
      if (v14 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v15 = (char *)operator new(8 * v14);
    }
    else
    {
      v15 = 0;
    }
    v21 = (unint64_t)&v15[8 * v10];
    v22 = (char *)(v21 + 8 * a2);
    v23 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    v24 = (char *)v21;
    if (v23 < 0x13)
      goto LABEL_45;
    if (v21 < (unint64_t)(a3 + 1))
    {
      v24 = &v15[8 * v10];
      if (&v15[8 * a2 + v9] > (char *)a3)
        goto LABEL_45;
    }
    v25 = v23 + 1;
    v24 = (char *)(v21 + 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL));
    v26 = vld1q_dup_f64(a3);
    v27 = (float64x2_t *)&v15[8 * v10 + 16];
    v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v27[-1] = v26;
      *v27 = v26;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v25 != (v25 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_45:
      do
      {
        *(double *)v24 = *a3;
        v24 += 8;
      }
      while (v24 != v22);
    }
    v29 = (_QWORD *)*a1;
    if (v7 != *a1)
    {
      v30 = v7 - *a1 - 8;
      if (v30 < 0x58)
        goto LABEL_46;
      if (v7 - (unint64_t)&v15[v9] < 0x20)
        goto LABEL_46;
      v31 = (v30 >> 3) + 1;
      v32 = 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
      v8 = (_QWORD *)(v7 - v32);
      v21 -= v32;
      v33 = &v15[8 * v10 - 16];
      v34 = (__int128 *)(v7 - 16);
      v35 = v31 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v36 = *v34;
        *((_OWORD *)v33 - 1) = *(v34 - 1);
        *(_OWORD *)v33 = v36;
        v33 -= 32;
        v34 -= 2;
        v35 -= 4;
      }
      while (v35);
      if (v31 != (v31 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_46:
        do
        {
          v37 = *--v8;
          *(_QWORD *)(v21 - 8) = v37;
          v21 -= 8;
        }
        while (v8 != v29);
      }
      v8 = (_QWORD *)*a1;
    }
    *a1 = v21;
    a1[1] = (unint64_t)v22;
    a1[2] = (unint64_t)&v15[8 * v14];
    if (v8)
      operator delete(v8);
  }
}

void std::vector<llvm::OwningArrayRef<mlir::Operation *>>::__append(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      v12 = 16 * a2;
      bzero(a1[1], 16 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = *a1;
    v7 = (v5 - *a1) >> 4;
    v8 = v7 + a2;
    if ((v7 + a2) >> 60)
      abort();
    v9 = v4 - v6;
    if (v9 >> 3 > v8)
      v8 = v9 >> 3;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0)
      v10 = 0xFFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
    {
      if (v10 >> 60)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v11 = (char *)operator new(16 * v10);
    }
    else
    {
      v11 = 0;
    }
    v13 = &v11[16 * v7];
    v14 = 16 * a2;
    v15 = &v11[16 * v10];
    bzero(v13, v14);
    v16 = &v13[v14];
    if (v5 == v6)
    {
      *a1 = v13;
      a1[1] = v16;
      a1[2] = v15;
    }
    else
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        *((_QWORD *)v5 - 2) = 0;
        *((_QWORD *)v5 - 1) = 0;
        v5 -= 16;
      }
      while (v5 != v6);
      v5 = *a1;
      v17 = a1[1];
      *a1 = v13;
      a1[1] = v16;
      a1[2] = v15;
      while (v17 != v5)
      {
        v19 = *((_QWORD *)v17 - 2);
        v17 -= 16;
        v18 = v19;
        if (v19)
          MEMORY[0x20BD002D4](v18, 0x20C8093837F09);
      }
    }
    if (v5)
      operator delete(v5);
  }
}

void std::vector<mlir::TypeRange>::__append(char **a1, unint64_t a2, _OWORD *a3)
{
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  char *v19;

  v7 = a1[1];
  v6 = a1[2];
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      v13 = 16 * a2;
      v14 = &v7[16 * a2];
      do
      {
        *(_OWORD *)v7 = *a3;
        v7 += 16;
        v13 -= 16;
      }
      while (v13);
      v7 = v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = (v7 - *a1) >> 4;
    if ((v8 + a2) >> 60)
      abort();
    v9 = v6 - *a1;
    v10 = v9 >> 3;
    if (v9 >> 3 <= v8 + a2)
      v10 = v8 + a2;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
    {
      if (v11 >> 60)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v12 = (char *)operator new(16 * v11);
    }
    else
    {
      v12 = 0;
    }
    v15 = &v12[16 * v8];
    v16 = 16 * a2;
    v17 = &v15[16 * a2];
    v18 = v15;
    do
    {
      *(_OWORD *)v18 = *a3;
      v18 += 16;
      v16 -= 16;
    }
    while (v16);
    v19 = *a1;
    if (v7 != *a1)
    {
      do
      {
        *((_OWORD *)v15 - 1) = *((_OWORD *)v7 - 1);
        v15 -= 16;
        v7 -= 16;
      }
      while (v7 != v19);
      v7 = *a1;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = &v12[16 * v11];
    if (v7)
      operator delete(v7);
  }
}

void std::vector<unsigned int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, std::vector<unsigned int>::const_reference __x)
{
  unsigned int *value;
  std::vector<unsigned int>::pointer end;
  unsigned int *v8;
  std::vector<unsigned int>::pointer begin;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  std::vector<unsigned int>::size_type v16;
  std::vector<unsigned int>::size_type v17;
  float32x4_t v18;
  float32x4_t *v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int *v22;
  std::vector<unsigned int>::size_type v23;
  unsigned int *v24;
  std::vector<unsigned int>::size_type v25;
  float32x4_t v26;
  float32x4_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  __int128 *v33;
  uint64_t v34;
  __int128 v35;
  unsigned int v36;

  end = this->__end_;
  value = this->__end_cap_.__value_;
  v8 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 < 0xF || end < __x + 1 && &end[__n] > __x)
        goto LABEL_43;
      v17 = v16 + 1;
      v8 = &end[v17 & 0x7FFFFFFFFFFFFFF8];
      v18 = vld1q_dup_f32((const float *)__x);
      v19 = (float32x4_t *)(end + 4);
      v20 = v17 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v19[-1] = v18;
        *v19 = v18;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_43:
        do
          *v8++ = *__x;
        while (v8 != &end[__n]);
      }
      v8 = &end[__n];
    }
    this->__end_ = v8;
  }
  else
  {
    begin = this->__begin_;
    v10 = (char *)end - (char *)this->__begin_;
    v11 = v10 >> 2;
    v12 = (v10 >> 2) + __n;
    if (v12 >> 62)
      abort();
    v13 = (char *)value - (char *)begin;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14)
    {
      if (v14 >> 62)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v15 = operator new(4 * v14);
    }
    else
    {
      v15 = 0;
    }
    v21 = (unsigned int *)&v15[4 * v11];
    v22 = &v21[__n];
    v23 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    v24 = v21;
    if (v23 < 0x13)
      goto LABEL_44;
    if (v21 < __x + 1)
    {
      v24 = (unsigned int *)&v15[4 * v11];
      if (&v15[4 * __n + v10] > (_BYTE *)__x)
        goto LABEL_44;
    }
    v25 = v23 + 1;
    v24 = &v21[v25 & 0x7FFFFFFFFFFFFFF8];
    v26 = vld1q_dup_f32((const float *)__x);
    v27 = (float32x4_t *)&v15[4 * v11 + 16];
    v28 = v25 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      *v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_44:
      do
        *v24++ = *__x;
      while (v24 != v22);
    }
    if (end != begin)
    {
      v29 = (char *)end - (char *)begin - 4;
      if (v29 < 0x2C)
        goto LABEL_45;
      if ((unint64_t)((char *)end - &v15[v10]) < 0x20)
        goto LABEL_45;
      v30 = (v29 >> 2) + 1;
      v31 = 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
      v8 = &end[v31 / 0xFFFFFFFFFFFFFFFCLL];
      v21 = (unsigned int *)((char *)v21 - v31);
      v32 = &v15[4 * v11 - 16];
      v33 = (__int128 *)(end - 4);
      v34 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v35 = *v33;
        *(v32 - 1) = *(v33 - 1);
        *v32 = v35;
        v32 -= 2;
        v33 -= 2;
        v34 -= 8;
      }
      while (v34);
      if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_45:
        do
        {
          v36 = *--v8;
          *--v21 = v36;
        }
        while (v8 != begin);
      }
    }
    this->__begin_ = v21;
    this->__end_ = v22;
    this->__end_cap_.__value_ = (unsigned int *)&v15[4 * v14];
    if (begin)
      operator delete(begin);
  }
}

void std::__stable_sort<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(uint64_t a1, _QWORD *a2, unint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v6;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  void **v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  void *v26;
  _DWORD *v27;
  int v28;
  uint64_t v29;
  int v30;
  void *v31;
  _DWORD *v32;
  _DWORD *v33;
  int v34;
  _DWORD *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  void *v53[2];
  _BYTE v54[48];
  void *v55[2];
  void *v56[2];
  uint64_t v57;
  unsigned __int16 v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  if (a3 < 2)
    return;
  v6 = a1;
  if (a3 == 2)
  {
    if (*(unsigned __int16 *)(a1 + 112) < *((unsigned __int16 *)a2 - 4))
      std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(a1, (uint64_t)(a2 - 15));
    return;
  }
  if ((uint64_t)a3 > 0)
  {
    v10 = a3 >> 1;
    v11 = (_QWORD *)(a1 + 120 * (a3 >> 1));
    v12 = a3 >> 1;
    if ((uint64_t)a3 <= a5)
    {
      std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(a1, v11, v12, a4);
      v41 = &a4[15 * v10];
      std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(v6 + 120 * (a3 >> 1), a2, a3 - (a3 >> 1), v41);
      v42 = &a4[15 * a3];
      v43 = (uint64_t)v41;
      v44 = (uint64_t)a4;
      while ((_QWORD *)v43 != v42)
      {
        if (*(unsigned __int16 *)(v44 + 112) >= *(unsigned __int16 *)(v43 + 112))
        {
          mlir::detail::PDLByteCode::MatchResult::operator=(v6, v44);
          v44 += 120;
          v6 += 120;
          if ((_QWORD *)v44 == v41)
            goto LABEL_59;
        }
        else
        {
          mlir::detail::PDLByteCode::MatchResult::operator=(v6, v43);
          v43 += 120;
          v6 += 120;
          if ((_QWORD *)v44 == v41)
          {
LABEL_59:
            if ((_QWORD *)v43 != v42)
            {
              v45 = 0;
              do
              {
                mlir::detail::PDLByteCode::MatchResult::operator=(v6 + v45, v43 + v45);
                v45 += 120;
              }
              while ((_QWORD *)(v43 + v45) != v42);
            }
            goto LABEL_66;
          }
        }
      }
      if ((_QWORD *)v44 != v41)
      {
        v46 = 0;
        do
        {
          mlir::detail::PDLByteCode::MatchResult::operator=(v6 + v46, v44 + v46);
          v46 += 120;
        }
        while ((_QWORD *)(v44 + v46) != v41);
      }
LABEL_66:
      if (a4)
      {
        v47 = a3;
        v48 = a4 + 13;
        do
        {
          v49 = (_QWORD *)*(v48 - 2);
          if (v48 != v49)
            free(v49);
          v50 = (_QWORD *)*(v48 - 4);
          if (v48 - 2 != v50)
            free(v50);
          v51 = (_QWORD *)*(v48 - 12);
          if (v48 - 10 != v51)
            free(v51);
          v48 += 15;
          --v47;
        }
        while (v47);
      }
    }
    else
    {
      std::__stable_sort<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(a1, v11, v12, a4, a5);
      std::__stable_sort<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(v6 + 120 * (a3 >> 1), a2, a3 - (a3 >> 1), a4, a5);
      std::__inplace_merge<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(v6, v6 + 120 * (a3 >> 1), (uint64_t)a2, a3 >> 1, a3 - (a3 >> 1), (uint64_t)a4, a5);
    }
    return;
  }
  if ((_QWORD *)a1 == a2)
    return;
  v13 = (_QWORD *)(a1 + 120);
  if ((_QWORD *)(a1 + 120) == a2)
    return;
  v14 = 0;
  v15 = a1;
  while (2)
  {
    v16 = v13;
    if (*(unsigned __int16 *)(v15 + 112) >= *(unsigned __int16 *)(v15 + 232))
      goto LABEL_11;
    v52 = *v13;
    v53[0] = v54;
    v53[1] = (void *)0x600000000;
    if (*(_DWORD *)(v15 + 136))
      llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v53, v15 + 128);
    v55[0] = v56;
    v55[1] = 0;
    if (*(_DWORD *)(v15 + 200))
      llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v55, v15 + 192);
    v56[0] = &v57;
    v56[1] = 0;
    if (*(_DWORD *)(v15 + 216))
      llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v56, v15 + 208);
    v57 = *(_QWORD *)(v15 + 224);
    v58 = *(_WORD *)(v15 + 232);
    v17 = v14;
    while (1)
    {
      v18 = v6 + v17;
      v19 = *(const void **)(v6 + v17 + 8);
      *(_QWORD *)(v6 + v17 + 120) = *(_QWORD *)(v6 + v17);
      v20 = (void **)(v6 + v17 + 128);
      v21 = v6 + v17 + 24;
      if ((const void *)v21 == v19)
      {
        v35 = (_DWORD *)(v18 + 16);
        v36 = *(unsigned int *)(v18 + 16);
        v37 = *(unsigned int *)(v18 + 136);
        if (v37 >= v36)
        {
          if ((_DWORD)v36)
            memmove(*v20, v19, 8 * v36);
        }
        else
        {
          if (*(_DWORD *)(v6 + v17 + 140) < v36)
          {
            *(_DWORD *)(v18 + 136) = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v20, (void *)(v6 + v17 + 144), v36, 8);
            v37 = 0;
            v38 = *v35;
            if (!*v35)
              goto LABEL_39;
            goto LABEL_38;
          }
          if ((_DWORD)v37)
          {
            memmove(*v20, v19, 8 * v37);
            v38 = *v35;
            if (v37 == v38)
              goto LABEL_39;
            goto LABEL_38;
          }
          v37 = 0;
          v38 = *v35;
          if (*v35)
LABEL_38:
            memcpy((void *)(*(_QWORD *)(v18 + 128) + 8 * v37), (const void *)(*(_QWORD *)(v18 + 8) + 8 * v37), 8 * v38 - 8 * v37);
        }
LABEL_39:
        *(_DWORD *)(v18 + 136) = v36;
        *v35 = 0;
        v24 = v6 + v17;
        v25 = *(_DWORD *)(v6 + v17 + 80);
        if (!v25)
          goto LABEL_40;
        goto LABEL_24;
      }
      v22 = *v20;
      if ((void *)(v18 + 144) != v22)
      {
        free(v22);
        v19 = *(const void **)(v18 + 8);
      }
      v23 = v6 + v17;
      *(_QWORD *)(v18 + 128) = v19;
      *(_QWORD *)(v23 + 136) = *(_QWORD *)(v6 + v17 + 16);
      *(_QWORD *)(v18 + 8) = v21;
      *(_DWORD *)(v23 + 20) = 0;
      *(_DWORD *)(v15 + 16) = 0;
      v24 = v6 + v17;
      v25 = *(_DWORD *)(v6 + v17 + 80);
      if (!v25)
      {
LABEL_40:
        *(_DWORD *)(v24 + 200) = 0;
        v29 = v6 + v17;
        v30 = *(_DWORD *)(v6 + v17 + 96);
        if (!v30)
          goto LABEL_41;
        goto LABEL_27;
      }
LABEL_24:
      v26 = *(void **)(v24 + 192);
      if ((void *)(v24 + 208) != v26)
      {
        free(v26);
        v25 = *(_DWORD *)(v24 + 80);
      }
      v27 = (_DWORD *)(v6 + v17);
      *(_QWORD *)(v24 + 192) = *(_QWORD *)(v24 + 72);
      v28 = *(_DWORD *)(v6 + v17 + 84);
      v27[50] = v25;
      v27[51] = v28;
      *(_QWORD *)(v24 + 72) = v6 + v17 + 88;
      v27[21] = 0;
      *(_DWORD *)(v15 + 80) = 0;
      v29 = v6 + v17;
      v30 = *(_DWORD *)(v6 + v17 + 96);
      if (!v30)
      {
LABEL_41:
        v32 = (_DWORD *)(v29 + 216);
        goto LABEL_42;
      }
LABEL_27:
      v31 = *(void **)(v29 + 208);
      if ((void *)(v29 + 224) != v31)
      {
        free(v31);
        v30 = *(_DWORD *)(v29 + 96);
      }
      v32 = (_DWORD *)(v15 + 96);
      v33 = (_DWORD *)(v6 + v17);
      *(_QWORD *)(v29 + 208) = *(_QWORD *)(v29 + 88);
      v34 = *(_DWORD *)(v6 + v17 + 100);
      v33[54] = v30;
      v33[55] = v34;
      *(_QWORD *)(v29 + 88) = v6 + v17 + 104;
      v33[25] = 0;
LABEL_42:
      *v32 = 0;
      v39 = v6 + v17;
      *(_QWORD *)(v39 + 224) = *(_QWORD *)(v6 + v17 + 104);
      *(_WORD *)(v39 + 232) = *(_WORD *)(v6 + v17 + 112);
      if (!v17)
        break;
      v15 -= 120;
      v17 -= 120;
      if (*(unsigned __int16 *)(v39 - 8) >= v58)
      {
        v40 = v6 + v17 + 120;
        goto LABEL_48;
      }
    }
    v40 = v6;
LABEL_48:
    mlir::detail::PDLByteCode::MatchResult::operator=(v40, (uint64_t)&v52);
    if (v56[0] != &v57)
      free(v56[0]);
    if (v55[0] != v56)
      free(v55[0]);
    if (v53[0] != v54)
      free(v53[0]);
LABEL_11:
    v13 = v16 + 15;
    v14 += 120;
    v15 = (uint64_t)v16;
    if (v16 + 15 != a2)
      continue;
    break;
  }
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(uint64_t result, _QWORD *a2, unint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _DWORD *v26;
  char *v27;
  _QWORD *v28;
  void **v29;
  char *v30;
  char *v31;
  int v32;
  char *v33;
  char *v34;
  int v35;
  char *v36;
  int v37;
  char *v38;
  _DWORD *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  int v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;

  if (a3)
  {
    v4 = a4;
    v6 = a2;
    v7 = result;
    if (a3 == 2)
    {
      v11 = *(unsigned __int16 *)(result + 112);
      v12 = (uint64_t)(a4 + 1);
      v13 = a4 + 3;
      if (v11 < *((unsigned __int16 *)a2 - 4))
      {
        *a4 = *(a2 - 15);
        a4[1] = v13;
        a4[2] = 0x600000000;
        if (*((_DWORD *)a2 - 26))
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v12, (uint64_t)(a2 - 14));
        v4[9] = v4 + 11;
        v4[10] = 0;
        if (*((_DWORD *)v6 - 10))
          llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 9), (uint64_t)(v6 - 6));
        v4[11] = v4 + 13;
        v4[12] = 0;
        if (*((_DWORD *)v6 - 6))
          llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 11), (uint64_t)(v6 - 4));
        v14 = *(v6 - 2);
        *((_WORD *)v4 + 56) = *((_WORD *)v6 - 4);
        v4[13] = v14;
        v15 = *(_QWORD *)v7;
        v4[16] = v4 + 18;
        v4[15] = v15;
        v4[17] = 0x600000000;
        if (*(_DWORD *)(v7 + 16))
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(v4 + 16), v7 + 8);
        v8 = (uint64_t)(v4 + 26);
        v4[24] = v4 + 26;
        v4[25] = 0;
        result = (uint64_t)(v4 + 24);
        if (*(_DWORD *)(v7 + 80))
          result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v7 + 72);
        v9 = v4 + 28;
        v4[26] = v4 + 28;
        v4[27] = 0;
        if (!*(_DWORD *)(v7 + 96))
          goto LABEL_10;
LABEL_9:
        result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(v8, v7 + 88);
LABEL_10:
        v10 = *(_QWORD *)(v7 + 104);
        *((_WORD *)v9 + 4) = *(_WORD *)(v7 + 112);
        *v9 = v10;
        return result;
      }
      *a4 = *(_QWORD *)v7;
      a4[1] = v13;
      a4[2] = 0x600000000;
      if (*(_DWORD *)(v7 + 16))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v12, v7 + 8);
      v4[9] = v4 + 11;
      v4[10] = 0;
      if (*(_DWORD *)(v7 + 80))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 9), v7 + 72);
      v4[11] = v4 + 13;
      v4[12] = 0;
      if (*(_DWORD *)(v7 + 96))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 11), v7 + 88);
      v47 = *(_QWORD *)(v7 + 104);
      *((_WORD *)v4 + 56) = *(_WORD *)(v7 + 112);
      v4[13] = v47;
      v48 = *(v6 - 15);
      v4[16] = v4 + 18;
      v4[15] = v48;
      v4[17] = 0x600000000;
      if (*((_DWORD *)v6 - 26))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(v4 + 16), (uint64_t)(v6 - 14));
      v4[24] = v4 + 26;
      v4[25] = 0;
      result = (uint64_t)(v4 + 24);
      if (*((_DWORD *)v6 - 10))
        result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, (uint64_t)(v6 - 6));
      v4[26] = v4 + 28;
      v4[27] = 0;
      if (*((_DWORD *)v6 - 6))
        result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 26), (uint64_t)(v6 - 4));
      v49 = *(v6 - 2);
      *((_WORD *)v4 + 116) = *((_WORD *)v6 - 4);
      v4[28] = v49;
    }
    else
    {
      if (a3 == 1)
      {
        *a4 = *(_QWORD *)result;
        a4[1] = a4 + 3;
        a4[2] = 0x600000000;
        if (*(_DWORD *)(result + 16))
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(a4 + 1), result + 8);
        v8 = (uint64_t)(v4 + 11);
        v4[9] = v4 + 11;
        v4[10] = 0;
        result = (uint64_t)(v4 + 9);
        if (*(_DWORD *)(v7 + 80))
          result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v7 + 72);
        v9 = v4 + 13;
        v4[11] = v4 + 13;
        v4[12] = 0;
        if (!*(_DWORD *)(v7 + 96))
          goto LABEL_10;
        goto LABEL_9;
      }
      if ((uint64_t)a3 > 8)
      {
        v50 = a3 >> 1;
        v51 = 120 * (a3 >> 1);
        v52 = result + v51;
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(result, result + v51, a3 >> 1, a4, a3 >> 1);
        result = std::__stable_sort<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(v7 + v51, v6, a3 - v50, &v4[(unint64_t)v51 / 8], a3 - v50);
        v53 = v7 + v51;
        while ((_QWORD *)v53 != v6)
        {
          v55 = (uint64_t)(v4 + 1);
          v56 = v4 + 3;
          if (*(unsigned __int16 *)(v7 + 112) >= *(unsigned __int16 *)(v53 + 112))
          {
            *v4 = *(_QWORD *)v7;
            v4[1] = v56;
            v4[2] = 0x600000000;
            if (*(_DWORD *)(v7 + 16))
              llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v55, v7 + 8);
            v4[9] = v4 + 11;
            v4[10] = 0;
            result = (uint64_t)(v4 + 9);
            if (*(_DWORD *)(v7 + 80))
              result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v7 + 72);
            v4[11] = v4 + 13;
            v4[12] = 0;
            if (*(_DWORD *)(v7 + 96))
              result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 11), v7 + 88);
            v54 = *(_QWORD *)(v7 + 104);
            *((_WORD *)v4 + 56) = *(_WORD *)(v7 + 112);
            v4[13] = v54;
            v7 += 120;
            v4 += 15;
            if (v7 == v52)
            {
LABEL_122:
              if ((_QWORD *)v53 != v6)
              {
                v65 = 0;
                do
                {
                  v67 = v53 + v65 * 8;
                  v68 = &v4[v65];
                  *v68 = *(_QWORD *)(v53 + v65 * 8);
                  v4[v65 + 1] = &v4[v65 + 3];
                  v68[2] = 0x600000000;
                  if (*(_DWORD *)(v53 + v65 * 8 + 16))
                    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v4[v65 + 1], v67 + 8);
                  v68[9] = v68 + 11;
                  result = (uint64_t)(v68 + 9);
                  v68[10] = 0;
                  if (*(_DWORD *)(v67 + 80))
                    result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v53 + v65 * 8 + 72);
                  v69 = &v4[v65 + 13];
                  v68[11] = v69;
                  v4[v65 + 12] = 0;
                  if (*(_DWORD *)(v67 + 96))
                    result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v68 + 11), v53 + v65 * 8 + 88);
                  v66 = *(_QWORD *)(v67 + 104);
                  LOWORD(v4[v65 + 14]) = *(_WORD *)(v67 + 112);
                  *v69 = v66;
                  v65 += 15;
                }
                while ((_QWORD *)(v67 + 120) != v6);
              }
              return result;
            }
          }
          else
          {
            *v4 = *(_QWORD *)v53;
            v4[1] = v56;
            v4[2] = 0x600000000;
            if (*(_DWORD *)(v53 + 16))
              llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v55, v53 + 8);
            v4[9] = v4 + 11;
            v4[10] = 0;
            result = (uint64_t)(v4 + 9);
            if (*(_DWORD *)(v53 + 80))
              result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v53 + 72);
            v4[11] = v4 + 13;
            v4[12] = 0;
            if (*(_DWORD *)(v53 + 96))
              result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 11), v53 + 88);
            v57 = *(_QWORD *)(v53 + 104);
            *((_WORD *)v4 + 56) = *(_WORD *)(v53 + 112);
            v4[13] = v57;
            v53 += 120;
            v4 += 15;
            if (v7 == v52)
              goto LABEL_122;
          }
        }
        if (v7 != v52)
        {
          v58 = 0;
          do
          {
            v60 = v7 + v58 * 8;
            v61 = &v4[v58];
            *v61 = *(_QWORD *)(v7 + v58 * 8);
            v4[v58 + 1] = &v4[v58 + 3];
            result = (uint64_t)&v4[v58 + 1];
            v61[2] = 0x600000000;
            if (*(_DWORD *)(v7 + v58 * 8 + 16))
              result = llvm::SmallVectorImpl<llvm::SMLoc>::operator=(result, v60 + 8);
            v62 = v61 + 11;
            v61[9] = v61 + 11;
            v61[10] = 0;
            v63 = (uint64_t)(v61 + 9);
            if (*(_DWORD *)(v60 + 80))
              result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(v63, v7 + v58 * 8 + 72);
            v64 = &v4[v58 + 13];
            *v62 = v64;
            v4[v58 + 12] = 0;
            if (*(_DWORD *)(v60 + 96))
              result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v62, v7 + v58 * 8 + 88);
            v59 = *(_QWORD *)(v60 + 104);
            LOWORD(v4[v58 + 14]) = *(_WORD *)(v60 + 112);
            *v64 = v59;
            v58 += 15;
          }
          while (v60 + 120 != v52);
        }
      }
      else if ((_QWORD *)result != a2)
      {
        *a4 = *(_QWORD *)result;
        a4[1] = a4 + 3;
        a4[2] = 0x600000000;
        if (*(_DWORD *)(result + 16))
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(a4 + 1), result + 8);
        v4[9] = v4 + 11;
        v4[10] = 0;
        result = (uint64_t)(v4 + 9);
        if (*(_DWORD *)(v7 + 80))
          result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v7 + 72);
        v4[11] = v4 + 13;
        v4[12] = 0;
        if (*(_DWORD *)(v7 + 96))
          result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v4 + 11), v7 + 88);
        v16 = *(_QWORD *)(v7 + 104);
        *((_WORD *)v4 + 56) = *(_WORD *)(v7 + 112);
        v4[13] = v16;
        v17 = (_QWORD *)(v7 + 120);
        if ((_QWORD *)(v7 + 120) != v6)
        {
          v18 = 0;
          v19 = v4;
          v70 = v6;
          while (1)
          {
            while (1)
            {
              v21 = v17;
              v22 = (uint64_t)(v19 + 16);
              v23 = v19 + 18;
              if (*((unsigned __int16 *)v19 + 56) < *(unsigned __int16 *)(v7 + 232))
                break;
              v46 = v21;
              v19[15] = *v21;
              v19[16] = v23;
              v19[17] = 0x600000000;
              if (*(_DWORD *)(v7 + 136))
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v22, v7 + 128);
              v19[24] = v19 + 26;
              v19[25] = 0;
              result = (uint64_t)(v19 + 24);
              if (*(_DWORD *)(v7 + 200))
                result = llvm::SmallVectorImpl<llvm::SMRange>::operator=(result, v7 + 192);
              v19[26] = v19 + 28;
              v19[27] = 0;
              if (*(_DWORD *)(v7 + 216))
                result = llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v19 + 26), v7 + 208);
              v20 = *(_QWORD *)(v7 + 224);
              *((_WORD *)v19 + 116) = *(_WORD *)(v7 + 232);
              v19[28] = v20;
              v7 = (uint64_t)v46;
              v19 += 15;
              v17 = v46 + 15;
              v18 += 120;
              if (v46 + 15 == v6)
                return result;
            }
            v72 = (uint64_t)v21;
            v19[15] = *v19;
            v19[16] = v23;
            v19[17] = 0x600000000;
            if (*((_DWORD *)v19 + 4))
              llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v22, (uint64_t)(v19 + 1));
            v19[24] = v19 + 26;
            v19[25] = 0;
            if (*((_DWORD *)v19 + 20))
              llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v19 + 24), (uint64_t)(v19 + 9));
            v19[26] = v19 + 28;
            v19[27] = 0;
            if (*((_DWORD *)v19 + 24))
              llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)(v19 + 26), (uint64_t)(v19 + 11));
            v19[28] = v19[13];
            *((_WORD *)v19 + 116) = *((_WORD *)v19 + 56);
            v24 = v4;
            if (v19 != v4)
              break;
LABEL_79:
            v7 = v72;
            result = mlir::detail::PDLByteCode::MatchResult::operator=((uint64_t)v24, v72);
            v19 += 15;
            v17 = (_QWORD *)(v72 + 120);
            v18 += 120;
            if ((_QWORD *)(v72 + 120) == v6)
              return result;
          }
          v71 = v18;
          v25 = v19;
          v73 = v7;
          while (1)
          {
            v24 = (_QWORD *)((char *)v4 + v18);
            if (*(unsigned __int16 *)((char *)v4 + v18 - 8) >= *(unsigned __int16 *)(v7 + 232))
            {
LABEL_78:
              v6 = v70;
              v18 = v71;
              goto LABEL_79;
            }
            v28 = (_QWORD *)*(v24 - 14);
            *v24 = *(v24 - 15);
            v29 = (void **)(v24 + 1);
            if (v24 - 12 == v28)
              break;
            v30 = (char *)v4 + v18;
            if ((char *)v4 + v18 + 24 != *v29)
            {
              free(*v29);
              v28 = (_QWORD *)*(v24 - 14);
            }
            *v29 = v28;
            *((_QWORD *)v30 + 2) = *((_QWORD *)v30 - 13);
            *(v24 - 14) = v24 - 12;
            *((_DWORD *)v30 - 25) = 0;
            *((_DWORD *)v25 - 26) = 0;
            v31 = (char *)v4 + v18;
            v32 = *(_DWORD *)((char *)v4 + v18 - 40);
            if (!v32)
            {
LABEL_65:
              *((_DWORD *)v31 + 20) = 0;
              v36 = (char *)v4 + v18;
              v37 = *(_DWORD *)((char *)v4 + v18 - 24);
              if (v37)
                goto LABEL_66;
              goto LABEL_44;
            }
LABEL_51:
            v33 = (char *)*((_QWORD *)v31 + 9);
            if (v31 + 88 != v33)
            {
              free(v33);
              v32 = *((_DWORD *)v31 - 10);
            }
            v34 = (char *)v4 + v18;
            *((_QWORD *)v31 + 9) = *((_QWORD *)v31 - 6);
            v35 = *(_DWORD *)((char *)v4 + v18 - 36);
            *((_DWORD *)v34 + 20) = v32;
            *((_DWORD *)v34 + 21) = v35;
            *((_QWORD *)v31 - 6) = (char *)v4 + v18 - 32;
            *((_DWORD *)v34 - 9) = 0;
            *((_DWORD *)v25 - 10) = 0;
            v36 = (char *)v4 + v18;
            v37 = *(_DWORD *)((char *)v4 + v18 - 24);
            if (v37)
            {
LABEL_66:
              v43 = (char *)*((_QWORD *)v36 + 11);
              if (v36 + 104 != v43)
              {
                free(v43);
                v37 = *((_DWORD *)v36 - 6);
              }
              v26 = v25 - 3;
              v44 = (char *)v4 + v18;
              *((_QWORD *)v36 + 11) = *((_QWORD *)v36 - 4);
              v45 = *(_DWORD *)((char *)v4 + v18 - 20);
              *((_DWORD *)v44 + 24) = v37;
              *((_DWORD *)v44 + 25) = v45;
              *((_QWORD *)v36 - 4) = (char *)v4 + v18 - 16;
              *((_DWORD *)v44 - 5) = 0;
              goto LABEL_45;
            }
LABEL_44:
            v26 = v36 + 96;
LABEL_45:
            v25 -= 15;
            *v26 = 0;
            v27 = (char *)v4 + v18;
            *((_QWORD *)v27 + 13) = *(_QWORD *)((char *)v4 + v18 - 16);
            *((_WORD *)v27 + 56) = *((_WORD *)v24 - 4);
            v18 -= 120;
            if (!v18)
            {
              v24 = v4;
              goto LABEL_78;
            }
          }
          v38 = (char *)v4 + v18;
          v39 = (_DWORD *)((char *)v4 + v18 - 104);
          v40 = *v39;
          v41 = *(unsigned int *)((char *)v4 + v18 + 16);
          if (v41 >= v40)
          {
            if ((_DWORD)v40)
              memmove(*v29, v28, 8 * v40);
          }
          else
          {
            if (*((_DWORD *)v38 + 5) < v40)
            {
              *((_DWORD *)v38 + 4) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v24 + 1), (char *)v4 + v18 + 24, v40, 8);
              v41 = 0;
              v42 = *v39;
              if (!*v39)
                goto LABEL_64;
              goto LABEL_63;
            }
            if ((_DWORD)v41)
            {
              memmove(*v29, v28, 8 * v41);
              v42 = *v39;
              if (v41 == v42)
                goto LABEL_64;
              goto LABEL_63;
            }
            v41 = 0;
            v42 = *v39;
            if (*v39)
LABEL_63:
              memcpy((char *)*v29 + 8 * v41, (const void *)(*(v24 - 14) + 8 * v41), 8 * v42 - 8 * v41);
          }
LABEL_64:
          *((_DWORD *)v38 + 4) = v40;
          v7 = v73;
          *v39 = 0;
          v31 = (char *)v4 + v18;
          v32 = *(_DWORD *)((char *)v4 + v18 - 40);
          if (!v32)
            goto LABEL_65;
          goto LABEL_51;
        }
      }
    }
  }
  return result;
}

void std::__inplace_merge<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t i;
  uint64_t v34;
  uint64_t v35;
  _BOOL4 v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;

  if (!a5)
    return;
  v7 = a5;
  while (v7 > a7 && a4 > a7)
  {
    if (!a4)
      return;
    v11 = 0;
    v12 = -a4;
    while (1)
    {
      v13 = a1 + v11;
      if (*(unsigned __int16 *)(a1 + v11 + 112) < *(unsigned __int16 *)(a2 + 112))
        break;
      v11 += 120;
      if (__CFADD__(v12++, 1))
        return;
    }
    v15 = -v12;
    v80 = a3;
    if (-v12 >= v7)
    {
      if (v12 == -1)
      {
        std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(a1 + v11, a2);
        return;
      }
      if (v12 > 0)
        v15 = 1 - v12;
      v26 = v15 >> 1;
      v21 = a1 + 120 * (v15 >> 1) + v11;
      if (a3 == a2)
      {
        v18 = a3;
      }
      else
      {
        v27 = 0xEEEEEEEEEEEEEEEFLL * ((a3 - a2) >> 3);
        v18 = a2;
        do
        {
          v28 = v27 >> 1;
          v29 = v18 + 120 * (v27 >> 1);
          v30 = *(unsigned __int16 *)(v29 + 112);
          v31 = v29 + 120;
          v27 += ~(v27 >> 1);
          if (v30 > *(unsigned __int16 *)(v21 + 112))
            v18 = v31;
          else
            v27 = v28;
        }
        while (v27);
      }
      v17 = 0xEEEEEEEEEEEEEEEFLL * ((v18 - a2) >> 3);
      v32 = v18;
      if (v21 != a2)
      {
LABEL_37:
        v32 = v21;
        if (a2 != v18)
        {
          v77 = v26;
          v78 = v17;
          v79 = a7;
          std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(v21, a2);
          v32 = v21 + 120;
          for (i = a2 + 120; i != v18; i += 120)
          {
            if (v32 == a2)
              a2 = i;
            std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(v32, i);
            v32 += 120;
          }
          if (v32 != a2)
          {
            v34 = v32;
            v35 = a2;
            while (1)
            {
              std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(v34, a2);
              a2 += 120;
              v36 = v34 + 120 == v35;
              if (a2 == v18)
              {
                if (v34 + 120 == v35)
                  goto LABEL_56;
                a2 = v35 + 120;
                v34 += 240;
                while (1)
                {
                  std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(v34 - 120, v35);
                  v36 = v34 == v35;
                  if (a2 != v18)
                    break;
                  v37 = v34 == v35;
                  v34 += 120;
                  if (v37)
                    goto LABEL_56;
                }
              }
              else
              {
                v34 += 120;
              }
              if (v36)
                v35 = a2;
            }
          }
          v32 = a2;
LABEL_56:
          v17 = v78;
          a7 = v79;
          v26 = v77;
        }
      }
    }
    else
    {
      if (v7 >= 0)
        v16 = v7;
      else
        v16 = v7 + 1;
      v17 = v16 >> 1;
      v18 = a2 + 120 * (v16 >> 1);
      if (v13 == a2)
      {
        v19 = a1 + v11;
        v21 = a2;
      }
      else
      {
        v19 = a1 + v11;
        v20 = 0xEEEEEEEEEEEEEEEFLL * ((a2 - a1 - v11) >> 3);
        v21 = v13;
        do
        {
          v22 = v20 >> 1;
          v23 = v21 + 120 * (v20 >> 1);
          v24 = *(unsigned __int16 *)(v23 + 112);
          v25 = v23 + 120;
          v20 += ~(v20 >> 1);
          if (v24 < *(unsigned __int16 *)(v18 + 112))
            v20 = v22;
          else
            v21 = v25;
        }
        while (v20);
      }
      v26 = 0xEEEEEEEEEEEEEEEFLL * ((v21 - v19) >> 3);
      v32 = v18;
      if (v21 != a2)
        goto LABEL_37;
    }
    a4 = -(v26 + v12);
    v38 = v7 - v17;
    if (v26 + v17 >= v7 - (v26 + v17) - v12)
    {
      v40 = v26;
      v41 = -(v26 + v12);
      v42 = v17;
      v43 = a7;
      std::__inplace_merge<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(v32, v18, v80, v41, v38, a6);
      a7 = v43;
      v44 = v21;
      a4 = v40;
      a3 = v32;
      v7 = v42;
      a1 = v13;
      a2 = v44;
      if (!v7)
        return;
    }
    else
    {
      v39 = a7;
      std::__inplace_merge<std::_ClassicAlgPolicy,mlir::detail::PDLByteCode::match(mlir::Operation *,mlir::PatternRewriter &,llvm::SmallVectorImpl<mlir::detail::PDLByteCode::MatchResult> &,mlir::detail::PDLByteCodeMutableState &)::$_0 &,mlir::detail::PDLByteCode::MatchResult*>(v13, v21, v32, v26, v17, a6);
      a7 = v39;
      a3 = v80;
      v7 = v38;
      a1 = v32;
      a2 = v18;
      if (!v38)
        return;
    }
  }
  if (a4 <= v7)
  {
    if (a1 == a2)
      return;
    v55 = a3;
    v56 = 0;
    v47 = 0;
    v48 = a6;
    do
    {
      v58 = a1 + v56;
      v59 = (_QWORD *)(a6 + v56);
      *v59 = *(_QWORD *)(a1 + v56);
      *(_QWORD *)(a6 + v56 + 8) = a6 + v56 + 24;
      v59[2] = 0x600000000;
      if (*(_DWORD *)(a1 + v56 + 16))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(a6 + v56 + 8, v58 + 8);
      v60 = v59 + 11;
      v59[9] = v59 + 11;
      v59[10] = 0;
      v61 = (uint64_t)(v59 + 9);
      if (*(_DWORD *)(v58 + 80))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=(v61, a1 + v56 + 72);
      v62 = (_QWORD *)(a6 + v56 + 104);
      *v60 = v62;
      *(_QWORD *)(a6 + v56 + 96) = 0;
      if (*(_DWORD *)(v58 + 96))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v60, a1 + v56 + 88);
      v57 = *(_QWORD *)(v58 + 104);
      *(_WORD *)(a6 + v56 + 112) = *(_WORD *)(v58 + 112);
      *v62 = v57;
      ++v47;
      v56 += 120;
    }
    while (v58 + 120 != a2);
    if (v56)
    {
      v68 = a6 + v56;
      v69 = a6;
      while (a2 != v55)
      {
        if (*(unsigned __int16 *)(v69 + 112) >= *(unsigned __int16 *)(a2 + 112))
        {
          mlir::detail::PDLByteCode::MatchResult::operator=(a1, v69);
          v69 += 120;
          a1 += 120;
          if (v68 == v69)
            goto LABEL_105;
        }
        else
        {
          mlir::detail::PDLByteCode::MatchResult::operator=(a1, a2);
          a2 += 120;
          a1 += 120;
          if (v68 == v69)
            goto LABEL_105;
        }
      }
      v72 = 0;
      do
      {
        mlir::detail::PDLByteCode::MatchResult::operator=(a1 + v72, v69 + v72);
        v72 += 120;
      }
      while (v68 - 120 != v69 + v72 - 120);
    }
  }
  else
  {
    if (a2 == a3)
      return;
    v45 = a3;
    v46 = 0;
    v47 = 0;
    v48 = a6;
    do
    {
      v50 = (_QWORD *)(a6 + v46);
      v51 = a2 + v46;
      *v50 = *(_QWORD *)(a2 + v46);
      *(_QWORD *)(a6 + v46 + 8) = a6 + v46 + 24;
      v50[2] = 0x600000000;
      if (*(_DWORD *)(a2 + v46 + 16))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(a6 + v46 + 8, v51 + 8);
      v52 = v50 + 11;
      v50[9] = v50 + 11;
      v50[10] = 0;
      v53 = (uint64_t)(v50 + 9);
      if (*(_DWORD *)(v51 + 80))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=(v53, a2 + v46 + 72);
      v54 = (_QWORD *)(a6 + v46 + 104);
      *v52 = v54;
      *(_QWORD *)(a6 + v46 + 96) = 0;
      if (*(_DWORD *)(v51 + 96))
        llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v52, a2 + v46 + 88);
      v49 = *(_QWORD *)(v51 + 104);
      *(_WORD *)(a6 + v46 + 112) = *(_WORD *)(v51 + 112);
      *v54 = v49;
      ++v47;
      v46 += 120;
    }
    while (v51 + 120 != v45);
    if (v46)
    {
      v63 = a6 + v46;
      v64 = v45 - 120;
      while (a2 != a1)
      {
        v65 = *(unsigned __int16 *)(a2 - 8);
        v66 = *(unsigned __int16 *)(v63 - 8);
        if (v65 >= v66)
          v67 = v63 - 120;
        else
          v67 = a2 - 120;
        if (v65 >= v66)
          v63 -= 120;
        else
          a2 -= 120;
        mlir::detail::PDLByteCode::MatchResult::operator=(v64, v67);
        v64 -= 120;
        if (v63 == a6)
          goto LABEL_105;
      }
      v70 = 0;
      do
      {
        v71 = v64 + v70;
        v70 -= 120;
        mlir::detail::PDLByteCode::MatchResult::operator=(v71, v63 + v70);
      }
      while (v63 + v70 != a6);
    }
  }
LABEL_105:
  if (v48 && v47)
  {
    v73 = (_QWORD *)(a6 + 104);
    do
    {
      v74 = (_QWORD *)*(v73 - 2);
      if (v73 != v74)
        free(v74);
      v75 = (char *)*(v73 - 4);
      if (v73 - 2 != (_QWORD *)v75)
        free(v75);
      v76 = (char *)*(v73 - 12);
      if (v73 - 10 != (_QWORD *)v76)
        free(v76);
      v73 += 15;
      --v47;
    }
    while (v47);
  }
}

void std::swap[abi:nn180100]<mlir::detail::PDLByteCode::MatchResult>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5[2];
  _BYTE v6[48];
  void *v7[2];
  void *v8[2];
  uint64_t v9;
  __int16 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)a1;
  v5[0] = v6;
  v5[1] = (void *)0x600000000;
  if (*(_DWORD *)(a1 + 16))
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v5, a1 + 8);
  v7[0] = v8;
  v7[1] = 0;
  if (*(_DWORD *)(a1 + 80))
    llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v7, a1 + 72);
  v8[0] = &v9;
  v8[1] = 0;
  if (*(_DWORD *)(a1 + 96))
    llvm::SmallVectorImpl<llvm::SMRange>::operator=((uint64_t)v8, a1 + 88);
  v9 = *(_QWORD *)(a1 + 104);
  v10 = *(_WORD *)(a1 + 112);
  mlir::detail::PDLByteCode::MatchResult::operator=(a1, a2);
  mlir::detail::PDLByteCode::MatchResult::operator=(a2, (uint64_t)&v4);
  if (v8[0] != &v9)
    free(v8[0]);
  if (v7[0] != v8)
    free(v7[0]);
  if (v5[0] != v6)
    free(v5[0]);
}

uint64_t mlir::detail::PDLByteCode::MatchResult::operator=(uint64_t a1, uint64_t a2)
{
  int v4;
  int *v5;
  void *v6;
  int v7;
  int v8;
  int *v9;
  void *v10;
  int v11;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  llvm::SmallVectorImpl<llvm::SMLoc>::operator=(a1 + 8, a2 + 8);
  if (a1 != a2)
  {
    v5 = (int *)(a2 + 80);
    v4 = *(_DWORD *)(a2 + 80);
    if (v4)
    {
      v6 = *(void **)(a1 + 72);
      if (v6 != (void *)(a1 + 88))
      {
        free(v6);
        v4 = *v5;
      }
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
      v7 = *(_DWORD *)(a2 + 84);
      *(_DWORD *)(a1 + 80) = v4;
      *(_DWORD *)(a1 + 84) = v7;
      *(_QWORD *)(a2 + 72) = a2 + 88;
      *(_DWORD *)(a2 + 84) = 0;
      *v5 = 0;
      v9 = (int *)(a2 + 96);
      v8 = *(_DWORD *)(a2 + 96);
      if (v8)
        goto LABEL_6;
    }
    else
    {
      *(_DWORD *)(a1 + 80) = 0;
      v9 = (int *)(a2 + 96);
      v8 = *(_DWORD *)(a2 + 96);
      if (v8)
      {
LABEL_6:
        v10 = *(void **)(a1 + 88);
        if (v10 != (void *)(a1 + 104))
        {
          free(v10);
          v8 = *v9;
        }
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v11 = *(_DWORD *)(a2 + 100);
        *(_DWORD *)(a1 + 96) = v8;
        *(_DWORD *)(a1 + 100) = v11;
        *(_QWORD *)(a2 + 88) = a2 + 104;
        *(_DWORD *)(a2 + 100) = 0;
        goto LABEL_11;
      }
    }
    v9 = (int *)(a1 + 96);
LABEL_11:
    *v9 = 0;
  }
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_WORD *)(a1 + 112) = *(_WORD *)(a2 + 112);
  return a1;
}

void mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, void **a5, uint64_t a6)
{
  char *v12;
  uint64_t v13;
  unint64_t v14;
  void *v15;
  BOOL v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  void *v20;
  BOOL v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  __int128 *v27;
  uint64_t v28;
  __int128 v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _OWORD *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  _DWORD *v38;
  unsigned int v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  int v44;
  BOOL v45;
  int v46;
  uint64_t *v47;
  unsigned int (*v48)(uint64_t, _QWORD);
  uint64_t v49;
  unint64_t v50;
  uint64_t *v51;
  _QWORD *v52;
  uint64_t *v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  uint64_t *v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t *v64;
  uint64_t v65;
  _QWORD *v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  char *v71;
  uint64_t *v72;
  uint64_t v73;
  __int128 v74;
  uint64_t v75;
  int v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  int v81;
  BOOL v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  llvm *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  __n128 v91;
  uint64_t v92;
  uint64_t v93;
  ZinIrHalH13g *v94;
  ZinIrHalH13g *v95;
  ZinIrHalH13g *v96;
  mlir::ForwardIterator *v97;
  void *v98;
  void *v99;
  void *v100;
  uint64_t v101;
  uint64_t v102;
  ZinIrHalH13g *v103;
  ZinIrHalH13g *v104;
  ZinIrHalH13g *v105;
  mlir::ForwardIterator *v106;
  uint64_t v107;
  uint64_t *v108;
  void *v109;
  void *v110;
  mlir::detail::PDLByteCode *v111;
  llvm *v112[2];
  int v113;
  uint64_t v114;
  void **v115[2];
  void *__p;
  void *v117;
  uint64_t v118;
  llvm *v119;
  uint64_t v120;
  unsigned int v121;
  llvm *v122;
  uint64_t v123;
  int v124;
  void *v125[2];
  _QWORD v126[16];

  v126[14] = *MEMORY[0x24BDAC8D0];
  v12 = (char *)operator new(0x68uLL);
  *((_QWORD *)v12 + 2) = 0;
  *(_QWORD *)v12 = &unk_24C05C790;
  *((_QWORD *)v12 + 1) = 0;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 72) = 0u;
  *(_OWORD *)(v12 + 88) = 0u;
  *(_QWORD *)(a1 + 8) = v12;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_QWORD *)a1 = v12 + 24;
  v122 = 0;
  v123 = 0;
  v124 = 0;
  v119 = 0;
  v120 = 0;
  v121 = 0;
  if (a4)
  {
    v13 = 24 * a4;
    do
    {
      LODWORD(v14) = *((char *)a3 + 23);
      v15 = *a3;
      v16 = (v14 & 0x80000000) != 0;
      if ((v14 & 0x80000000) == 0)
        v15 = a3;
      v125[0] = v15;
      v14 = v14;
      if (v16)
        v14 = (unint64_t)a3[1];
      v125[1] = (void *)v14;
      __p = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)&v122, (uint64_t)v125, &__p) & 1) == 0)
      {
        v17 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::InsertIntoBucketImpl<llvm::StringRef>((uint64_t)&v122, (uint64_t)v125, (uint64_t)v125, __p);
        *(_OWORD *)v17 = *(_OWORD *)v125;
      }
      a3 += 3;
      v13 -= 24;
    }
    while (v13);
  }
  if (a6)
  {
    v18 = 24 * a6;
    do
    {
      LODWORD(v19) = *((char *)a5 + 23);
      v20 = *a5;
      v21 = (v19 & 0x80000000) != 0;
      if ((v19 & 0x80000000) == 0)
        v20 = a5;
      v125[0] = v20;
      v19 = v19;
      if (v21)
        v19 = (unint64_t)a5[1];
      v125[1] = (void *)v19;
      __p = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)&v119, (uint64_t)v125, &__p) & 1) == 0)
      {
        v22 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::InsertIntoBucketImpl<llvm::StringRef>((uint64_t)&v119, (uint64_t)v125, (uint64_t)v125, __p);
        *(_OWORD *)v22 = *(_OWORD *)v125;
      }
      a5 += 3;
      v18 -= 24;
    }
    while (v18);
  }
  __p = 0;
  v117 = 0;
  v118 = 0;
  v115[0] = &__p;
  v115[1] = (void **)a1;
  v23 = *(uint64_t **)(a2 + 8);
  v24 = *(uint64_t **)(a2 + 16);
  v107 = a2;
  if (v23 == v24)
  {
LABEL_108:
    v85 = v107;
    v86 = *(_QWORD *)(v107 + 32);
    v114 = v86;
    if (v86)
    {
      v112[0] = *(llvm **)(v107 + 104);
      v87 = *(llvm **)(v107 + 112);
      *(_QWORD *)(v107 + 104) = 0;
      *(_QWORD *)(v107 + 112) = 0;
      v113 = *(_DWORD *)(v107 + 120);
      *(_DWORD *)(v107 + 120) = 0;
      v88 = v86 + 64;
      v90 = *(unsigned int *)(v86 + 40);
      v89 = *(unsigned int *)(v86 + 44);
      v112[1] = v87;
      v91.n128_f64[0] = mlir::Region::getOps<mlir::pdl::PatternOp>((mlir::Region *)(((v86 + 64 + 16 * ((v89 >> 23) & 1) + ((v89 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * v90), (uint64_t)v125);
      if (v126[0] != v126[8])
      {
        v92 = *(_QWORD *)(((v88
                          + 16 * (((unint64_t)*(unsigned int *)(v86 + 44) >> 23) & 1)
                          + (((unint64_t)*(unsigned int *)(v86 + 44) >> 21) & 0x7F8)
                          + 7) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * *(unsigned int *)(v86 + 40)
                        + 8);
        if (v92)
          v93 = v92 - 8;
        else
          v93 = 0;
        v94 = (ZinIrHalH13g *)(v93 + 32);
        v95 = *(ZinIrHalH13g **)(v93 + 40);
        if (v95 != (ZinIrHalH13g *)(v93 + 32))
        {
          do
          {
            v96 = (ZinIrHalH13g *)*((_QWORD *)v95 + 1);
            ZinIrHalH13g::~ZinIrHalH13g(v95);
            mlir::detail::walk<mlir::ForwardIterator>(v97, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<convertPDLToPDLInterp(mlir::ModuleOp,llvm::DenseMap<mlir::Operation *,mlir::PDLPatternConfigSet *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::PDLPatternConfigSet *>> &)::$_0>, (uint64_t)&v111, 1);
            v95 = v96;
          }
          while (v96 != v94);
        }
        mlir::PassManager::PassManager(v125, *(_QWORD *)(v86 + 48), 1, v91);
        mlir::PassManager::enableVerifier((uint64_t)v125, 0);
        mlir::createPDLToPDLInterpPass((uint64_t)v112, (uint64_t *)&v109);
        v98 = v109;
        v109 = 0;
        v110 = v98;
        mlir::OpPassManager::addPass((_BYTE **)v125, (uint64_t *)&v110);
        v99 = v110;
        v110 = 0;
        if (v99)
          (*(void (**)(void *))(*(_QWORD *)v99 + 8))(v99);
        v100 = v109;
        v109 = 0;
        if (v100)
          (*(void (**)(void *))(*(_QWORD *)v100 + 8))(v100);
        if (!mlir::PassManager::run((mlir::PassManager *)v125, (mlir::Operation *)v86))
        {
          mlir::PassManager::~PassManager((mlir::PassManager *)v125);
          llvm::report_fatal_error((llvm *)"failed to lower PDL pattern module to the PDL Interpreter", (const char *)1);
        }
        v101 = *(_QWORD *)(((v88
                           + 16 * (((unint64_t)*(unsigned int *)(v86 + 44) >> 23) & 1)
                           + (((unint64_t)*(unsigned int *)(v86 + 44) >> 21) & 0x7F8)
                           + 7) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(v86 + 40)
                         + 8);
        if (v101)
          v102 = v101 - 8;
        else
          v102 = 0;
        v103 = (ZinIrHalH13g *)(v102 + 32);
        v104 = *(ZinIrHalH13g **)(v102 + 40);
        if (v104 != (ZinIrHalH13g *)(v102 + 32))
        {
          do
          {
            v105 = (ZinIrHalH13g *)*((_QWORD *)v104 + 1);
            ZinIrHalH13g::~ZinIrHalH13g(v104);
            mlir::detail::walk<mlir::ForwardIterator>(v106, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<convertPDLToPDLInterp(mlir::ModuleOp,llvm::DenseMap<mlir::Operation *,mlir::PDLPatternConfigSet *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::PDLPatternConfigSet *>> &)::$_0>, (uint64_t)&v111, 1);
            v104 = v105;
          }
          while (v105 != v103);
        }
        mlir::PassManager::~PassManager((mlir::PassManager *)v125);
        v85 = v107;
      }
      v125[0] = v126;
      v125[1] = (void *)0x600000000;
      if (*(_DWORD *)(v85 + 48))
        llvm::SmallVectorImpl<std::unique_ptr<mlir::PDLPatternConfigSet>>::operator=((uint64_t)v125, v85 + 40);
      llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)&v110, (uint64_t *)(v85 + 128));
      llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)&v109, (uint64_t *)(v85 + 152));
      std::make_unique[abi:nn180100]<mlir::detail::PDLByteCode,mlir::ModuleOp &,llvm::SmallVector<std::unique_ptr<mlir::PDLPatternConfigSet>,6u>,llvm::DenseMap<mlir::Operation *,mlir::PDLPatternConfigSet*,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::PDLPatternConfigSet*>> &,llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>,llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,mlir::PDLResultList &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>>(&v114, (uint64_t)v125, (uint64_t)v112, (uint64_t)&v110, (uint64_t)&v109);
    }
    if (__p)
    {
      v117 = __p;
      operator delete(__p);
    }
    llvm::deallocate_buffer(v119, (void *)(16 * v121));
  }
  v108 = *(uint64_t **)(a2 + 16);
  while (1)
  {
    if ((_DWORD)v120)
    {
      *(_OWORD *)v125 = *(_OWORD *)(*v23 + 64);
      v112[0] = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)&v119, (uint64_t)v125, v112) & 1) == 0)
      {
        v26 = *(unsigned int *)(*v23 + 88);
        if (!(_DWORD)v26)
          goto LABEL_22;
        v27 = *(__int128 **)(*v23 + 80);
        v28 = 16 * v26 - 16;
        do
        {
          v29 = *v27++;
          *(_OWORD *)v125 = v29;
          v112[0] = 0;
          v30 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)&v119, (uint64_t)v125, v112);
          if ((v30 & 1) != 0)
            break;
          v31 = v28;
          v28 -= 16;
        }
        while (v31);
        if (!v30)
          goto LABEL_22;
      }
    }
    v32 = *v23;
    if ((_DWORD)v123)
    {
      *(_OWORD *)v125 = *(_OWORD *)(v32 + 64);
      v112[0] = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)&v122, (uint64_t)v125, v112) & 1) != 0)goto LABEL_22;
      v32 = *v23;
      v33 = *(unsigned int *)(*v23 + 88);
      if ((_DWORD)v33)
      {
        v34 = *(_OWORD **)(v32 + 80);
        v35 = 16 * v33;
        do
        {
          *(_OWORD *)v125 = *v34;
          v112[0] = 0;
          if ((llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)&v122, (uint64_t)v125, v112) & 1) != 0)goto LABEL_22;
          ++v34;
          v35 -= 16;
        }
        while (v35);
        v32 = *v23;
      }
    }
    v36 = *(_DWORD *)(v32 + 16);
    if (v36 == 1)
      break;
    if (v36 == 2)
    {
      v125[0] = *(void **)(v32 + 8);
      v125[1] = (void *)1;
      v112[0] = (llvm *)v125;
      v47 = v23;
      v48 = (unsigned int (*)(uint64_t, _QWORD))llvm::function_ref<BOOL ()(mlir::RegisteredOperationName)>::callback_fn<mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(mlir::RewritePatternSet &&,llvm::ArrayRef<std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>>,std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>)::$_3>;
    }
    else
    {
      if (*(_DWORD *)(*v23 + 16) != 3)
      {
        v63 = *(_QWORD **)a1;
        v64 = *(uint64_t **)(*(_QWORD *)a1 + 56);
        if ((unint64_t)v64 >= *(_QWORD *)(*(_QWORD *)a1 + 64))
        {
          v66 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(v63 + 6, v23);
        }
        else
        {
          v65 = *v23;
          *v23 = 0;
          *v64 = v65;
          v66 = v64 + 1;
        }
        v63[7] = v66;
        goto LABEL_22;
      }
      v125[0] = *(void **)(*v23 + 8);
      v125[1] = (void *)1;
      v112[0] = (llvm *)v125;
      v47 = v23;
      v48 = (unsigned int (*)(uint64_t, _QWORD))llvm::function_ref<BOOL ()(mlir::RegisteredOperationName)>::callback_fn<mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(mlir::RewritePatternSet &&,llvm::ArrayRef<std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>>,std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>)::$_4>;
    }
    mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(mlir::RewritePatternSet &&,llvm::ArrayRef<std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>>,std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>)::$_0::operator()(v115, v47, v48, (uint64_t)v112);
LABEL_22:
    if (++v23 == v24)
      goto LABEL_108;
  }
  v37 = *(_QWORD *)(v32 + 8);
  v38 = *(_DWORD **)a1;
  v39 = *(_DWORD *)(*(_QWORD *)a1 + 16);
  if (!v39)
    goto LABEL_91;
  v40 = ((v37 >> 4) ^ (v37 >> 9)) & (v39 - 1);
  v41 = (_QWORD *)(*(_QWORD *)v38 + 32 * v40);
  v42 = *v41;
  if (v37 == *v41)
    goto LABEL_59;
  v43 = 0;
  v44 = 1;
  while (v42 != -4096)
  {
    if (v43)
      v45 = 0;
    else
      v45 = v42 == -8192;
    if (v45)
      v43 = v41;
    v46 = v40 + v44++;
    v40 = v46 & (v39 - 1);
    v41 = (_QWORD *)(*(_QWORD *)v38 + 32 * v40);
    v42 = *v41;
    if (v37 == *v41)
      goto LABEL_59;
  }
  if (v43)
    v41 = v43;
  v76 = v38[2];
  if (4 * v76 + 4 < 3 * v39)
  {
    if (v39 + ~v76 - v38[3] > v39 >> 3)
    {
      v49 = *v41;
      ++v38[2];
      if (v49 == -4096)
      {
LABEL_58:
        *v41 = v37;
        v41[1] = 0;
        v41[2] = 0;
        v41[3] = 0;
        v32 = *v23;
LABEL_59:
        v51 = (uint64_t *)v41[2];
        v50 = v41[3];
        if ((unint64_t)v51 < v50)
        {
          *v51 = v32;
          v41[2] = v51 + 1;
          v52 = *(_QWORD **)a1;
          v53 = *(uint64_t **)(*(_QWORD *)a1 + 32);
          if ((unint64_t)v53 >= *(_QWORD *)(*(_QWORD *)a1 + 40))
            goto LABEL_85;
LABEL_21:
          v25 = *v23;
          *v23 = 0;
          *v53 = v25;
          v52[4] = v53 + 1;
          goto LABEL_22;
        }
        v54 = a1;
        v55 = (char *)v41[1];
        v56 = ((char *)v51 - v55) >> 3;
        v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 61)
          abort();
        v58 = v50 - (_QWORD)v55;
        if (v58 >> 2 > v57)
          v57 = v58 >> 2;
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8)
          v59 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v59 = v57;
        if (v59)
        {
          if (v59 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v60 = (char *)operator new(8 * v59);
          v61 = (uint64_t *)&v60[8 * v56];
          *v61 = v32;
          v62 = (uint64_t)(v61 + 1);
          if (v51 == (uint64_t *)v55)
          {
LABEL_82:
            v41[1] = v61;
            v41[2] = v62;
            v41[3] = &v60[8 * v59];
            a1 = v54;
            if (v51)
              operator delete(v51);
            v24 = v108;
            v41[2] = v62;
            v52 = *(_QWORD **)a1;
            v53 = *(uint64_t **)(*(_QWORD *)a1 + 32);
            if ((unint64_t)v53 >= *(_QWORD *)(*(_QWORD *)a1 + 40))
            {
LABEL_85:
              v52[4] = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(v52 + 3, v23);
              goto LABEL_22;
            }
            goto LABEL_21;
          }
        }
        else
        {
          v60 = 0;
          v61 = (uint64_t *)(8 * v56);
          *(_QWORD *)(8 * v56) = v32;
          v62 = 8 * v56 + 8;
          if (v51 == (uint64_t *)v55)
            goto LABEL_82;
        }
        v67 = (char *)(v51 - 1) - v55;
        if (v67 < 0x58)
          goto LABEL_137;
        if ((unint64_t)(v55 - v60) < 0x20)
          goto LABEL_137;
        v68 = (v67 >> 3) + 1;
        v69 = 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
        v70 = &v51[v69 / 0xFFFFFFFFFFFFFFF8];
        v61 = (uint64_t *)((char *)v61 - v69);
        v71 = &v60[8 * v56 - 16];
        v72 = v51 - 2;
        v73 = v68 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v74 = *(_OWORD *)v72;
          *((_OWORD *)v71 - 1) = *((_OWORD *)v72 - 1);
          *(_OWORD *)v71 = v74;
          v71 -= 32;
          v72 -= 4;
          v73 -= 4;
        }
        while (v73);
        v51 = v70;
        if (v68 != (v68 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_137:
          do
          {
            v75 = *--v51;
            *--v61 = v75;
          }
          while (v51 != (uint64_t *)v55);
        }
        v51 = (uint64_t *)v41[1];
        goto LABEL_82;
      }
LABEL_57:
      --v38[3];
      goto LABEL_58;
    }
  }
  else
  {
LABEL_91:
    v39 *= 2;
  }
  llvm::DenseMap<mlir::OperationName,std::vector<mlir::RewritePattern *>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::vector<mlir::RewritePattern *>>>::grow(*(_QWORD *)a1, v39);
  v77 = v38[4] - 1;
  v78 = v77 & ((v37 >> 4) ^ (v37 >> 9));
  v41 = (_QWORD *)(*(_QWORD *)v38 + 32 * v78);
  v79 = *v41;
  if (v37 == *v41)
  {
LABEL_93:
    ++v38[2];
    if (v37 == -4096)
      goto LABEL_58;
  }
  else
  {
    v80 = 0;
    v81 = 1;
    while (v79 != -4096)
    {
      if (v80)
        v82 = 0;
      else
        v82 = v79 == -8192;
      if (v82)
        v80 = v41;
      v83 = v78 + v81++;
      v78 = v83 & v77;
      v41 = (_QWORD *)(*(_QWORD *)v38 + 32 * v78);
      v79 = *v41;
      if (v37 == *v41)
        goto LABEL_93;
    }
    if (v80)
      v41 = v80;
    v84 = *v41;
    ++v38[2];
    if (v84 == -4096)
      goto LABEL_58;
  }
  goto LABEL_57;
}

_QWORD *mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(mlir::RewritePatternSet &&,llvm::ArrayRef<std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>>,std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>)::$_0::operator()(void ***a1, uint64_t *a2, unsigned int (*a3)(uint64_t, _QWORD), uint64_t a4)
{
  uint64_t v4;
  uint64_t *v6;
  _QWORD *v7;
  _QWORD *v8;
  unsigned int (*v9)(uint64_t, _QWORD);
  uint64_t RegisteredOperations;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  char *v15;
  char *v16;
  void **v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  int v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  int v55;
  BOOL v56;
  int v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  _QWORD *result;
  uint64_t *v63;
  _QWORD *v65;

  v4 = a4;
  v6 = (uint64_t *)a1[1];
  v8 = **a1;
  v7 = (*a1)[1];
  v63 = v6;
  if (v8 != v7)
  {
    v9 = a3;
LABEL_8:
    v65 = v7;
    while (1)
    {
      v20 = *v8;
      if (!v9(v4, *v8))
        goto LABEL_11;
      v21 = *v6;
      v22 = *(_DWORD *)(*v6 + 16);
      if (!v22)
        goto LABEL_55;
      v23 = (v22 - 1) & ((v20 >> 4) ^ (v20 >> 9));
      v24 = (_QWORD *)(*(_QWORD *)v21 + 32 * v23);
      v25 = *v24;
      if (*v24 == v20)
        goto LABEL_30;
      v26 = 0;
      v27 = 1;
      while (v25 != -4096)
      {
        if (v26)
          v28 = 0;
        else
          v28 = v25 == -8192;
        if (v28)
          v26 = v24;
        v29 = v23 + v27++;
        v23 = v29 & (v22 - 1);
        v24 = (_QWORD *)(*(_QWORD *)v21 + 32 * v23);
        v25 = *v24;
        if (*v24 == v20)
          goto LABEL_30;
      }
      if (v26)
        v24 = v26;
      v50 = *(_DWORD *)(v21 + 8);
      if (4 * v50 + 4 < 3 * v22)
      {
        if (v22 + ~v50 - *(_DWORD *)(v21 + 12) > v22 >> 3)
          goto LABEL_26;
      }
      else
      {
LABEL_55:
        v22 *= 2;
      }
      llvm::DenseMap<mlir::OperationName,std::vector<mlir::RewritePattern *>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::vector<mlir::RewritePattern *>>>::grow(*v6, v22);
      v51 = *(_DWORD *)(v21 + 16) - 1;
      v52 = v51 & ((v20 >> 4) ^ (v20 >> 9));
      v24 = (_QWORD *)(*(_QWORD *)v21 + 32 * v52);
      v53 = *v24;
      if (*v24 == v20)
      {
        v30 = v20;
        goto LABEL_27;
      }
      v54 = 0;
      v55 = 1;
      while (v53 != -4096)
      {
        if (v54)
          v56 = 0;
        else
          v56 = v53 == -8192;
        if (v56)
          v54 = v24;
        v57 = v52 + v55++;
        v52 = v57 & v51;
        v24 = (_QWORD *)(*(_QWORD *)v21 + 32 * v52);
        v53 = *v24;
        v30 = v20;
        v4 = a4;
        v6 = v63;
        v9 = a3;
        if (*v24 == v20)
          goto LABEL_27;
      }
      if (v54)
        v24 = v54;
      v4 = a4;
      v6 = v63;
      v9 = a3;
LABEL_26:
      v30 = *v24;
LABEL_27:
      ++*(_DWORD *)(v21 + 8);
      if (v30 != -4096)
        --*(_DWORD *)(v21 + 12);
      *v24 = v20;
      v24[1] = 0;
      v24[2] = 0;
      v24[3] = 0;
LABEL_30:
      v31 = *a2;
      v33 = (uint64_t *)v24[2];
      v32 = v24[3];
      if ((unint64_t)v33 < v32)
      {
        *v33 = v31;
        v19 = (uint64_t)(v33 + 1);
        goto LABEL_10;
      }
      v34 = (char *)v24[1];
      v35 = ((char *)v33 - v34) >> 3;
      v36 = v35 + 1;
      if ((unint64_t)(v35 + 1) >> 61)
        goto LABEL_76;
      v37 = v32 - (_QWORD)v34;
      if (v37 >> 2 > v36)
        v36 = v37 >> 2;
      if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v36;
      if (v38)
      {
        if (v38 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v39 = (char *)operator new(8 * v38);
        v40 = (uint64_t *)&v39[8 * v35];
        *v40 = v31;
        v19 = (uint64_t)(v40 + 1);
        if (v33 == (uint64_t *)v34)
        {
LABEL_43:
          v4 = a4;
          v6 = v63;
          v24[1] = v40;
          v24[2] = v19;
          v24[3] = &v39[8 * v38];
          v9 = a3;
          if (!v33)
            goto LABEL_10;
LABEL_51:
          operator delete(v33);
          goto LABEL_10;
        }
      }
      else
      {
        v39 = 0;
        v40 = (uint64_t *)(8 * v35);
        *(_QWORD *)(8 * v35) = v31;
        v19 = 8 * v35 + 8;
        if (v33 == (uint64_t *)v34)
          goto LABEL_43;
      }
      v41 = (char *)(v33 - 1) - v34;
      if (v41 < 0x58)
      {
        v6 = v63;
        do
        {
LABEL_49:
          v49 = *--v33;
          *--v40 = v49;
        }
        while (v33 != (uint64_t *)v34);
        goto LABEL_50;
      }
      v6 = v63;
      if ((unint64_t)(v34 - v39) < 0x20)
        goto LABEL_49;
      v42 = (v41 >> 3) + 1;
      v43 = 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
      v44 = &v33[v43 / 0xFFFFFFFFFFFFFFF8];
      v40 = (uint64_t *)((char *)v40 - v43);
      v45 = &v39[8 * v35 - 16];
      v46 = v33 - 2;
      v47 = v42 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v48 = *(_OWORD *)v46;
        *((_OWORD *)v45 - 1) = *((_OWORD *)v46 - 1);
        *(_OWORD *)v45 = v48;
        v45 -= 32;
        v46 -= 4;
        v47 -= 4;
      }
      while (v47);
      v33 = v44;
      if (v42 != (v42 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_49;
LABEL_50:
      v33 = (uint64_t *)v24[1];
      v24[1] = v40;
      v24[2] = v19;
      v24[3] = &v39[8 * v38];
      v4 = a4;
      v9 = a3;
      if (v33)
        goto LABEL_51;
LABEL_10:
      v24[2] = v19;
      v7 = v65;
LABEL_11:
      if (++v8 == v7)
        goto LABEL_70;
    }
  }
  RegisteredOperations = mlir::MLIRContext::getRegisteredOperations((mlir::MLIRContext *)(*(_QWORD *)(*a2 + 24) & 0xFFFFFFFFFFFFFFF8));
  if (v12)
  {
    v13 = v12;
    if (v12 < 0)
LABEL_76:
      abort();
    v14 = (const void *)RegisteredOperations;
    v15 = (char *)operator new(8 * v12);
    v16 = &v15[8 * v13];
    memcpy(v15, v14, 8 * v13);
    v4 = a4;
    v6 = v63;
    v17 = *a1;
    v18 = **a1;
    if (v18)
      goto LABEL_6;
  }
  else
  {
    v16 = 0;
    v15 = 0;
    v17 = *a1;
    v18 = **a1;
    if (v18)
    {
LABEL_6:
      v17[1] = v18;
      operator delete(v18);
    }
  }
  *v17 = v15;
  v17[1] = v16;
  v17[2] = v16;
  v8 = **a1;
  v7 = (*a1)[1];
  v9 = a3;
  if (v8 != v7)
    goto LABEL_8;
LABEL_70:
  v58 = *v6;
  v59 = *(uint64_t **)(*v6 + 32);
  if ((unint64_t)v59 >= *(_QWORD *)(*v6 + 40))
  {
    result = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>((_QWORD *)(v58 + 24), a2);
  }
  else
  {
    v60 = *a2;
    *a2 = 0;
    *v59 = v60;
    result = v59 + 1;
  }
  *(_QWORD *)(v58 + 32) = result;
  return result;
}

void std::make_unique[abi:nn180100]<mlir::detail::PDLByteCode,mlir::ModuleOp &,llvm::SmallVector<std::unique_ptr<mlir::PDLPatternConfigSet>,6u>,llvm::DenseMap<mlir::Operation *,mlir::PDLPatternConfigSet*,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::PDLPatternConfigSet*>> &,llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>,llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,mlir::PDLResultList &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  void *v12;
  __int128 v13;
  void *v14;
  __int128 v15;
  void *v16[2];
  _QWORD v17[7];

  v17[6] = *MEMORY[0x24BDAC8D0];
  v10 = operator new();
  v11 = *a1;
  v16[0] = v17;
  v16[1] = (void *)0x600000000;
  if (*(_DWORD *)(a2 + 8))
    llvm::SmallVectorImpl<std::unique_ptr<mlir::PDLPatternConfigSet>>::operator=((uint64_t)v16, a2);
  v14 = *(void **)a4;
  v15 = *(_OWORD *)(a4 + 8);
  *(_DWORD *)(a4 + 16) = 0;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  v12 = *(void **)a5;
  v13 = *(_OWORD *)(a5 + 8);
  *(_DWORD *)(a5 + 16) = 0;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  mlir::detail::PDLByteCode::PDLByteCode(v10, v11, v16, a3, &v14, &v12);
}

void mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet(mlir::FrozenRewritePatternSet *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)*((_QWORD *)this + 1);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  uint64_t v6;
  int HashValue;
  unsigned int v8;
  void *v9;
  size_t v10;
  _QWORD *v11;
  int v12;
  int v13;
  _QWORD *v14;
  const void *v15;
  BOOL v16;
  int v17;
  uint64_t result;
  int v19;
  int v20;
  const void *v21;
  BOOL v22;
  int v23;
  int v24;
  int v25;
  const void *v26;
  int v27;
  int v28;
  BOOL v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  BOOL v34;
  int v35;
  int v36;
  int v37;
  const void *v38;
  BOOL v39;
  int v40;
  void *__s1;

  v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    v14 = 0;
    result = 0;
    goto LABEL_70;
  }
  v6 = *a1;
  HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*(_QWORD **)a2, *(_QWORD *)(a2 + 8));
  v8 = v4 - 1;
  v9 = *(void **)a2;
  v10 = *(_QWORD *)(a2 + 8);
  if (!v10)
  {
    if (v9 == (void *)-2)
    {
      v11 = 0;
      v19 = 1;
      v20 = HashValue & v8;
      v14 = (_QWORD *)(v6 + 16 * (HashValue & v8));
      v21 = (const void *)*v14;
      if (*v14 == -1)
        goto LABEL_21;
LABEL_19:
      if (v21 != (const void *)-2 && v14[1])
      {
LABEL_21:
        while (v21 != (const void *)-1)
        {
          if (v11)
            v22 = 0;
          else
            v22 = v21 == (const void *)-2;
          if (v22)
            v11 = v14;
          v23 = v19 + v20;
          ++v19;
          v20 = v23 & v8;
          v14 = (_QWORD *)(v6 + 16 * (v23 & v8));
          v21 = (const void *)*v14;
          if (*v14 != -1)
            goto LABEL_19;
        }
        goto LABEL_66;
      }
    }
    else
    {
      v11 = 0;
      v31 = 1;
      v32 = HashValue & v8;
      v14 = (_QWORD *)(v6 + 16 * (HashValue & v8));
      v33 = *v14;
      if (*v14 == -2)
        goto LABEL_47;
LABEL_43:
      if (v33 == -1)
      {
        if (v9 != (void *)-1)
        {
LABEL_47:
          while (v33 != -1)
          {
            if (v11)
              v34 = 0;
            else
              v34 = v33 == -2;
            if (v34)
              v11 = v14;
            v35 = v31 + v32;
            ++v31;
            v32 = v35 & v8;
            v14 = (_QWORD *)(v6 + 16 * (v35 & v8));
            v33 = *v14;
            if (*v14 != -2)
              goto LABEL_43;
          }
          goto LABEL_66;
        }
      }
      else if (v14[1])
      {
        goto LABEL_47;
      }
    }
    goto LABEL_69;
  }
  if (v9 != (void *)-2)
  {
    if (v9 != (void *)-1)
    {
      __s1 = v9;
      v11 = 0;
      v36 = 1;
      v37 = HashValue & v8;
      v14 = (_QWORD *)(v6 + 16 * (HashValue & v8));
      v38 = (const void *)*v14;
      if (*v14 <= 0xFFFFFFFFFFFFFFFDLL)
        goto LABEL_63;
      while (v38 != (const void *)-1)
      {
        if (v11)
          v39 = 0;
        else
          v39 = v38 == (const void *)-2;
        if (v39)
          v11 = v14;
        v40 = v36 + v37;
        ++v36;
        v37 = v40 & v8;
        v14 = (_QWORD *)(v6 + 16 * (v40 & v8));
        v38 = (const void *)*v14;
        if (*v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
LABEL_63:
          if (v10 == v14[1] && !memcmp(__s1, v38, v10))
            goto LABEL_69;
        }
      }
      goto LABEL_66;
    }
    v11 = 0;
    v24 = 1;
    v25 = HashValue & v8;
    v14 = (_QWORD *)(v6 + 16 * (HashValue & v8));
    v26 = (const void *)*v14;
    if (*v14 == -2)
      goto LABEL_34;
LABEL_31:
    if (v26 != (const void *)-1)
    {
      if (v10 != v14[1] || (v27 = v24, v28 = memcmp((const void *)0xFFFFFFFFFFFFFFFFLL, v26, v10), v24 = v27, v28))
      {
LABEL_34:
        while (v26 != (const void *)-1)
        {
          if (v11)
            v29 = 0;
          else
            v29 = v26 == (const void *)-2;
          if (v29)
            v11 = v14;
          v30 = v24 + v25;
          ++v24;
          v25 = v30 & v8;
          v14 = (_QWORD *)(v6 + 16 * (v30 & v8));
          v26 = (const void *)*v14;
          if (*v14 != -2)
            goto LABEL_31;
        }
        goto LABEL_66;
      }
    }
LABEL_69:
    result = 1;
    goto LABEL_70;
  }
  v11 = 0;
  v12 = 1;
  v13 = HashValue & v8;
  v14 = (_QWORD *)(v6 + 16 * (HashValue & v8));
  v15 = (const void *)*v14;
  if (*v14 == -1)
    goto LABEL_8;
LABEL_5:
  if (v15 == (const void *)-2 || v10 == v14[1] && !memcmp((const void *)0xFFFFFFFFFFFFFFFELL, v15, v10))
    goto LABEL_69;
LABEL_8:
  while (v15 != (const void *)-1)
  {
    if (v11)
      v16 = 0;
    else
      v16 = v15 == (const void *)-2;
    if (v16)
      v11 = v14;
    v17 = v12 + v13;
    ++v12;
    v13 = v17 & v8;
    v14 = (_QWORD *)(v6 + 16 * (v17 & v8));
    v15 = (const void *)*v14;
    if (*v14 != -1)
      goto LABEL_5;
  }
LABEL_66:
  result = 0;
  if (v11)
    v14 = v11;
LABEL_70:
  *a3 = v14;
  return result;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<convertPDLToPDLInterp(mlir::ModuleOp,llvm::DenseMap<mlir::Operation *,mlir::PDLPatternConfigSet *,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::PDLPatternConfigSet *>> &)::$_0>(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::isOpTriviallyDead((void ***)a2, a2))
    mlir::Operation::erase(a2);
}

llvm::StringMapImpl *llvm::StringMap<std::function<mlir::LogicalResult ()(mlir::PatternRewriter &,llvm::ArrayRef<mlir::PDLValue>)>,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t *v9;
  size_t v11;
  size_t *v12;
  _QWORD *buffer;
  size_t *v14;
  char *v15;
  _QWORD *v16;
  size_t v17;
  uint64_t v19;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0x2800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    v4 = *(_QWORD *)this;
    v5 = *((unsigned int *)this + 2);
    v6 = *a2;
    *(_QWORD *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if ((_DWORD)v5)
    {
      v7 = 0;
      v19 = v4 + 8 * v5 + 8;
      v8 = v6 + 8 * v5 + 8;
      do
      {
        while (1)
        {
          v9 = *(size_t **)(*a2 + 8 * v7);
          if (v9 && v9 + 1 != 0)
            break;
          *(_QWORD *)(*(_QWORD *)this + 8 * v7++) = v9;
          if (v5 == v7)
            return this;
        }
        v12 = v9 + 1;
        v11 = *v9;
        buffer = llvm::allocate_buffer(*v9 + 41, (std::align_val_t)8uLL);
        v14 = buffer;
        v15 = (char *)(buffer + 5);
        if (v11)
          memcpy(buffer + 5, v9 + 5, v11);
        v15[v11] = 0;
        *v14 = v11;
        v16 = v14 + 1;
        v17 = v9[4];
        if (v17)
        {
          if ((size_t *)v17 == v12)
          {
            v14[4] = (size_t)v16;
            (*(void (**)(size_t *))(*v12 + 24))(v9 + 1);
          }
          else
          {
            v14[4] = (*(uint64_t (**)(size_t, _QWORD *))(*(_QWORD *)v17 + 16))(v17, v16);
          }
        }
        else
        {
          v14[4] = 0;
        }
        *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v14;
        *(_DWORD *)(v19 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

void std::__shared_ptr_emplace<mlir::FrozenRewritePatternSet::Impl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C05C790;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::FrozenRewritePatternSet::Impl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C05C790;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_emplace<mlir::FrozenRewritePatternSet::Impl>::__on_zero_shared(uint64_t a1)
{
  mlir::FrozenRewritePatternSet::Impl::~Impl((mlir::FrozenRewritePatternSet::Impl *)(a1 + 24));
}

void mlir::FrozenRewritePatternSet::Impl::~Impl(mlir::FrozenRewritePatternSet::Impl *this)
{
  mlir::detail::PDLByteCode *v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  llvm *v14;
  _QWORD *v15;
  uint64_t v16;
  void *v17;
  void *v18;

  v2 = (mlir::detail::PDLByteCode *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v2)
  {
    mlir::detail::PDLByteCode::~PDLByteCode(v2);
    MEMORY[0x20BD002F8]();
  }
  v3 = (_QWORD *)*((_QWORD *)this + 6);
  if (v3)
  {
    v4 = (_QWORD *)*((_QWORD *)this + 7);
    v5 = (void *)*((_QWORD *)this + 6);
    if (v4 != v3)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 6);
    }
    *((_QWORD *)this + 7) = v3;
    operator delete(v5);
  }
  v8 = (_QWORD *)*((_QWORD *)this + 3);
  if (v8)
  {
    v9 = (_QWORD *)*((_QWORD *)this + 4);
    v10 = (void *)*((_QWORD *)this + 3);
    if (v9 != v8)
    {
      do
      {
        v12 = *--v9;
        v11 = v12;
        *v9 = 0;
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
      }
      while (v9 != v8);
      v10 = (void *)*((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 4) = v8;
    operator delete(v10);
  }
  v13 = *((unsigned int *)this + 4);
  v14 = *(llvm **)this;
  if ((_DWORD)v13)
  {
    v15 = (_QWORD *)((char *)v14 + 16);
    v16 = 32 * v13;
    do
    {
      if ((*(v15 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v17 = (void *)*(v15 - 1);
        if (v17)
        {
          *v15 = v17;
          operator delete(v17);
        }
      }
      v15 += 4;
      v16 -= 32;
    }
    while (v16);
    v14 = *(llvm **)this;
    v18 = (void *)(32 * *((unsigned int *)this + 4));
  }
  else
  {
    v18 = 0;
  }
  llvm::deallocate_buffer(v14, v18);
}

uint64_t sub_20749D7B4()
{
  uint64_t v0;

  return v0;
}

_QWORD *llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::InsertIntoBucketImpl<llvm::StringRef>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_7:
    llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::grow(a1, v7);
    v9 = 0;
    llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)a1, a3, &v9);
    a4 = v9;
    ++*(_DWORD *)(a1 + 8);
    if (*a4 == -1)
      return a4;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    goto LABEL_7;
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1)
LABEL_4:
    --*(_DWORD *)(a1 + 12);
  return a4;
}

_OWORD *llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _OWORD *result;
  _OWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _OWORD *v14;
  uint64_t v15;
  _OWORD *v16;
  void *v17;
  uint64_t v18;
  llvm *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _OWORD *v23;
  uint64_t v24;
  _OWORD *v25;
  _OWORD *v26;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      v12 = (v11 - 1) & 0xFFFFFFFFFFFFFFFLL;
      if (v12 < 3)
        goto LABEL_10;
      v13 = v12 + 1;
      v10 = &result[v13 & 0x1FFFFFFFFFFFFFFCLL];
      v14 = result + 2;
      v15 = v13 & 0x1FFFFFFFFFFFFFFCLL;
      do
      {
        *(v14 - 2) = xmmword_207A9BBE0;
        *(v14 - 1) = xmmword_207A9BBE0;
        *v14 = xmmword_207A9BBE0;
        v14[1] = xmmword_207A9BBE0;
        v14 += 4;
        v15 -= 4;
      }
      while (v15);
      if (v13 != (v13 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_10:
        v16 = &result[v11];
        do
          *v10++ = xmmword_207A9BBE0;
        while (v10 != v16);
      }
    }
    v17 = (void *)(16 * v3);
    if ((_DWORD)v3)
    {
      v18 = 16 * v3;
      v19 = v4;
      do
      {
        if (*(_QWORD *)v19 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v26 = 0;
          llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::LookupBucketFor<llvm::StringRef>((uint64_t *)a1, (uint64_t)v19, &v26);
          *v26 = *(_OWORD *)v19;
          ++*(_DWORD *)(a1 + 8);
        }
        v19 = (llvm *)((char *)v19 + 16);
        v18 -= 16;
      }
      while (v18);
    }
    llvm::deallocate_buffer(v4, v17);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v20 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v20)
  {
    v21 = (v20 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v21 < 3)
      goto LABEL_23;
    v22 = v21 + 1;
    v10 = &result[v22 & 0x1FFFFFFFFFFFFFFCLL];
    v23 = result + 2;
    v24 = v22 & 0x1FFFFFFFFFFFFFFCLL;
    do
    {
      *(v23 - 2) = xmmword_207A9BBE0;
      *(v23 - 1) = xmmword_207A9BBE0;
      *v23 = xmmword_207A9BBE0;
      v23[1] = xmmword_207A9BBE0;
      v23 += 4;
      v24 -= 4;
    }
    while (v24);
    if (v22 != (v22 & 0x1FFFFFFFFFFFFFFCLL))
    {
LABEL_23:
      v25 = &result[v20];
      do
        *v10++ = xmmword_207A9BBE0;
      while (v10 != v25);
    }
  }
  return result;
}

_QWORD *llvm::DenseMap<mlir::OperationName,std::vector<mlir::RewritePattern *>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::vector<mlir::RewritePattern *>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  llvm *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  int v28;
  BOOL v29;
  int v30;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0x7FFFFFFFFFFFFFFLL) == 0)
        goto LABEL_10;
      v12 = ((v11 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
      v10 = &result[4 * (v12 & 0xFFFFFFFFFFFFFFELL)];
      v13 = result + 4;
      v14 = v12 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 4) = -4096;
        *v13 = -4096;
        v13 += 8;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL))
      {
LABEL_10:
        v15 = &result[4 * v11];
        do
        {
          *v10 = -4096;
          v10 += 4;
        }
        while (v10 != v15);
      }
    }
    if ((_DWORD)v3)
    {
      v16 = v4;
      do
      {
        v23 = *(_QWORD *)v16;
        if ((*(_QWORD *)v16 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v24 = *(_DWORD *)(a1 + 16) - 1;
          v25 = v24 & ((v23 >> 4) ^ (v23 >> 9));
          v22 = (_QWORD *)(*(_QWORD *)a1 + 32 * v25);
          v26 = *v22;
          if (v23 != *v22)
          {
            v27 = 0;
            v28 = 1;
            while (v26 != -4096)
            {
              if (v27)
                v29 = 0;
              else
                v29 = v26 == -8192;
              if (v29)
                v27 = v22;
              v30 = v25 + v28++;
              v25 = v30 & v24;
              v22 = (_QWORD *)(*(_QWORD *)a1 + 32 * v25);
              v26 = *v22;
              if (v23 == *v22)
                goto LABEL_24;
            }
            if (v27)
              v22 = v27;
          }
LABEL_24:
          *v22 = v23;
          v22[1] = 0;
          v22[2] = 0;
          v22[3] = 0;
          *(_OWORD *)(v22 + 1) = *(_OWORD *)((char *)v16 + 8);
          v22[3] = *((_QWORD *)v16 + 3);
          *((_QWORD *)v16 + 1) = 0;
          *((_QWORD *)v16 + 2) = 0;
          *((_QWORD *)v16 + 3) = 0;
          ++*(_DWORD *)(a1 + 8);
        }
        v16 = (llvm *)((char *)v16 + 32);
      }
      while (v16 != (llvm *)((char *)v4 + 32 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(32 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v17 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v17)
  {
    if (((v17 - 1) & 0x7FFFFFFFFFFFFFFLL) == 0)
      goto LABEL_19;
    v18 = ((v17 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
    v10 = &result[4 * (v18 & 0xFFFFFFFFFFFFFFELL)];
    v19 = result + 4;
    v20 = v18 & 0xFFFFFFFFFFFFFFELL;
    do
    {
      *(v19 - 4) = -4096;
      *v19 = -4096;
      v19 += 8;
      v20 -= 2;
    }
    while (v20);
    if (v18 != (v18 & 0xFFFFFFFFFFFFFFELL))
    {
LABEL_19:
      v21 = &result[4 * v17];
      do
      {
        *v10 = -4096;
        v10 += 4;
      }
      while (v10 != v21);
    }
  }
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::RegisteredOperationName)>::callback_fn<mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(mlir::RewritePatternSet &&,llvm::ArrayRef<std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>>,std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>)::$_3>(unint64_t **a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t *v7;
  _QWORD *v8;
  unint64_t v9;

  v2 = *(unsigned int *)(a2 + 40);
  if (!(_DWORD)v2)
    return 0;
  v3 = **a1;
  v4 = *(_QWORD **)(a2 + 32);
  v5 = &v4[2 * v2];
  do
  {
    v6 = v2 >> 1;
    v7 = &v4[2 * (v2 >> 1)];
    v9 = *v7;
    v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3)
      v4 = v8;
    else
      v2 = v6;
  }
  while (v2);
  return v4 != v5 && *v4 == v3 && v4[1] != 0;
}

uint64_t llvm::function_ref<BOOL ()(mlir::RegisteredOperationName)>::callback_fn<mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(mlir::RewritePatternSet &&,llvm::ArrayRef<std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>>,std::basic_string<char,llvm::ArrayRef::char_traits<char>,llvm::ArrayRef::allocator<char>>)::$_4>(_QWORD **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 32))(a2, **a1);
}

void mlir::detail::PDLByteCode::~PDLByteCode(mlir::detail::PDLByteCode *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unsigned int v15;
  uint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  void *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char **v26;
  char **v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;

  v2 = *((_QWORD *)this + 470);
  if (v2)
  {
    v3 = *((_QWORD *)this + 471);
    v4 = (void *)*((_QWORD *)this + 470);
    if (v3 == v2)
    {
LABEL_11:
      *((_QWORD *)this + 471) = v2;
      operator delete(v4);
      goto LABEL_12;
    }
    while (1)
    {
      v7 = v3 - 32;
      v5 = *(_QWORD **)(v3 - 8);
      if ((_QWORD *)(v3 - 32) == v5)
      {
        v5 = (_QWORD *)(v3 - 32);
        v6 = 4;
      }
      else
      {
        if (!v5)
          goto LABEL_6;
        v6 = 5;
      }
      (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
      v3 = v7;
      if (v7 == v2)
      {
        v4 = (void *)*((_QWORD *)this + 470);
        goto LABEL_11;
      }
    }
  }
LABEL_12:
  v8 = *((_QWORD *)this + 467);
  if (!v8)
    goto LABEL_23;
  v9 = *((_QWORD *)this + 468);
  v10 = (void *)*((_QWORD *)this + 467);
  if (v9 != v8)
  {
    while (1)
    {
      v13 = v9 - 32;
      v11 = *(_QWORD **)(v9 - 8);
      if ((_QWORD *)(v9 - 32) == v11)
      {
        v11 = (_QWORD *)(v9 - 32);
        v12 = 4;
      }
      else
      {
        if (!v11)
          goto LABEL_17;
        v12 = 5;
      }
      (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_17:
      v9 = v13;
      if (v13 == v8)
      {
        v10 = (void *)*((_QWORD *)this + 467);
        break;
      }
    }
  }
  *((_QWORD *)this + 468) = v8;
  operator delete(v10);
LABEL_23:
  v14 = (char *)*((_QWORD *)this + 49);
  v15 = *((_DWORD *)this + 100);
  if (v15)
  {
    v16 = 104 * v15;
    do
    {
      v17 = &v14[v16];
      v18 = *(char **)&v14[v16 - 32];
      if (&v14[v16 - 16] != v18)
        free(v18);
      v19 = (char *)*((_QWORD *)v17 - 10);
      if (v17 - 64 != v19)
        free(v19);
      v16 -= 104;
    }
    while (v16);
    v14 = (char *)*((_QWORD *)this + 49);
  }
  if (v14 != (char *)this + 408)
    free(v14);
  v20 = (char *)*((_QWORD *)this + 30);
  if (v20 != (char *)this + 264)
    free(v20);
  v21 = (char *)*((_QWORD *)this + 11);
  if (v21 != (char *)this + 112)
    free(v21);
  v22 = (void *)*((_QWORD *)this + 8);
  if (v22)
  {
    *((_QWORD *)this + 9) = v22;
    operator delete(v22);
  }
  v23 = *(char **)this;
  v24 = *((unsigned int *)this + 2);
  if ((_DWORD)v24)
  {
    v25 = &v23[8 * v24];
    do
    {
      v27 = (char **)*((_QWORD *)v25 - 1);
      v25 -= 8;
      v26 = v27;
      *(_QWORD *)v25 = 0;
      if (v27)
      {
        v28 = *v26;
        v29 = *((unsigned int *)v26 + 2);
        if ((_DWORD)v29)
        {
          v30 = 8 * v29;
          v31 = v28 - 8;
          do
          {
            v32 = *(_QWORD *)&v31[v30];
            *(_QWORD *)&v31[v30] = 0;
            if (v32)
              (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
            v30 -= 8;
          }
          while (v30);
          v28 = *v26;
        }
        if (v28 != (char *)(v26 + 2))
          free(v28);
        MEMORY[0x20BD002F8](v26, 0x1080C407559D7D1);
      }
    }
    while (v25 != v23);
    v23 = *(char **)this;
  }
  if (v23 != (char *)this + 16)
    free(v23);
}

mlir::PatternApplicator *mlir::PatternApplicator::PatternApplicator(mlir::PatternApplicator *this, const mlir::FrozenRewritePatternSet *a2)
{
  mlir::detail::PDLByteCode *v3;
  mlir::detail::PDLByteCodeMutableState *v4;
  mlir::detail::PDLByteCodeMutableState *v5;

  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 4) = (char *)this + 48;
  *((_QWORD *)this + 5) = 0x100000000;
  *((_QWORD *)this + 7) = 0;
  v3 = *(mlir::detail::PDLByteCode **)(*(_QWORD *)a2 + 72);
  if (v3)
  {
    v4 = (mlir::detail::PDLByteCodeMutableState *)operator new();
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_OWORD *)v4 + 4) = 0u;
    *((_OWORD *)v4 + 5) = 0u;
    *((_OWORD *)v4 + 6) = 0u;
    *((_OWORD *)v4 + 7) = 0u;
    *((_OWORD *)v4 + 8) = 0u;
    *((_OWORD *)v4 + 9) = 0u;
    *((_OWORD *)v4 + 10) = 0u;
    *((_OWORD *)v4 + 11) = 0u;
    v5 = (mlir::detail::PDLByteCodeMutableState *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v4;
    if (v5)
    {
      mlir::detail::PDLByteCodeMutableState::~PDLByteCodeMutableState(v5);
      MEMORY[0x20BD002F8]();
      v4 = (mlir::detail::PDLByteCodeMutableState *)*((_QWORD *)this + 7);
    }
    mlir::detail::PDLByteCode::initializeMutableState(v3, v4);
  }
  return this;
}

void mlir::PatternApplicator::~PatternApplicator(mlir::PatternApplicator *this)
{
  mlir::detail::PDLByteCodeMutableState *v2;
  char *v3;
  uint64_t v4;
  llvm *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;

  v2 = (mlir::detail::PDLByteCodeMutableState *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v2)
  {
    mlir::detail::PDLByteCodeMutableState::~PDLByteCodeMutableState(v2);
    MEMORY[0x20BD002F8]();
  }
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  v4 = *((unsigned int *)this + 6);
  v5 = (llvm *)*((_QWORD *)this + 1);
  if ((_DWORD)v4)
  {
    v6 = (char *)v5 + 24;
    v7 = 40 * v4;
    do
    {
      if ((*((_QWORD *)v6 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v8 = (char *)*((_QWORD *)v6 - 2);
        if (v6 != v8)
          free(v8);
      }
      v6 += 40;
      v7 -= 40;
    }
    while (v7);
    v5 = (llvm *)*((_QWORD *)this + 1);
    v9 = 40 * *((unsigned int *)this + 6);
  }
  else
  {
    v9 = 0;
  }
  llvm::deallocate_buffer(v5, (void *)v9);
}

uint64_t sub_20749E0A8()
{
  uint64_t v0;

  return v0;
}

void mlir::PatternApplicator::applyCostModel(uint64_t **a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  int v35;
  BOOL v36;
  unsigned int v37;
  int v38;
  int v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  unsigned int v43;
  uint64_t *buffer;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t *v56;
  int v57;
  BOOL v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t *v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  _QWORD v70[3];
  uint64_t *v71;
  _QWORD v72[2];
  uint64_t v73;
  llvm *v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v72[0] = a2;
  v72[1] = a3;
  v4 = *(_QWORD *)(**a1 + 72);
  if (v4)
  {
    v5 = *(_DWORD *)(v4 + 400);
    if (v5)
    {
      v8 = 0;
      v9 = *(_QWORD *)(v4 + 392);
      v10 = 104 * v5;
      do
      {
        v11 = (uint64_t)a1[7];
        v12 = a2(a3, v9);
        mlir::detail::PDLByteCodeMutableState::updatePatternBenefit(v11, v8++, v12);
        v9 += 104;
        v10 -= 104;
      }
      while (v10);
    }
  }
  v13 = *((_DWORD *)a1 + 4);
  if (!v13 && !*((_DWORD *)a1 + 5))
  {
LABEL_10:
    v15 = **a1;
    if (!*(_DWORD *)(v15 + 8))
      goto LABEL_85;
    goto LABEL_21;
  }
  v14 = *((unsigned int *)a1 + 6);
  if (v14 > 4 * v13 && v14 >= 0x41)
  {
    llvm::DenseMap<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>>>::shrink_and_clear((uint64_t)(a1 + 1));
    goto LABEL_10;
  }
  if ((_DWORD)v14)
  {
    v16 = (uint64_t)(a1[1] + 3);
    for (i = 40 * v14; i; i -= 40)
    {
      v18 = *(_QWORD *)(v16 - 24);
      if (v18 != -8192)
      {
        if (v18 == -4096)
          goto LABEL_15;
        v19 = *(void **)(v16 - 16);
        if ((void *)v16 != v19)
          free(v19);
      }
      *(_QWORD *)(v16 - 24) = -4096;
LABEL_15:
      v16 += 40;
    }
  }
  a1[2] = 0;
  v15 = **a1;
  if (!*(_DWORD *)(v15 + 8))
    goto LABEL_85;
LABEL_21:
  v20 = *(unsigned int *)(v15 + 16);
  if ((_DWORD)v20)
  {
    v21 = 32 * v20;
    v22 = *(uint64_t **)v15;
    while ((*v22 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v22 += 4;
      v21 -= 32;
      if (!v21)
        goto LABEL_85;
    }
  }
  else
  {
    v22 = *(uint64_t **)v15;
  }
  v23 = *(_QWORD *)v15 + 32 * v20;
  if (v22 == (uint64_t *)v23)
    goto LABEL_85;
LABEL_28:
  v24 = (uint64_t *)v22[1];
  v25 = v22[2];
  while (v24 != (uint64_t *)v25)
  {
    v30 = *v24;
    if (*(__int16 *)(*v24 + 20) == -1)
      goto LABEL_33;
    v31 = a1[1];
    v32 = *((unsigned int *)a1 + 6);
    if (!(_DWORD)v32)
      goto LABEL_54;
    v26 = ((*v22 >> 4) ^ (*v22 >> 9)) & (v32 - 1);
    v27 = &v31[5 * v26];
    v28 = *v27;
    if (*v22 != *v27)
    {
      v34 = 0;
      v35 = 1;
      while (v28 != -4096)
      {
        if (v34)
          v36 = 0;
        else
          v36 = v28 == -8192;
        if (v36)
          v34 = v27;
        v37 = v26 + v35++;
        v26 = v37 & (v32 - 1);
        v27 = &v31[5 * v26];
        v28 = *v27;
        if (*v22 == *v27)
          goto LABEL_30;
      }
      if (v34)
        v27 = v34;
      v38 = *((_DWORD *)a1 + 4);
      if (4 * v38 + 4 >= (3 * v32))
      {
LABEL_54:
        v39 = 2 * v32;
        goto LABEL_56;
      }
      if ((int)v32 + ~v38 - *((_DWORD *)a1 + 5) <= v32 >> 3)
      {
        v39 = *((_DWORD *)a1 + 6);
LABEL_56:
        v40 = (v39 - 1) | ((unint64_t)(v39 - 1) >> 1);
        v41 = v40 | (v40 >> 2) | ((v40 | (v40 >> 2)) >> 4);
        v42 = ((v41 | (v41 >> 8)) >> 16) | v41 | (v41 >> 8);
        if ((v42 + 1) > 0x40)
          v43 = v42 + 1;
        else
          v43 = 64;
        *((_DWORD *)a1 + 6) = v43;
        buffer = (uint64_t *)llvm::allocate_buffer(40 * v43, (std::align_val_t)8uLL);
        a1[1] = buffer;
        if (v31)
        {
          v45 = 5 * v32;
          llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>>>,mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>>>::moveFromOldBuckets((uint64_t)(a1 + 1), v31, &v31[v45]);
          llvm::deallocate_buffer((llvm *)v31, (void *)(v45 * 8));
        }
        a1[2] = 0;
        v46 = *((unsigned int *)a1 + 6);
        v47 = 40 * v46 - 40;
        v48 = buffer;
        if (v47 < 0x28)
          goto LABEL_109;
        v49 = v47 / 0x28 + 1;
        v48 = &buffer[5 * (v49 & 0xFFFFFFFFFFFFFFELL)];
        v50 = v49 & 0xFFFFFFFFFFFFFFELL;
        v51 = buffer;
        do
        {
          *v51 = -4096;
          v51[5] = -4096;
          v51 += 10;
          v50 -= 2;
        }
        while (v50);
        if (v49 != (v49 & 0xFFFFFFFFFFFFFFELL))
        {
LABEL_109:
          do
          {
            *v48 = -4096;
            v48 += 5;
          }
          while (v48 != &buffer[5 * v46]);
        }
        v52 = *v22;
        v53 = v46 - 1;
        v54 = ((*v22 >> 4) ^ (*v22 >> 9)) & v53;
        v27 = &buffer[5 * v54];
        v55 = *v27;
        if (*v22 != *v27)
        {
          v56 = 0;
          v57 = 1;
          while (v55 != -4096)
          {
            if (v56)
              v58 = 0;
            else
              v58 = v55 == -8192;
            if (v58)
              v56 = v27;
            v59 = v54 + v57++;
            v54 = v59 & v53;
            v27 = &buffer[5 * v54];
            v55 = *v27;
            if (v52 == *v27)
              goto LABEL_67;
          }
          if (v56)
            v27 = v56;
          goto LABEL_39;
        }
LABEL_67:
        ++*((_DWORD *)a1 + 4);
        if (v52 != -4096)
LABEL_40:
          --*((_DWORD *)a1 + 5);
      }
      else
      {
LABEL_39:
        v33 = *v27;
        ++*((_DWORD *)a1 + 4);
        if (v33 != -4096)
          goto LABEL_40;
      }
      *v27 = *v22;
      v27[1] = (uint64_t)(v27 + 3);
      v27[2] = 0x200000000;
    }
LABEL_30:
    v29 = *((unsigned int *)v27 + 4);
    if (v29 >= *((unsigned int *)v27 + 5))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v27 + 1), v27 + 3, v29 + 1, 8);
      v29 = *((unsigned int *)v27 + 4);
    }
    *(_QWORD *)(v27[1] + 8 * v29) = v30;
    ++*((_DWORD *)v27 + 4);
LABEL_33:
    ++v24;
  }
  while (1)
  {
    v22 += 4;
    if (v22 == (uint64_t *)v23)
      break;
    if ((*v22 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      if (v22 != (uint64_t *)v23)
        goto LABEL_28;
      break;
    }
  }
  v15 = **a1;
LABEL_85:
  v60 = (uint64_t)(a1 + 4);
  *((_DWORD *)a1 + 10) = 0;
  v61 = *(uint64_t **)(v15 + 48);
  v62 = *(uint64_t **)(v15 + 56);
  if (v61 != v62)
  {
    v63 = 0;
    do
    {
      v64 = *v61;
      if (*(__int16 *)(*v61 + 20) != -1)
      {
        if (v63 >= *((_DWORD *)a1 + 11))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 4), a1 + 6, v63 + 1, 8);
          v63 = *((_DWORD *)a1 + 10);
        }
        a1[4][v63] = v64;
        v63 = *((_DWORD *)a1 + 10) + 1;
        *((_DWORD *)a1 + 10) = v63;
      }
      ++v61;
    }
    while (v61 != v62);
  }
  v73 = 1;
  v74 = (llvm *)-4096;
  v76 = -4096;
  v77 = -4096;
  v78 = -4096;
  v71 = &v73;
  v70[0] = v72;
  v70[1] = &v73;
  v70[2] = &v71;
  if (*((_DWORD *)a1 + 4))
  {
    v65 = a1[1];
    v66 = *((unsigned int *)a1 + 6);
    if ((_DWORD)v66)
    {
      v67 = 40 * v66;
      v68 = a1[1];
      while ((*v68 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v68 += 5;
        v67 -= 40;
        if (!v67)
          goto LABEL_97;
      }
    }
    else
    {
      v68 = a1[1];
    }
    v69 = &v65[5 * v66];
LABEL_102:
    if (v68 != v69)
    {
      mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_1::operator()((uint64_t)v70, (uint64_t)(v68 + 1));
      while (1)
      {
        v68 += 5;
        if (v68 == v69)
          break;
        if ((*v68 | 0x1000) != 0xFFFFFFFFFFFFF000)
          goto LABEL_102;
      }
    }
  }
LABEL_97:
  mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_1::operator()((uint64_t)v70, v60);
  if ((v73 & 1) == 0)
    llvm::deallocate_buffer(v74, (void *)(16 * v75));
}

void mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_1::operator()(uint64_t a1, uint64_t a2)
{
  int *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  unsigned int v13;
  int **v14;
  int *v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int **v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  char *v24;
  unint64_t v25;
  const std::nothrow_t *v26;
  unint64_t v27;
  char *v28;
  BOOL v29;
  int *v30;
  int *v31;
  unint64_t v32;
  int *v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  BOOL v50;
  unsigned int v51;
  char *v52;
  __int16 v53;
  int *v54;

  if (*(_DWORD *)(a2 + 8) == 1)
  {
    if ((**(unsigned __int16 (***)(_QWORD, uint64_t))a1)(*(_QWORD *)(*(_QWORD *)a1 + 8), **(_QWORD **)a2 + 8) == 0xFFFF)*(_DWORD *)(a2 + 8) = 0;
    return;
  }
  v4 = *(int **)(a1 + 8);
  v5 = *v4;
  if (*v4 > 1 || v4[1])
  {
    if ((v5 & 1) != 0)
    {
      v30 = v4 + 2;
      v31 = v4 + 18;
      v32 = 48;
    }
    else
    {
      v6 = (2 * v5) & 0xFFFFFFFC;
      v7 = v4[4];
      if (v6 < v7 && v7 >= 0x41)
      {
        llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::shrink_and_clear((char *)v4);
        goto LABEL_10;
      }
      if (!(_DWORD)v7)
      {
LABEL_49:
        *v4 = v7;
        v4[1] = 0;
        v8 = *(char **)a2;
        v9 = *(unsigned int *)(a2 + 8);
        if ((_DWORD)v9)
          goto LABEL_11;
LABEL_50:
        v25 = 0;
        v54 = **(int ***)(a1 + 16);
        v24 = v8;
LABEL_51:
        std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(v24, v8, &v54, v25, 0, 0);
        v37 = *(_DWORD *)(a2 + 8);
        if (v37)
          goto LABEL_52;
        return;
      }
      v30 = (int *)*((_QWORD *)v4 + 1);
      v31 = &v30[4 * v7];
      v32 = (char *)v31 - (char *)v30 - 16;
      if (v32 < 0x10)
      {
        v33 = (int *)*((_QWORD *)v4 + 1);
        do
        {
LABEL_47:
          *(_QWORD *)v33 = -4096;
          v33 += 4;
        }
        while (v33 != v31);
LABEL_48:
        LODWORD(v7) = *v4 & 1;
        goto LABEL_49;
      }
    }
    v34 = (v32 >> 4) + 1;
    v33 = &v30[4 * (v34 & 0x1FFFFFFFFFFFFFFELL)];
    v35 = v30 + 4;
    v36 = v34 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v35 - 2) = -4096;
      *v35 = -4096;
      v35 += 4;
      v36 -= 2;
    }
    while (v36);
    if (v34 == (v34 & 0x1FFFFFFFFFFFFFFELL))
      goto LABEL_48;
    goto LABEL_47;
  }
LABEL_10:
  v8 = *(char **)a2;
  v9 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v9)
    goto LABEL_50;
LABEL_11:
  v10 = &v8[8 * v9];
  do
  {
    if (*(_QWORD *)v8)
      v16 = (int *)(*(_QWORD *)v8 + 8);
    else
      v16 = 0;
    v54 = v16;
    v17 = *(_QWORD *)(a1 + 8);
    v53 = (**(uint64_t (***)(_QWORD))a1)(*(_QWORD *)(*(_QWORD *)a1 + 8));
    v18 = v17 + 8;
    if ((*(_BYTE *)v17 & 1) != 0)
    {
      v11 = 4;
    }
    else
    {
      v11 = *(_DWORD *)(v17 + 16);
      if (!v11)
      {
        v19 = 0;
        goto LABEL_22;
      }
      v18 = *(_QWORD *)(v17 + 8);
    }
    v12 = v11 - 1;
    v13 = ((v54 >> 4) ^ (v54 >> 9)) & v12;
    v14 = (int **)(v18 + 16 * v13);
    v15 = *v14;
    if (v54 == *v14)
      goto LABEL_14;
    v20 = 0;
    v21 = 1;
    while (v15 != (int *)-4096)
    {
      if (v20)
        v22 = 0;
      else
        v22 = v15 == (int *)-8192;
      if (v22)
        v20 = v14;
      v23 = v13 + v21++;
      v13 = v23 & v12;
      v14 = (int **)(v18 + 16 * v13);
      v15 = *v14;
      if (v54 == *v14)
        goto LABEL_14;
    }
    if (v20)
      v19 = (uint64_t)v20;
    else
      v19 = (uint64_t)v14;
LABEL_22:
    llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&,mlir::PatternBenefit>(v17, v19, &v54, &v53);
LABEL_14:
    v8 += 8;
  }
  while (v8 != v10);
  v24 = *(char **)a2;
  v25 = *(unsigned int *)(a2 + 8);
  v8 = (char *)(*(_QWORD *)a2 + 8 * v25);
  v54 = **(int ***)(a1 + 16);
  if (v25 < 0x81)
    goto LABEL_51;
  v26 = (const std::nothrow_t *)MEMORY[0x24BEDB6B8];
  v27 = v25;
  while (1)
  {
    v28 = (char *)operator new(8 * v27, v26);
    if (v28)
      break;
    v29 = v27 > 1;
    v27 >>= 1;
    if (!v29)
      goto LABEL_51;
  }
  v52 = v28;
  std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(v24, v8, &v54, v25, v28, v27);
  operator delete(v52);
  v37 = *(_DWORD *)(a2 + 8);
  if (v37)
  {
    while (1)
    {
LABEL_52:
      v38 = *(_QWORD *)(a1 + 8);
      v39 = *(_QWORD *)(*(_QWORD *)a2 + 8 * v37 - 8);
      v40 = (int *)(v39 + 8);
      if (!v39)
        v40 = 0;
      v54 = v40;
      v41 = v38 + 8;
      if ((*(_BYTE *)v38 & 1) != 0)
      {
        v42 = 4;
      }
      else
      {
        v42 = *(_DWORD *)(v38 + 16);
        if (!v42)
        {
          v47 = 0;
          goto LABEL_63;
        }
        v41 = *(_QWORD *)(v38 + 8);
      }
      v43 = v42 - 1;
      v44 = (v42 - 1) & ((v40 >> 4) ^ (v40 >> 9));
      v45 = v41 + 16 * v44;
      v46 = *(_QWORD *)v45;
      if (v40 == *(int **)v45)
        goto LABEL_59;
      v48 = 0;
      v49 = 1;
      while (v46 != -4096)
      {
        if (v48)
          v50 = 0;
        else
          v50 = v46 == -8192;
        if (v50)
          v48 = v45;
        v51 = v44 + v49++;
        v44 = v51 & v43;
        v45 = v41 + 16 * (v51 & v43);
        v46 = *(_QWORD *)v45;
        if (v40 == *(int **)v45)
          goto LABEL_59;
      }
      if (v48)
        v47 = v48;
      else
        v47 = v45;
LABEL_63:
      v45 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>(v38, v47, &v54);
LABEL_59:
      if (*(__int16 *)(v45 + 8) == -1)
      {
        v37 = *(_DWORD *)(a2 + 8) - 1;
        *(_DWORD *)(a2 + 8) = v37;
        if (v37)
          continue;
      }
      return;
    }
  }
}

uint64_t **mlir::PatternApplicator::walkAllPatterns(uint64_t **result, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *i;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;

  v5 = result;
  v6 = **result;
  if (*(_DWORD *)(v6 + 8))
  {
    v7 = *(unsigned int *)(v6 + 16);
    if ((_DWORD)v7)
    {
      v8 = 32 * v7;
      v9 = *(_QWORD **)v6;
      while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v9 += 4;
        v8 -= 32;
        if (!v8)
          goto LABEL_15;
      }
    }
    else
    {
      v9 = *(_QWORD **)v6;
    }
    v10 = *(_QWORD *)v6 + 32 * v7;
    if (v9 != (_QWORD *)v10)
    {
LABEL_9:
      v11 = (uint64_t *)v9[1];
      for (i = (uint64_t *)v9[2]; v11 != i; result = (uint64_t **)a2(a3, v13 + 8))
        v13 = *v11++;
      while (1)
      {
        v9 += 4;
        if (v9 == (_QWORD *)v10)
          break;
        if ((*v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          if (v9 != (_QWORD *)v10)
            goto LABEL_9;
          break;
        }
      }
      v6 = **v5;
    }
  }
LABEL_15:
  v14 = *(uint64_t **)(v6 + 48);
  v15 = *(uint64_t **)(v6 + 56);
  if (v14 != v15)
  {
    do
    {
      v16 = *v14++;
      result = (uint64_t **)a2(a3, v16 + 8);
    }
    while (v14 != v15);
    v6 = **v5;
  }
  v17 = *(_QWORD *)(v6 + 72);
  if (v17)
  {
    v18 = *(_DWORD *)(v17 + 400);
    if (v18)
    {
      v19 = *(_QWORD *)(v17 + 392);
      v20 = 104 * v18;
      do
      {
        result = (uint64_t **)a2(a3, v19);
        v19 += 104;
        v20 -= 104;
      }
      while (v20);
    }
  }
  return result;
}

uint64_t mlir::PatternApplicator::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int (*a4)(uint64_t), uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  char *v34;
  mlir::MLIRContext *Context;
  uint64_t v36;
  _QWORD *v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v44[10];
  char v45;
  char *v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD v52[2];
  _QWORD v53[2];
  unsigned __int8 v54;
  unint64_t v55;
  void *v56;
  uint64_t v57;
  _QWORD v58[62];

  v58[60] = *MEMORY[0x24BDAC8D0];
  v53[0] = a6;
  v53[1] = a7;
  v52[0] = a9;
  v52[1] = a10;
  v51 = a2;
  v56 = v58;
  v57 = 0x400000000;
  v14 = *(_QWORD *)(**(_QWORD **)a1 + 72);
  v50 = v14;
  if (v14)
  {
    mlir::detail::PDLByteCode::match(v14, a2, a3, (uint64_t)&v56, *(_QWORD *)(a1 + 56));
    a2 = v51;
  }
  v15 = *(_QWORD *)(a1 + 8);
  v16 = *(_DWORD *)(a1 + 24);
  if (!v16)
  {
LABEL_9:
    v19 = (uint64_t *)(v15 + 40 * v16);
    goto LABEL_10;
  }
  v17 = *(_QWORD *)(a2 + 48);
  v18 = ((v17 >> 4) ^ (v17 >> 9)) & (v16 - 1);
  v19 = (uint64_t *)(v15 + 40 * v18);
  v20 = *v19;
  if (v17 != *v19)
  {
    v21 = 1;
    while (v20 != -4096)
    {
      v22 = v18 + v21++;
      v18 = v22 & (v16 - 1);
      v19 = (uint64_t *)(v15 + 40 * v18);
      v20 = *v19;
      if (v17 == *v19)
        goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_10:
  if (v19 == (uint64_t *)(v15 + 40 * v16))
  {
    v24 = 0;
    v23 = 0;
  }
  else
  {
    v23 = v19[1];
    v24 = *((_DWORD *)v19 + 4);
  }
  v49 = 0;
  v25 = *(unsigned int *)(a1 + 40);
  v48 = 0;
  v26 = v57;
  v54 = 0;
  do
  {
    while (1)
    {
      do
      {
        v46 = 0;
        v47 = 0;
        if (HIDWORD(v49) >= v24)
        {
          v29 = v49;
          if (v49 >= v25)
          {
            v33 = v48;
            if (v48 >= v26)
              goto LABEL_45;
            v34 = (char *)v56;
            goto LABEL_37;
          }
          v30 = *(_QWORD *)(a1 + 32);
LABEL_25:
          v31 = *(_QWORD *)(v30 + 8 * v29);
          goto LABEL_26;
        }
        v27 = *(_QWORD *)(v23 + 8 * HIDWORD(v49));
        if (v27)
          v28 = v27 + 8;
        else
          v28 = 0;
        v47 = v28;
        v29 = v49;
        if (v49 >= v25)
        {
          v32 = (unsigned int *)&v49 + 1;
          v33 = v48;
          if (v48 >= v26)
            goto LABEL_38;
LABEL_32:
          v34 = (char *)v56;
          if (v28 && *(unsigned __int16 *)(v28 + 12) >= *((unsigned __int16 *)v56 + 60 * v33 + 56))
            goto LABEL_39;
LABEL_37:
          v46 = &v34[120 * v33];
          v28 = *((_QWORD *)v46 + 13);
          v47 = v28;
          v32 = &v48;
          goto LABEL_38;
        }
        v30 = *(_QWORD *)(a1 + 32);
        if (!v27)
          goto LABEL_25;
        v31 = *(_QWORD *)(v30 + 8 * v49);
        if (*(unsigned __int16 *)(v28 + 12) >= *(unsigned __int16 *)(v31 + 20))
        {
          v32 = (unsigned int *)&v49 + 1;
          v28 = v27 + 8;
          v33 = v48;
          if (v48 < v26)
            goto LABEL_32;
          goto LABEL_38;
        }
LABEL_26:
        if (v31)
          v28 = v31 + 8;
        else
          v28 = 0;
        v47 = v28;
        v32 = (unsigned int *)&v49;
        v33 = v48;
        if (v48 < v26)
          goto LABEL_32;
LABEL_38:
        if (!v28)
          goto LABEL_45;
LABEL_39:
        ++*v32;
      }
      while (a4 && !a4(a5));
      v45 = 0;
      Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v51 + 24));
      v44[0] = a3;
      v44[1] = (uint64_t)&v51;
      v44[2] = (uint64_t)&v46;
      v44[3] = (uint64_t)&v54;
      v44[4] = (uint64_t)&v50;
      v44[5] = a1;
      v44[6] = (uint64_t)&v47;
      v44[7] = (uint64_t)v52;
      v44[8] = (uint64_t)&v45;
      v44[9] = (uint64_t)v53;
      v55 = v51 & 0xFFFFFFFFFFFFFFF9;
      v36 = v47;
      if (mlir::MLIRContext::hasActionHandler(Context))
        break;
      llvm::function_ref<void ()(void)>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &,llvm::function_ref<BOOL ()(mlir::Pattern const&)>,llvm::function_ref<void ()(mlir::Pattern const&)>,llvm::function_ref<mlir::LogicalResult ()(mlir::Pattern const&)>)::$_0>(v44);
      if (v45)
        goto LABEL_45;
    }
    mlir::MLIRContext::executeActionInternal<mlir::ApplyPatternAction,mlir::Pattern const&>((uint64_t *)Context, (uint64_t)llvm::function_ref<void ()(void)>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &,llvm::function_ref<BOOL ()(mlir::Pattern const&)>,llvm::function_ref<void ()(mlir::Pattern const&)>,llvm::function_ref<mlir::LogicalResult ()(mlir::Pattern const&)>)::$_0>, (uint64_t)v44, (uint64_t)&v55, 1, v36);
  }
  while (!v45);
LABEL_45:
  v37 = *(_QWORD **)(a1 + 56);
  if (v37)
    mlir::detail::PDLByteCodeMutableState::cleanupAfterMatchAndRewrite(v37);
  v38 = (char *)v56;
  if ((_DWORD)v57)
  {
    v39 = 120 * v57;
    do
    {
      v40 = *(char **)&v38[v39 - 32];
      if (&v38[v39 - 16] != v40)
        free(v40);
      v41 = *(char **)&v38[v39 - 48];
      if (&v38[v39 - 32] != v41)
        free(v41);
      v42 = *(char **)&v38[v39 - 112];
      if (&v38[v39 - 96] != v42)
        free(v42);
      v39 -= 120;
    }
    while (v39);
    v38 = (char *)v56;
  }
  if (v38 != (char *)v58)
    free(v38);
  return v54;
}

char *llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::shrink_and_clear(char *result)
{
  char *v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  char *v6;
  char *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  _QWORD *v19;
  uint64_t v20;

  v1 = result;
  v2 = *(_DWORD *)result;
  v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if (v3 - 28 >= 3)
    v4 = 1 << (33 - v3);
  else
    v4 = 64;
  if (v2 >= 2)
    v5 = v4;
  else
    v5 = 0;
  if ((v2 & 1) != 0 && v5 < 5)
  {
    *(_DWORD *)result &= 1u;
    *((_DWORD *)result + 1) = 0;
    v6 = result + 8;
    v7 = result + 72;
    v8 = 48;
    goto LABEL_15;
  }
  if ((v2 & 1) != 0)
  {
    if (v5 <= 4)
    {
      *(_QWORD *)result = 1;
    }
    else
    {
      *(_DWORD *)result &= ~1u;
      result = (char *)llvm::allocate_buffer(16 * v5, (std::align_val_t)8uLL);
      *((_QWORD *)v1 + 1) = result;
      *((_QWORD *)v1 + 2) = v5;
      v14 = *(_DWORD *)v1;
      *(_QWORD *)v1 = *(_DWORD *)v1 & 1;
      if ((v14 & 1) == 0)
      {
        v15 = &result[16 * v5];
        v16 = 16 * v5 - 16;
        if (v16 < 0x10)
        {
          v18 = result;
          goto LABEL_31;
        }
LABEL_24:
        v17 = (v16 >> 4) + 1;
        v18 = &result[16 * (v17 & 0x1FFFFFFFFFFFFFFELL)];
        v19 = result + 16;
        v20 = v17 & 0x1FFFFFFFFFFFFFFELL;
        do
        {
          *(v19 - 2) = -4096;
          *v19 = -4096;
          v19 += 4;
          v20 -= 2;
        }
        while (v20);
        if (v17 == (v17 & 0x1FFFFFFFFFFFFFFELL))
          return result;
        do
        {
LABEL_31:
          *(_QWORD *)v18 = -4096;
          v18 += 16;
        }
        while (v18 != v15);
        return result;
      }
    }
    result = v1 + 8;
    v15 = v1 + 72;
    v16 = 48;
    goto LABEL_24;
  }
  v10 = *((unsigned int *)result + 4);
  if ((_DWORD)v5 != (_DWORD)v10)
    llvm::deallocate_buffer(*((llvm **)result + 1), (void *)(16 * v10));
  *(_QWORD *)result = 0;
  if (!(_DWORD)v5)
    return result;
  v6 = (char *)*((_QWORD *)result + 1);
  v7 = &v6[16 * v5];
  v8 = 16 * v5 - 16;
  if (v8 < 0x10)
  {
    v9 = (char *)*((_QWORD *)result + 1);
    do
    {
LABEL_18:
      *(_QWORD *)v9 = -4096;
      v9 += 16;
    }
    while (v9 != v7);
    return result;
  }
LABEL_15:
  v11 = (v8 >> 4) + 1;
  v9 = &v6[16 * (v11 & 0x1FFFFFFFFFFFFFFELL)];
  v12 = v6 + 16;
  v13 = v11 & 0x1FFFFFFFFFFFFFFELL;
  do
  {
    *(v12 - 2) = -4096;
    *v12 = -4096;
    v12 += 4;
    v13 -= 2;
  }
  while (v13);
  if (v11 != (v11 & 0x1FFFFFFFFFFFFFFELL))
    goto LABEL_18;
  return result;
}

uint64_t llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&,mlir::PatternBenefit>(uint64_t a1, uint64_t a2, _QWORD *a3, _WORD *a4)
{
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  unsigned int v21;

  v8 = *(_DWORD *)a1;
  v9 = *(_DWORD *)a1 >> 1;
  if ((*(_DWORD *)a1 & 1) != 0)
    v10 = 4;
  else
    v10 = *(_DWORD *)(a1 + 16);
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
  }
  else if (v10 + ~v9 - *(_DWORD *)(a1 + 4) > v10 >> 3)
  {
    v11 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::grow(a1, v10);
  v13 = a1 + 8;
  v8 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) != 0)
  {
    v14 = 4;
  }
  else
  {
    v14 = *(_DWORD *)(a1 + 16);
    if (!v14)
    {
      v11 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    v13 = *(_QWORD *)(a1 + 8);
  }
  v11 = *(_DWORD *)a1 & 1;
  v15 = v14 - 1;
  v16 = ((*a3 >> 4) ^ (*a3 >> 9)) & (v14 - 1);
  a2 = v13 + 16 * v16;
  v17 = *(_QWORD *)a2;
  if (*a3 != *(_QWORD *)a2)
  {
    v18 = 0;
    v19 = 1;
    while (v17 != -4096)
    {
      if (v18)
        v20 = 0;
      else
        v20 = v17 == -8192;
      if (v20)
        v18 = a2;
      v21 = v16 + v19++;
      v16 = v21 & v15;
      a2 = v13 + 16 * (v21 & v15);
      v17 = *(_QWORD *)a2;
      if (*a3 == *(_QWORD *)a2)
        goto LABEL_7;
    }
    if (v18)
      a2 = v18;
  }
LABEL_7:
  *(_DWORD *)a1 = (v8 & 0xFFFFFFFE | v11) + 2;
  if (*(_QWORD *)a2 != -4096)
    --*(_DWORD *)(a1 + 4);
  *(_QWORD *)a2 = *a3;
  *(_WORD *)(a2 + 8) = *a4;
  return a2;
}

int *llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::grow(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  __int16 v17;
  _QWORD v18[7];

  v18[6] = *MEMORY[0x24BDAC8D0];
  if (a2 >= 5)
  {
    v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40)
      a2 = v5 + 1;
    else
      a2 = 64;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    v6 = *(uint64_t **)(a1 + 8);
    v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      v14 = a2;
      *(_QWORD *)(a1 + 8) = llvm::allocate_buffer(16 * a2, (std::align_val_t)8uLL);
      *(_QWORD *)(a1 + 16) = v14;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    v15 = (char *)(16 * v7);
    llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::moveFromOldBuckets((int *)a1, v6, (uint64_t *)&v15[(_QWORD)v6]);
    llvm::deallocate_buffer((llvm *)v6, v15);
  }
  v8 = &v16;
  if ((*(_QWORD *)(a1 + 8) | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
    v9 = *(_QWORD *)(a1 + 24);
    if ((v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
      goto LABEL_10;
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 8);
    v17 = *(_WORD *)(a1 + 16);
    v8 = v18;
    v9 = *(_QWORD *)(a1 + 24);
    if ((v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
LABEL_10:
      v10 = *(_QWORD *)(a1 + 40);
      if ((v10 | 0x1000) == 0xFFFFFFFFFFFFF000)
        goto LABEL_11;
      goto LABEL_19;
    }
  }
  *v8 = v9;
  *((_WORD *)v8 + 4) = *(_WORD *)(a1 + 32);
  v8 += 2;
  v10 = *(_QWORD *)(a1 + 40);
  if ((v10 | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
LABEL_11:
    v11 = *(_QWORD *)(a1 + 56);
    if ((v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
      goto LABEL_12;
LABEL_20:
    *v8 = v11;
    *((_WORD *)v8 + 4) = *(_WORD *)(a1 + 64);
    v8 += 2;
    if (a2 < 5)
      return llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::moveFromOldBuckets((int *)a1, &v16, v8);
    goto LABEL_13;
  }
LABEL_19:
  *v8 = v10;
  *((_WORD *)v8 + 4) = *(_WORD *)(a1 + 48);
  v8 += 2;
  v11 = *(_QWORD *)(a1 + 56);
  if ((v11 | 0x1000) != 0xFFFFFFFFFFFFF000)
    goto LABEL_20;
LABEL_12:
  if (a2 >= 5)
  {
LABEL_13:
    *(_DWORD *)a1 &= ~1u;
    v12 = a2;
    *(_QWORD *)(a1 + 8) = llvm::allocate_buffer(16 * a2, (std::align_val_t)8uLL);
    *(_QWORD *)(a1 + 16) = v12;
  }
  return llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::moveFromOldBuckets((int *)a1, &v16, v8);
}

int *llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::moveFromOldBuckets(int *result, uint64_t *a2, uint64_t *a3)
{
  int v3;
  uint64_t v4;
  int *v5;
  int *v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  _QWORD *v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v3 = *result;
  *result &= 1u;
  result[1] = 0;
  if ((v3 & 1) != 0)
  {
    v6 = result + 18;
    v5 = result + 2;
    v7 = 48;
  }
  else
  {
    v4 = result[4];
    if (!(_DWORD)v4)
      goto LABEL_11;
    v5 = (int *)*((_QWORD *)result + 1);
    v6 = &v5[4 * v4];
    v7 = (char *)v6 - (char *)v5 - 16;
    if (v7 < 0x10)
    {
      v9 = (int *)*((_QWORD *)result + 1);
      do
      {
LABEL_10:
        *(_QWORD *)v9 = -4096;
        v9 += 4;
      }
      while (v9 != v6);
      goto LABEL_11;
    }
  }
  v8 = (v7 >> 4) + 1;
  v9 = &v5[4 * (v8 & 0x1FFFFFFFFFFFFFFELL)];
  v10 = v5 + 4;
  v11 = v8 & 0x1FFFFFFFFFFFFFFELL;
  do
  {
    *(v10 - 2) = -4096;
    *v10 = -4096;
    v10 += 4;
    v11 -= 2;
  }
  while (v11);
  if (v8 != (v8 & 0x1FFFFFFFFFFFFFFELL))
    goto LABEL_10;
LABEL_11:
  while (a2 != a3)
  {
    v18 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      if ((*(_BYTE *)result & 1) != 0)
      {
        v13 = 4;
        v12 = result + 2;
      }
      else
      {
        v12 = (int *)*((_QWORD *)result + 1);
        v13 = result[4];
      }
      v14 = v13 - 1;
      v15 = (v13 - 1) & ((v18 >> 4) ^ (v18 >> 9));
      v16 = (uint64_t *)&v12[4 * v15];
      v17 = *v16;
      if (v18 != *v16)
      {
        v19 = 0;
        v20 = 1;
        while (v17 != -4096)
        {
          if (v19)
            v21 = 0;
          else
            v21 = v17 == -8192;
          if (v21)
            v19 = v16;
          v22 = v15 + v20++;
          v15 = v22 & v14;
          v16 = (uint64_t *)&v12[4 * (v22 & v14)];
          v17 = *v16;
          if (v18 == *v16)
            goto LABEL_15;
        }
        if (v19)
          v16 = v19;
      }
LABEL_15:
      *v16 = v18;
      *((_WORD *)v16 + 4) = *((_WORD *)a2 + 4);
      *result += 2;
    }
    a2 += 2;
  }
  return result;
}

void std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(char *a1, char *a2, int **a3, unint64_t a4, char *a5, uint64_t a6)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  int *v25;
  int v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  BOOL v46;
  unsigned int v47;
  uint64_t v48;
  int v49;
  BOOL v50;
  unsigned int v51;
  unint64_t v54;
  char *v55;
  unint64_t v56;
  uint64_t *v57;
  char *v58;
  uint64_t *v59;
  char *v60;
  char *v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _BOOL4 v66;
  _QWORD *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  uint64_t *v75;
  uint64_t v76;
  char *v77;
  __int128 v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;

  if (a4 < 2)
    return;
  v8 = a1;
  if (a4 == 2)
  {
    v9 = *((_QWORD *)a2 - 1);
    if (v9)
      v10 = v9 + 8;
    else
      v10 = 0;
    if (*(_QWORD *)a1)
      v11 = *(_QWORD *)a1 + 8;
    else
      v11 = 0;
    if (mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a3, v10, v11))
    {
      v12 = *(_QWORD *)v8;
      *(_QWORD *)v8 = *((_QWORD *)a2 - 1);
      *((_QWORD *)a2 - 1) = v12;
    }
    return;
  }
  if ((uint64_t)a4 <= 128)
  {
    if (a1 == a2)
      return;
    v14 = a1 + 8;
    if (a1 + 8 == a2)
      return;
    v15 = a1;
LABEL_19:
    v17 = v14;
    v19 = *(_QWORD *)v15;
    v18 = *((_QWORD *)v15 + 1);
    if (v18)
      v20 = v18 + 8;
    else
      v20 = 0;
    if (v19)
      v21 = v19 + 8;
    else
      v21 = 0;
    if (!mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a3, v20, v21))goto LABEL_18;
    v22 = *(_QWORD *)v17;
    if (*(_QWORD *)v17)
      v23 = *(_QWORD *)v17 + 8;
    else
      v23 = 0;
    v24 = (v23 >> 4) ^ (v23 >> 9);
    v16 = v17;
    while (1)
    {
      *(_QWORD *)v16 = *(_QWORD *)v15;
      if (v15 == v8)
      {
        v16 = v8;
LABEL_17:
        *(_QWORD *)v16 = v22;
LABEL_18:
        v14 = v17 + 8;
        v15 = v17;
        if (v17 + 8 != a2)
          goto LABEL_19;
        return;
      }
      v16 = v15;
      v31 = *((_QWORD *)v15 - 1);
      v15 -= 8;
      v32 = v31 + 8;
      if (v31)
        v33 = v32;
      else
        v33 = 0;
      v90 = v33;
      v91 = v23;
      v34 = *a3;
      v36 = (uint64_t)(*a3 + 2);
      v35 = **a3;
      if ((v35 & 1) != 0)
      {
        v37 = 4;
      }
      else
      {
        v37 = v34[4];
        if (!v37)
        {
          v42 = 0;
          goto LABEL_46;
        }
        v36 = *((_QWORD *)v34 + 1);
      }
      v38 = v37 - 1;
      v39 = v38 & v24;
      v40 = v36 + 16 * (v38 & v24);
      v41 = *(_QWORD *)v40;
      if (*(_QWORD *)v40 == v23)
        goto LABEL_42;
      v48 = 0;
      v49 = 1;
      while (v41 != -4096)
      {
        if (v48)
          v50 = 0;
        else
          v50 = v41 == -8192;
        if (v50)
          v48 = v40;
        v51 = v39 + v49++;
        v39 = v51 & v38;
        v40 = v36 + 16 * v39;
        v41 = *(_QWORD *)v40;
        if (*(_QWORD *)v40 == v23)
          goto LABEL_42;
      }
      if (v48)
        v42 = v48;
      else
        v42 = v40;
LABEL_46:
      v40 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>((uint64_t)v34, v42, &v91);
      v34 = *a3;
      v35 = **a3;
LABEL_42:
      if ((v35 & 1) != 0)
      {
        v25 = v34 + 2;
        v26 = 4;
      }
      else
      {
        v26 = v34[4];
        if (!v26)
        {
          v43 = 0;
LABEL_48:
          v29 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>((uint64_t)v34, v43, &v90);
          goto LABEL_32;
        }
        v25 = (int *)*((_QWORD *)v34 + 1);
      }
      v27 = v26 - 1;
      v28 = ((v90 >> 4) ^ (v90 >> 9)) & (v26 - 1);
      v29 = (uint64_t)&v25[4 * v28];
      v30 = *(_QWORD *)v29;
      if (v90 != *(_QWORD *)v29)
      {
        v44 = 0;
        v45 = 1;
        while (v30 != -4096)
        {
          if (v44)
            v46 = 0;
          else
            v46 = v30 == -8192;
          if (v46)
            v44 = v29;
          v47 = v28 + v45++;
          v28 = v47 & v27;
          v29 = (uint64_t)&v25[4 * (v47 & v27)];
          v30 = *(_QWORD *)v29;
          if (v90 == *(_QWORD *)v29)
            goto LABEL_32;
        }
        if (v44)
          v43 = v44;
        else
          v43 = v29;
        goto LABEL_48;
      }
LABEL_32:
      if (*(unsigned __int16 *)(v29 + 8) >= *(unsigned __int16 *)(v40 + 8))
        goto LABEL_17;
    }
  }
  v54 = a4 >> 1;
  v55 = &a1[8 * (a4 >> 1)];
  v56 = a4 >> 1;
  if ((uint64_t)a4 > a6)
  {
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(a1, v55, a3, v56, a5, a6);
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), a5, a6);
    std::__inplace_merge<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>((uint64_t)v8, &v8[8 * (a4 >> 1)], a2, a3, a4 >> 1, a4 - (a4 >> 1), a5, a6);
    return;
  }
  std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(a1, v55, a3, v56, (uint64_t *)a5);
  v57 = (uint64_t *)&a5[8 * v54];
  std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v57);
  v58 = v8;
  v59 = v57;
  v60 = a5;
  v61 = &a5[8 * a4];
  do
  {
    if (v59 == (uint64_t *)v61)
    {
      if (v60 == (char *)v57)
        return;
      v80 = &a5[8 * v54] - v60 - 8;
      if (v80 >= 0x38 && (unint64_t)(v58 - v60) >= 0x20)
      {
        v84 = 0;
        v85 = (v80 >> 3) + 1;
        v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
        v81 = &v8[v86];
        v82 = (uint64_t *)&v60[v86];
        v87 = v85 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v88 = &v8[v84];
          v89 = *(_OWORD *)&v60[v84 + 16];
          *(_OWORD *)v88 = *(_OWORD *)&v60[v84];
          *((_OWORD *)v88 + 1) = v89;
          v84 += 32;
          v87 -= 4;
        }
        while (v87);
        if (v85 == (v85 & 0x3FFFFFFFFFFFFFFCLL))
          return;
      }
      else
      {
        v81 = v8;
        v82 = (uint64_t *)v60;
      }
      do
      {
        v83 = *v82++;
        *(_QWORD *)v81 = v83;
        v81 += 8;
      }
      while (v82 != v57);
      return;
    }
    v62 = v59;
    v63 = *v59;
    if (v63)
      v64 = v63 + 8;
    else
      v64 = 0;
    if (*(_QWORD *)v60)
      v65 = *(_QWORD *)v60 + 8;
    else
      v65 = 0;
    v66 = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a3, v64, v65);
    if (v66)
      v67 = v62;
    else
      v67 = v60;
    v60 += 8 * !v66;
    v59 = &v62[v66];
    *(_QWORD *)v8 = *v67;
    v8 += 8;
    v58 += 8;
  }
  while (v60 != (char *)v57);
  if (v59 != (uint64_t *)v61)
  {
    v68 = -8;
    if (!v66)
      v68 = 0;
    v69 = &a5[8 * a4] - (char *)v62 + v68 - 8;
    if (v69 < 0x68)
      goto LABEL_110;
    v70 = 1;
    if (!v66)
      v70 = 0;
    if ((unint64_t)(v58 - (char *)&v62[v70]) < 0x20)
      goto LABEL_110;
    v71 = 0;
    v72 = (v69 >> 3) + 1;
    v73 = v72 & 0x3FFFFFFFFFFFFFFCLL;
    v74 = &v8[v73 * 8];
    v75 = &v59[v73];
    v76 = v72 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v77 = &v8[v71 * 8];
      v78 = *(_OWORD *)&v59[v71 + 2];
      *(_OWORD *)v77 = *(_OWORD *)&v59[v71];
      *((_OWORD *)v77 + 1) = v78;
      v71 += 4;
      v76 -= 4;
    }
    while (v76);
    v8 = v74;
    v59 = v75;
    if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_110:
      do
      {
        v79 = *v59++;
        *(_QWORD *)v8 = v79;
        v8 += 8;
      }
      while (v59 != (uint64_t *)v61);
    }
  }
}

BOOL mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(int **a1, uint64_t a2, uint64_t a3)
{
  int *v4;
  int v5;
  _DWORD *v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _DWORD *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;

  v29 = a3;
  v30 = a2;
  v4 = *a1;
  v6 = v4 + 2;
  v5 = *v4;
  if ((*v4 & 1) != 0)
  {
    v7 = 4;
  }
  else
  {
    v7 = v4[4];
    if (!v7)
    {
      v19 = 0;
      goto LABEL_13;
    }
    v6 = (_DWORD *)*((_QWORD *)v4 + 1);
  }
  v8 = v7 - 1;
  v9 = v8 & ((a2 >> 4) ^ (a2 >> 9));
  v10 = (uint64_t)&v6[4 * v9];
  v11 = *(_QWORD *)v10;
  if (*(_QWORD *)v10 == a2)
    goto LABEL_6;
  v21 = 0;
  v22 = 1;
  while (v11 != -4096)
  {
    if (v21)
      v23 = 0;
    else
      v23 = v11 == -8192;
    if (v23)
      v21 = v10;
    v24 = v9 + v22++;
    v9 = v24 & v8;
    v10 = (uint64_t)&v6[4 * v9];
    v11 = *(_QWORD *)v10;
    if (*(_QWORD *)v10 == a2)
      goto LABEL_6;
  }
  if (v21)
    v19 = v21;
  else
    v19 = v10;
LABEL_13:
  v10 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>((uint64_t)v4, v19, &v30);
  v4 = *a1;
  v5 = **a1;
LABEL_6:
  if ((v5 & 1) != 0)
  {
    v13 = v4 + 2;
    v12 = 4;
  }
  else
  {
    v12 = v4[4];
    if (!v12)
    {
      v20 = 0;
LABEL_15:
      v16 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>((uint64_t)v4, v20, &v29);
      return *(unsigned __int16 *)(v16 + 8) < *(unsigned __int16 *)(v10 + 8);
    }
    v13 = (_DWORD *)*((_QWORD *)v4 + 1);
  }
  v14 = v12 - 1;
  v15 = ((v29 >> 4) ^ (v29 >> 9)) & (v12 - 1);
  v16 = (uint64_t)&v13[4 * v15];
  v17 = *(_QWORD *)v16;
  if (v29 != *(_QWORD *)v16)
  {
    v25 = 0;
    v26 = 1;
    while (v17 != -4096)
    {
      if (v25)
        v27 = 0;
      else
        v27 = v17 == -8192;
      if (v27)
        v25 = v16;
      v28 = v15 + v26++;
      v15 = v28 & v14;
      v16 = (uint64_t)&v13[4 * (v28 & v14)];
      v17 = *(_QWORD *)v16;
      if (v29 == *(_QWORD *)v16)
        return *(unsigned __int16 *)(v16 + 8) < *(unsigned __int16 *)(v10 + 8);
    }
    if (v25)
      v20 = v25;
    else
      v20 = v16;
    goto LABEL_15;
  }
  return *(unsigned __int16 *)(v16 + 8) < *(unsigned __int16 *)(v10 + 8);
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(char *a1, char *a2, int **a3, unint64_t a4, uint64_t *a5)
{
  uint64_t *v5;
  char *v7;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  __n128 result;
  char *v16;
  char *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL4 v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int *v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  BOOL v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  BOOL v54;
  unsigned int v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _BOOL4 v66;
  char *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  char *v75;
  uint64_t v76;
  uint64_t *v77;
  __int128 v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t *v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t *v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;

  if (a4)
  {
    v5 = a5;
    v7 = a1;
    if (a4 == 1)
    {
LABEL_15:
      *v5 = *(_QWORD *)v7;
      return result;
    }
    if (a4 == 2)
    {
      v11 = a2 - 8;
      v10 = *((_QWORD *)a2 - 1);
      if (v10)
        v12 = v10 + 8;
      else
        v12 = 0;
      if (*(_QWORD *)a1)
        v13 = *(_QWORD *)a1 + 8;
      else
        v13 = 0;
      v14 = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a3, v12, v13);
      if (v14)
        v16 = v11;
      else
        v16 = v7;
      *v5++ = *(_QWORD *)v16;
      if (!v14)
        v7 = v11;
      goto LABEL_15;
    }
    if ((uint64_t)a4 <= 8)
    {
      if (a1 == a2)
        return result;
      v17 = a1 + 8;
      *a5 = *(_QWORD *)a1;
      if (a1 + 8 == a2)
        return result;
      v18 = a5;
      while (1)
      {
        v21 = v18;
        v23 = *v18++;
        v22 = v23;
        v24 = *(_QWORD *)v17 ? *(_QWORD *)v17 + 8 : 0;
        v25 = v22 ? v22 + 8 : 0;
        v26 = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a3, v24, v25);
        v19 = v18;
        if (v26)
        {
          v21[1] = *v21;
          v19 = v5;
          if (v21 != v5)
            break;
        }
LABEL_22:
        v20 = *(_QWORD *)v17;
        v17 += 8;
        *v19 = v20;
        if (v17 == a2)
          return result;
      }
      v27 = v21;
      while (1)
      {
        v28 = *(_QWORD *)v17 + 8;
        if (!*(_QWORD *)v17)
          v28 = 0;
        v29 = *--v27;
        v30 = v29 + 8;
        if (v29)
          v31 = v30;
        else
          v31 = 0;
        v90 = v31;
        v91 = v28;
        v32 = *a3;
        v34 = (uint64_t)(*a3 + 2);
        v33 = **a3;
        if ((v33 & 1) != 0)
        {
          v35 = 4;
        }
        else
        {
          v35 = v32[4];
          if (!v35)
          {
            v46 = 0;
            goto LABEL_51;
          }
          v34 = *((_QWORD *)v32 + 1);
        }
        v36 = v35 - 1;
        v37 = v36 & ((v28 >> 4) ^ (v28 >> 9));
        v38 = v34 + 16 * v37;
        v39 = *(_QWORD *)v38;
        if (*(_QWORD *)v38 == v28)
          goto LABEL_42;
        v48 = 0;
        v49 = 1;
        while (v39 != -4096)
        {
          if (v48)
            v50 = 0;
          else
            v50 = v39 == -8192;
          if (v50)
            v48 = v38;
          v51 = v37 + v49++;
          v37 = v51 & v36;
          v38 = v34 + 16 * v37;
          v39 = *(_QWORD *)v38;
          if (*(_QWORD *)v38 == v28)
            goto LABEL_42;
        }
        if (v48)
          v46 = v48;
        else
          v46 = v38;
LABEL_51:
        v38 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>((uint64_t)v32, v46, &v91);
        v32 = *a3;
        v33 = **a3;
LABEL_42:
        if ((v33 & 1) != 0)
        {
          v41 = v32 + 2;
          v40 = 4;
        }
        else
        {
          v40 = v32[4];
          if (!v40)
          {
            v47 = 0;
LABEL_53:
            v44 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>((uint64_t)v32, v47, &v90);
            goto LABEL_47;
          }
          v41 = (int *)*((_QWORD *)v32 + 1);
        }
        v42 = v40 - 1;
        v43 = ((v90 >> 4) ^ (v90 >> 9)) & (v40 - 1);
        v44 = (uint64_t)&v41[4 * v43];
        v45 = *(_QWORD *)v44;
        if (v90 != *(_QWORD *)v44)
        {
          v52 = 0;
          v53 = 1;
          while (v45 != -4096)
          {
            if (v52)
              v54 = 0;
            else
              v54 = v45 == -8192;
            if (v54)
              v52 = v44;
            v55 = v43 + v53++;
            v43 = v55 & v42;
            v44 = (uint64_t)&v41[4 * (v55 & v42)];
            v45 = *(_QWORD *)v44;
            if (v90 == *(_QWORD *)v44)
              goto LABEL_47;
          }
          if (v52)
            v47 = v52;
          else
            v47 = v44;
          goto LABEL_53;
        }
LABEL_47:
        if (*(unsigned __int16 *)(v44 + 8) >= *(unsigned __int16 *)(v38 + 8))
        {
          v19 = v21;
          goto LABEL_22;
        }
        *v21 = *(v21 - 1);
        v21 = v27;
        if (v27 == v5)
        {
          v19 = v5;
          goto LABEL_22;
        }
      }
    }
    v56 = a4 >> 1;
    v57 = 8 * (a4 >> 1);
    v58 = &a1[v57];
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(a1, &a1[v57], a3, a4 >> 1, a5, a4 >> 1);
    std::__stable_sort<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(&v7[v57], a2, a3, a4 - v56, &v5[(unint64_t)v57 / 8], a4 - v56);
    v59 = (char *)v5;
    v60 = v7;
    v61 = v58;
    do
    {
      if (v61 == a2)
      {
        if (v60 == v58)
          return result;
        v80 = &v7[8 * v56] - v60 - 8;
        if (v80 >= 0x38 && (unint64_t)(v59 - v60) >= 0x20)
        {
          v84 = 0;
          v85 = (v80 >> 3) + 1;
          v86 = v85 & 0x3FFFFFFFFFFFFFFCLL;
          v81 = &v5[v86];
          v82 = &v60[v86 * 8];
          v87 = v85 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v88 = &v5[v84];
            result = *(__n128 *)&v60[v84 * 8];
            v89 = *(_OWORD *)&v60[v84 * 8 + 16];
            *(__n128 *)v88 = result;
            *((_OWORD *)v88 + 1) = v89;
            v84 += 4;
            v87 -= 4;
          }
          while (v87);
          if (v85 == (v85 & 0x3FFFFFFFFFFFFFFCLL))
            return result;
        }
        else
        {
          v81 = v5;
          v82 = v60;
        }
        do
        {
          v83 = *(_QWORD *)v82;
          v82 += 8;
          *v81++ = v83;
        }
        while (v82 != v58);
        return result;
      }
      v62 = v61;
      v63 = *(_QWORD *)v61;
      if (v63)
        v64 = v63 + 8;
      else
        v64 = 0;
      if (*(_QWORD *)v60)
        v65 = *(_QWORD *)v60 + 8;
      else
        v65 = 0;
      v66 = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a3, v64, v65);
      if (v66)
        v67 = v62;
      else
        v67 = v60;
      v61 = &v62[8 * v66];
      v60 += 8 * !v66;
      *v5++ = *(_QWORD *)v67;
      v59 += 8;
    }
    while (v60 != v58);
    if (v61 != a2)
    {
      v68 = -8;
      if (!v66)
        v68 = 0;
      v69 = a2 - v62 + v68 - 8;
      if (v69 < 0x68)
        goto LABEL_113;
      v70 = 8;
      if (!v66)
        v70 = 0;
      if ((unint64_t)(v59 - v62 - v70) < 0x20)
        goto LABEL_113;
      v71 = 0;
      v72 = (v69 >> 3) + 1;
      v73 = v72 & 0x3FFFFFFFFFFFFFFCLL;
      v74 = &v5[v73];
      v75 = &v61[v73 * 8];
      v76 = v72 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v77 = &v5[v71];
        result = *(__n128 *)&v61[v71 * 8];
        v78 = *(_OWORD *)&v61[v71 * 8 + 16];
        *(__n128 *)v77 = result;
        *((_OWORD *)v77 + 1) = v78;
        v71 += 4;
        v76 -= 4;
      }
      while (v76);
      v5 = v74;
      v61 = v75;
      if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_113:
        do
        {
          v79 = *(_QWORD *)v61;
          v61 += 8;
          *v5++ = v79;
        }
        while (v61 != a2);
      }
    }
  }
  return result;
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(uint64_t result, char *a2, char *a3, int **a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v10;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v51;
  int64_t v52;
  uint64_t v53;
  char *v54;
  size_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  BOOL v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  unint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  __int128 *v87;
  _OWORD *v88;
  uint64_t v89;
  __int128 v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  unint64_t v98;
  char *v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  __int128 *v103;
  _OWORD *v104;
  uint64_t v105;
  __int128 v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char *v110;
  uint64_t v111;
  unint64_t v112;
  char *v113;
  char *v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  __int128 v121;
  char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  char *v127;
  uint64_t v128;
  char *v129;
  char *v130;
  char *v131;
  uint64_t v132;
  char *v133;
  uint64_t v134;
  int *v135;

  if (!a6)
    return result;
  v10 = a6;
  v15 = (char *)result;
  while (v10 > a8 && a5 > a8)
  {
    if (!a5)
      return result;
    v16 = 0;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)a2 ? *(_QWORD *)a2 + 8 : 0;
      v19 = *(_QWORD *)&v15[8 * v17];
      v20 = v19 ? v19 + 8 : 0;
      result = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a4, v18, v20);
      if ((result & 1) != 0)
        break;
      ++v17;
      v16 -= 8;
      if (a5 == v17)
        return result;
    }
    result = (uint64_t)&v15[-v16];
    v133 = a3;
    v134 = v10;
    if (a5 - v17 >= v10)
    {
      if (a5 - 1 == v17)
      {
        v111 = *(_QWORD *)&v15[8 * v17];
        *(_QWORD *)&v15[8 * v17] = *(_QWORD *)a2;
        *(_QWORD *)a2 = v111;
        return result;
      }
      v124 = a8;
      v33 = (a5 - v17) / 2;
      v34 = &v15[8 * v33];
      v135 = *a4;
      if (a3 == a2)
      {
        v23 = a3;
      }
      else
      {
        v127 = &v15[-v16];
        v130 = a7;
        v35 = (a3 - a2) >> 3;
        v23 = a2;
        do
        {
          v36 = &v23[8 * (v35 >> 1)];
          v38 = *(_QWORD *)v36;
          v37 = v36 + 8;
          v39 = *(_QWORD *)&v34[8 * v17];
          v40 = v38 + 8;
          if (v38)
            v41 = v40;
          else
            v41 = 0;
          if (v39)
            v42 = v39 + 8;
          else
            v42 = 0;
          v43 = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(&v135, v41, v42);
          if (v43)
            v35 += ~(v35 >> 1);
          else
            v35 >>= 1;
          if (v43)
            v23 = v37;
        }
        while (v35);
        result = (uint64_t)v127;
        a7 = v130;
        v33 = (a5 - v17) / 2;
      }
      v26 = &v34[-v16];
      v22 = (v23 - a2) >> 3;
      a8 = v124;
      a3 = v23;
      if (v26 != a2)
      {
LABEL_53:
        a3 = v26;
        if (a2 != v23)
        {
          if (v26 + 8 == a2)
          {
            v131 = a7;
            v125 = a8;
            v51 = *(_QWORD *)v26;
            v52 = v23 - a2;
            v53 = result;
            v54 = a2;
            v55 = v23 - a2;
            v56 = v33;
            v57 = v22;
            memmove(v26, v54, v55);
            v22 = v57;
            v33 = v56;
            result = v53;
            a3 = &v26[v52];
            *(_QWORD *)&v26[v52] = v51;
            a8 = v125;
            a7 = v131;
          }
          else if (a2 + 8 == v23)
          {
            v58 = *((_QWORD *)v23 - 1);
            a3 = v26 + 8;
            if (v23 - 8 != v26)
            {
              v128 = result;
              v132 = *((_QWORD *)v23 - 1);
              v59 = v33;
              v60 = v22;
              memmove(v26 + 8, v26, v23 - 8 - v26);
              result = v128;
              v58 = v132;
              v22 = v60;
              v33 = v59;
            }
            *(_QWORD *)v26 = v58;
          }
          else
          {
            v44 = (a2 - v26) >> 3;
            v45 = (v23 - a2) >> 3;
            if (v44 == v45)
            {
              v46 = 0;
              do
              {
                v47 = *(_QWORD *)&v26[v46];
                *(_QWORD *)&v26[v46] = *(_QWORD *)&a2[v46];
                v48 = (uint64_t)&v26[v46 + 8];
                *(_QWORD *)&a2[v46] = v47;
                v49 = (uint64_t)&a2[v46 + 8];
                v46 += 8;
              }
              while ((char *)v48 != a2 && v49 != (_QWORD)v23);
              a3 = a2;
            }
            else
            {
              v61 = (v23 - a2) >> 3;
              v62 = (a2 - v26) >> 3;
              do
              {
                v63 = v62;
                v62 = v61;
                v61 = v63 % v61;
              }
              while (v61);
              if (v62)
              {
                v64 = &v26[8 * v62];
                do
                {
                  v66 = *((_QWORD *)v64 - 1);
                  v64 -= 8;
                  v65 = v66;
                  v67 = &v64[8 * v44];
                  v68 = v64;
                  do
                  {
                    v69 = v68;
                    v68 = v67;
                    *(_QWORD *)v69 = *(_QWORD *)v67;
                    v70 = (v23 - v67) >> 3;
                    v71 = __OFSUB__(v44, v70);
                    v73 = v44 - v70;
                    v72 = (v73 < 0) ^ v71;
                    v67 = &v26[8 * v73];
                    if (v72)
                      v67 = &v68[8 * v44];
                  }
                  while (v67 != v64);
                  *(_QWORD *)v68 = v65;
                }
                while (v64 != v26);
              }
              a3 = &v26[8 * v45];
            }
          }
        }
      }
    }
    else
    {
      if (v10 >= 0)
        v21 = v10;
      else
        v21 = v10 + 1;
      v22 = v21 >> 1;
      v23 = &a2[8 * (v21 >> 1)];
      if ((char *)result == a2)
      {
        v26 = a2;
        v33 = (uint64_t)&a2[-result] >> 3;
        a3 = &a2[8 * (v21 >> 1)];
      }
      else
      {
        v123 = v21 >> 1;
        v126 = &v15[-v16];
        v129 = a7;
        v24 = a8;
        v25 = (uint64_t)(a2 - v15 + v16) >> 3;
        v26 = (char *)result;
        do
        {
          v27 = &v26[8 * (v25 >> 1)];
          v30 = *(_QWORD *)v27;
          v29 = v27 + 8;
          v28 = v30;
          if (*(_QWORD *)v23)
            v31 = *(_QWORD *)v23 + 8;
          else
            v31 = 0;
          if (v28)
            v32 = v28 + 8;
          else
            v32 = 0;
          if (mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a4, v31, v32))
          {
            v25 >>= 1;
          }
          else
          {
            v26 = v29;
            v25 += ~(v25 >> 1);
          }
        }
        while (v25);
        a8 = v24;
        result = (uint64_t)v126;
        a7 = v129;
        v22 = v123;
        v33 = (v26 - v126) >> 3;
        a3 = v23;
        if (v26 != a2)
          goto LABEL_53;
      }
    }
    v74 = a5 - v33 - v17;
    v75 = v134 - v22;
    if (v33 + v22 >= v134 + a5 - (v33 + v22) - v17)
    {
      v77 = (char *)result;
      a5 = v33;
      v78 = v74;
      v79 = v22;
      result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(a3, v23, v133, a4, v78, v134 - v22, a7, a8);
      v80 = v26;
      v81 = v79;
      v15 = v77;
      a2 = v80;
      v10 = v81;
      if (!v81)
        return result;
    }
    else
    {
      result = std::__inplace_merge<std::_ClassicAlgPolicy,mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0 &,mlir::RewritePattern const**>(result, v26, a3, a4, v33, v22, a7, a8);
      v76 = a3;
      a3 = v133;
      a5 = v74;
      v15 = v76;
      a2 = v23;
      v10 = v75;
      if (!v75)
        return result;
    }
  }
  if (a5 <= v10)
  {
    if (v15 != a2)
    {
      v98 = a2 - v15 - 8;
      v99 = a7;
      v100 = v15;
      if (v98 < 0x18)
        goto LABEL_141;
      v99 = a7;
      v100 = v15;
      if ((unint64_t)(a7 - v15) < 0x20)
        goto LABEL_141;
      v101 = (v98 >> 3) + 1;
      v102 = 8 * (v101 & 0x3FFFFFFFFFFFFFFCLL);
      v99 = &a7[v102];
      v100 = &v15[v102];
      v103 = (__int128 *)(v15 + 16);
      v104 = a7 + 16;
      v105 = v101 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v106 = *v103;
        *(v104 - 1) = *(v103 - 1);
        *v104 = v106;
        v103 += 2;
        v104 += 2;
        v105 -= 4;
      }
      while (v105);
      if (v101 != (v101 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_141:
        do
        {
          v107 = *(_QWORD *)v100;
          v100 += 8;
          *(_QWORD *)v99 = v107;
          v99 += 8;
        }
        while (v100 != a2);
      }
      if (v99 != a7)
      {
        while (a2 != a3)
        {
          if (*(_QWORD *)a2)
            v108 = *(_QWORD *)a2 + 8;
          else
            v108 = 0;
          if (*(_QWORD *)a7)
            v109 = *(_QWORD *)a7 + 8;
          else
            v109 = 0;
          result = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a4, v108, v109);
          if ((_DWORD)result)
            v110 = a2;
          else
            v110 = a7;
          a7 += 8 * (result ^ 1);
          a2 += 8 * result;
          *(_QWORD *)v15 = *(_QWORD *)v110;
          v15 += 8;
          if (a7 == v99)
            return result;
        }
        return (uint64_t)memmove(v15, a7, v99 - a7);
      }
    }
  }
  else if (a2 != a3)
  {
    v82 = a3 - a2 - 8;
    v83 = a7;
    v84 = a2;
    if (v82 < 0x18)
      goto LABEL_142;
    v83 = a7;
    v84 = a2;
    if ((unint64_t)(a7 - a2) < 0x20)
      goto LABEL_142;
    v85 = (v82 >> 3) + 1;
    v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
    v83 = &a7[v86];
    v84 = &a2[v86];
    v87 = (__int128 *)(a2 + 16);
    v88 = a7 + 16;
    v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v90 = *v87;
      *(v88 - 1) = *(v87 - 1);
      *v88 = v90;
      v87 += 2;
      v88 += 2;
      v89 -= 4;
    }
    while (v89);
    if (v85 != (v85 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_142:
      do
      {
        v91 = *(_QWORD *)v84;
        v84 += 8;
        *(_QWORD *)v83 = v91;
        v83 += 8;
      }
      while (v84 != a3);
    }
    if (v83 != a7)
    {
      v92 = a3;
      while (a2 != v15)
      {
        v93 = *((_QWORD *)a2 - 1);
        v94 = *((_QWORD *)v83 - 1);
        if (v94)
          v95 = v94 + 8;
        else
          v95 = 0;
        if (v93)
          v96 = v93 + 8;
        else
          v96 = 0;
        result = mlir::PatternApplicator::applyCostModel(llvm::function_ref<mlir::PatternBenefit ()(mlir::Pattern const&)>)::$_0::operator()(a4, v95, v96);
        if ((_DWORD)result)
          v97 = a2;
        else
          v97 = v83;
        if ((_DWORD)result)
          a2 -= 8;
        else
          v83 -= 8;
        *((_QWORD *)a3 - 1) = *((_QWORD *)v97 - 1);
        a3 -= 8;
        v92 -= 8;
        if (v83 == a7)
          return result;
      }
      v112 = v83 - a7 - 8;
      if (v112 < 0x58 || (unint64_t)(v83 - v92) < 0x20)
      {
        v113 = v83;
        v114 = a3;
        goto LABEL_132;
      }
      v117 = 0;
      v118 = (v112 >> 3) + 1;
      v119 = 8 * (v118 & 0x3FFFFFFFFFFFFFFCLL);
      v113 = &v83[-v119];
      v114 = &a3[-v119];
      v120 = v118 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v121 = *(_OWORD *)&v83[v117 - 16];
        v122 = &a3[v117];
        *((_OWORD *)v122 - 2) = *(_OWORD *)&v83[v117 - 32];
        *((_OWORD *)v122 - 1) = v121;
        v117 -= 32;
        v120 -= 4;
      }
      while (v120);
      if (v118 != (v118 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_132:
        v115 = v114 - 8;
        do
        {
          v116 = *((_QWORD *)v113 - 1);
          v113 -= 8;
          *(_QWORD *)v115 = v116;
          v115 -= 8;
        }
        while (v113 != a7);
      }
    }
  }
  return result;
}

uint64_t llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>,mlir::Pattern const*,mlir::PatternBenefit,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::InsertIntoBucket<mlir::Pattern const* const&>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  unsigned int v19;

  v6 = *(_DWORD *)a1;
  v7 = *(_DWORD *)a1 >> 1;
  if ((*(_DWORD *)a1 & 1) != 0)
    v8 = 4;
  else
    v8 = *(_DWORD *)(a1 + 16);
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
  }
  else if (v8 + ~v7 - *(_DWORD *)(a1 + 4) > v8 >> 3)
  {
    v9 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<mlir::Pattern const*,mlir::PatternBenefit,4u,llvm::DenseMapInfo<mlir::Pattern const*,void>,llvm::detail::DenseMapPair<mlir::Pattern const*,mlir::PatternBenefit>>::grow(a1, v8);
  v11 = a1 + 8;
  v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) != 0)
  {
    v12 = 4;
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 16);
    if (!v12)
    {
      v9 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    v11 = *(_QWORD *)(a1 + 8);
  }
  v9 = *(_DWORD *)a1 & 1;
  v13 = v12 - 1;
  v14 = ((*a3 >> 4) ^ (*a3 >> 9)) & (v12 - 1);
  a2 = v11 + 16 * v14;
  v15 = *(_QWORD *)a2;
  if (*a3 != *(_QWORD *)a2)
  {
    v16 = 0;
    v17 = 1;
    while (v15 != -4096)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v15 == -8192;
      if (v18)
        v16 = a2;
      v19 = v14 + v17++;
      v14 = v19 & v13;
      a2 = v11 + 16 * (v19 & v13);
      v15 = *(_QWORD *)a2;
      if (*a3 == *(_QWORD *)a2)
        goto LABEL_7;
    }
    if (v16)
      a2 = v16;
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*(_QWORD *)a2 != -4096)
    --*(_DWORD *)(a1 + 4);
  *(_QWORD *)a2 = *a3;
  *(_WORD *)(a2 + 8) = -1;
  return a2;
}

void mlir::detail::PDLByteCodeMutableState::~PDLByteCodeMutableState(mlir::detail::PDLByteCodeMutableState *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  v2 = (void *)*((_QWORD *)this + 21);
  if (v2)
  {
    *((_QWORD *)this + 22) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 18);
  if (v3)
  {
    *((_QWORD *)this + 19) = v3;
    operator delete(v3);
  }
  v4 = *((_QWORD *)this + 15);
  if (v4)
  {
    v5 = *((_QWORD *)this + 16);
    v6 = (void *)*((_QWORD *)this + 15);
    if (v5 != v4)
    {
      do
      {
        v8 = *(_QWORD *)(v5 - 16);
        v5 -= 16;
        v7 = v8;
        if (v8)
          MEMORY[0x20BD002D4](v7, 0x20C8093837F09);
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this + 15);
    }
    *((_QWORD *)this + 16) = v4;
    operator delete(v6);
  }
  v9 = (void *)*((_QWORD *)this + 12);
  if (v9)
  {
    *((_QWORD *)this + 13) = v9;
    operator delete(v9);
  }
  v10 = *((_QWORD *)this + 9);
  if (v10)
  {
    v11 = *((_QWORD *)this + 10);
    v12 = (void *)*((_QWORD *)this + 9);
    if (v11 != v10)
    {
      do
      {
        v14 = *(_QWORD *)(v11 - 16);
        v11 -= 16;
        v13 = v14;
        if (v14)
          MEMORY[0x20BD002D4](v13, 0x20C8093837F09);
      }
      while (v11 != v10);
      v12 = (void *)*((_QWORD *)this + 9);
    }
    *((_QWORD *)this + 10) = v10;
    operator delete(v12);
  }
  v15 = (void *)*((_QWORD *)this + 6);
  if (v15)
  {
    *((_QWORD *)this + 7) = v15;
    operator delete(v15);
  }
  v16 = *((_QWORD *)this + 3);
  if (v16)
  {
    v17 = *((_QWORD *)this + 4);
    v18 = (void *)*((_QWORD *)this + 3);
    if (v17 != v16)
    {
      do
      {
        v20 = *(_QWORD *)(v17 - 16);
        v17 -= 16;
        v19 = v20;
        if (v20)
          MEMORY[0x20BD002D4](v19, 0x20C8093837F09);
      }
      while (v17 != v16);
      v18 = (void *)*((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 4) = v16;
    operator delete(v18);
  }
  v21 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v21;
    operator delete(v21);
  }
}

void llvm::DenseMap<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>>>::shrink_and_clear(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int v7;
  unsigned int v8;
  llvm *v9;
  unint64_t v10;
  llvm *v11;
  unint64_t v12;
  uint64_t v13;
  llvm *v14;
  llvm *v15;

  v2 = *(unsigned int *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v4 = *(_QWORD *)a1 + 24;
    v5 = 40 * v2;
    do
    {
      if ((*(_QWORD *)(v4 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v6 = *(void **)(v4 - 16);
        if ((void *)v4 != v6)
          free(v6);
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
  }
  v7 = 1 << (33 - __clz(v3 - 1));
  if (v7 <= 64)
    v7 = 64;
  if (v3)
    v8 = v7;
  else
    v8 = 0;
  if (v8 != *(_DWORD *)(a1 + 16))
    llvm::deallocate_buffer(*(llvm **)a1, (void *)(40 * v2));
  *(_QWORD *)(a1 + 8) = 0;
  if (v8)
  {
    v9 = *(llvm **)a1;
    v10 = 40 * v8 - 40;
    if (v10 < 0x28)
    {
      v11 = *(llvm **)a1;
LABEL_20:
      v15 = (llvm *)((char *)v9 + 40 * v8);
      do
      {
        *(_QWORD *)v11 = -4096;
        v11 = (llvm *)((char *)v11 + 40);
      }
      while (v11 != v15);
      return;
    }
    v12 = v10 / 0x28 + 1;
    v11 = (llvm *)((char *)v9 + 40 * (v12 & 0xFFFFFFFFFFFFFFELL));
    v13 = v12 & 0xFFFFFFFFFFFFFFELL;
    v14 = *(llvm **)a1;
    do
    {
      *(_QWORD *)v14 = -4096;
      *((_QWORD *)v14 + 5) = -4096;
      v14 = (llvm *)((char *)v14 + 80);
      v13 -= 2;
    }
    while (v13);
    if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL))
      goto LABEL_20;
  }
}

void llvm::DenseMapBase<llvm::DenseMap<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>>>,mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,llvm::SmallVector<mlir::RewritePattern const*,2u>>>::moveFromOldBuckets(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  unsigned int v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  _QWORD *v20;
  int v21;
  BOOL v22;
  unsigned int v23;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 40 * v6 - 40;
    if (v8 < 0x28)
    {
      v9 = *(_QWORD **)a1;
LABEL_7:
      v13 = &v7[5 * v6];
      do
      {
        *v9 = -4096;
        v9 += 5;
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    v10 = v8 / 0x28 + 1;
    v9 = &v7[5 * (v10 & 0xFFFFFFFFFFFFFFELL)];
    v11 = v10 & 0xFFFFFFFFFFFFFFELL;
    v12 = *(_QWORD **)a1;
    do
    {
      *v12 = -4096;
      v12[5] = -4096;
      v12 += 10;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0xFFFFFFFFFFFFFFELL))
      goto LABEL_7;
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      v14 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v15 = *(_DWORD *)(a1 + 16) - 1;
        v16 = v15 & ((v14 >> 4) ^ (v14 >> 9));
        v17 = (_QWORD *)(*(_QWORD *)a1 + 40 * v16);
        v18 = *v17;
        if (v14 != *v17)
        {
          v20 = 0;
          v21 = 1;
          while (v18 != -4096)
          {
            if (v20)
              v22 = 0;
            else
              v22 = v18 == -8192;
            if (v22)
              v20 = v17;
            v23 = v16 + v21++;
            v16 = v23 & v15;
            v17 = (_QWORD *)(*(_QWORD *)a1 + 40 * (v23 & v15));
            v18 = *v17;
            if (v14 == *v17)
              goto LABEL_14;
          }
          if (v20)
            v17 = v20;
        }
LABEL_14:
        *v17 = v14;
        v17[1] = v17 + 3;
        v17[2] = 0x200000000;
        if (*((_DWORD *)v4 + 4))
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(v17 + 1), (uint64_t)(v4 + 1));
        ++*(_DWORD *)(a1 + 8);
        v19 = (uint64_t *)v4[1];
        if (v19 != v4 + 3)
          free(v19);
      }
      v4 += 5;
    }
    while (v4 != a3);
  }
}

uint64_t mlir::MLIRContext::executeActionInternal<mlir::ApplyPatternAction,mlir::Pattern const&>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned __int8 v6;
  uint64_t *v7;
  unint64_t v8;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  const char *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v7 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v6 & 1) == 0)
  {
    v23 = a3;
    v24 = a1;
    v21 = a6;
    v22 = a2;
    v19 = a4;
    v20 = a5;
    v7 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    a4 = v19;
    a5 = v20;
    a6 = v21;
    a2 = v22;
    v11 = v10;
    a3 = v23;
    a1 = v24;
    if (v11)
    {
      v25 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ApplyPatternAction]";
      v26 = 74;
      v12 = llvm::StringRef::find((uint64_t *)&v25, "DesiredTypeName = ", 0x12uLL, 0);
      if (v26 >= v12)
        v13 = v12;
      else
        v13 = v26;
      v14 = &v25[v13];
      v15 = v26 - v13;
      if (v26 - v13 >= 0x12)
        v16 = 18;
      else
        v16 = v26 - v13;
      v17 = v15 - v16;
      if (v17 >= v17 - 1)
        v18 = v17 - 1;
      else
        v18 = v17;
      mlir::detail::TypeIDResolver<mlir::ApplyPatternAction,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v14[v16], v18);
      v7 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a4 = v19;
      a5 = v20;
      a6 = v21;
      a2 = v22;
      a3 = v23;
      a1 = v24;
    }
  }
  v8 = v7[114];
  v27 = a4;
  v28 = a5;
  v25 = (const char *)&unk_24C034680;
  v26 = v8;
  v29 = a6;
  return mlir::MLIRContext::executeActionInternal(a1, a2, a3, (uint64_t)&v25);
}

void mlir::ApplyPatternAction::~ApplyPatternAction(mlir::ApplyPatternAction *this)
{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::tracing::ActionImpl<mlir::ApplyPatternAction>::getTag()
{
  return "apply-pattern";
}

llvm::raw_ostream *mlir::ApplyPatternAction::print(mlir::ApplyPatternAction *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v2;
  _BYTE *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  llvm::raw_ostream *result;
  uint64_t v9;
  const char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = a2;
  v4 = (_BYTE *)*((_QWORD *)a2 + 4);
  if (*((_BYTE **)a2 + 3) == v4)
  {
    v6 = (void *)*((_QWORD *)v2 + 4);
    if (*((_QWORD *)v2 + 3) - (_QWORD)v6 <= 0xCuLL)
    {
LABEL_3:
      v2 = llvm::raw_ostream::write(v2, "apply-pattern", 0xDuLL);
      v7 = *((_QWORD *)v2 + 4);
      if ((unint64_t)(*((_QWORD *)v2 + 3) - v7) > 9)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else
  {
    *v4 = 96;
    v5 = *((_QWORD *)a2 + 3);
    v6 = (void *)(*((_QWORD *)a2 + 4) + 1);
    *((_QWORD *)a2 + 4) = v6;
    if ((unint64_t)(v5 - (_QWORD)v6) <= 0xC)
      goto LABEL_3;
  }
  qmemcpy(v6, "apply-pattern", 13);
  v12 = *((_QWORD *)v2 + 3);
  v7 = *((_QWORD *)v2 + 4) + 13;
  *((_QWORD *)v2 + 4) = v7;
  if ((unint64_t)(v12 - v7) > 9)
  {
LABEL_4:
    *(_WORD *)(v7 + 8) = 8250;
    *(_QWORD *)v7 = *(_QWORD *)" pattern: ";
    result = (llvm::raw_ostream *)(*((_QWORD *)v2 + 4) + 10);
    *((_QWORD *)v2 + 4) = result;
    v9 = *((_QWORD *)this + 4);
    v10 = *(const char **)(v9 + 56);
    v11 = *(_QWORD *)(v9 + 64);
    if (v11 <= *((_QWORD *)v2 + 3) - (_QWORD)result)
      goto LABEL_5;
    return llvm::raw_ostream::write(v2, v10, v11);
  }
LABEL_10:
  v2 = llvm::raw_ostream::write(v2, " pattern: ", 0xAuLL);
  result = (llvm::raw_ostream *)*((_QWORD *)v2 + 4);
  v13 = *((_QWORD *)this + 4);
  v10 = *(const char **)(v13 + 56);
  v11 = *(_QWORD *)(v13 + 64);
  if (v11 > *((_QWORD *)v2 + 3) - (_QWORD)result)
    return llvm::raw_ostream::write(v2, v10, v11);
LABEL_5:
  if (v11)
  {
    result = (llvm::raw_ostream *)memcpy(result, v10, v11);
    *((_QWORD *)v2 + 4) += v11;
  }
  return result;
}

uint64_t llvm::function_ref<void ()(void)>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &,llvm::function_ref<BOOL ()(mlir::Pattern const&)>,llvm::function_ref<void ()(mlir::Pattern const&)>,llvm::function_ref<mlir::LogicalResult ()(mlir::Pattern const&)>)::$_0>(uint64_t *a1)
{
  uint64_t v2;
  ZinIrHalH13g **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;

  v2 = a1[5];
  v4 = *a1;
  v3 = (ZinIrHalH13g **)a1[1];
  v5 = *((_QWORD *)*v3 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(*v3);
  *(_QWORD *)(v4 + 24) = v5;
  *(_QWORD *)(v4 + 32) = v6;
  v7 = *(_QWORD *)a1[2];
  if (!v7)
  {
    v9 = *(_QWORD *)a1[6];
    if (v9)
      v10 = v9 - 8;
    else
      v10 = 0;
    result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 32))(v10, *(_QWORD *)a1[1], *a1);
    *(_BYTE *)a1[3] = result;
    if (!(_BYTE)result)
      goto LABEL_13;
LABEL_8:
    v11 = a1[7];
    if (*(_QWORD *)v11)
    {
      result = (*(uint64_t (**)(_QWORD, _QWORD))v11)(*(_QWORD *)(v11 + 8), *(_QWORD *)a1[6]);
      v12 = (_BYTE *)a1[3];
      if (!(_BYTE)result)
      {
        *v12 = 0;
        goto LABEL_13;
      }
      if (!*v12)
        goto LABEL_13;
    }
    *(_BYTE *)a1[8] = 1;
    return result;
  }
  result = mlir::detail::PDLByteCode::rewrite(*(_QWORD *)a1[4], *a1, v7, *(_QWORD *)(v2 + 56));
  *(_BYTE *)a1[3] = result;
  if ((_BYTE)result)
    goto LABEL_8;
LABEL_13:
  v13 = a1[9];
  if (*(_QWORD *)v13)
    return (*(uint64_t (**)(_QWORD, _QWORD))v13)(*(_QWORD *)(v13 + 8), *(_QWORD *)a1[6]);
  return result;
}

const char *mlir::scf::SCFDialect::initialize(mlir::scf::SCFDialect *this)
{
  char *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  uint64_t v5;
  const char *result;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t v18;

  mlir::Dialect::addOperations<mlir::scf::ConditionOp,mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::ForallOp,mlir::scf::IfOp,mlir::scf::InParallelOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::ReduceOp,mlir::scf::ReduceReturnOp,mlir::scf::WhileOp,mlir::scf::YieldOp>((uint64_t)this);
  v2 = (char *)operator new();
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v16 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v8 = v7;
    v2 = v16;
    if (v8)
    {
      v17 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      v18 = 79;
      v9 = llvm::StringRef::find((uint64_t *)&v17, "DesiredTypeName = ", 0x12uLL, 0);
      if (v18 >= v9)
        v10 = v9;
      else
        v10 = v18;
      v11 = &v17[v10];
      v12 = v18 - v10;
      if (v18 - v10 >= 0x12)
        v13 = 18;
      else
        v13 = v18 - v10;
      v14 = v12 - v13;
      if (v14 >= v14 - 1)
        v15 = v14 - 1;
      else
        v15 = v14;
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v16;
    }
  }
  v5 = v4[374];
  *((_QWORD *)v2 + 1) = this;
  *((_QWORD *)v2 + 2) = v5;
  *(_QWORD *)v2 = &off_24BFF28B0;
  v17 = v2;
  mlir::Dialect::addInterface((uint64_t)this, (uint64_t *)&v17);
  result = v17;
  v17 = 0;
  if (result)
    return (const char *)(*(uint64_t (**)(const char *))(*(_QWORD *)result + 8))(result);
  return result;
}

mlir::scf::SCFDialect *mlir::scf::SCFDialect::SCFDialect(mlir::scf::SCFDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v6;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"scf", 3, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::SCFDialect,void>::id);
  *v3 = off_24BFF4688;
  v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"arith", 5))
  {
    v6 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v6);
  }
  mlir::scf::SCFDialect::initialize(this);
  return this;
}

void mlir::scf::SCFDialect::~SCFDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_2074A1514()
{
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::Dialect::addOperations<mlir::scf::ConditionOp,mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::ForallOp,mlir::scf::IfOp,mlir::scf::InParallelOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::ReduceOp,mlir::scf::ReduceReturnOp,mlir::scf::WhileOp,mlir::scf::YieldOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;
  _QWORD *v14;

  v2 = (_QWORD *)operator new();
  v14 = mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v14, 0, 0);
  v3 = (uint64_t)v14;
  v14 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  mlir::RegisteredOperationName::insert<mlir::scf::ExecuteRegionOp>(a1);
  v4 = (_QWORD *)operator new();
  v14 = mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v14, 0, 0);
  v5 = (uint64_t)v14;
  v14 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = (_QWORD *)operator new();
  v14 = mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v14, (uint64_t)&mlir::scf::ForallOp::getAttributeNames(void)::attrNames, 5);
  v7 = (uint64_t)v14;
  v14 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  mlir::RegisteredOperationName::insert<mlir::scf::IfOp>(a1);
  v8 = (_QWORD *)operator new();
  v14 = mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v14, 0, 0);
  v9 = (uint64_t)v14;
  v14 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  mlir::RegisteredOperationName::insert<mlir::scf::IndexSwitchOp>(a1);
  v10 = (_QWORD *)operator new();
  v14 = mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::Model(v10, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v14, (uint64_t)&mlir::scf::ParallelOp::getAttributeNames(void)::attrNames, 1);
  v11 = (uint64_t)v14;
  v14 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  mlir::RegisteredOperationName::insert<mlir::scf::ReduceOp>(a1);
  mlir::RegisteredOperationName::insert<mlir::scf::ReduceReturnOp>(a1);
  mlir::RegisteredOperationName::insert<mlir::scf::WhileOp>(a1);
  v12 = (_QWORD *)operator new();
  v14 = mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::Model(v12, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v14, 0, 0);
  result = (uint64_t)v14;
  v14 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL mlir::scf::ExecuteRegionOp::parse(uint64_t a1, mlir::OperationState *a2)
{
  uint64_t v4;

  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 536))(a1, (uint64_t)a2 + 64)
    && (v4 = mlir::OperationState::addRegion(a2),
        (*(unsigned __int8 (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, 0, 0, 0)))
  {
    return (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, (uint64_t)a2 + 112) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::scf::ExecuteRegionOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  uint64_t v4;
  uint64_t v5;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  mlir::Operation *v9;
  mlir::ArrayAttr *v10;
  uint64_t Value;
  uint64_t v12;
  uint64_t v14[4];
  uint64_t v15[2];

  v4 = *((unsigned int *)*this + 9);
  v5 = (uint64_t)*this - 16;
  if (!(_DWORD)v4)
    v5 = 0;
  v15[0] = v5;
  v15[1] = v4;
  mlir::OperandRange::getTypes(v15, v14);
  if (v14[0] != v14[2] || v14[1] != v14[3])
    mlir::AsmPrinter::printArrowTypeList<mlir::ValueTypeRange<mlir::ResultRange> &>((uint64_t)a2, v14);
  v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (_BYTE *)*((_QWORD *)v7 + 4);
  if ((unint64_t)v8 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 32);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v8 + 1;
    *v8 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)a2 + 224))(a2, (((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), 0, 1, 0);
  v9 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v14[0] = mlir::Operation::getAttrDictionary(v9);
    v10 = (mlir::ArrayAttr *)v14;
  }
  else
  {
    v10 = (mlir::Operation *)((char *)v9 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v10);
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v12, 0, 0);
}

uint64_t mlir::scf::ExecuteRegionOp::verify(uint64_t **this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  const void **v20[4];
  __int16 v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD *v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v1 = (_QWORD *)((((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8]
                  + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                  + 7) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *((unsigned int *)*this + 10));
  if ((_QWORD *)*v1 == v1)
  {
    v20[0] = (const void **)"region needs to have at least one block";
    v21 = 259;
    mlir::OpState::emitOpError(this, v20, (uint64_t)v22);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
    if (v22[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
    if (v29)
    {
      v13 = __p;
      if (__p)
      {
        v14 = v28;
        v15 = __p;
        if (v28 != __p)
        {
          do
            v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          v15 = __p;
        }
        v28 = v13;
        operator delete(v15);
      }
      v8 = v25;
      if (!v25)
        goto LABEL_37;
      v16 = v26;
      v10 = v25;
      if (v26 == v25)
        goto LABEL_36;
      do
      {
        v18 = *--v16;
        v17 = v18;
        *v16 = 0;
        if (v18)
          MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
      }
      while (v16 != v8);
      goto LABEL_35;
    }
  }
  else
  {
    v2 = v1[1];
    if (v2)
      v3 = v2 - 8;
    else
      v3 = 0;
    if (((*(_QWORD *)(v3 + 56) - *(_QWORD *)(v3 + 48)) & 0x7FFFFFFF8) == 0)
      return 1;
    v20[0] = (const void **)"region cannot have any arguments";
    v21 = 259;
    mlir::OpState::emitOpError(this, v20, (uint64_t)v22);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
    if (v22[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
    if (v29)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v28;
        v7 = __p;
        if (v28 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v28 = v5;
        operator delete(v7);
      }
      v8 = v25;
      if (!v25)
        goto LABEL_37;
      v9 = v26;
      v10 = v25;
      if (v26 == v25)
      {
LABEL_36:
        v26 = v8;
        operator delete(v10);
LABEL_37:
        if (v23 != &v24)
          free(v23);
        return v4;
      }
      do
      {
        v12 = *--v9;
        v11 = v12;
        *v9 = 0;
        if (v12)
          MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
      }
      while (v9 != v8);
LABEL_35:
      v10 = v25;
      goto LABEL_36;
    }
  }
  return v4;
}

void mlir::scf::ConditionOp::getSuccessorRegions(mlir::Operation **a1, _QWORD **a2, uint64_t a3, uint64_t a4)
{
  mlir::Block *v8;
  unsigned int *ParentOp;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  __int128 v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  __int128 v34;
  unint64_t v35;
  BOOL v36;
  unint64_t v37;
  BOOL v38;
  char *v39;
  char *v40;
  _QWORD *v41;
  char v42[40];
  _QWORD **v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46[3];

  v46[2] = *MEMORY[0x24BDAC8D0];
  mlir::scf::detail::ConditionOpGenericAdaptorBase::ConditionOpGenericAdaptorBase((uint64_t)v42, *a1);
  v43 = a2;
  v44 = a3;
  v8 = (mlir::Block *)*((_QWORD *)*a1 + 2);
  if (v8)
  {
    ParentOp = (unsigned int *)mlir::Block::getParentOp(v8);
    v10 = *v43;
    if (*v43)
      goto LABEL_3;
LABEL_26:
    v41 = 0;
    v12 = ParentOp[11];
    if ((v12 & 0x7FFFFF) != 0)
    {
LABEL_9:
      v13 = (((unint64_t)&ParentOp[4 * ((v12 >> 23) & 1) + 17] + ((v12 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
          + 32 * ParentOp[10];
      v14 = v13 + 24;
      if (*(_QWORD *)(v13 + 24) != v13 + 24)
        goto LABEL_10;
      goto LABEL_28;
    }
LABEL_27:
    v13 = 0;
    v14 = 24;
    if (MEMORY[0x18] != 24)
    {
LABEL_10:
      v15 = *(_QWORD *)(v13 + 32);
      if (v15)
        v16 = v15 - 8;
      else
        v16 = 0;
      v17 = *(_QWORD *)(v16 + 48);
      v18 = (*(_QWORD *)(v16 + 56) - v17) >> 3;
      v19 = *(_DWORD *)(a4 + 8);
      if (v19 < *(_DWORD *)(a4 + 12))
        goto LABEL_14;
      goto LABEL_29;
    }
LABEL_28:
    v17 = 0;
    v18 = 0;
    v19 = *(_DWORD *)(a4 + 8);
    if (v19 < *(_DWORD *)(a4 + 12))
    {
LABEL_14:
      v20 = (uint64_t *)(*(_QWORD *)a4 + 24 * v19);
      *v20 = v14;
      mlir::ValueRange::ValueRange((unint64_t *)v20 + 1, v17, v18);
LABEL_15:
      ++*(_DWORD *)(a4 + 8);
      goto LABEL_16;
    }
LABEL_29:
    v45 = v14;
    v25 = (char *)&v45;
    mlir::ValueRange::ValueRange(v46, v17, v18);
    v26 = *(unsigned int *)(a4 + 8);
    v27 = *(_QWORD *)a4;
    if (v26 >= *(_DWORD *)(a4 + 12))
    {
      v35 = v26 + 1;
      v36 = v27 + 24 * v26 > (unint64_t)&v45;
      if (v27 <= (unint64_t)&v45 && v36)
      {
        v39 = (char *)&v46[-1] - v27;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v35, 24);
        v27 = *(_QWORD *)a4;
        v25 = &v39[*(_QWORD *)a4];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v35, 24);
        v27 = *(_QWORD *)a4;
        v25 = (char *)&v45;
      }
    }
    v28 = v27 + 24 * *(unsigned int *)(a4 + 8);
    v29 = *(_OWORD *)v25;
    *(_QWORD *)(v28 + 16) = *((_QWORD *)v25 + 2);
    *(_OWORD *)v28 = v29;
    goto LABEL_15;
  }
  ParentOp = 0;
  v10 = *a2;
  if (!v10)
    goto LABEL_26;
LABEL_3:
  if (mlir::BoolAttr::classof(v10))
    v11 = v10;
  else
    v11 = 0;
  v41 = v11;
  if (!v11 || mlir::BoolAttr::getValue((mlir::BoolAttr *)&v41))
  {
    v12 = ParentOp[11];
    if ((v12 & 0x7FFFFF) != 0)
      goto LABEL_9;
    goto LABEL_27;
  }
LABEL_16:
  if (!v41 || !mlir::BoolAttr::getValue((mlir::BoolAttr *)&v41))
  {
    v21 = ParentOp[9];
    if ((_DWORD)v21)
      v22 = (uint64_t)(ParentOp - 4);
    else
      v22 = 0;
    v23 = *(_DWORD *)(a4 + 8);
    if (v23 >= *(_DWORD *)(a4 + 12))
    {
      v45 = 0;
      v30 = (char *)&v45;
      mlir::ValueRange::ValueRange(v46, v22, v21);
      v31 = *(unsigned int *)(a4 + 8);
      v32 = *(_QWORD *)a4;
      if (v31 >= *(_DWORD *)(a4 + 12))
      {
        v37 = v31 + 1;
        v38 = v32 + 24 * v31 > (unint64_t)&v45;
        if (v32 <= (unint64_t)&v45 && v38)
        {
          v40 = (char *)&v46[-1] - v32;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v37, 24);
          v32 = *(_QWORD *)a4;
          v30 = &v40[*(_QWORD *)a4];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v37, 24);
          v32 = *(_QWORD *)a4;
          v30 = (char *)&v45;
        }
      }
      v33 = v32 + 24 * *(unsigned int *)(a4 + 8);
      v34 = *(_OWORD *)v30;
      *(_QWORD *)(v33 + 16) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v33 = v34;
    }
    else
    {
      v24 = (_QWORD *)(*(_QWORD *)a4 + 24 * v23);
      *v24 = 0;
      mlir::ValueRange::ValueRange(v24 + 1, v22, v21);
    }
    ++*(_DWORD *)(a4 + 8);
  }
}

unint64_t mlir::scf::WhileOp::getAfter(mlir::scf::WhileOp *this)
{
  unint64_t v1;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  if ((v1 & 0x7FFFFF) != 0)
    return ((*(_QWORD *)this + 16 * ((v1 >> 23) & 1) + ((v1 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
         + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
         + 24;
  else
    return 24;
}

_QWORD *mlir::scf::ForOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t), uint64_t a10)
{
  uint64_t v15;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t Loc;
  _QWORD *result;
  _OWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  unint64_t v37[2];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41[3];

  v41[2] = *MEMORY[0x24BDAC8D0];
  v38 = a3;
  v39 = a4;
  v40 = a5;
  mlir::ValueRange::ValueRange(v41, (uint64_t)&v38, 3uLL);
  mlir::OperationState::addOperands(a2, v41[0], v41[1]);
  mlir::OperationState::addOperands(a2, a6, a7);
  v38 = a6;
  v39 = 0;
  if (a7)
  {
    v15 = 0;
    do
    {
      v17 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v38, v15) + 8);
      v18 = *(unsigned int *)(a2 + 72);
      if (v18 >= *(unsigned int *)(a2 + 76))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18 + 1, 8);
        v18 = *(unsigned int *)(a2 + 72);
      }
      *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v18) = v17 & 0xFFFFFFFFFFFFFFF8;
      ++*(_DWORD *)(a2 + 72);
      v15 = ++v39;
    }
    while (v38 != a6 || v15 != a7);
  }
  v19 = *(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8;
  v20 = (uint64_t *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  v21 = operator new();
  *(_OWORD *)v21 = 0u;
  *(_OWORD *)(v21 + 16) = 0u;
  *(_QWORD *)(v21 + 32) = v21 + 32;
  *(_QWORD *)(v21 + 40) = v21 + 32;
  *(_QWORD *)(v21 + 56) = 0;
  *(_QWORD *)(v21 + 64) = 0;
  *(_QWORD *)(v21 + 48) = 0;
  llvm::ilist_traits<mlir::Block>::addNodeToList((uint64_t)v20, v21);
  v22 = *v20;
  *(_QWORD *)(v21 + 16) = v20;
  *(_QWORD *)(v21 + 8) = v22;
  v21 += 8;
  *(_QWORD *)(v22 + 8) = v21;
  *v20 = v21;
  v23 = v20[1];
  if (v23)
    v24 = (_QWORD *)(v23 - 8);
  else
    v24 = 0;
  mlir::Block::addArgument(v24, v19, *(_QWORD *)a2);
  v38 = a6;
  v39 = 0;
  if (!a7)
  {
    if (!a9)
      return (_QWORD *)mlir::impl::ensureRegionTerminator(v20, a1, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::buildTerminator);
    goto LABEL_22;
  }
  v25 = 0;
  do
  {
    v36 = mlir::ValueRange::dereference_iterator(&v38, v25);
    v26 = *(_QWORD *)(v36 + 8) & 0xFFFFFFFFFFFFFFF8;
    Loc = mlir::Value::getLoc((mlir::Value *)&v36);
    result = mlir::Block::addArgument(v24, v26, Loc);
    v25 = ++v39;
  }
  while (v38 != a6 || v25 != a7);
  if (a9)
  {
LABEL_22:
    v30 = (_OWORD *)(a1 + 16);
    v35 = *(_OWORD *)(a1 + 16);
    v31 = v24[5];
    *(_QWORD *)(a1 + 16) = v24;
    *(_QWORD *)(a1 + 24) = v31;
    v32 = *(_QWORD *)a2;
    v33 = (uint64_t *)v24[6];
    v34 = *v33;
    mlir::ValueRange::ValueRange(v37, (uint64_t)(v33 + 1), ((uint64_t)(v24[7] - (_QWORD)v33) >> 3) - 1);
    result = (_QWORD *)a9(a10, a1, v32, v34, v37[0], v37[1]);
    if ((_QWORD)v35)
    {
      *v30 = v35;
    }
    else
    {
      *(_QWORD *)v30 = 0;
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  return result;
}

uint64_t mlir::scf::ForOp::verify(uint64_t **this)
{
  uint64_t DefiningOp;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  const void **v21[4];
  __int16 v22;
  unint64_t v23;
  void *v24[2];
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  _QWORD *v29;
  void *__p;
  _QWORD *v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v23 = 0;
  v21[0] = *(const void ***)((*this)[9] + 88);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v21);
  if (!DefiningOp)
    goto LABEL_13;
  v3 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    goto LABEL_13;
  v24[0] = &v25;
  v24[1] = (void *)0x100000000;
  mlir::Operation::fold(v3, 0, 0, (uint64_t)v24);
  v4 = (*(_QWORD *)v24[0] & 0xFFFFFFFFFFFFFFF8) == 0
    || *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v24[0] & 0xFFFFFFFFFFFFFFF8) + 136) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
  if (!v4)
    v23 = *(_QWORD *)v24[0] & 0xFFFFFFFFFFFFFFF8;
  if (v24[0] != &v25)
    free(v24[0]);
  if (!v4 && mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v23) <= 0)
  {
    v21[0] = (const void **)"constant step operand must be positive";
    v22 = 259;
    mlir::OpState::emitOpError(this, v21, (uint64_t)v24);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v24);
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    if (v32)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v31;
        v16 = __p;
        if (v31 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v31 = v14;
        operator delete(v16);
      }
      v9 = v28;
      if (!v28)
        goto LABEL_45;
      v17 = v29;
      v11 = v28;
      if (v29 == v28)
        goto LABEL_44;
      do
      {
        v19 = *--v17;
        v18 = v19;
        *v17 = 0;
        if (v19)
          MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
      }
      while (v17 != v9);
      goto LABEL_43;
    }
  }
  else
  {
LABEL_13:
    if ((*((_BYTE *)*this + 46) & 0x80) != 0 && *((unsigned int *)*this + 17) - 3 == *((_DWORD *)*this + 9))
      return 1;
    v21[0] = (const void **)"mismatch in number of loop-carried values and defined values";
    v22 = 259;
    mlir::OpState::emitOpError(this, v21, (uint64_t)v24);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v24);
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    if (v32)
    {
      v6 = __p;
      if (__p)
      {
        v7 = v31;
        v8 = __p;
        if (v31 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v31 = v6;
        operator delete(v8);
      }
      v9 = v28;
      if (!v28)
        goto LABEL_45;
      v10 = v29;
      v11 = v28;
      if (v29 == v28)
      {
LABEL_44:
        v29 = v9;
        operator delete(v11);
LABEL_45:
        if (v26 != &v27)
          free(v26);
        return v5;
      }
      do
      {
        v13 = *--v10;
        v12 = v13;
        *v10 = 0;
        if (v13)
          MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
      }
      while (v10 != v9);
LABEL_43:
      v11 = v28;
      goto LABEL_44;
    }
  }
  return v5;
}

uint64_t mlir::scf::ForOp::verifyRegions(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t NextResultAtOffset;
  unint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  char *v42;
  char *v43;
  __int128 v44;
  uint64_t v45;
  int *v46;
  char *v47;
  char *v48;
  __int128 v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  int *v56;
  char *v57;
  char *v58;
  __int128 v59;
  uint64_t v60;
  int *v61;
  char *v62;
  char *v63;
  __int128 v64;
  uint64_t v65;
  int *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  BOOL v82;
  unint64_t v83;
  BOOL v84;
  unint64_t v85;
  BOOL v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  const void **v93[4];
  __int16 v94;
  int v95;
  const char *v96;
  uint64_t v97;
  _QWORD v98[3];
  void *v99;
  unsigned int v100;
  unsigned int v101;
  _BYTE v102[96];
  void *v103;
  _QWORD *v104;
  void *__p;
  _QWORD *v106;
  char v107;
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = *(_QWORD *)((((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8]
                   + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)*this + 10)
                 + 8);
  if (v3)
    v4 = v3 - 8;
  else
    v4 = 0;
  v5 = *(_QWORD *)(v4 + 48);
  v6 = v2[9];
  if ((*(_QWORD *)(*(_QWORD *)v5 + 8) & 0xFFFFFFFFFFFFFFF8) == (*(_QWORD *)(*(_QWORD *)(v6 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v16 = *(_QWORD *)(v4 + 56) - v5;
    v17 = ((unint64_t)v16 >> 3) - 1;
    if ((_DWORD)v17 == *((_DWORD *)v2 + 9))
    {
      v18 = *((unsigned int *)v2 + 17);
      v19 = (uint64_t)(v2 - 2);
      if (((unint64_t)v16 >> 3) == 1)
        v20 = 0;
      else
        v20 = v19;
      v7 = 1;
      if ((_DWORD)v18 != 3 && v16 != 8)
      {
        v21 = 0;
        v22 = v5 + 8;
        v23 = 8 * (v16 >> 3) - 16;
        v24 = (uint64_t *)(v6 + 120);
        v25 = v18 - 4;
        while (1)
        {
          if (v17 == v21)
            return 1;
          v26 = *v24;
          NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
          v28 = *(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8;
          if (v28 != (*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
            break;
          if ((*(_QWORD *)(*(_QWORD *)(v22 + 8 * v21) + 8) & 0xFFFFFFFFFFFFFFF8) != v28)
          {
            v94 = 257;
            mlir::OpState::emitOpError(this, v93, (uint64_t)v98);
            if (v98[0])
            {
              v95 = 3;
              v96 = "types mismatch between ";
              v97 = 23;
              v56 = &v95;
              v57 = (char *)v99;
              if (v100 >= v101)
              {
                v78 = v100 + 1;
                if (v99 <= &v95 && (char *)v99 + 24 * v100 > (char *)&v95)
                {
                  v88 = (char *)&v95 - (_BYTE *)v99;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v78, 24);
                  v57 = (char *)v99;
                  v56 = (int *)((char *)v99 + v88);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v78, 24);
                  v56 = &v95;
                  v57 = (char *)v99;
                }
              }
              v58 = &v57[24 * v100];
              v59 = *(_OWORD *)v56;
              *((_QWORD *)v58 + 2) = *((_QWORD *)v56 + 2);
              *(_OWORD *)v58 = v59;
              v60 = ++v100;
              if (v98[0])
              {
                v95 = 5;
                v96 = (const char *)v21;
                v61 = &v95;
                v62 = (char *)v99;
                if (v60 >= v101)
                {
                  v81 = v60 + 1;
                  v82 = (char *)v99 + 24 * v60 > (char *)&v95;
                  if (v99 <= &v95 && v82)
                  {
                    v90 = (char *)&v95 - (_BYTE *)v99;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v81, 24);
                    v62 = (char *)v99;
                    v61 = (int *)((char *)v99 + v90);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v81, 24);
                    v61 = &v95;
                    v62 = (char *)v99;
                  }
                }
                v63 = &v62[24 * v100];
                v64 = *(_OWORD *)v61;
                *((_QWORD *)v63 + 2) = *((_QWORD *)v61 + 2);
                *(_OWORD *)v63 = v64;
                v65 = ++v100;
                if (v98[0])
                {
                  v95 = 3;
                  v96 = "th iter region arg and defined value";
                  v97 = 36;
                  v66 = &v95;
                  v67 = (char *)v99;
                  if (v65 >= v101)
                  {
                    v85 = v65 + 1;
                    v86 = (char *)v99 + 24 * v65 > (char *)&v95;
                    if (v99 <= &v95 && v86)
                    {
                      v92 = (char *)&v95 - (_BYTE *)v99;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v85, 24);
                      v67 = (char *)v99;
                      v66 = (int *)((char *)v99 + v92);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v85, 24);
                      v66 = &v95;
                      v67 = (char *)v99;
                    }
                  }
                  v68 = &v67[24 * v100];
                  v69 = *(_OWORD *)v66;
                  *((_QWORD *)v68 + 2) = *((_QWORD *)v66 + 2);
                  *(_OWORD *)v68 = v69;
                  ++v100;
                }
              }
            }
            v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v98);
            if (v98[0])
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v98);
            if (!v107)
              return v7;
            v70 = __p;
            if (__p)
            {
              v71 = v106;
              v72 = __p;
              if (v106 != __p)
              {
                do
                  v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
                while (v71 != v70);
                v72 = __p;
              }
              v106 = v70;
              operator delete(v72);
            }
            v11 = v103;
            if (!v103)
              goto LABEL_91;
            v73 = v104;
            v13 = v103;
            if (v104 == v103)
              goto LABEL_90;
            do
            {
              v75 = *--v73;
              v74 = v75;
              *v73 = 0;
              if (v75)
                MEMORY[0x20BD002D4](v74, 0x1000C8077774924);
            }
            while (v73 != v11);
            goto LABEL_89;
          }
          v7 = 1;
          if (v25 != v21)
          {
            ++v21;
            v29 = v23;
            v23 -= 8;
            v24 += 4;
            if (v29)
              continue;
          }
          return v7;
        }
        v94 = 257;
        mlir::OpState::emitOpError(this, v93, (uint64_t)v98);
        if (v98[0])
        {
          v95 = 3;
          v96 = "types mismatch between ";
          v97 = 23;
          v36 = &v95;
          v37 = (char *)v99;
          if (v100 >= v101)
          {
            v77 = v100 + 1;
            if (v99 <= &v95 && (char *)v99 + 24 * v100 > (char *)&v95)
            {
              v87 = (char *)&v95 - (_BYTE *)v99;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v77, 24);
              v37 = (char *)v99;
              v36 = (int *)((char *)v99 + v87);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v77, 24);
              v36 = &v95;
              v37 = (char *)v99;
            }
          }
          v38 = &v37[24 * v100];
          v39 = *(_OWORD *)v36;
          *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
          *(_OWORD *)v38 = v39;
          v40 = ++v100;
          if (v98[0])
          {
            v95 = 5;
            v96 = (const char *)v21;
            v41 = &v95;
            v42 = (char *)v99;
            if (v40 >= v101)
            {
              v79 = v40 + 1;
              v80 = (char *)v99 + 24 * v40 > (char *)&v95;
              if (v99 <= &v95 && v80)
              {
                v89 = (char *)&v95 - (_BYTE *)v99;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v79, 24);
                v42 = (char *)v99;
                v41 = (int *)((char *)v99 + v89);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v79, 24);
                v41 = &v95;
                v42 = (char *)v99;
              }
            }
            v43 = &v42[24 * v100];
            v44 = *(_OWORD *)v41;
            *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
            *(_OWORD *)v43 = v44;
            v45 = ++v100;
            if (v98[0])
            {
              v95 = 3;
              v96 = "th iter operand and defined value";
              v97 = 33;
              v46 = &v95;
              v47 = (char *)v99;
              if (v45 >= v101)
              {
                v83 = v45 + 1;
                v84 = (char *)v99 + 24 * v45 > (char *)&v95;
                if (v99 <= &v95 && v84)
                {
                  v91 = (char *)&v95 - (_BYTE *)v99;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v83, 24);
                  v47 = (char *)v99;
                  v46 = (int *)((char *)v99 + v91);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v83, 24);
                  v46 = &v95;
                  v47 = (char *)v99;
                }
              }
              v48 = &v47[24 * v100];
              v49 = *(_OWORD *)v46;
              *((_QWORD *)v48 + 2) = *((_QWORD *)v46 + 2);
              *(_OWORD *)v48 = v49;
              ++v100;
            }
          }
        }
        v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v98);
        if (v98[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v98);
        if (!v107)
          return v7;
        v50 = __p;
        if (__p)
        {
          v51 = v106;
          v52 = __p;
          if (v106 != __p)
          {
            do
              v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
            while (v51 != v50);
            v52 = __p;
          }
          v106 = v50;
          operator delete(v52);
        }
        v11 = v103;
        if (!v103)
          goto LABEL_91;
        v53 = v104;
        v13 = v103;
        if (v104 == v103)
          goto LABEL_90;
        do
        {
          v55 = *--v53;
          v54 = v55;
          *v53 = 0;
          if (v55)
            MEMORY[0x20BD002D4](v54, 0x1000C8077774924);
        }
        while (v53 != v11);
        goto LABEL_89;
      }
    }
    else
    {
      v93[0] = (const void **)"mismatch in number of basic block args and defined values";
      v94 = 259;
      mlir::OpState::emitOpError(this, v93, (uint64_t)v98);
      v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v98);
      if (v98[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v98);
      if (v107)
      {
        v30 = __p;
        if (__p)
        {
          v31 = v106;
          v32 = __p;
          if (v106 != __p)
          {
            do
              v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
            while (v31 != v30);
            v32 = __p;
          }
          v106 = v30;
          operator delete(v32);
        }
        v11 = v103;
        if (!v103)
          goto LABEL_91;
        v33 = v104;
        v13 = v103;
        if (v104 == v103)
          goto LABEL_90;
        do
        {
          v35 = *--v33;
          v34 = v35;
          *v33 = 0;
          if (v35)
            MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
        }
        while (v33 != v11);
        goto LABEL_89;
      }
    }
  }
  else
  {
    v93[0] = (const void **)"expected induction variable to be same type as bounds and step";
    v94 = 259;
    mlir::OpState::emitOpError(this, v93, (uint64_t)v98);
    v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v98);
    if (v98[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v98);
    if (v107)
    {
      v8 = __p;
      if (__p)
      {
        v9 = v106;
        v10 = __p;
        if (v106 != __p)
        {
          do
            v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          v10 = __p;
        }
        v106 = v8;
        operator delete(v10);
      }
      v11 = v103;
      if (!v103)
        goto LABEL_91;
      v12 = v104;
      v13 = v103;
      if (v104 == v103)
      {
LABEL_90:
        v104 = v11;
        operator delete(v13);
LABEL_91:
        if (v99 != v102)
          free(v99);
        return v7;
      }
      do
      {
        v15 = *--v12;
        v14 = v15;
        *v12 = 0;
        if (v15)
          MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
      }
      while (v12 != v11);
LABEL_89:
      v13 = v103;
      goto LABEL_90;
    }
  }
  return v7;
}

uint64_t mlir::scf::ForOp::promoteIfSingleIteration(mlir::scf::ForOp *this, mlir::RewriterBase *a2)
{
  uint64_t v4;
  char v5;
  BOOL v6;
  uint64_t v8;
  ZinIrHalH13g **v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t YieldedValues;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27[3];

  v27[2] = *MEMORY[0x24BDAC8D0];
  v4 = mlir::constantTripCount(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) | 4, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 56) | 4, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 88) | 4);
  if (v5)
    v6 = v4 == 1;
  else
    v6 = 0;
  if (!v6)
    return 0;
  v8 = *(_QWORD *)(((*(_QWORD *)this
                   + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                 + 8);
  if (v8)
    v9 = (ZinIrHalH13g **)(v8 - 8);
  else
    v9 = 0;
  mlir::Block::getTerminator(v9);
  v11 = v10;
  v12 = *(unsigned int *)(*(_QWORD *)this + 36);
  if ((_DWORD)v12)
    v13 = *(_QWORD *)this - 16;
  else
    v13 = 0;
  mlir::ValueRange::ValueRange(v27, v13, v12);
  YieldedValues = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues((uint64_t)this);
  mlir::RewriterBase::replaceAllUsesWith((uint64_t)a2, v27[0], v27[1], YieldedValues, v15);
  v23 = &v25;
  v16 = *(_QWORD *)this;
  v17 = *(_QWORD *)(*(_QWORD *)this + 72);
  v25 = *(_QWORD *)(v17 + 24);
  v24 = 0x600000001;
  llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>((uint64_t)&v23, (uint64_t)&v26, v17 + 96, 0, v17 + 96, *(unsigned int *)(v16 + 68) - 3);
  v18 = *(_QWORD *)this;
  v19 = *(_QWORD *)(((*(_QWORD *)this
                    + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                  + 8);
  if (v19)
    v20 = v19 - 8;
  else
    v20 = 0;
  v21 = *(_QWORD *)(v18 + 16);
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  (*(void (**)(mlir::RewriterBase *, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a2 + 56))(a2, v20, v21, v18, v22[0], v22[1]);
  (*(void (**)(mlir::RewriterBase *, uint64_t))(*(_QWORD *)a2 + 40))(a2, v11);
  (*(void (**)(mlir::RewriterBase *, _QWORD))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)this);
  if (v23 != &v25)
    free(v23);
  return 1;
}

uint64_t mlir::RewriterBase::replaceAllUsesWith(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v21 = a2;
  v22 = 0;
  v23 = a4;
  v24 = 0;
  if (a3)
  {
    v9 = result;
    v10 = 0;
    v11 = 0;
    do
    {
      if (v23 == a4 && v11 == a5)
        break;
      v14 = (uint64_t **)mlir::ValueRange::dereference_iterator(&v21, v10);
      result = mlir::ValueRange::dereference_iterator(&v23, v24);
      v15 = *v14;
      if (*v14)
      {
        v16 = (uint64_t *)result;
        do
        {
          v17 = (uint64_t *)*v15;
          v18 = v15[2];
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 72))(v9, v18);
          v19 = (uint64_t *)v15[1];
          if (v19)
          {
            *v19 = *v15;
            if (*v15)
              *(_QWORD *)(*v15 + 8) = v15[1];
          }
          v15[3] = (uint64_t)v16;
          v15[1] = (uint64_t)v16;
          v20 = *v16;
          *v15 = *v16;
          if (v20)
            *(_QWORD *)(v20 + 8) = v15;
          *v16 = (uint64_t)v15;
          result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 80))(v9, v18);
          v15 = v17;
        }
        while (v17);
      }
      v10 = v22 + 1;
      v11 = v24 + 1;
      ++v22;
      ++v24;
    }
    while (v21 != a2 || v10 != a3);
  }
  return result;
}

unint64_t mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues(uint64_t a1)
{
  uint64_t v1;
  ZinIrHalH13g **v2;
  uint64_t v3;
  int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int OperandNumber;
  uint64_t v10;
  unint64_t v12;
  unsigned int v13[4];
  void *v14;
  _QWORD v15[4];

  v15[3] = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(((*(_QWORD *)a1
                   + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)a1 + 40)
                 + 8);
  if (v1)
    v2 = (ZinIrHalH13g **)(v1 - 8);
  else
    v2 = 0;
  mlir::Block::getTerminator(v2);
  if ((*(_BYTE *)(v3 + 46) & 0x80) != 0)
    v4 = *(_DWORD *)(v3 + 68);
  else
    v4 = 0;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v13, v3, 0, v4, 0, 0);
  v5 = mlir::MutableOperandRange::operator mlir::OperandRange(v13);
  v7 = v6;
  if (v14 != v15)
    free(v14);
  if (v7)
  {
    v8 = *(_QWORD *)(v5 + 16);
    OperandNumber = mlir::OpOperand::getOperandNumber(v5);
    if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
      v10 = *(_QWORD *)(v8 + 72);
    else
      v10 = 0;
    mlir::ValueRange::ValueRange(&v12, v10 + 32 * OperandNumber, v7);
  }
  else
  {
    mlir::ValueRange::ValueRange(&v12, 0, 0);
  }
  return v12;
}

uint64_t mlir::scf::ForOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _DWORD *v11;
  llvm::raw_ostream *v12;
  uint64_t v13;
  mlir::Operation *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  llvm::raw_ostream *v24;
  uint64_t v25;
  mlir::Operation *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  llvm::raw_ostream *v30;
  _BYTE *v31;
  llvm::raw_ostream *v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  llvm::raw_ostream *v36;
  uint64_t v37;
  llvm::raw_ostream *v38;
  _BYTE *v39;
  mlir::Operation *v40;
  unint64_t v41;
  unint64_t v42;
  _BOOL8 v43;
  mlir::Operation *v44;
  mlir::ArrayAttr *v45;
  uint64_t Value;
  uint64_t v47;
  uint64_t v49[2];
  uint64_t v50[4];
  _QWORD v51[2];
  unint64_t v52[3];

  v52[2] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, " ", 1uLL);
  }
  else
  {
    *v5 = 32;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_QWORD *)((((unint64_t)*this
                   + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                   + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)*this + 10)
                 + 8);
  if (v6)
    v7 = v6 - 8;
  else
    v7 = 0;
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, **(_QWORD **)(v7 + 48));
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = *((_QWORD *)v8 + 4);
  if ((unint64_t)(*((_QWORD *)v8 + 3) - v9) > 2)
  {
    *(_BYTE *)(v9 + 2) = 32;
    *(_WORD *)v9 = 15648;
    *((_QWORD *)v8 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v8, " = ", 3uLL);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_DWORD *)*((_QWORD *)v10 + 4);
  if (*((_QWORD *)v10 + 3) - (_QWORD)v11 > 3uLL)
  {
    *v11 = 544175136;
    *((_QWORD *)v10 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v10, " to ", 4uLL);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 56));
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = *((_QWORD *)v12 + 4);
  if ((unint64_t)(*((_QWORD *)v12 + 3) - v13) > 5)
  {
    *(_WORD *)(v13 + 4) = 8304;
    *(_DWORD *)v13 = 1702130464;
    *((_QWORD *)v12 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v12, " step ", 6uLL);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 88));
  v14 = *this;
  v15 = *((unsigned int *)*this + 11);
  v16 = *(_QWORD *)((((unint64_t)*this + 16 * ((v15 >> 23) & 1) + ((v15 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)*this + 10)
                  + 8);
  if (v16)
    v17 = v16 - 8;
  else
    v17 = 0;
  v18 = *(_QWORD *)(v17 + 48);
  v19 = ((*(_QWORD *)(v17 + 56) - v18) >> 3) - 1;
  v20 = (_QWORD *)(v18 + 8);
  if ((v15 & 0x800000) != 0)
  {
    v21 = *((unsigned int *)v14 + 17);
    v22 = *((_QWORD *)v14 + 9);
    v23 = v21 - 3;
  }
  else
  {
    v22 = 0;
    v23 = -3;
  }
  mlir::ValueRange::ValueRange(v52, v22 + 96, v23);
  printInitializationList(a2, v20, v19, v52[0], v52[1], " iter_args", 0xAuLL);
  if ((*((_BYTE *)*this + 46) & 0x80) == 0 || *((_DWORD *)*this + 17) != 3)
  {
    v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v25 = *((_QWORD *)v24 + 4);
    if ((unint64_t)(*((_QWORD *)v24 + 3) - v25) > 4)
    {
      *(_BYTE *)(v25 + 4) = 40;
      *(_DWORD *)v25 = 540945696;
      *((_QWORD *)v24 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v24, " -> (", 5uLL);
    }
    v26 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
      v27 = *((unsigned int *)v26 + 17);
      v28 = *((_QWORD *)v26 + 9);
      v29 = v27 - 3;
    }
    else
    {
      v28 = 0;
      v29 = -3;
    }
    v49[0] = v28 + 96;
    v49[1] = v29;
    mlir::OperandRange::getTypes(v49, v50);
    v51[0] = ", ";
    v51[1] = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(v50[0], v50[1], v50[2], v50[3], (uint64_t)a2, (uint64_t)a2, (uint64_t)v51);
    v30 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v31 = (_BYTE *)*((_QWORD *)v30 + 4);
    if ((unint64_t)v31 >= *((_QWORD *)v30 + 3))
    {
      llvm::raw_ostream::write(v30, 41);
    }
    else
    {
      *((_QWORD *)v30 + 4) = v31 + 1;
      *v31 = 41;
    }
  }
  v32 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v33 = (_BYTE *)*((_QWORD *)v32 + 4);
  if ((unint64_t)v33 >= *((_QWORD *)v32 + 3))
  {
    llvm::raw_ostream::write(v32, 32);
  }
  else
  {
    *((_QWORD *)v32 + 4) = v33 + 1;
    *v33 = 32;
  }
  v34 = *(_QWORD *)((((unint64_t)*this
                    + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)*this + 10)
                  + 8);
  if (v34)
    v35 = v34 - 8;
  else
    v35 = 0;
  v50[0] = *(_QWORD *)(**(_QWORD **)(v35 + 48) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (mlir::Type::isIndex((mlir::Type *)v50))
  {
LABEL_43:
    v40 = *this;
    v41 = *((unsigned int *)*this + 11);
    if ((v41 & 0x7FFFFF) != 0)
      goto LABEL_44;
LABEL_51:
    v42 = 0;
    if ((v41 & 0x800000) != 0)
      goto LABEL_45;
    goto LABEL_52;
  }
  v36 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v37 = *((_QWORD *)v36 + 4);
  if ((unint64_t)(*((_QWORD *)v36 + 3) - v37) > 2)
  {
    *(_BYTE *)(v37 + 2) = 32;
    *(_WORD *)v37 = 14880;
    *((_QWORD *)v36 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v36, " : ", 3uLL);
  }
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v50[0]);
  v38 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v39 = (_BYTE *)*((_QWORD *)v38 + 4);
  if ((unint64_t)v39 < *((_QWORD *)v38 + 3))
  {
    *((_QWORD *)v38 + 4) = v39 + 1;
    *v39 = 32;
    goto LABEL_43;
  }
  llvm::raw_ostream::write(v38, 32);
  v40 = *this;
  v41 = *((unsigned int *)*this + 11);
  if ((v41 & 0x7FFFFF) == 0)
    goto LABEL_51;
LABEL_44:
  v42 = (((unint64_t)v40 + 16 * ((v41 >> 23) & 1) + ((v41 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
      + 32 * *((unsigned int *)v40 + 10);
  if ((v41 & 0x800000) != 0)
  {
LABEL_45:
    v43 = *((_DWORD *)v40 + 17) != 3;
    goto LABEL_46;
  }
LABEL_52:
  v43 = 1;
LABEL_46:
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, _BOOL8, _QWORD))(*(_QWORD *)a2 + 224))(a2, v42, 0, v43, 0);
  v44 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v50[0] = mlir::Operation::getAttrDictionary(v44);
    v45 = (mlir::ArrayAttr *)v50;
  }
  else
  {
    v45 = (mlir::Operation *)((char *)v44 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v45);
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v47, 0, 0);
}

llvm::raw_ostream *printInitializationList(llvm::raw_ostream *result, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, size_t a7)
{
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  void *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  _QWORD *v18;
  uint64_t v19;
  llvm::raw_ostream *v20;
  uint64_t v21;
  uint64_t v22;
  llvm::raw_ostream *v24;
  _WORD *v25;
  uint64_t v26;
  llvm::raw_ostream *v27;
  uint64_t v28;
  _BYTE *v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    v13 = result;
    v14 = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)result + 16))(result);
    v15 = (void *)*((_QWORD *)v14 + 4);
    if (a7 <= *((_QWORD *)v14 + 3) - (_QWORD)v15)
    {
      if (a7)
      {
        memcpy(v15, a6, a7);
        *((_QWORD *)v14 + 4) += a7;
      }
    }
    else
    {
      llvm::raw_ostream::write(v14, (const char *)a6, a7);
    }
    v16 = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)v13 + 16))(v13);
    v17 = (_BYTE *)*((_QWORD *)v16 + 4);
    if ((unint64_t)v17 >= *((_QWORD *)v16 + 3))
    {
      llvm::raw_ostream::write(v16, 40);
      v30 = a2;
      v32 = a4;
      v33 = 0;
      if (!a3)
        goto LABEL_26;
    }
    else
    {
      *((_QWORD *)v16 + 4) = v17 + 1;
      *v17 = 40;
      v30 = a2;
      v32 = a4;
      v33 = 0;
      if (!a3)
      {
LABEL_26:
        result = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)v13 + 16))(v13);
        v29 = (_BYTE *)*((_QWORD *)result + 4);
        if (*((_BYTE **)result + 3) == v29)
          return llvm::raw_ostream::write(result, ")", 1uLL);
        *v29 = 41;
        ++*((_QWORD *)result + 4);
        return result;
      }
    }
    v18 = &a2[a3];
    v19 = mlir::ValueRange::dereference_iterator(&v32, 0);
    (*(void (**)(llvm::raw_ostream *, _QWORD))(*(_QWORD *)v13 + 160))(v13, *a2);
    v20 = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)v13 + 16))(v13);
    v21 = *((_QWORD *)v20 + 4);
    if ((unint64_t)(*((_QWORD *)v20 + 3) - v21) > 2)
    {
      *(_BYTE *)(v21 + 2) = 32;
      *(_WORD *)v21 = 15648;
      *((_QWORD *)v20 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(v20, " = ", 3uLL);
    }
    (*(void (**)(llvm::raw_ostream *, uint64_t))(*(_QWORD *)v13 + 160))(v13, v19);
    v22 = v33 + 1;
    v31 = v30 + 1;
    ++v33;
    for (; v31 != v18; ++v33)
    {
      if (v32 == a4 && v22 == a5)
        break;
      v24 = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)v13 + 16))(v13);
      v25 = (_WORD *)*((_QWORD *)v24 + 4);
      if (*((_QWORD *)v24 + 3) - (_QWORD)v25 > 1uLL)
      {
        *v25 = 8236;
        *((_QWORD *)v24 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v24, ", ", 2uLL);
      }
      v26 = mlir::ValueRange::dereference_iterator(&v32, v33);
      (*(void (**)(llvm::raw_ostream *, _QWORD))(*(_QWORD *)v13 + 160))(v13, *v31);
      v27 = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)v13 + 16))(v13);
      v28 = *((_QWORD *)v27 + 4);
      if ((unint64_t)(*((_QWORD *)v27 + 3) - v28) > 2)
      {
        *(_BYTE *)(v28 + 2) = 32;
        *(_WORD *)v28 = 15648;
        *((_QWORD *)v27 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(v27, " = ", 3uLL);
      }
      (*(void (**)(llvm::raw_ostream *, uint64_t))(*(_QWORD *)v13 + 160))(v13, v26);
      v22 = v33 + 1;
      ++v31;
    }
    goto LABEL_26;
  }
  return result;
}

uint64_t mlir::scf::ForOp::parse(uint64_t a1, uint64_t a2)
{
  mlir::IndexType **v4;
  __n128 v5;
  char v6;
  mlir::MLIRContext *v7;
  uint64_t IndexType;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  _QWORD *v15;
  unint64_t v16;
  BOOL v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  const char *v22;
  __int16 v23;
  _QWORD v24[4];
  _QWORD v25[4];
  _QWORD v26[4];
  _QWORD v27[6];
  char v28;
  char v29;
  uint64_t v30;
  void *v31[24];
  void *v32;
  uint64_t v33;
  _BYTE v34[128];
  void *v35;
  uint64_t v36;
  _BYTE v37[16];
  __int16 v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v4 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v30 = 0;
  memset(v27, 0, 24);
  v29 = 0;
  v27[4] = 0;
  v27[5] = 0;
  v28 = 0;
  memset(v26, 0, 24);
  memset(v25, 0, 24);
  memset(v24, 0, 24);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v27, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v26, 1))
    return 0;
  v38 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "to", 2, &v35))return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v25, 1))
    return 0;
  v38 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "step", 4, &v35)|| !(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v24, 1))
  {
    return 0;
  }
  v35 = v37;
  v36 = 0x400000000;
  v32 = v34;
  v33 = 0x400000000;
  v5 = llvm::SmallVectorTemplateBase<mlir::OpAsmParser::Argument,true>::push_back((uint64_t)&v35, (unint64_t)v27);
  v6 = (*(uint64_t (**)(uint64_t, const char *, uint64_t, __n128))(*(_QWORD *)a1 + 376))(a1, "iter_args", 9, v5);
  if (v6
    && (!mlir::OpAsmParser::parseAssignmentList(a1)
     || !(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 528))(a1, a2 + 64)))
  {
    goto LABEL_34;
  }
  if (*(unsigned int *)(a2 + 72) + 1 == v36)
  {
    if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 112))(a1))
    {
      if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v30))
        goto LABEL_34;
      IndexType = v30;
    }
    else
    {
      IndexType = mlir::Builder::getIndexType(v4, v7);
      v30 = IndexType;
    }
    *((_QWORD *)v35 + 4) = IndexType;
    if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v26)
      && (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v25, v30, a2 + 16)&& (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v24, v30, a2 + 16))
    {
      if (v6)
      {
        if ((_DWORD)v36 != 1)
        {
          if ((_DWORD)v33)
          {
            v12 = *(unsigned int *)(a2 + 72);
            if ((_DWORD)v12)
            {
              v13 = 0;
              v14 = (char *)v32;
              v15 = *(_QWORD **)(a2 + 64);
              v20 = ((unint64_t)v36 << 6) - 128;
              v21 = (char *)v35 + 96;
              v19 = (v12 << 6) - 64;
              v16 = ((unint64_t)v33 << 6) - 64;
              while (1)
              {
                *(_QWORD *)&v21[v13] = *v15;
                if (!(*(unsigned __int8 (**)(uint64_t, char *))(*(_QWORD *)a1 + 696))(a1, v14))
                  goto LABEL_34;
                if (v20 != v13 && v16 != v13)
                {
                  v14 += 32;
                  ++v15;
                  v17 = v19 == v13;
                  v13 += 64;
                  if (!v17)
                    continue;
                }
                break;
              }
            }
          }
        }
      }
      v18 = (_QWORD *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
      if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, void *, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v18, v35, v36, 0))
      {
        mlir::impl::ensureRegionTerminator(v18, v4, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::buildTerminator);
        v9 = (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112) != 0;
        goto LABEL_35;
      }
    }
LABEL_34:
    v9 = 0;
    goto LABEL_35;
  }
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v22 = "mismatch in number of loop-carried values and defined values";
  v23 = 259;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v31, a1, v11, &v22);
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v31);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v31);
LABEL_35:
  if (v32 != v34)
    free(v32);
  if (v35 != v37)
    free(v35);
  return v9;
}

__n128 llvm::SmallVectorTemplateBase<mlir::OpAsmParser::Argument,true>::push_back(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  __n128 result;
  __int128 v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v13;

  v2 = a2;
  v4 = *(unsigned int *)(a1 + 8);
  v5 = *(_QWORD *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    v10 = v4 + 1;
    v11 = v5 + (v4 << 6);
    if (v5 <= a2 && v11 > a2)
    {
      v13 = a2 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v10, 64);
      v5 = *(_QWORD *)a1;
      v2 = *(_QWORD *)a1 + v13;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v10, 64);
      v5 = *(_QWORD *)a1;
    }
  }
  v6 = v5 + ((unint64_t)*(unsigned int *)(a1 + 8) << 6);
  result = *(__n128 *)v2;
  v8 = *(_OWORD *)(v2 + 16);
  v9 = *(_OWORD *)(v2 + 48);
  *(_OWORD *)(v6 + 32) = *(_OWORD *)(v2 + 32);
  *(_OWORD *)(v6 + 48) = v9;
  *(__n128 *)v6 = result;
  *(_OWORD *)(v6 + 16) = v8;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t mlir::OpAsmParser::parseAssignmentList(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v13;
  __int16 v14;
  _QWORD v15[3];
  void *v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  void *__p;
  _QWORD *v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 792))(a1);
  if ((unsigned __int16)v2 <= 0xFFu)
  {
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    v13 = "expected '('";
    v14 = 259;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v15, a1, v3, &v13);
    v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v15);
    if (v15[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v15);
    if (v22)
    {
      v4 = __p;
      if (__p)
      {
        v5 = v21;
        v6 = __p;
        if (v21 != __p)
        {
          do
            v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
          while (v5 != v4);
          v6 = __p;
        }
        v21 = v4;
        operator delete(v6);
      }
      v7 = v18;
      if (v18)
      {
        v8 = v19;
        v9 = v18;
        if (v19 != v18)
        {
          do
          {
            v11 = *--v8;
            v10 = v11;
            *v8 = 0;
            if (v11)
              MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
          }
          while (v8 != v7);
          v9 = v18;
        }
        v19 = v7;
        operator delete(v9);
      }
      if (v16 != &v17)
        free(v16);
    }
  }
  return v2;
}

void mlir::scf::ForOp::replaceWithAdditionalYields(ZinIrHalH13g **a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, unint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  _QWORD *v11;
  ZinIrHalH13g *v12;
  uint64_t v13;
  uint64_t v14;
  ZinIrHalH13g *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  const double *v25;
  unsigned __int128 *v26;
  unint64_t v27;
  const double *v28;
  unsigned __int128 v29;
  unsigned __int128 v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *Context;
  uint64_t v44;
  char v45;
  uint64_t v46;
  ZinIrHalH13g *v47;
  void *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  ZinIrHalH13g **v54;
  ZinIrHalH13g *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t **v76;
  uint64_t *v77;
  uint64_t **v78;
  ZinIrHalH13g *v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t InterfaceFor;
  __int128 v89;
  uint64_t v90;
  __int128 v91;
  __int128 v95;
  _QWORD *v96;
  uint64_t v97;
  unint64_t v98[2];
  unint64_t v99[2];
  void *v100;
  uint64_t v101;
  _BYTE v102[48];
  void *v103;
  uint64_t v104;
  uint64_t **v105;
  uint64_t v106[4];
  __int16 v107;
  uint64_t *v108;
  uint64_t v109;
  __int16 *v110;
  uint64_t v111;
  __int16 v112;
  uint64_t v113;

  v113 = *MEMORY[0x24BDAC8D0];
  v11 = (_QWORD *)(a2 + 24);
  v95 = *(_OWORD *)(a2 + 24);
  v12 = *a1;
  v13 = *((_QWORD *)v12 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v12);
  *v11 = v13;
  v11[1] = v14;
  v96 = v11;
  v15 = *a1;
  if ((*((_BYTE *)*a1 + 46) & 0x80) == 0)
  {
    v100 = v102;
    v101 = 0x600000000;
    v17 = -3;
    v18 = 96;
LABEL_3:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v102, v17, 8);
    v19 = v101;
    v20 = v100;
    v21 = (char *)v100 + 8 * v101;
    if (v17 < 0xD)
      goto LABEL_17;
LABEL_7:
    if ((unint64_t)v21 >= v18 + 32 * v17 || v18 + 24 >= (unint64_t)&v20[8 * v17 + 8 * v19])
    {
      v23 = v17 & 3;
      if ((v17 & 3) == 0)
        v23 = 4;
      v24 = v17 - v23;
      v21 += 8 * v24;
      v25 = (const double *)(v18 + 88);
      v26 = (unsigned __int128 *)&v20[8 * v19 + 16];
      v27 = v24;
      do
      {
        v28 = v25 - 8;
        v29 = (unsigned __int128)vld4q_f64(v28);
        v30 = (unsigned __int128)vld4q_f64(v25);
        *(v26 - 1) = v29;
        *v26 = v30;
        v25 += 16;
        v26 += 2;
        v27 -= 4;
      }
      while (v27);
LABEL_18:
      v31 = (uint64_t *)(v18 + 32 * v24 + 24);
      do
      {
        v32 = *v31;
        v31 += 4;
        *(_QWORD *)v21 = v32;
        v21 += 8;
        ++v24;
      }
      while (v17 != v24);
      LODWORD(v101) = v101 + v17;
      v33 = v101;
      v34 = a4 + v101;
      if (v34 > HIDWORD(v101))
        goto LABEL_21;
      goto LABEL_22;
    }
LABEL_17:
    v24 = 0;
    goto LABEL_18;
  }
  v16 = *((unsigned int *)v15 + 17);
  v17 = v16 - 3;
  v18 = *((_QWORD *)v15 + 9) + 96;
  v100 = v102;
  v101 = 0x600000000;
  if ((unint64_t)(v16 - 3) >= 7)
    goto LABEL_3;
  v19 = 0;
  if (v16 != 3)
  {
    v20 = v102;
    v21 = v102;
    if (v17 < 0xD)
      goto LABEL_17;
    goto LABEL_7;
  }
  v33 = 0;
  LODWORD(v101) = 0;
  v34 = a4;
  if (a4 > 6)
  {
LABEL_21:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v102, v34, 8);
    v33 = v101;
  }
LABEL_22:
  v103 = a3;
  v104 = 0;
  if (a4)
  {
    v35 = 0;
    v36 = (uint64_t *)((char *)v100 + 8 * v33);
    do
    {
      *v36++ = mlir::ValueRange::dereference_iterator(&v103, v35);
      v35 = ++v104;
    }
    while (v103 != a3 || v35 != a4);
    LODWORD(v33) = v101;
  }
  LODWORD(v101) = v33 + a4;
  v38 = *((_QWORD *)*a1 + 3);
  v39 = (_QWORD *)*((_QWORD *)*a1 + 9);
  v40 = v39[3];
  v41 = v39[7];
  v42 = v39[11];
  v97 = v38;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v97);
  v44 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.for", (const unsigned __int8 *)7, Context);
  if (!v45)
  {
    v112 = 1283;
    v110 = (__int16 *)"scf.for";
    v111 = 7;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v107 = 259;
    llvm::operator+((uint64_t *)&v108, v106, (uint64_t)&v103);
    llvm::report_fatal_error((llvm::Twine *)&v103, 1);
  }
  mlir::OperationState::OperationState(&v103, v38, v44);
  mlir::ValueRange::ValueRange((unint64_t *)&v108, (uint64_t)v100, v101);
  mlir::scf::ForOp::build((uint64_t)(v96 - 2), (uint64_t)&v103, v40, v41, v42, (uint64_t)v108, v109, v46, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t))llvm::function_ref<void ()(mlir::OpBuilder &,mlir::Location,mlir::Value,mlir::ValueRange)>::callback_fn<mlir::scf::ForOp::replaceWithAdditionalYields(mlir::RewriterBase &,mlir::ValueRange,BOOL,std::function<llvm::SmallVector<mlir::Value,6u> ()(mlir::OpBuilder &,mlir::Location,llvm::ArrayRef<mlir::BlockArgument>)> const&)::$_0>, (uint64_t)v106);
  v47 = mlir::OpBuilder::create((mlir::OpBuilder *)(v96 - 2), (const mlir::OperationState *)&v103);
  v48 = *(void **)(*((_QWORD *)v47 + 6) + 16);
  mlir::OperationState::~OperationState((mlir::OperationState *)&v103);
  v50 = *((unsigned int *)*a1 + 10);
  v49 = *((unsigned int *)*a1 + 11);
  v51 = (uint64_t)*a1 + 16 * ((v49 >> 23) & 1);
  if (v48 == &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id)
    v52 = (uint64_t)v47;
  else
    v52 = 0;
  v97 = v52;
  v53 = *(_QWORD *)(((v51 + ((v49 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v50 + 8);
  if (v53)
    v54 = (ZinIrHalH13g **)(v53 - 8);
  else
    v54 = 0;
  mlir::Block::getTerminator(v54);
  v56 = (uint64_t)v55;
  v57 = *(_QWORD *)(((v52
                    + 64
                    + 16 * (((unint64_t)*(unsigned int *)(v52 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(v52 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v52 + 40)
                  + 8);
  if (v57)
    v58 = v57 - 8;
  else
    v58 = 0;
  v59 = *(_QWORD *)(v58 + 48);
  v60 = (*(_QWORD *)(v58 + 56) - v59) >> 3;
  if (v60 <= a4)
    v61 = v59;
  else
    v61 = v59 + 8 * (v60 - a4);
  if (v60 >= a4)
    v62 = a4;
  else
    v62 = v60;
  v91 = *(_OWORD *)(a2 + 24);
  v63 = *((_QWORD *)v55 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v55);
  *(_QWORD *)(a2 + 24) = v63;
  *(_QWORD *)(a2 + 32) = v64;
  v106[0] = *((_QWORD *)*a1 + 3);
  v108 = (uint64_t *)v61;
  v109 = v62;
  v65 = *(_QWORD *)(a6 + 24);
  if (v65)
  {
    (*(void (**)(void **__return_ptr, uint64_t, _QWORD *, uint64_t *, uint64_t **))(*(_QWORD *)v65 + 48))(&v103, v65, v96 - 2, v106, &v108);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, v56);
    if ((*(_BYTE *)(v56 + 46) & 0x80) != 0)
      v66 = *(_DWORD *)(v56 + 68);
    else
      v66 = 0;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)&v108, v56, 0, v66, 0, 0);
    mlir::ValueRange::ValueRange((unint64_t *)v106, (uint64_t)v103, v104);
    mlir::MutableOperandRange::append((uint64_t)&v108, v106[0], v106[1]);
    if (v110 != &v112)
      free(v110);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 80))(a2, v56);
    if (v103 != &v105)
      free(v103);
    if ((_QWORD)v91)
    {
      *(_OWORD *)v96 = v91;
    }
    else
    {
      *v96 = 0;
      v96[1] = 0;
    }
    v67 = *(_QWORD *)((((unint64_t)*a1
                      + 16 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1)
                      + (((unint64_t)*((unsigned int *)*a1 + 11) >> 21) & 0x7F8)
                      + 71) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *((unsigned int *)*a1 + 10)
                    + 8);
    if (v67)
      v68 = v67 - 8;
    else
      v68 = 0;
    v69 = *(_QWORD *)(((v52
                      + 64
                      + 16 * (((unint64_t)*(unsigned int *)(v52 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(v52 + 44) >> 21) & 0x7F8)
                      + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(v52 + 40)
                    + 8);
    if (v69)
      v70 = v69 - 8;
    else
      v70 = 0;
    v71 = *(_QWORD *)(v70 + 48);
    v72 = *(_QWORD *)(v68 + 48);
    if ((*(_QWORD *)(v70 + 56) - v71) >> 3 >= (unint64_t)((unint64_t)(*(_QWORD *)(v68 + 56)
                                                                                                 - v72) >> 3))
      v73 = ((unint64_t)(*(_QWORD *)(v68 + 56) - v72) >> 3);
    else
      v73 = (*(_QWORD *)(v70 + 56) - v71) >> 3;
    mlir::ValueRange::ValueRange(v99, v71, v73);
    mlir::RewriterBase::mergeBlocks(a2, v68, v70, v99[0], v99[1]);
    if (a5)
    {
      v103 = a3;
      v104 = 0;
      v105 = (uint64_t **)v61;
      v74 = (uint64_t)v47;
      if (a4 && v62)
      {
        v75 = 0;
        do
        {
          v76 = (uint64_t **)mlir::ValueRange::dereference_iterator(&v103, v75);
          v77 = *v105;
          v108 = &v97;
          mlir::RewriterBase::replaceUsesWithIf(a2, v76, v77, (uint64_t (*)(uint64_t, uint64_t *))llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::scf::ForOp::replaceWithAdditionalYields(mlir::RewriterBase &,mlir::ValueRange,BOOL,std::function<llvm::SmallVector<mlir::Value,6u> ()(mlir::OpBuilder &,mlir::Location,llvm::ArrayRef<mlir::BlockArgument>)> const&)::$_2>, (uint64_t)&v108);
          v75 = v104 + 1;
          v78 = v105 + 1;
          v104 = v75;
          ++v105;
        }
        while ((v75 != a4 || v103 != a3) && v78 != (uint64_t **)(v61 + 8 * v62));
        v74 = v97;
      }
    }
    else
    {
      v74 = (uint64_t)v47;
    }
    v81 = *a1;
    v82 = *(_DWORD *)(v74 + 36);
    v83 = v74 - 16;
    if (v82)
      v84 = v83;
    else
      v84 = 0;
    v85 = *((_DWORD *)v81 + 9);
    if (v82 >= v85)
      v86 = v85;
    else
      v86 = v82;
    mlir::ValueRange::ValueRange(v98, v84, v86);
    (*(void (**)(uint64_t, ZinIrHalH13g *, unint64_t, unint64_t))(*(_QWORD *)a2 + 24))(a2, v81, v98[0], v98[1]);
    v87 = v97;
    if (v97)
      InterfaceFor = mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(v97);
    else
      InterfaceFor = 0;
    v89 = v95;
    *(_QWORD *)a7 = v87;
    *(_QWORD *)(a7 + 8) = InterfaceFor;
    *(_BYTE *)(a7 + 16) = 1;
    if (v100 != v102)
    {
      free(v100);
      v89 = v95;
    }
    if ((_QWORD)v89)
    {
      *(_OWORD *)v96 = v89;
    }
    else
    {
      *v96 = 0;
      v96[1] = 0;
    }
  }
  else
  {
    v90 = std::__throw_bad_function_call[abi:nn180100]();
    mlir::scf::ForOp::getSuccessorRegions(v90);
  }
}

__n128 mlir::scf::ForOp::getSuccessorRegions(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __n128 *v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  __int128 v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  __n128 *v25;
  __n128 result;
  unint64_t v27;
  BOOL v28;
  unint64_t v29;
  BOOL v30;
  char *v31;
  char *v32;
  unint64_t v33;
  unint64_t v34[3];

  v34[2] = *MEMORY[0x24BDAC8D0];
  v5 = *a1;
  v6 = *(unsigned int *)(*a1 + 44);
  if ((v6 & 0x7FFFFF) != 0)
  {
    v7 = (v6 >> 23) & 1;
    v8 = (v6 >> 21) & 0x7F8;
    v9 = *(unsigned int *)(v5 + 40);
    v10 = ((v5 + 16 * v7 + v8 + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v9;
  }
  else
  {
    v10 = 0;
    v9 = *(unsigned int *)(v5 + 40);
    v7 = (v6 >> 23) & 1;
    v8 = (v6 >> 21) & 0x7F8;
  }
  v11 = *(_QWORD *)(((v5 + 16 * v7 + v8 + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v9 + 8);
  if (v11)
    v12 = v11 - 8;
  else
    v12 = 0;
  v13 = *(_QWORD *)(v12 + 48);
  v14 = ((*(_QWORD *)(v12 + 56) - v13) >> 3) - 1;
  v33 = v10;
  v15 = (__n128 *)&v33;
  mlir::ValueRange::ValueRange(v34, v13 + 8, v14);
  v16 = *(unsigned int *)(a3 + 8);
  v17 = *(_QWORD *)a3;
  if (v16 < *(_DWORD *)(a3 + 12))
    goto LABEL_8;
  v27 = v16 + 1;
  v28 = v17 + 24 * v16 > (unint64_t)&v33;
  if (v17 > (unint64_t)&v33 || !v28)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v27, 24);
    v17 = *(_QWORD *)a3;
LABEL_8:
    v18 = (char *)&v33;
    goto LABEL_9;
  }
  v31 = (char *)&v34[-1] - v17;
  llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v27, 24);
  v17 = *(_QWORD *)a3;
  v18 = &v31[*(_QWORD *)a3];
LABEL_9:
  v19 = v17 + 24 * *(unsigned int *)(a3 + 8);
  v20 = *(_OWORD *)v18;
  *(_QWORD *)(v19 + 16) = *((_QWORD *)v18 + 2);
  *(_OWORD *)v19 = v20;
  ++*(_DWORD *)(a3 + 8);
  v21 = *(unsigned int *)(*a1 + 36);
  if ((_DWORD)v21)
    v22 = *a1 - 16;
  else
    v22 = 0;
  v33 = 0;
  mlir::ValueRange::ValueRange(v34, v22, v21);
  v23 = *(unsigned int *)(a3 + 8);
  v24 = *(_QWORD *)a3;
  if (v23 >= *(_DWORD *)(a3 + 12))
  {
    v29 = v23 + 1;
    v30 = v24 + 24 * v23 > (unint64_t)&v33;
    if (v24 <= (unint64_t)&v33 && v30)
    {
      v32 = (char *)&v34[-1] - v24;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v29, 24);
      v24 = *(_QWORD *)a3;
      v15 = (__n128 *)&v32[*(_QWORD *)a3];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v29, 24);
      v24 = *(_QWORD *)a3;
      v15 = (__n128 *)&v33;
    }
  }
  v25 = (__n128 *)(v24 + 24 * *(unsigned int *)(a3 + 8));
  result = *v15;
  v25[1].n128_u64[0] = v15[1].n128_u64[0];
  *v25 = result;
  ++*(_DWORD *)(a3 + 8);
  return result;
}

uint64_t mlir::scf::ForallOp::promoteIfSingleIteration(mlir::scf::ForallOp *this, mlir::RewriterBase *a2)
{
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t *v12;
  mlir::RewriterBase *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  BOOL v21;
  uint64_t v22;
  void *v24;
  uint64_t v25;
  _BYTE v26[48];
  void *v27;
  uint64_t v28;
  _BYTE v29[48];
  void *__src;
  uint64_t v31;
  _BYTE v32[48];
  void *__dst;
  uint64_t v34;
  _BYTE v35[48];
  void *v36;
  uint64_t v37;
  _BYTE v38[48];
  void *v39;
  uint64_t v40;
  _QWORD v41[8];

  v41[6] = *MEMORY[0x24BDAC8D0];
  mlir::scf::ForallOp::getMixedLowerBound(this, (uint64_t)&__src);
  mlir::scf::ForallOp::getMixedUpperBound(this, (uint64_t)&v27);
  mlir::scf::ForallOp::getMixedStep(this, (uint64_t)&v24);
  __dst = v35;
  v34 = 0x600000000;
  v4 = v31;
  if ((_DWORD)v31)
  {
    if (__src == v32)
    {
      v5 = v31;
      if (v31 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v35, v31, 8), (v5 = v31) != 0))
      {
        memcpy(__dst, __src, 8 * v5);
      }
      LODWORD(v34) = v4;
    }
    else
    {
      __dst = __src;
      v34 = v31;
      __src = v32;
      HIDWORD(v31) = 0;
    }
    LODWORD(v31) = 0;
  }
  v36 = v38;
  v37 = 0x600000000;
  v6 = v28;
  if ((_DWORD)v28)
  {
    if (v27 != v29)
    {
      v36 = v27;
      v37 = v28;
      v27 = v29;
      HIDWORD(v28) = 0;
LABEL_18:
      LODWORD(v28) = 0;
      goto LABEL_19;
    }
    if (v28 < 7)
    {
      v7 = v28;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v28, 8);
      v7 = v28;
      if (!(_DWORD)v28)
        goto LABEL_17;
    }
    memcpy(v36, v27, 8 * v7);
LABEL_17:
    LODWORD(v37) = v6;
    goto LABEL_18;
  }
LABEL_19:
  v39 = v41;
  v40 = 0x600000000;
  v8 = v25;
  v9 = v24;
  if (!(_DWORD)v25)
    goto LABEL_29;
  if (v24 == v26)
  {
    if (v25 < 7)
    {
      v10 = v25;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v25, 8);
      v10 = v25;
      v9 = v24;
      if (!(_DWORD)v25)
        goto LABEL_27;
    }
    memcpy(v39, v9, 8 * v10);
    v9 = v24;
LABEL_27:
    LODWORD(v40) = v8;
    goto LABEL_28;
  }
  v39 = v24;
  v40 = v25;
  v24 = v26;
  HIDWORD(v25) = 0;
  v9 = v26;
LABEL_28:
  LODWORD(v25) = 0;
LABEL_29:
  if (v9 != v26)
    free(v9);
  if (v27 != v29)
    free(v27);
  if (__src != v32)
    free(__src);
  v11 = 0;
  v12 = (uint64_t *)v39;
  if ((_DWORD)v34 && (_DWORD)v37 && (_DWORD)v40)
  {
    v13 = a2;
    v14 = (uint64_t *)__dst;
    v15 = (uint64_t *)v36;
    v16 = 8 * v40 - 8;
    v17 = 8 * v37 - 8;
    v18 = 8 * v34 - 8;
    do
    {
      v19 = mlir::constantTripCount(*v14, *v15, *v12);
      if (v20)
        v21 = v19 == 1;
      else
        v21 = 0;
      v11 = !v21;
      if (!v21)
        break;
      if (!v18)
        break;
      if (!v17)
        break;
      ++v14;
      ++v15;
      ++v12;
      v22 = v16;
      v16 -= 8;
      v17 -= 8;
      v18 -= 8;
    }
    while (v22);
    v12 = (uint64_t *)v39;
    a2 = v13;
  }
  if (v12 != v41)
    free(v12);
  if (v36 != v38)
    free(v36);
  if (__dst != v35)
    free(__dst);
  if ((v11 & 1) != 0)
    return 0;
  mlir::scf::promote((uint64_t)a2, *(_QWORD *)this);
  return 1;
}

void mlir::scf::ForallOp::getMixedLowerBound(mlir::scf::ForallOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t Context;
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15[3];

  v15[2] = *MEMORY[0x24BDAC8D0];
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  v5 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v5 = 0;
  v6 = *(_QWORD *)(v5 + 8);
  v13 = Context;
  v14 = v6;
  v7 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v14);
  v9 = v8;
  v10 = *(unsigned int *)(*(_QWORD *)this + 44);
  v11 = *(_QWORD *)this + 16 * ((v10 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v11 = 0;
  if ((v10 & 0x800000) != 0)
    v12 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v12 = 0;
  mlir::ValueRange::ValueRange(v15, v12, *(unsigned int *)(v11 + 32));
  mlir::getMixedValues(v7, v9, v15[0], v15[1], (mlir::Builder *)&v13, a2);
}

void mlir::scf::ForallOp::getMixedUpperBound(mlir::scf::ForallOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t Context;
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17[3];

  v17[2] = *MEMORY[0x24BDAC8D0];
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  v5 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v5 = 0;
  v6 = *(_QWORD *)(v5 + 24);
  v15 = Context;
  v16 = v6;
  v7 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v16);
  v9 = v8;
  v10 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v11 = *(_QWORD *)this + 16 * ((v10 >> 23) & 1) + 64;
  else
    v11 = 0;
  v12 = *(unsigned int *)(v11 + 32);
  v13 = *(_DWORD *)(v11 + 36);
  if ((v10 & 0x800000) != 0)
    v14 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v14 = 0;
  mlir::ValueRange::ValueRange(v17, v14 + 32 * v12, (v13 + v12) - v12);
  mlir::getMixedValues(v7, v9, v17[0], v17[1], (mlir::Builder *)&v15, a2);
}

void mlir::scf::ForallOp::getMixedStep(mlir::scf::ForallOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t Context;
  unint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18[3];

  v18[2] = *MEMORY[0x24BDAC8D0];
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)this + 24));
  v5 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v5 = 0;
  v6 = *(_QWORD *)(v5 + 16);
  v16 = Context;
  v17 = v6;
  v7 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v17);
  v9 = v8;
  v10 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v11 = (_DWORD *)(*(_QWORD *)this + 16 * ((v10 >> 23) & 1) + 64);
  else
    v11 = 0;
  v12 = v11[8];
  v13 = v11[9];
  v14 = v11[10];
  if ((v10 & 0x800000) != 0)
    v15 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v15 = 0;
  mlir::ValueRange::ValueRange(v18, v15 + 32 * (v13 + v12), (v14 + v13 + v12) - (unint64_t)(v13 + v12));
  mlir::getMixedValues(v7, v9, v18[0], v18[1], (mlir::Builder *)&v16, a2);
}

void mlir::scf::promote(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::IndexType **v5;
  uint64_t v6;
  ZinIrHalH13g **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  char *v23;
  uint64_t *i;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  BOOL v28;
  uint64_t v29;
  unint64_t v30;
  const double *v31;
  unsigned __int128 *v32;
  unint64_t v33;
  const double *v34;
  unsigned __int128 v35;
  unsigned __int128 v36;
  unint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  ZinIrHalH13g *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  ZinIrHalH13g *v51;
  ZinIrHalH13g *v52;
  uint64_t v53;
  uint64_t Input;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  ZinIrHalH13g *v62;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69[2];
  uint64_t v70[2];
  uint64_t v71[2];
  _QWORD v72[2];
  _QWORD v73[2];
  _QWORD v74[2];
  unint64_t v75;
  uint64_t v76;
  uint64_t Dest;
  uint64_t v78;
  ZinIrHalH13g *v79;
  unint64_t v80[2];
  unint64_t v81[2];
  unint64_t v82[2];
  char *v83;
  unsigned int v84;
  unsigned int v85;
  _BYTE v86[48];
  _QWORD *v87;
  uint64_t v88;
  _QWORD v89[8];

  v89[6] = *MEMORY[0x24BDAC8D0];
  v79 = (ZinIrHalH13g *)a2;
  v4 = a1 + 24;
  v68 = *(_OWORD *)(a1 + 24);
  v5 = (mlir::IndexType **)(a1 + 8);
  v6 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v6)
    v7 = (ZinIrHalH13g **)(v6 - 8);
  else
    v7 = 0;
  mlir::Block::getTerminator(v7);
  v9 = v8;
  v10 = *(_QWORD *)(a2 + 24);
  mlir::scf::ForallOp::getMixedLowerBound((mlir::scf::ForallOp *)&v79, (uint64_t)&v87);
  mlir::getValueOrCreateConstantIndexOp(v5, v10, v87, v88, (uint64_t)&v83);
  if (v87 != v89)
    free(v87);
  v11 = *((unsigned int *)v79 + 11);
  if (HIBYTE(*((_DWORD *)v79 + 11)))
    v12 = (_DWORD *)((char *)v79 + 16 * ((v11 >> 23) & 1) + 64);
  else
    v12 = 0;
  v13 = v12[8];
  v14 = v12[9];
  v16 = v12[10];
  v15 = v12[11];
  if ((v11 & 0x800000) == 0)
  {
    v66 = (v14 + v13 + v16);
    v18 = 32 * v66;
    v19 = (v15 + v66) - v66;
    v20 = 32 * v66;
    v21 = v84;
    v22 = v19 + v84;
    if (v22 <= v85)
      goto LABEL_12;
    goto LABEL_11;
  }
  v17 = (v14 + v13 + v16);
  v18 = *((_QWORD *)v79 + 9) + 32 * v17;
  v19 = (v15 + v17) - v17;
  v20 = v18;
  v21 = v84;
  v22 = v19 + v84;
  if (v22 > v85)
  {
LABEL_11:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v22, 8);
    v21 = v84;
  }
LABEL_12:
  if (v19 || v18 != v20)
  {
    v23 = &v83[8 * v21];
    if (v18 != v20)
    {
      for (i = (uint64_t *)(v18 + 24); ; i += 4)
      {
        v25 = *i;
        *(_QWORD *)v23 = v25;
        v23 += 8;
      }
    }
    if (v19 > 0xC
      && ((v26 = v21, v27 = &v83[8 * v19 + 8 * v21], (unint64_t)v23 < v18 + 32 * v19)
        ? (v28 = v18 + 24 >= (unint64_t)v27)
        : (v28 = 1),
          v28))
    {
      v29 = v19 & 3;
      if ((v19 & 3) == 0)
        v29 = 4;
      v30 = v19 - v29;
      v23 += 8 * v30;
      v31 = (const double *)(v18 + 88);
      v32 = (unsigned __int128 *)&v83[8 * v26 + 16];
      v33 = v30;
      do
      {
        v34 = v31 - 8;
        v35 = (unsigned __int128)vld4q_f64(v34);
        v36 = (unsigned __int128)vld4q_f64(v31);
        *(v32 - 1) = v35;
        *v32 = v36;
        v31 += 16;
        v32 += 2;
        v33 -= 4;
      }
      while (v33);
    }
    else
    {
      v30 = 0;
    }
    v37 = v19 - v30;
    v38 = (uint64_t *)(v18 + 32 * v30 + 24);
    do
    {
      v39 = *v38;
      v38 += 4;
      *(_QWORD *)v23 = v39;
      v23 += 8;
      --v37;
    }
    while (v37);
    v21 = v84;
  }
  v40 = v21 + v19;
  v84 = v21 + v19;
  v41 = v79;
  v42 = *(_QWORD *)((((unint64_t)v79
                    + 16 * (((unint64_t)*((unsigned int *)v79 + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)v79 + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v79 + 10)
                  + 8);
  if (v42)
    v43 = v42 - 8;
  else
    v43 = 0;
  v44 = *((_QWORD *)v79 + 2);
  mlir::ValueRange::ValueRange(v82, (uint64_t)v83, v40);
  (*(void (**)(uint64_t, uint64_t, uint64_t, ZinIrHalH13g *, unint64_t, unint64_t))(*(_QWORD *)a1 + 56))(a1, v43, v44, v41, v82[0], v82[1]);
  v45 = *((_QWORD *)v79 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v79);
  v47 = *(_QWORD *)(v46 + 8);
  *(_QWORD *)(a1 + 24) = v45;
  *(_QWORD *)(a1 + 32) = v47;
  v87 = v89;
  v88 = 0x600000000;
  v48 = *((unsigned int *)v79 + 9);
  if (v48 >= 7)
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v89, v48, 8);
  v67 = v9;
  v49 = *(_QWORD *)(((v9
                    + 16 * (((unint64_t)*(unsigned int *)(v9 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(v9 + 44) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v9 + 40)
                  + 8);
  if (v49)
    v50 = v49 - 8;
  else
    v50 = 0;
  v51 = (ZinIrHalH13g *)(v50 + 32);
  v52 = *(ZinIrHalH13g **)(v50 + 40);
  if (v52 != (ZinIrHalH13g *)(v50 + 32))
  {
    do
    {
      ZinIrHalH13g::~ZinIrHalH13g(v52);
      v78 = v53;
      Dest = mlir::tensor::ParallelInsertSliceOp::getDest((mlir::tensor::ParallelInsertSliceOp *)&v78);
      Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v78);
      v55 = *((_QWORD *)v79 + 3);
      v75 = *(_QWORD *)(Dest + 8) & 0xFFFFFFFFFFFFFFF8;
      v76 = Input;
      v74[0] = mlir::memref::ReinterpretCastOp::getSizes((mlir::memref::ReinterpretCastOp *)&v78);
      v74[1] = v56;
      v73[0] = mlir::memref::ReinterpretCastOp::getStrides((mlir::memref::ReinterpretCastOp *)&v78);
      v73[1] = v57;
      v72[0] = mlir::tensor::InsertSliceOp::getStrides((mlir::tensor::InsertSliceOp *)&v78);
      v72[1] = v58;
      v71[0] = mlir::memref::ReinterpretCastOp::getStaticOffsets((mlir::memref::ReinterpretCastOp *)&v78);
      v71[1] = v59;
      v70[0] = mlir::memref::ReinterpretCastOp::getStaticSizes((mlir::memref::ReinterpretCastOp *)&v78);
      v70[1] = v60;
      v69[0] = mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)&v78);
      v69[1] = v61;
      v62 = mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Type,mlir::Value &,mlir::Value &,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(v5, v55, (uint64_t *)&v75, &v76, &Dest, (uint64_t)v74, (uint64_t)v73, (uint64_t)v72, v71, v70, v69);
      v63 = v88;
      if (v88 >= (unint64_t)HIDWORD(v88))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v89, v88 + 1, 8);
        v63 = v88;
      }
      v87[v63] = (char *)v62 - 16;
      LODWORD(v88) = v88 + 1;
      v52 = (ZinIrHalH13g *)*((_QWORD *)v52 + 1);
    }
    while (v52 != v51);
  }
  v64 = *((unsigned int *)v79 + 9);
  if ((_DWORD)v64)
    v65 = (char *)v79 - 16;
  else
    v65 = 0;
  mlir::ValueRange::ValueRange(v81, (uint64_t)v65, v64);
  mlir::ValueRange::ValueRange(v80, (uint64_t)v87, v88);
  mlir::RewriterBase::replaceAllUsesWith(a1, v81[0], v81[1], v80[0], v80[1]);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v67);
  (*(void (**)(uint64_t, ZinIrHalH13g *))(*(_QWORD *)a1 + 40))(a1, v79);
  if (v87 != v89)
    free(v87);
  if (v83 != v86)
    free(v83);
  if ((_QWORD)v68)
  {
    *(_OWORD *)v4 = v68;
  }
  else
  {
    *(_QWORD *)v4 = 0;
    *(_QWORD *)(v4 + 8) = 0;
  }
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::InsertSliceOp,mlir::Type,mlir::Value &,mlir::Value &,mlir::OperandRange,mlir::OperandRange,mlir::OperandRange,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>,llvm::ArrayRef<long long>>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  uint64_t *Context;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  ZinIrHalH13g *v25;
  ZinIrHalH13g *v26;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  __int16 v31;
  uint64_t v32[4];
  __int16 v33;
  unint64_t v34[2];
  unint64_t v35[2];
  unint64_t v36[2];
  _QWORD v37[40];

  v37[38] = *MEMORY[0x24BDAC8D0];
  v29 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v29);
  v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.insert_slice", (const unsigned __int8 *)0x13, Context);
  if (!v21)
  {
    v33 = 1283;
    v32[2] = (uint64_t)"tensor.insert_slice";
    v32[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v31 = 259;
    llvm::operator+(v32, (uint64_t *)&v30, (uint64_t)v37);
    llvm::report_fatal_error((llvm::Twine *)v37, 1);
  }
  mlir::OperationState::OperationState(v37, a2, v20);
  v28 = *a3;
  v22 = *a4;
  v23 = *a5;
  mlir::ValueRange::ValueRange(v36, *(_QWORD *)a6, *(_QWORD *)(a6 + 8));
  mlir::ValueRange::ValueRange(v35, *(_QWORD *)a7, *(_QWORD *)(a7 + 8));
  mlir::ValueRange::ValueRange(v34, *(_QWORD *)a8, *(_QWORD *)(a8 + 8));
  mlir::tensor::InsertSliceOp::build(a1, (uint64_t)v37, v28, v22, v23, v36[0], v36[1], v24, v35[0], v35[1], v34[0], v34[1], *a9, a9[1], *a10, a10[1], *a11, a11[1]);
  v25 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v37);
  if (*(_UNKNOWN **)(*((_QWORD *)v25 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::InsertSliceOp,void>::id)
    v26 = v25;
  else
    v26 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v37);
  return v26;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  ZinIrHalH13g *v9;
  ZinIrHalH13g *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x24BDAC8D0];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.yield", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"scf.yield";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::OperationState::addOperands((uint64_t)v18, v17[0], v17[1]);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void mlir::scf::ForOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  const char *v140;
  unint64_t v141;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"scf.for", 7, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v4 = &off_24BFF2800;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ForOpIterArgsFolder]";
  v141 = 92;
  v9 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v9)
    v10 = v9;
  else
    v10 = v141;
  v11 = &v140[v10];
  v12 = v141 - v10;
  if (v141 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v141 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_154;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_155;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_158;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_158:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"scf.for", 7, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v38 = &off_24BFF29D0;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyTrivialLoops]";
  v141 = 93;
  v43 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v43)
    v44 = v43;
  else
    v44 = v141;
  v45 = &v140[v44];
  v46 = v141 - v44;
  if (v141 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v141 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_154;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_155;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_159;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_159:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"scf.for", 7, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v72 = &off_24BFF2CE8;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::LastTensorLoadCanonicalization]";
  v141 = 103;
  v77 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v77)
    v78 = v77;
  else
    v78 = v141;
  v79 = &v140[v78];
  v80 = v141 - v78;
  if (v141 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v141 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_154;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_155;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_160;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_160:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"scf.for", 7, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v106 = &off_24BFF2A28;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ForOpTensorCastFolder]";
  v141 = 94;
  v111 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v111)
    v112 = v111;
  else
    v112 = v141;
  v113 = &v140[v112];
  v114 = v141 - v112;
  if (v141 - v112 >= 0x12)
    v115 = 18;
  else
    v115 = v141 - v112;
  v116 = &v113[v115];
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
LABEL_154:
    abort();
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (!v122)
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
    goto LABEL_150;
  }
  if (v122 >> 61)
LABEL_155:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v123 = (char *)operator new(8 * v122);
  v124 = (uint64_t *)&v123[8 * v119];
  v125 = &v123[8 * v122];
  *v124 = v106;
  v110 = (uint64_t)(v124 + 1);
  v126 = (char *)(v109 - v118);
  if (v109 != v118)
  {
LABEL_138:
    v127 = (unint64_t)(v126 - 8);
    if (v127 < 0x78
      || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
      && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
    {
      goto LABEL_161;
    }
    v128 = (v127 >> 3) + 1;
    v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
    v130 = &v109[-v129];
    v124 = (uint64_t *)((char *)v124 - v129);
    v131 = &v123[8 * v119 - 16];
    v132 = v109 - 16;
    v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v135 = *((_OWORD *)v132 - 1);
      v134 = *(_OWORD *)v132;
      *((_OWORD *)v132 - 1) = 0uLL;
      *(_OWORD *)v132 = 0uLL;
      *((_OWORD *)v131 - 1) = v135;
      *(_OWORD *)v131 = v134;
      v131 -= 32;
      v132 -= 32;
      v133 -= 4;
    }
    while (v133);
    v109 = v130;
    if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_161:
      do
      {
        v136 = *((_QWORD *)v109 - 1);
        v109 -= 8;
        *(_QWORD *)v109 = 0;
        *--v124 = v136;
      }
      while (v109 != v118);
    }
    v109 = (char *)a1[1];
    v137 = (char *)a1[2];
    a1[1] = v124;
    a1[2] = v110;
    a1[3] = v125;
    while (v137 != v109)
    {
      v139 = *((_QWORD *)v137 - 1);
      v137 -= 8;
      v138 = v139;
      *(_QWORD *)v137 = 0;
      if (v139)
        (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
    }
    goto LABEL_151;
  }
LABEL_150:
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
}

void mlir::scf::ForOp::getConstantStep(mlir::scf::ForOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t DefiningOp;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 88);
  v7 = 0;
  v8 = v3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v8);
  if (!DefiningOp)
    goto LABEL_11;
  v5 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    goto LABEL_11;
  v9 = v11;
  v10 = 0x100000000;
  mlir::Operation::fold(v5, 0, 0, (uint64_t)&v9);
  v6 = (*(_QWORD *)v9 & 0xFFFFFFFFFFFFFFF8) == 0
    || *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 & 0xFFFFFFFFFFFFFFF8) + 136) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
  if (!v6)
    v7 = *(_QWORD *)v9 & 0xFFFFFFFFFFFFFFF8;
  if (v9 != v11)
    free(v9);
  if (!v6)
  {
    mlir::IntegerAttr::getValue(&v7, (llvm::APInt *)&v9);
    *(_DWORD *)(a2 + 8) = v10;
    *(_QWORD *)a2 = v9;
    *(_BYTE *)(a2 + 16) = 1;
  }
  else
  {
LABEL_11:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 16) = 0;
  }
}

BOOL mlir::scf::ForallOp::verify(uint64_t **this)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  const char *v14;
  uint64_t *v15;
  uint64_t *v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  const char *v24;
  uint64_t Value;
  uint64_t v26;
  _QWORD **v27;
  uint64_t v28;
  uint64_t *v29;
  unint64_t v30;
  int64x2_t *v31;
  const char *v32;
  const char *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int64x2_t *v38;
  const char *v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int64x2_t *StaticStrides;
  const char *v47;
  const char *v48;
  uint64_t DynamicStep;
  unint64_t v50;
  uint64_t v51;
  const char *v52;
  int *v53;
  char *v54;
  char *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  char *v59;
  char *v60;
  __int128 v61;
  uint64_t *v62;
  int v63;
  uint64_t v64;
  int *v65;
  char *v66;
  char *v67;
  __int128 v68;
  uint64_t v69;
  int *v70;
  char *v71;
  char *v72;
  __int128 v73;
  _QWORD *v74;
  _QWORD *v75;
  void *v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  char *v83;
  char *v84;
  __int128 v85;
  uint64_t v86;
  int *v87;
  char *v88;
  char *v89;
  __int128 v90;
  _QWORD *v91;
  _QWORD *v92;
  void *v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  int *v97;
  char *v98;
  char *v99;
  __int128 v100;
  uint64_t v101;
  int *v102;
  char *v103;
  char *v104;
  __int128 v105;
  _QWORD *v106;
  _QWORD *v107;
  void *v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  int *v112;
  char *v113;
  char *v114;
  __int128 v115;
  uint64_t v116;
  int *v117;
  char *v118;
  char *v119;
  __int128 v120;
  _QWORD *v121;
  _QWORD *v122;
  void *v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  int *v128;
  char *v129;
  char *v130;
  __int128 v131;
  _QWORD *v132;
  _QWORD *v133;
  void *v134;
  _QWORD *v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v139;
  unint64_t v140;
  BOOL v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  BOOL v145;
  unint64_t v146;
  BOOL v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  BOOL v151;
  unint64_t v152;
  BOOL v153;
  unint64_t v154;
  int64_t v155;
  int64_t v156;
  int64_t v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  int64_t v161;
  int64_t v162;
  int64_t v163;
  int64_t v164;
  int64_t v165;
  const void **v166[4];
  __int16 v167;
  int v168;
  const char *v169;
  uint64_t v170;
  unint64_t v171[2];
  unint64_t v172[2];
  unint64_t v173[2];
  unint64_t v174;
  _BOOL8 v175[2];
  void *v176;
  unsigned int v177;
  unsigned int v178;
  _BYTE v179[96];
  void *v180;
  _QWORD *v181;
  void *__p;
  _QWORD *v183;
  char v184;
  uint64_t v185;

  v185 = *MEMORY[0x24BDAC8D0];
  v2 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v2 = 0;
  v174 = *(_QWORD *)(v2 + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v174);
  v4 = *this;
  v5 = *((unsigned int *)*this + 9);
  v6 = *((unsigned int *)*this + 11);
  v7 = (v6 >> 23) & 1;
  if (BYTE3(v6))
    v8 = &(*this)[2 * v7 + 8];
  else
    v8 = 0;
  v9 = (*((_DWORD *)v8 + 9) + *((_DWORD *)v8 + 8) + *((_DWORD *)v8 + 10));
  if ((*((_DWORD *)v8 + 11) + v9) - v9 == v5)
  {
    v10 = v3;
    v11 = *(_QWORD *)((((unint64_t)&(*this)[2 * v7 + 8] + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *((unsigned int *)v4 + 10)
                    + 8);
    if (v11)
      v12 = v11 - 8;
    else
      v12 = 0;
    v13 = (const char *)v3;
    if (v3 + v5 == ((*(_QWORD *)(v12 + 56) - *(_QWORD *)(v12 + 48)) >> 3))
    {
      if (!v3)
      {
LABEL_16:
        v15 = &v4[2 * v7 + 8];
        if (BYTE3(v6))
          v16 = v15;
        else
          v16 = 0;
        v17 = *((_DWORD *)v16 + 11);
        if (v17)
        {
          v18 = 0;
          v19 = (*((_DWORD *)v16 + 9) + *((_DWORD *)v16 + 8) + *((_DWORD *)v16 + 10));
          v20 = (v17 + v19) - v19;
          v21 = v4[9] + 32 * v19;
          v22 = 1;
          while ((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 48) + 8 * (v10 + v22 - 1)) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(_QWORD *)(*(_QWORD *)(v21 + 32 * v18 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
          {
            v18 = v22++;
            if (v20 <= v18)
              goto LABEL_23;
          }
          v166[0] = (const void **)"type mismatch between ";
          v167 = 259;
          mlir::OpState::emitOpError(this, v166, (uint64_t)&v174);
          if (v174)
          {
            v168 = 5;
            v169 = (const char *)v18;
            v112 = &v168;
            v113 = (char *)v176;
            if (v177 >= v178)
            {
              v149 = v177 + 1;
              if (v176 <= &v168 && (char *)v176 + 24 * v177 > (char *)&v168)
              {
                v162 = (char *)&v168 - (_BYTE *)v176;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v149, 24);
                v113 = (char *)v176;
                v112 = (int *)((char *)v176 + v162);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v149, 24);
                v112 = &v168;
                v113 = (char *)v176;
              }
            }
            v114 = &v113[24 * v177];
            v115 = *(_OWORD *)v112;
            *((_QWORD *)v114 + 2) = *((_QWORD *)v112 + 2);
            *(_OWORD *)v114 = v115;
            v116 = ++v177;
            if (v174)
            {
              v168 = 3;
              v169 = "-th output and corresponding block argument";
              v170 = 43;
              v117 = &v168;
              v118 = (char *)v176;
              if (v116 >= v178)
              {
                v152 = v116 + 1;
                v153 = (char *)v176 + 24 * v116 > (char *)&v168;
                if (v176 <= &v168 && v153)
                {
                  v164 = (char *)&v168 - (_BYTE *)v176;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v152, 24);
                  v118 = (char *)v176;
                  v117 = (int *)((char *)v176 + v164);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v152, 24);
                  v117 = &v168;
                  v118 = (char *)v176;
                }
              }
              v119 = &v118[24 * v177];
              v120 = *(_OWORD *)v117;
              *((_QWORD *)v119 + 2) = *((_QWORD *)v117 + 2);
              *(_OWORD *)v119 = v120;
              ++v177;
            }
          }
          v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v174);
          if (v174)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v174);
          if (!v184)
            return v51;
          v121 = __p;
          if (__p)
          {
            v122 = v183;
            v123 = __p;
            if (v183 != __p)
            {
              do
                v122 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v122 - 1);
              while (v122 != v121);
              v123 = __p;
            }
            v183 = v121;
            operator delete(v123);
          }
          v77 = v180;
          if (!v180)
            goto LABEL_151;
          v124 = v181;
          v79 = v180;
          if (v181 == v180)
            goto LABEL_150;
          do
          {
            v126 = *--v124;
            v125 = v126;
            *v124 = 0;
            if (v126)
              MEMORY[0x20BD002D4](v125, 0x1000C8077774924);
          }
          while (v124 != v77);
        }
        else
        {
LABEL_23:
          if (!*v15)
            goto LABEL_30;
          v174 = *v15;
          v175[0] = 1;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v174);
          if (!v23)
            goto LABEL_30;
          v174 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
          v175[0] = v174 != 0;
          mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v174);
          if (v24 != v13)
          {
            v167 = 257;
            mlir::OpState::emitOpError(this, v166, (uint64_t)&v174);
            v127 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v174, "mapping attribute size must match op rank");
            v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v127);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v174);
            return v51;
          }
          v174 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
          v175[0] = v174 != 0;
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v174);
          if (!v26)
          {
LABEL_30:
            v29 = *this;
            if (HIBYTE(*((_DWORD *)*this + 11)))
              v30 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
            else
              v30 = 0;
            v174 = *(_QWORD *)(v30 + 8);
            v31 = (int64x2_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v174);
            v33 = v32;
            v34 = *((unsigned int *)*this + 11);
            v35 = (uint64_t)&(*this)[2 * ((v34 >> 23) & 1) + 8];
            if (!HIBYTE(*((_DWORD *)*this + 11)))
              v35 = 0;
            if ((v34 & 0x800000) != 0)
              v36 = (*this)[9];
            else
              v36 = 0;
            mlir::ValueRange::ValueRange(v173, v36, *(unsigned int *)(v35 + 32));
            if (!mlir::verifyListOfOperandsOrIntegers(v29, (const void **)"lower bound", (const char *)0xB, v10, v31, v33, v173[0], v173[1]))return 0;
            v37 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
            if (!HIBYTE(*((_DWORD *)*this + 11)))
              v37 = 0;
            v174 = *(_QWORD *)(v37 + 24);
            v38 = (int64x2_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v174);
            v40 = v39;
            v41 = *((unsigned int *)*this + 11);
            v42 = HIBYTE(*((_DWORD *)*this + 11)) ? (uint64_t)&(*this)[2 * ((v41 >> 23) & 1) + 8] : 0;
            v43 = *(unsigned int *)(v42 + 32);
            v44 = *(_DWORD *)(v42 + 36);
            v45 = (v41 & 0x800000) != 0 ? (*this)[9] : 0;
            mlir::ValueRange::ValueRange(v172, v45 + 32 * v43, (v44 + v43) - v43);
            if (!mlir::verifyListOfOperandsOrIntegers(v29, (const void **)"upper bound", (const char *)0xB, v10, v38, v40, v172[0], v172[1]))return 0;
            StaticStrides = (int64x2_t *)mlir::memref::ReinterpretCastOp::getStaticStrides((mlir::memref::ReinterpretCastOp *)this);
            v48 = v47;
            DynamicStep = mlir::scf::ForallOp::getDynamicStep((mlir::scf::ForallOp *)this);
            mlir::ValueRange::ValueRange(v171, DynamicStep, v50);
            return mlir::verifyListOfOperandsOrIntegers(v29, (const void **)"step", (const char *)4, v10, StaticStrides, v48, v171[0], v171[1]) != 0;
          }
          v27 = (_QWORD **)Value;
          v28 = 8 * v26;
          while (mlir::detail::InterfaceMap::lookup<mlir::DeviceMappingAttrInterface>(**v27 + 8))
          {
            ++v27;
            v28 -= 8;
            if (!v28)
              goto LABEL_30;
          }
          v167 = 257;
          mlir::OpState::emitOpError(this, v166, (uint64_t)&v174);
          if (v174)
          {
            mlir::Diagnostic::operator<<((uint64_t)v175, **(_QWORD **)((*this)[6] + 96));
            if (v174)
            {
              v168 = 3;
              v169 = " is not device mapping attribute";
              v170 = 32;
              v128 = &v168;
              v129 = (char *)v176;
              if (v177 >= v178)
              {
                v154 = v177 + 1;
                if (v176 <= &v168 && (char *)v176 + 24 * v177 > (char *)&v168)
                {
                  v165 = (char *)&v168 - (_BYTE *)v176;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v154, 24);
                  v129 = (char *)v176;
                  v128 = (int *)((char *)v176 + v165);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v154, 24);
                  v128 = &v168;
                  v129 = (char *)v176;
                }
              }
              v130 = &v129[24 * v177];
              v131 = *(_OWORD *)v128;
              *((_QWORD *)v130 + 2) = *((_QWORD *)v128 + 2);
              *(_OWORD *)v130 = v131;
              ++v177;
            }
          }
          v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v174);
          if (v174)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v174);
          if (!v184)
            return v51;
          v132 = __p;
          if (__p)
          {
            v133 = v183;
            v134 = __p;
            if (v183 != __p)
            {
              do
                v133 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v133 - 1);
              while (v133 != v132);
              v134 = __p;
            }
            v183 = v132;
            operator delete(v134);
          }
          v77 = v180;
          if (!v180)
            goto LABEL_151;
          v135 = v181;
          v79 = v180;
          if (v181 == v180)
          {
LABEL_150:
            v181 = v77;
            operator delete(v79);
LABEL_151:
            if (v176 != v179)
              free(v176);
            return v51;
          }
          do
          {
            v137 = *--v135;
            v136 = v137;
            *v135 = 0;
            if (v137)
              MEMORY[0x20BD002D4](v136, 0x1000C8077774924);
          }
          while (v135 != v77);
        }
LABEL_149:
        v79 = v180;
        goto LABEL_150;
      }
      v14 = 0;
      while (1)
      {
        v174 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 48) + 8 * (_QWORD)v14) + 8) & 0xFFFFFFFFFFFFFFF8;
        if (!mlir::Type::isIndex((mlir::Type *)&v174))
          break;
        if (v13 == ++v14)
        {
          v4 = *this;
          v6 = *((unsigned int *)*this + 11);
          v7 = (v6 >> 23) & 1;
          goto LABEL_16;
        }
      }
      v166[0] = (const void **)"expects ";
      v167 = 259;
      mlir::OpState::emitOpError(this, v166, (uint64_t)&v174);
      if (v174)
      {
        v168 = 2;
        v169 = v14;
        v97 = &v168;
        v98 = (char *)v176;
        if (v177 >= v178)
        {
          v148 = v177 + 1;
          if (v176 <= &v168 && (char *)v176 + 24 * v177 > (char *)&v168)
          {
            v161 = (char *)&v168 - (_BYTE *)v176;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v148, 24);
            v98 = (char *)v176;
            v97 = (int *)((char *)v176 + v161);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v148, 24);
            v97 = &v168;
            v98 = (char *)v176;
          }
        }
        v99 = &v98[24 * v177];
        v100 = *(_OWORD *)v97;
        *((_QWORD *)v99 + 2) = *((_QWORD *)v97 + 2);
        *(_OWORD *)v99 = v100;
        v101 = ++v177;
        if (v174)
        {
          v168 = 3;
          v169 = "-th block argument to be an index";
          v170 = 33;
          v102 = &v168;
          v103 = (char *)v176;
          if (v101 >= v178)
          {
            v150 = v101 + 1;
            v151 = (char *)v176 + 24 * v101 > (char *)&v168;
            if (v176 <= &v168 && v151)
            {
              v163 = (char *)&v168 - (_BYTE *)v176;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v150, 24);
              v103 = (char *)v176;
              v102 = (int *)((char *)v176 + v163);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v150, 24);
              v102 = &v168;
              v103 = (char *)v176;
            }
          }
          v104 = &v103[24 * v177];
          v105 = *(_OWORD *)v102;
          *((_QWORD *)v104 + 2) = *((_QWORD *)v102 + 2);
          *(_OWORD *)v104 = v105;
          ++v177;
        }
      }
      v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v174);
      if (v174)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v174);
      if (v184)
      {
        v106 = __p;
        if (__p)
        {
          v107 = v183;
          v108 = __p;
          if (v183 != __p)
          {
            do
              v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
            while (v107 != v106);
            v108 = __p;
          }
          v183 = v106;
          operator delete(v108);
        }
        v77 = v180;
        if (!v180)
          goto LABEL_151;
        v109 = v181;
        v79 = v180;
        if (v181 == v180)
          goto LABEL_150;
        do
        {
          v111 = *--v109;
          v110 = v111;
          *v109 = 0;
          if (v111)
            MEMORY[0x20BD002D4](v110, 0x1000C8077774924);
        }
        while (v109 != v77);
        goto LABEL_149;
      }
    }
    else
    {
      v166[0] = (const void **)"region expects ";
      v167 = 259;
      mlir::OpState::emitOpError(this, v166, (uint64_t)&v174);
      if (v174)
      {
        v168 = 5;
        v169 = v13;
        v82 = &v168;
        v83 = (char *)v176;
        if (v177 >= v178)
        {
          v142 = v177 + 1;
          if (v176 <= &v168 && (char *)v176 + 24 * v177 > (char *)&v168)
          {
            v157 = (char *)&v168 - (_BYTE *)v176;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v142, 24);
            v83 = (char *)v176;
            v82 = (int *)((char *)v176 + v157);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v142, 24);
            v82 = &v168;
            v83 = (char *)v176;
          }
        }
        v84 = &v83[24 * v177];
        v85 = *(_OWORD *)v82;
        *((_QWORD *)v84 + 2) = *((_QWORD *)v82 + 2);
        *(_OWORD *)v84 = v85;
        v86 = ++v177;
        if (v174)
        {
          v168 = 3;
          v169 = " arguments";
          v170 = 10;
          v87 = &v168;
          v88 = (char *)v176;
          if (v86 >= v178)
          {
            v144 = v86 + 1;
            v145 = (char *)v176 + 24 * v86 > (char *)&v168;
            if (v176 <= &v168 && v145)
            {
              v159 = (char *)&v168 - (_BYTE *)v176;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v144, 24);
              v88 = (char *)v176;
              v87 = (int *)((char *)v176 + v159);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v144, 24);
              v87 = &v168;
              v88 = (char *)v176;
            }
          }
          v89 = &v88[24 * v177];
          v90 = *(_OWORD *)v87;
          *((_QWORD *)v89 + 2) = *((_QWORD *)v87 + 2);
          *(_OWORD *)v89 = v90;
          ++v177;
        }
      }
      v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v174);
      if (v174)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v174);
      if (v184)
      {
        v91 = __p;
        if (__p)
        {
          v92 = v183;
          v93 = __p;
          if (v183 != __p)
          {
            do
              v92 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v92 - 1);
            while (v92 != v91);
            v93 = __p;
          }
          v183 = v91;
          operator delete(v93);
        }
        v77 = v180;
        if (!v180)
          goto LABEL_151;
        v94 = v181;
        v79 = v180;
        if (v181 == v180)
          goto LABEL_150;
        do
        {
          v96 = *--v94;
          v95 = v96;
          *v94 = 0;
          if (v96)
            MEMORY[0x20BD002D4](v95, 0x1000C8077774924);
        }
        while (v94 != v77);
        goto LABEL_149;
      }
    }
  }
  else
  {
    v166[0] = (const void **)"produces ";
    v167 = 259;
    mlir::OpState::emitOpError(this, v166, (uint64_t)&v174);
    if (v174)
    {
      v52 = (const char *)*((unsigned int *)*this + 9);
      v168 = 5;
      v169 = v52;
      v53 = &v168;
      v54 = (char *)v176;
      if (v177 >= v178)
      {
        v139 = v177 + 1;
        if (v176 <= &v168 && (char *)v176 + 24 * v177 > (char *)&v168)
        {
          v155 = (char *)&v168 - (_BYTE *)v176;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v139, 24);
          v54 = (char *)v176;
          v53 = (int *)((char *)v176 + v155);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v139, 24);
          v53 = &v168;
          v54 = (char *)v176;
        }
      }
      v55 = &v54[24 * v177];
      v56 = *(_OWORD *)v53;
      *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
      *(_OWORD *)v55 = v56;
      v57 = ++v177;
      if (v174)
      {
        v168 = 3;
        v169 = " results, but has only ";
        v170 = 23;
        v58 = &v168;
        v59 = (char *)v176;
        if (v57 >= v178)
        {
          v140 = v57 + 1;
          v141 = (char *)v176 + 24 * v57 > (char *)&v168;
          if (v176 <= &v168 && v141)
          {
            v156 = (char *)&v168 - (_BYTE *)v176;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v140, 24);
            v59 = (char *)v176;
            v58 = (int *)((char *)v176 + v156);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v140, 24);
            v58 = &v168;
            v59 = (char *)v176;
          }
        }
        v60 = &v59[24 * v177];
        v61 = *(_OWORD *)v58;
        *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
        *(_OWORD *)v60 = v61;
        ++v177;
        if (v174)
        {
          v62 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
          if (!HIBYTE(*((_DWORD *)*this + 11)))
            v62 = 0;
          v63 = *((_DWORD *)v62 + 11);
          v64 = (*((_DWORD *)v62 + 9) + *((_DWORD *)v62 + 8) + *((_DWORD *)v62 + 10));
          v168 = 5;
          v169 = (const char *)((v63 + v64) - v64);
          v65 = &v168;
          v66 = (char *)v176;
          if (v177 >= v178)
          {
            v143 = v177 + 1;
            if (v176 <= &v168 && (char *)v176 + 24 * v177 > (char *)&v168)
            {
              v158 = (char *)&v168 - (_BYTE *)v176;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v143, 24);
              v66 = (char *)v176;
              v65 = (int *)((char *)v176 + v158);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v143, 24);
              v65 = &v168;
              v66 = (char *)v176;
            }
          }
          v67 = &v66[24 * v177];
          v68 = *(_OWORD *)v65;
          *((_QWORD *)v67 + 2) = *((_QWORD *)v65 + 2);
          *(_OWORD *)v67 = v68;
          v69 = ++v177;
          if (v174)
          {
            v168 = 3;
            v169 = " outputs";
            v170 = 8;
            v70 = &v168;
            v71 = (char *)v176;
            if (v69 >= v178)
            {
              v146 = v69 + 1;
              v147 = (char *)v176 + 24 * v69 > (char *)&v168;
              if (v176 <= &v168 && v147)
              {
                v160 = (char *)&v168 - (_BYTE *)v176;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v146, 24);
                v71 = (char *)v176;
                v70 = (int *)((char *)v176 + v160);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v176, v179, v146, 24);
                v70 = &v168;
                v71 = (char *)v176;
              }
            }
            v72 = &v71[24 * v177];
            v73 = *(_OWORD *)v70;
            *((_QWORD *)v72 + 2) = *((_QWORD *)v70 + 2);
            *(_OWORD *)v72 = v73;
            ++v177;
          }
        }
      }
    }
    v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v174);
    if (v174)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v174);
    if (v184)
    {
      v74 = __p;
      if (__p)
      {
        v75 = v183;
        v76 = __p;
        if (v183 != __p)
        {
          do
            v75 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v75 - 1);
          while (v75 != v74);
          v76 = __p;
        }
        v183 = v74;
        operator delete(v76);
      }
      v77 = v180;
      if (!v180)
        goto LABEL_151;
      v78 = v181;
      v79 = v180;
      if (v181 == v180)
        goto LABEL_150;
      do
      {
        v81 = *--v78;
        v80 = v81;
        *v78 = 0;
        if (v81)
          MEMORY[0x20BD002D4](v80, 0x1000C8077774924);
      }
      while (v78 != v77);
      goto LABEL_149;
    }
  }
  return v51;
}

uint64_t mlir::scf::ForallOp::getDynamicStep(mlir::scf::ForallOp *this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = *(_QWORD *)this + 16 * ((v1 >> 23) & 1) + 64;
  else
    v2 = 0;
  v3 = (*(_DWORD *)(v2 + 36) + *(_DWORD *)(v2 + 32));
  if ((v1 & 0x800000) != 0)
    return *(_QWORD *)(*(_QWORD *)this + 72) + 32 * v3;
  else
    return 32 * v3;
}

uint64_t mlir::scf::ForallOp::print(mlir::scf::ForallOp *this, mlir::OpAsmPrinter *a2)
{
  _BYTE *v4;
  llvm::raw_ostream *v5;
  _WORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int isNormalized;
  llvm::raw_ostream *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  llvm::raw_ostream *v37;
  _DWORD *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  llvm::raw_ostream *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  unint64_t v64;
  _DWORD *v65;
  int v66;
  int v67;
  int v68;
  int v69;
  uint64_t v70;
  llvm::raw_ostream *v71;
  _BYTE *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  llvm::raw_ostream *v79;
  _DWORD *v80;
  uint64_t v81;
  const char *v82;
  llvm::raw_ostream *v83;
  _WORD *v84;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  const char *v97;
  uint64_t v98;
  unint64_t AttrDictionary;
  uint64_t v100;
  uint64_t AttrData;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107[2];
  unint64_t v108[2];
  unint64_t v109[2];
  unint64_t v110[2];
  unint64_t v111[3];

  v111[2] = *MEMORY[0x24BDAC8D0];
  v4 = *(_BYTE **)this;
  v5 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v6 = (_WORD *)*((_QWORD *)v5 + 4);
  if (*((_QWORD *)v5 + 3) - (_QWORD)v6 > 1uLL)
  {
    *v6 = 10272;
    *((_QWORD *)v5 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v5, " (", 2uLL);
  }
  v7 = *(unsigned int *)(*(_QWORD *)this + 44);
  v8 = *(_QWORD *)this + 16 * ((v7 >> 23) & 1) + 64;
  v9 = *(_QWORD *)(((v8 + ((v7 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                 + 8);
  if (v9)
    v10 = v9 - 8;
  else
    v10 = 0;
  v11 = *(_QWORD *)(v10 + 48);
  v12 = (*(_QWORD *)(v10 + 56) - v11) >> 3;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v8 = 0;
  AttrDictionary = *(_QWORD *)(v8 + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
  if (v12 >= v13)
    v14 = v13;
  else
    v14 = v12;
  mlir::ValueRange::ValueRange(&AttrDictionary, v11, v14);
  mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator>((uint64_t)a2, AttrDictionary, 0, AttrDictionary, v100);
  isNormalized = mlir::scf::ForallOp::isNormalized(this);
  v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v17 = *((_QWORD *)v16 + 4);
  v18 = *((_QWORD *)v16 + 3) - v17;
  if (isNormalized)
  {
    if (v18 > 4)
    {
      *(_BYTE *)(v17 + 4) = 32;
      *(_DWORD *)v17 = 1852383273;
      *((_QWORD *)v16 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v16, ") in ", 5uLL);
    }
    v19 = *(unsigned int *)(*(_QWORD *)this + 44);
    v20 = *(_QWORD *)this + 16 * ((v19 >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v20 = 0;
    v21 = *(unsigned int *)(v20 + 32);
    if ((v19 & 0x800000) != 0)
      v22 = *(_QWORD *)(*(_QWORD *)this + 72);
    else
      v22 = 0;
    v23 = v22 + 32 * v21;
    v24 = (*(_DWORD *)(v20 + 36) + v21) - v21;
    AttrDictionary = *(_QWORD *)(v20 + 24);
    v25 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
    v27 = v26;
    mlir::ValueRange::ValueRange(v111, 0, 0);
    v28 = v111[0];
    v29 = v111[1];
  }
  else
  {
    if (v18 > 3)
    {
      *(_DWORD *)v17 = 540876841;
      *((_QWORD *)v16 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v16, ") = ", 4uLL);
    }
    v30 = *(unsigned int *)(*(_QWORD *)this + 44);
    v31 = *(_QWORD *)this + 16 * ((v30 >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v31 = 0;
    v32 = *(unsigned int *)(v31 + 32);
    if ((v30 & 0x800000) != 0)
      v33 = *(_QWORD *)(*(_QWORD *)this + 72);
    else
      v33 = 0;
    AttrDictionary = *(_QWORD *)(v31 + 8);
    v34 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
    v36 = v35;
    mlir::ValueRange::ValueRange(v110, 0, 0);
    mlir::printDynamicIndexList((uint64_t)a2, (uint64_t)v4, v33, v32, v34, v36, v110[0], v110[1], 0, 0, 1);
    v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v38 = (_DWORD *)*((_QWORD *)v37 + 4);
    if (*((_QWORD *)v37 + 3) - (_QWORD)v38 > 3uLL)
    {
      *v38 = 544175136;
      *((_QWORD *)v37 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v37, " to ", 4uLL);
    }
    v39 = *(unsigned int *)(*(_QWORD *)this + 44);
    v40 = *(_QWORD *)this + 16 * ((v39 >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v40 = 0;
    v41 = *(unsigned int *)(v40 + 32);
    if ((v39 & 0x800000) != 0)
      v42 = *(_QWORD *)(*(_QWORD *)this + 72);
    else
      v42 = 0;
    v43 = v42 + 32 * v41;
    v44 = (*(_DWORD *)(v40 + 36) + v41) - v41;
    AttrDictionary = *(_QWORD *)(v40 + 24);
    v45 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
    v47 = v46;
    mlir::ValueRange::ValueRange(v109, 0, 0);
    mlir::printDynamicIndexList((uint64_t)a2, (uint64_t)v4, v43, v44, v45, v47, v109[0], v109[1], 0, 0, 1);
    v48 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v49 = *((_QWORD *)v48 + 4);
    if ((unint64_t)(*((_QWORD *)v48 + 3) - v49) > 5)
    {
      *(_WORD *)(v49 + 4) = 8304;
      *(_DWORD *)v49 = 1702130464;
      *((_QWORD *)v48 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v48, " step ", 6uLL);
    }
    v50 = *(unsigned int *)(*(_QWORD *)this + 44);
    v51 = *(_QWORD *)this + 16 * ((v50 >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v51 = 0;
    if ((v50 & 0x800000) != 0)
      v52 = *(_QWORD *)(*(_QWORD *)this + 72);
    else
      v52 = 0;
    v53 = (*(_DWORD *)(v51 + 36) + *(_DWORD *)(v51 + 32));
    v23 = v52 + 32 * v53;
    v24 = (*(_DWORD *)(v51 + 40) + v53) - v53;
    AttrDictionary = *(_QWORD *)(v51 + 16);
    v25 = (unint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
    v27 = v54;
    mlir::ValueRange::ValueRange(v108, 0, 0);
    v28 = v108[0];
    v29 = v108[1];
  }
  mlir::printDynamicIndexList((uint64_t)a2, (uint64_t)v4, v23, v24, v25, v27, v28, v29, 0, 0, 1);
  v55 = *(unsigned int *)(*(_QWORD *)this + 44);
  v56 = *(_QWORD *)this + 16 * ((v55 >> 23) & 1) + 64;
  v57 = *(_QWORD *)(((v56 + ((v55 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                  + 8);
  if (v57)
    v58 = v57 - 8;
  else
    v58 = 0;
  v59 = *(_QWORD *)(v58 + 48);
  v60 = (*(_QWORD *)(v58 + 56) - v59) >> 3;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v56 = 0;
  AttrDictionary = *(_QWORD *)(v56 + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
  v62 = v60 - v61;
  v63 = (_QWORD *)(v59 + 8 * v61);
  v64 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v65 = (_DWORD *)(*(_QWORD *)this + 16 * ((v64 >> 23) & 1) + 64);
  else
    v65 = 0;
  v66 = v65[8];
  v67 = v65[9];
  v69 = v65[10];
  v68 = v65[11];
  if ((v64 & 0x800000) != 0)
    v70 = *(_QWORD *)(*(_QWORD *)this + 72);
  else
    v70 = 0;
  mlir::ValueRange::ValueRange(v107, v70 + 32 * (v67 + v66 + v69), (v68 + v67 + v66 + v69) - (unint64_t)(v67 + v66 + v69));
  printInitializationList(a2, v63, v62, v107[0], v107[1], " shared_outs", 0xCuLL);
  v71 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v72 = (_BYTE *)*((_QWORD *)v71 + 4);
  if (*((_BYTE **)v71 + 3) == v72)
  {
    llvm::raw_ostream::write(v71, " ", 1uLL);
  }
  else
  {
    *v72 = 32;
    ++*((_QWORD *)v71 + 4);
  }
  v73 = *(unsigned int *)(*(_QWORD *)this + 44);
  v74 = *(_QWORD *)this + 16 * ((v73 >> 23) & 1) + 64;
  v75 = *(_QWORD *)(((v74 + ((v73 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                  + 8);
  if (v75)
    v76 = v75 - 8;
  else
    v76 = 0;
  v77 = *(_QWORD *)(v76 + 56) - *(_QWORD *)(v76 + 48);
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v74 = 0;
  AttrDictionary = *(_QWORD *)(v74 + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&AttrDictionary);
  if (v78 != v77 >> 3)
  {
    v79 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v80 = (_DWORD *)*((_QWORD *)v79 + 4);
    if (*((_QWORD *)v79 + 3) - (_QWORD)v80 > 3uLL)
    {
      *v80 = 673201709;
      *((_QWORD *)v79 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v79, "-> (", 4uLL);
    }
    v81 = *(unsigned int *)(*(_QWORD *)this + 36);
    v82 = (const char *)(*(_QWORD *)this - 16);
    if (!(_DWORD)v81)
      v82 = 0;
    v97 = v82;
    v98 = v81;
    mlir::OperandRange::getTypes((uint64_t *)&v97, (uint64_t *)&AttrDictionary);
    v97 = ", ";
    v98 = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(AttrDictionary, v100, AttrData, v102, (uint64_t)a2, (uint64_t)a2, (uint64_t)&v97);
    v83 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v84 = (_WORD *)*((_QWORD *)v83 + 4);
    if (*((_QWORD *)v83 + 3) - (_QWORD)v84 > 1uLL)
    {
      *v84 = 8233;
      *((_QWORD *)v83 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v83, ") ", 2uLL);
    }
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, BOOL, _QWORD))(*(_QWORD *)a2 + 224))(a2, ((*(_QWORD *)this+ 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(*(_QWORD *)this + 40), 0, *(_DWORD *)(*(_QWORD *)this + 36) != 0, 0);
  if (v4[47])
  {
    AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::ArrayAttr *)(v4 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  v88 = v87;
  v97 = *(const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 96)
                       + 8 * *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 104)
                       - 8);
  AttrDictionary = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v97);
  v100 = v89;
  v96 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 96) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v96);
  v102 = v90;
  v95 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 96) + 24);
  v103 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v95);
  v104 = v91;
  v94 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 96) + 16);
  v105 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v94);
  v106 = v92;
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, unint64_t *, uint64_t))(*(_QWORD *)a2 + 192))(a2, Value, v88, &AttrDictionary, 4);
}

uint64_t mlir::scf::ForallOp::isNormalized(mlir::scf::ForallOp *this)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  char v5;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t ConstantIntValue;
  char v11;
  BOOL v12;
  BOOL v13;
  uint64_t v14;
  void *v16;
  unsigned int v17;
  _BYTE v18[48];
  void *v19;
  unsigned int v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x24BDAC8D0];
  mlir::scf::ForallOp::getMixedLowerBound(this, (uint64_t)&v19);
  if (!v20)
  {
LABEL_9:
    mlir::scf::ForallOp::getMixedStep(this, (uint64_t)&v16);
    v7 = (uint64_t *)v16;
    if (v17)
    {
      v8 = 8 * v17 - 8;
      do
      {
        v9 = *v7++;
        ConstantIntValue = mlir::getConstantIntValue(v9);
        if (v11)
          v12 = ConstantIntValue == 1;
        else
          v12 = 0;
        v14 = v12;
        v13 = (_DWORD)v14 != 1 || v8 == 0;
        v8 -= 8;
      }
      while (!v13);
      v7 = (uint64_t *)v16;
      if (v16 == v18)
        goto LABEL_26;
    }
    else
    {
      v14 = 1;
      if (v16 == v18)
        goto LABEL_26;
    }
    free(v7);
    goto LABEL_26;
  }
  v2 = (uint64_t *)v19;
  v3 = 8 * v20;
  while (1)
  {
    v4 = mlir::getConstantIntValue(*v2);
    if (!v5 || v4 != 0)
      break;
    ++v2;
    v3 -= 8;
    if (!v3)
      goto LABEL_9;
  }
  v14 = 0;
LABEL_26:
  if (v19 != v21)
    free(v19);
  return v14;
}

uint64_t mlir::scf::ForallOp::parse(mlir::AsmParser *a1, uint64_t a2)
{
  mlir::MLIRContext *v4;
  uint64_t IndexType;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _BYTE *v18;
  uint64_t v19;
  mlir::MLIRContext *v20;
  mlir::Region *v21;
  char *v22;
  unint64_t v23;
  char *v24;
  char *v25;
  __int128 *v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  unsigned int v31;
  unint64_t v32;
  int64_t v34;
  uint64_t v35;
  char *v36;
  unint64_t v37;
  char *v38;
  char *v39;
  __int128 *v40;
  char *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  unint64_t v45;
  char *v46;
  mlir::MLIRContext **v48;
  uint64_t DenseI32ArrayAttr;
  mlir::Region *v50;
  int64_t v51;
  mlir::Region *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t DenseI64ArrayAttr;
  mlir::MLIRContext *v56[4];
  void *v57;
  uint64_t v58;
  _BYTE v59[256];
  const char *v60;
  int v61;
  int v62;
  __int16 v63;
  void *v64;
  uint64_t v65;
  _BYTE v66[128];
  void *__b;
  uint64_t v68;
  _BYTE v69[16];
  __int16 v70;
  void *v71;
  uint64_t v72;
  _BYTE v73[32];
  void *v74;
  uint64_t v75;
  _BYTE v76[32];
  void *v77;
  uint64_t v78;
  _BYTE v79[32];
  void *v80;
  uint64_t v81;
  _QWORD v82[34];

  v82[32] = *MEMORY[0x24BDAC8D0];
  v56[0] = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
  memset(&v56[1], 0, 24);
  IndexType = mlir::Builder::getIndexType(v56, v4);
  v80 = v82;
  v81 = 0x400000000;
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, void **, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 736))(a1, &v80, 1, 0, 0))
  {
    v10 = 0;
    goto LABEL_37;
  }
  v54 = 0;
  DenseI64ArrayAttr = 0;
  v53 = 0;
  v77 = v79;
  v78 = 0x100000000;
  v74 = v76;
  v75 = 0x100000000;
  v71 = v73;
  v72 = 0x100000000;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "in", 2))
  {
    __b = 0;
    if (mlir::parseDynamicIndexList((uint64_t)a1, (uint64_t)&v74, &v54, (uint64_t *)&__b, 0, 1))
    {
      if ((_DWORD)v75)
      {
        v6 = (char *)v74;
        v7 = 32 * v75;
        while ((*(unsigned __int8 (**)(mlir::AsmParser *, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v6, IndexType, a2 + 16))
        {
          v6 += 32;
          v7 -= 32;
          if (!v7)
            goto LABEL_8;
        }
        goto LABEL_30;
      }
LABEL_8:
      v8 = v81;
      __b = v69;
      HIDWORD(v68) = 6;
      if (v81 < 7)
      {
        if ((_DWORD)v81)
          bzero(v69, 8 * v81);
        v9 = v69;
      }
      else
      {
        LODWORD(v68) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v69, v81, 8);
        v9 = __b;
        bzero(__b, 8 * v8);
      }
      LODWORD(v68) = v8;
      DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(v56, (uint64_t)v9, v8);
      if (__b != v69)
        free(__b);
      __b = v69;
      HIDWORD(v68) = 6;
      if (v8 < 7)
      {
        if ((_DWORD)v8)
          memset_pattern16(v69, &unk_207A80400, 8 * v8);
        v18 = v69;
      }
      else
      {
        LODWORD(v68) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v69, v8, 8);
        v18 = __b;
        memset_pattern16(__b, &unk_207A80400, 8 * v8);
      }
      LODWORD(v68) = v8;
      v53 = mlir::Builder::getDenseI64ArrayAttr(v56, (uint64_t)v18, v8);
      if (__b != v69)
        free(__b);
LABEL_52:
      __b = v69;
      v68 = 0x400000000;
      v64 = v66;
      v65 = 0x400000000;
      v19 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      if ((*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "shared_outs", 11))
      {
        if ((_DWORD)v65 == *(_DWORD *)(a2 + 72))
        {
          if (mlir::OpAsmParser::parseAssignmentList((uint64_t)a1)
            && (*(unsigned __int8 (**)(mlir::AsmParser *, uint64_t))(*(_QWORD *)a1 + 536))(a1, a2 + 64)
            && mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>((uint64_t)a1, (uint64_t *)&v64, a2 + 64, v19, a2 + 16))
          {
            goto LABEL_57;
          }
          v10 = 0;
        }
        else
        {
          v60 = "mismatch between out operands and types";
          v63 = 259;
          (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const char **))(*(_QWORD *)a1 + 24))(&v57, a1, v19, &v60);
          v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v57);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v57);
        }
LABEL_91:
        if (v64 != v66)
          free(v64);
        if (__b != v69)
          free(__b);
        goto LABEL_31;
      }
LABEL_57:
      v57 = v59;
      v58 = 0x400000000;
      v21 = (mlir::Region *)operator new();
      *(_QWORD *)v21 = v21;
      *((_QWORD *)v21 + 1) = v21;
      *((_QWORD *)v21 + 2) = 0;
      v52 = v21;
      if ((_DWORD)v81)
      {
        v22 = (char *)v80;
        v23 = (unint64_t)v81 << 6;
        v24 = (char *)v80;
        do
        {
          *((_QWORD *)v24 + 4) = mlir::Builder::getIndexType(v56, v20);
          v25 = (char *)v57;
          v26 = (__int128 *)v24;
          if (v58 >= HIDWORD(v58))
          {
            v32 = v58 + 1;
            if (v57 <= v24 && (char *)v57 + 64 * (unint64_t)v58 > v24)
            {
              v34 = v22 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v32, 64);
              v25 = (char *)v57;
              v26 = (__int128 *)((char *)v57 + v34);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v32, 64);
              v25 = (char *)v57;
              v26 = (__int128 *)v24;
            }
          }
          v27 = &v25[64 * (unint64_t)v58];
          v28 = *v26;
          v29 = v26[1];
          v30 = v26[3];
          *((_OWORD *)v27 + 2) = v26[2];
          *((_OWORD *)v27 + 3) = v30;
          *(_OWORD *)v27 = v28;
          *((_OWORD *)v27 + 1) = v29;
          v31 = v58 + 1;
          LODWORD(v58) = v58 + 1;
          v24 += 64;
          v22 += 64;
          v23 -= 64;
        }
        while (v23);
      }
      else
      {
        v31 = v58;
      }
      if ((_DWORD)v68)
      {
        v35 = 0;
        v36 = (char *)__b;
        v37 = (unint64_t)v68 << 6;
        v38 = (char *)__b;
        do
        {
          *((_QWORD *)v38 + 4) = *(_QWORD *)(*(_QWORD *)(a2 + 64) + v35);
          v39 = (char *)v57;
          v40 = (__int128 *)v38;
          if (v31 >= HIDWORD(v58))
          {
            v45 = v31 + 1;
            v46 = (char *)v57 + 64 * (unint64_t)v31;
            if (v57 <= v38 && v46 > v38)
            {
              v51 = v36 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v45, 64);
              v39 = (char *)v57;
              v40 = (__int128 *)((char *)v57 + v51);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v45, 64);
              v39 = (char *)v57;
              v40 = (__int128 *)v38;
            }
          }
          v41 = &v39[64 * (unint64_t)v58];
          v42 = *v40;
          v43 = v40[1];
          v44 = v40[3];
          *((_OWORD *)v41 + 2) = v40[2];
          *((_OWORD *)v41 + 3) = v44;
          *(_OWORD *)v41 = v42;
          *((_OWORD *)v41 + 1) = v43;
          v31 = v58 + 1;
          LODWORD(v58) = v58 + 1;
          v38 += 64;
          v36 += 64;
          v35 += 8;
          v37 -= 64;
        }
        while (v37);
      }
      if ((*(unsigned __int8 (**)(mlir::AsmParser *, mlir::Region *, void *, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v21, v57, v31, 0))
      {
        mlir::scf::ForallOp::ensureTerminator(v21, v56, *(_QWORD *)a2);
        mlir::OperationState::addRegion(a2, (unint64_t)&v52);
        if ((*(unsigned __int8 (**)(mlir::AsmParser *, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
        {
          mlir::OperationState::addAttribute((mlir::Attribute *)a2, (uint64_t)"staticLowerBound", 16, DenseI64ArrayAttr);
          mlir::OperationState::addAttribute((mlir::Attribute *)a2, (uint64_t)"staticUpperBound", 16, v54);
          mlir::OperationState::addAttribute((mlir::Attribute *)a2, (uint64_t)"staticStep", 10, v53);
          v48 = (mlir::MLIRContext **)(*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 32))(a1);
          v60 = (const char *)__PAIR64__(v75, v78);
          v61 = v72;
          v62 = v65;
          DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(v48, (uint64_t)&v60, 4);
          mlir::OperationState::addAttribute((mlir::Attribute *)a2, (uint64_t)"operandSegmentSizes", 19, DenseI32ArrayAttr);
          v10 = 1;
        }
        else
        {
          v10 = 0;
        }
      }
      else
      {
        v10 = 0;
      }
      v50 = v52;
      v52 = 0;
      if (v50)
      {
        mlir::Region::~Region(v50);
        MEMORY[0x20BD002F8]();
      }
      if (v57 != v59)
        free(v57);
      goto LABEL_91;
    }
  }
  else if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 136))(a1))
  {
    __b = 0;
    if (mlir::parseDynamicIndexList((uint64_t)a1, (uint64_t)&v77, &DenseI64ArrayAttr, (uint64_t *)&__b, 0, 1))
    {
      if ((_DWORD)v78)
      {
        v11 = (char *)v77;
        v12 = 32 * v78;
        while ((*(unsigned __int8 (**)(mlir::AsmParser *, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v11, IndexType, a2 + 16))
        {
          v11 += 32;
          v12 -= 32;
          if (!v12)
            goto LABEL_17;
        }
        goto LABEL_30;
      }
LABEL_17:
      v70 = 257;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "to", 2, &__b))
      {
        __b = 0;
        if (mlir::parseDynamicIndexList((uint64_t)a1, (uint64_t)&v74, &v54, (uint64_t *)&__b, 0, 1))
        {
          if ((_DWORD)v75)
          {
            v13 = (char *)v74;
            v14 = 32 * v75;
            while ((*(unsigned __int8 (**)(mlir::AsmParser *, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v13, IndexType, a2 + 16))
            {
              v13 += 32;
              v14 -= 32;
              if (!v14)
                goto LABEL_23;
            }
            goto LABEL_30;
          }
LABEL_23:
          v70 = 257;
          if ((*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "step", 4, &__b))
          {
            __b = 0;
            if (mlir::parseDynamicIndexList((uint64_t)a1, (uint64_t)&v71, &v53, (uint64_t *)&__b, 0, 1))
            {
              if ((_DWORD)v72)
              {
                v15 = (char *)v71;
                v16 = 32 * v72;
                while ((*(unsigned __int8 (**)(mlir::AsmParser *, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v15, IndexType, a2 + 16))
                {
                  v15 += 32;
                  v16 -= 32;
                  if (!v16)
                    goto LABEL_52;
                }
                goto LABEL_30;
              }
              goto LABEL_52;
            }
          }
        }
      }
    }
  }
LABEL_30:
  v10 = 0;
LABEL_31:
  if (v71 != v73)
    free(v71);
  if (v74 != v76)
    free(v74);
  if (v77 != v79)
    free(v77);
LABEL_37:
  if (v80 != v82)
    free(v80);
  return v10;
}

void mlir::scf::ForallOp::ensureTerminator(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  ZinIrHalH13g **v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10[3];

  v10[2] = *MEMORY[0x24BDAC8D0];
  mlir::impl::ensureRegionTerminator(a1, (uint64_t)a2, a3, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::scf::ForallOp>::buildTerminator);
  v5 = a1[1];
  if (v5)
    v6 = (ZinIrHalH13g **)(v5 - 8);
  else
    v6 = 0;
  mlir::Block::getTerminator(v6);
  if (*(_UNKNOWN **)(*(_QWORD *)(v7 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::InParallelOp,void>::id)
    v8 = v7;
  else
    v8 = 0;
  v9 = (_QWORD *)(((v8
                  + 16 * (((unint64_t)*(unsigned int *)(v8 + 44) >> 23) & 1)
                  + (((unint64_t)*(unsigned int *)(v8 + 44) >> 21) & 0x7F8)
                  + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(v8 + 40));
  if ((_QWORD *)*v9 == v9)
  {
    mlir::ValueRange::ValueRange(v10, 0, 0);
    mlir::OpBuilder::createBlock(a2, (uint64_t)v9, 0, v10[0], v10[1], 0, 0);
  }
}

void mlir::scf::ForallOp::build(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unint64_t a10, uint64_t a11, char a12, void (*a13)(uint64_t, uint64_t, uint64_t, unint64_t, unint64_t), uint64_t a14)
{
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t DenseI64ArrayAttr;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t DenseI32ArrayAttr;
  mlir::StringAttr *Context;
  uint64_t v34;
  _QWORD *v35;
  _OWORD *v36;
  mlir::MLIRContext *v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t IndexType;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  int64x2_t v44;
  int64x2_t *v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  int64x2_t v51;
  int64x2_t *v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  int64x2_t v57;
  int64x2_t *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int128 v62;
  void *v63;
  __int128 v64;
  unint64_t v65[2];
  unint64_t v66[2];
  void *v67;
  uint64_t v68;
  _QWORD v69[6];
  void *v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78[2];
  unint64_t v79[2];
  _DWORD v80[4];
  unint64_t v81[2];
  unint64_t v82[2];
  unint64_t v83[2];
  void *v84;
  uint64_t v85;
  _BYTE v86[48];
  void *v87;
  uint64_t v88;
  _BYTE v89[48];
  void *v90;
  uint64_t v91;
  _BYTE v92[48];
  void *v93;
  uint64_t v94;
  _BYTE v95[48];
  _BYTE *v96;
  uint64_t v97;
  _BYTE v98[48];
  _QWORD *v99;
  uint64_t v100;
  _QWORD v101[8];

  v101[6] = *MEMORY[0x24BDAC8D0];
  v99 = v101;
  v100 = 0x600000000;
  v96 = v98;
  v97 = 0x600000000;
  v93 = v95;
  v94 = 0x600000000;
  v90 = v92;
  v91 = 0x600000000;
  v87 = v89;
  v88 = 0x600000000;
  v84 = v86;
  v85 = 0x600000000;
  mlir::dispatchIndexOpFoldResults(a3, a4, (uint64_t)&v90, (uint64_t)&v99);
  mlir::dispatchIndexOpFoldResults(a5, a6, (uint64_t)&v87, (uint64_t)&v96);
  mlir::dispatchIndexOpFoldResults(a7, a8, (uint64_t)&v84, (uint64_t)&v93);
  mlir::ValueRange::ValueRange(v83, (uint64_t)v90, v91);
  mlir::OperationState::addOperands(a2, v83[0], v83[1]);
  mlir::ValueRange::ValueRange(v82, (uint64_t)v87, v88);
  mlir::OperationState::addOperands(a2, v82[0], v82[1]);
  mlir::ValueRange::ValueRange(v81, (uint64_t)v84, v85);
  mlir::OperationState::addOperands(a2, v81[0], v81[1]);
  mlir::OperationState::addOperands(a2, a9, a10);
  mlir::TypeRange::TypeRange((unint64_t *)&v70, a9, a10);
  v22 = v70;
  v21 = v71;
  v23 = *(unsigned int *)(a2 + 72);
  if (v71 + v23 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v71 + v23, 8);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  if (v21)
  {
    v24 = 0;
    v25 = *(_QWORD *)(a2 + 64) + 8 * v23;
    do
    {
      *(_QWORD *)(v25 + 8 * v24) = mlir::TypeRange::dereference_iterator((uint64_t)v22, v24);
      ++v24;
    }
    while (v21 != v24);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v23 + v21;
  v26 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 8);
  DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v99, v100);
  ZinMirCacheTensors::ZinMirCacheTensors(&v70, v26, DenseI64ArrayAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v70, v71);
  v28 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 24);
  v29 = mlir::Builder::getDenseI64ArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v96, v97);
  ZinMirCacheTensors::ZinMirCacheTensors(&v70, v28, v29);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v70, v71);
  v30 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 16);
  v31 = mlir::Builder::getDenseI64ArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v93, v94);
  ZinMirCacheTensors::ZinMirCacheTensors(&v70, v30, v31);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v70, v71);
  v80[0] = v91;
  v80[1] = v88;
  v80[2] = v85;
  v80[3] = a10;
  DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v80, 4);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  LOWORD(v74) = 261;
  v70 = "operandSegmentSizes";
  v71 = 19;
  v34 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v70);
  ZinMirCacheTensors::ZinMirCacheTensors(&v67, v34, DenseI32ArrayAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v67, v68);
  if (a12)
  {
    ZinMirCacheTensors::ZinMirCacheTensors(&v70, **(_QWORD **)(*(_QWORD *)(a2 + 8) + 96), a11);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v70, v71);
  }
  v35 = (_QWORD *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  v36 = (_OWORD *)(a1 + 16);
  v64 = *(_OWORD *)(a1 + 16);
  mlir::ValueRange::ValueRange(v79, 0, 0);
  mlir::OpBuilder::createBlock((_QWORD *)a1, (uint64_t)v35, 0, v79[0], v79[1], 0, 0);
  v38 = v35[1];
  if (v38)
    v39 = (_QWORD *)(v38 - 8);
  else
    v39 = 0;
  IndexType = mlir::Builder::getIndexType((mlir::IndexType **)a1, v37);
  v41 = IndexType;
  v70 = &v72;
  HIDWORD(v71) = 6;
  if (a4 < 7)
  {
    if (a4)
    {
      v72 = IndexType;
      if (a4 != 1)
      {
        v73 = IndexType;
        if (a4 != 2)
        {
          v74 = IndexType;
          if (a4 != 3)
          {
            v75 = IndexType;
            if (a4 != 4)
            {
              v76 = IndexType;
              if (a4 != 5)
                v77 = IndexType;
            }
          }
        }
      }
    }
  }
  else
  {
    LODWORD(v71) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, &v72, a4, 8);
    v42 = (unint64_t *)((char *)v70 + 8 * (a4 & 0xFFFFFFFFFFFFFFFCLL));
    v43 = a4 & 3;
    v44 = vdupq_n_s64(v41);
    v45 = (int64x2_t *)((char *)v70 + 16);
    v46 = a4 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v45[-1] = v44;
      *v45 = v44;
      v45 += 2;
      v46 -= 4;
    }
    while (v46);
    if (a4 != (a4 & 0xFFFFFFFFFFFFFFFCLL))
    {
      do
      {
        *v42++ = v41;
        --v43;
      }
      while (v43);
    }
  }
  LODWORD(v71) = a4;
  mlir::ValueRange::ValueRange(v78, (uint64_t)v70, a4);
  v47 = v100;
  v67 = v69;
  v68 = 0x600000000;
  v48 = *(_QWORD *)a2;
  if (v100 < 7)
  {
    if ((_DWORD)v100)
    {
      v69[0] = *(_QWORD *)a2;
      if ((_DWORD)v100 != 1)
      {
        v69[1] = v48;
        if ((_DWORD)v100 != 2)
        {
          v69[2] = v48;
          if ((_DWORD)v100 != 3)
          {
            v69[3] = v48;
            if ((_DWORD)v100 != 4)
            {
              v69[4] = v48;
              if ((_DWORD)v100 != 5)
                v69[5] = v48;
            }
          }
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v67, v69, v100, 8);
    v49 = (unint64_t *)((char *)v67 + 8 * (v47 & 0xFFFFFFFC));
    v50 = v47 & 3;
    v51 = vdupq_n_s64(v48);
    v52 = (int64x2_t *)((char *)v67 + 16);
    v53 = v47 & 0xFFFFFFFC;
    do
    {
      v52[-1] = v51;
      *v52 = v51;
      v52 += 2;
      v53 -= 4;
    }
    while (v53);
    if ((v47 & 0xFFFFFFFC) != v47)
    {
      do
      {
        *v49++ = v48;
        --v50;
      }
      while (v50);
    }
  }
  LODWORD(v68) = v47;
  mlir::Block::addArguments(v39, v78[0], v78[1], (uint64_t)v67, v47);
  if (v67 != v69)
    free(v67);
  if (v70 != &v72)
    free(v70);
  mlir::TypeRange::TypeRange(v66, a9, a10);
  v70 = &v72;
  v71 = 0x600000000;
  v54 = *(_QWORD *)a2;
  if (a10 < 7)
  {
    if (a10)
    {
      v72 = *(_QWORD *)a2;
      if (a10 != 1)
      {
        v73 = v54;
        if (a10 != 2)
        {
          v74 = v54;
          if (a10 != 3)
          {
            v75 = v54;
            if (a10 != 4)
            {
              v76 = v54;
              if (a10 != 5)
                v77 = v54;
            }
          }
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, &v72, a10, 8);
    v55 = (unint64_t *)((char *)v70 + 8 * (a10 & 0xFFFFFFFFFFFFFFFCLL));
    v56 = a10 & 3;
    v57 = vdupq_n_s64(v54);
    v58 = (int64x2_t *)((char *)v70 + 16);
    v59 = a10 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v58[-1] = v57;
      *v58 = v57;
      v58 += 2;
      v59 -= 4;
    }
    while (v59);
    if (a10 != (a10 & 0xFFFFFFFFFFFFFFFCLL))
    {
      do
      {
        *v55++ = v54;
        --v56;
      }
      while (v56);
    }
  }
  LODWORD(v71) = a10;
  mlir::Block::addArguments(v39, v66[0], v66[1], (uint64_t)v70, a10);
  if (v70 != &v72)
    free(v70);
  v60 = v39[5];
  *(_QWORD *)(a1 + 16) = v39;
  *(_QWORD *)(a1 + 24) = v60;
  v61 = *(_QWORD *)a2;
  if (a13)
  {
    mlir::ValueRange::ValueRange(v65, v39[6], (uint64_t)(v39[7] - v39[6]) >> 3);
    a13(a14, a1, v61, v65[0], v65[1]);
    v62 = v64;
    if ((_QWORD)v64)
      goto LABEL_59;
  }
  else
  {
    mlir::scf::ForallOp::ensureTerminator(v35, (_QWORD *)a1, v61);
    v62 = v64;
    if ((_QWORD)v64)
    {
LABEL_59:
      *v36 = v62;
      v63 = v84;
      if (v84 == v86)
        goto LABEL_61;
      goto LABEL_60;
    }
  }
  *(_QWORD *)v36 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v63 = v84;
  if (v84 != v86)
LABEL_60:
    free(v63);
LABEL_61:
  if (v87 != v89)
    free(v87);
  if (v90 != v92)
    free(v90);
  if (v93 != v95)
    free(v93);
  if (v96 != v98)
    free(v96);
  if (v99 != v101)
    free(v99);
}

uint64_t mlir::scf::ForallOp::getSingleInductionVar(mlir::scf::ForallOp *this)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = 0;
  v13[0] = *(_QWORD *)(v2 + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v13);
  result = 0;
  if (v4 == 1)
  {
    v5 = *(unsigned int *)(*(_QWORD *)this + 44);
    v6 = *(_QWORD *)this + 16 * ((v5 >> 23) & 1) + 64;
    v7 = *(_QWORD *)(((v6 + ((v5 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *(unsigned int *)(*(_QWORD *)this + 40)
                   + 8);
    if (v7)
      v8 = v7 - 8;
    else
      v8 = 0;
    v9 = *(_QWORD *)(v8 + 48);
    v10 = (*(_QWORD *)(v8 + 56) - v9) >> 3;
    if (!BYTE3(v5))
      v6 = 0;
    v13[0] = *(_QWORD *)(v6 + 8);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v13);
    if (v10 >= v11)
      v12 = v11;
    else
      v12 = v10;
    mlir::ValueRange::ValueRange(v13, v9, v12);
    return mlir::ValueRange::dereference_iterator(v13, 0);
  }
  return result;
}

void mlir::scf::ForallOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  const char *v140;
  unint64_t v141;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"tensor.dim", 10, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v4 = &off_24BFF26F8;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::DimOfForallOp]";
  v141 = 86;
  v9 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v9)
    v10 = v9;
  else
    v10 = v141;
  v11 = &v140[v10];
  v12 = v141 - v10;
  if (v141 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v141 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_154;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_155;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_158;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_158:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"scf.forall", 10, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v38 = &off_24BFF2D98;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldTensorCastOfOutputIntoForallOp]";
  v141 = 107;
  v43 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v43)
    v44 = v43;
  else
    v44 = v141;
  v45 = &v140[v44];
  v46 = v141 - v44;
  if (v141 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v141 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_154;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_155;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_159;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_159:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"scf.forall", 10, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v72 = &off_24BFF2C90;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ForallOpControlOperandsFolder]";
  v141 = 102;
  v77 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v77)
    v78 = v77;
  else
    v78 = v141;
  v79 = &v140[v78];
  v80 = v141 - v78;
  if (v141 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v141 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_154;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_155;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_160;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_160:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v140, 1);
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"scf.forall", 10, (__int16)v140, a2, 0, 0);
  *(_QWORD *)v106 = &off_24BFF2EA0;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  v140 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ForallOpSingleOrZeroIterationDimsFolder]";
  v141 = 112;
  v111 = llvm::StringRef::find((uint64_t *)&v140, "DesiredTypeName = ", 0x12uLL, 0);
  if (v141 >= v111)
    v112 = v111;
  else
    v112 = v141;
  v113 = &v140[v112];
  v114 = v141 - v112;
  if (v141 - v112 >= 0x12)
    v115 = 18;
  else
    v115 = v141 - v112;
  v116 = &v113[v115];
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
LABEL_154:
    abort();
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (!v122)
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
    goto LABEL_150;
  }
  if (v122 >> 61)
LABEL_155:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v123 = (char *)operator new(8 * v122);
  v124 = (uint64_t *)&v123[8 * v119];
  v125 = &v123[8 * v122];
  *v124 = v106;
  v110 = (uint64_t)(v124 + 1);
  v126 = (char *)(v109 - v118);
  if (v109 != v118)
  {
LABEL_138:
    v127 = (unint64_t)(v126 - 8);
    if (v127 < 0x78
      || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
      && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
    {
      goto LABEL_161;
    }
    v128 = (v127 >> 3) + 1;
    v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
    v130 = &v109[-v129];
    v124 = (uint64_t *)((char *)v124 - v129);
    v131 = &v123[8 * v119 - 16];
    v132 = v109 - 16;
    v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v135 = *((_OWORD *)v132 - 1);
      v134 = *(_OWORD *)v132;
      *((_OWORD *)v132 - 1) = 0uLL;
      *(_OWORD *)v132 = 0uLL;
      *((_OWORD *)v131 - 1) = v135;
      *(_OWORD *)v131 = v134;
      v131 -= 32;
      v132 -= 32;
      v133 -= 4;
    }
    while (v133);
    v109 = v130;
    if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_161:
      do
      {
        v136 = *((_QWORD *)v109 - 1);
        v109 -= 8;
        *(_QWORD *)v109 = 0;
        *--v124 = v136;
      }
      while (v109 != v118);
    }
    v109 = (char *)a1[1];
    v137 = (char *)a1[2];
    a1[1] = v124;
    a1[2] = v110;
    a1[3] = v125;
    while (v137 != v109)
    {
      v139 = *((_QWORD *)v137 - 1);
      v137 -= 8;
      v138 = v139;
      *(_QWORD *)v137 = 0;
      if (v139)
        (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
    }
    goto LABEL_151;
  }
LABEL_150:
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
}

__n128 mlir::scf::ForallOp::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  __n128 *v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t v13;
  __n128 *v14;
  __n128 result;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  BOOL v19;
  char *v20;
  char *v21;
  unint64_t v22;
  unint64_t v23[3];

  v23[2] = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  if ((v4 & 0x7FFFFF) != 0)
    v5 = ((*(_QWORD *)a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(*(_QWORD *)a1 + 40);
  else
    v5 = 0;
  v22 = v5;
  v6 = (__n128 *)&v22;
  mlir::ValueRange::ValueRange(v23, 0, 0);
  v7 = *(unsigned int *)(a3 + 8);
  v8 = *(_QWORD *)a3;
  if (v7 < *(_DWORD *)(a3 + 12))
    goto LABEL_5;
  v16 = v7 + 1;
  v17 = v8 + 24 * v7 > (unint64_t)&v22;
  if (v8 > (unint64_t)&v22 || !v17)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16, 24);
    v8 = *(_QWORD *)a3;
LABEL_5:
    v9 = (char *)&v22;
    goto LABEL_6;
  }
  v20 = (char *)&v23[-1] - v8;
  llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16, 24);
  v8 = *(_QWORD *)a3;
  v9 = &v20[*(_QWORD *)a3];
LABEL_6:
  v10 = v8 + 24 * *(unsigned int *)(a3 + 8);
  v11 = *(_OWORD *)v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  ++*(_DWORD *)(a3 + 8);
  v22 = 0;
  mlir::ValueRange::ValueRange(v23, 0, 0);
  v12 = *(unsigned int *)(a3 + 8);
  v13 = *(_QWORD *)a3;
  if (v12 >= *(_DWORD *)(a3 + 12))
  {
    v18 = v12 + 1;
    v19 = v13 + 24 * v12 > (unint64_t)&v22;
    if (v13 <= (unint64_t)&v22 && v19)
    {
      v21 = (char *)&v23[-1] - v13;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v18, 24);
      v13 = *(_QWORD *)a3;
      v6 = (__n128 *)&v21[*(_QWORD *)a3];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v18, 24);
      v13 = *(_QWORD *)a3;
      v6 = (__n128 *)&v22;
    }
  }
  v14 = (__n128 *)(v13 + 24 * *(unsigned int *)(a3 + 8));
  result = *v6;
  v14[1].n128_u64[0] = v6[1].n128_u64[0];
  *v14 = result;
  ++*(_DWORD *)(a3 + 8);
  return result;
}

uint64_t mlir::scf::InParallelOp::verify(uint64_t **this)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  ZinIrHalH13g *v16;
  ZinIrHalH13g *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t Dest;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v50;
  int64_t v51;
  const void **v52;
  __int16 v53;
  const void **v54;
  uint64_t v55;
  uint64_t v56;
  __int16 v57;
  uint64_t *v58;
  uint64_t v59;
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD *v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)(*this)[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp
      && *(_QWORD *)(*(_QWORD *)(ParentOp + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id)
    {
      v14 = *(_QWORD *)((((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                                                   + 8]
                        + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                        + 7) & 0xFFFFFFFFFFFFFFF8)
                      + 32 * *((unsigned int *)*this + 10)
                      + 8);
      if (v14)
        v15 = v14 - 8;
      else
        v15 = 0;
      v16 = (ZinIrHalH13g *)(v15 + 32);
      v17 = *(ZinIrHalH13g **)(v15 + 40);
      if (v17 == (ZinIrHalH13g *)(v15 + 32))
        return 1;
      v18 = ParentOp;
      v19 = ParentOp + 64;
      while (1)
      {
        ZinIrHalH13g::~ZinIrHalH13g(v17);
        if (*(_UNKNOWN **)(v20[6] + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::ParallelInsertSliceOp,void>::id)
          break;
        v21 = v20;
        v58 = v20;
        Dest = mlir::tensor::ParallelInsertSliceOp::getDest((mlir::tensor::ParallelInsertSliceOp *)&v58);
        v23 = *(unsigned int *)(v18 + 44);
        v24 = *(_QWORD *)(((v19 + 16 * ((v23 >> 23) & 1) + ((v23 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * *(unsigned int *)(v18 + 40)
                        + 8);
        if (v24)
          v25 = v24 - 8;
        else
          v25 = 0;
        v26 = *(_QWORD *)(v25 + 48);
        v27 = *(_QWORD *)(v25 + 56) - v26;
        v28 = v27 >> 3;
        if (HIBYTE(*(_DWORD *)(v18 + 44)))
          v29 = v19 + 16 * ((v23 >> 23) & 1);
        else
          v29 = 0;
        v58 = *(uint64_t **)(v29 + 8);
        mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v58);
        v31 = (_QWORD *)(v26 + 8 * v30);
        if (v28 != v30)
        {
          v32 = 8 * v28 - 8 * v30;
          v31 = (_QWORD *)(v26 + 8 * v30);
          while (*v31 != Dest)
          {
            ++v31;
            v32 -= 8;
            if (!v32)
            {
              v31 = (_QWORD *)(v26 + (v27 & 0xFFFFFFFFFFFFFFF8));
              break;
            }
          }
        }
        if (v28 - v30 == ((uint64_t)v31 - v26 + -8 * v30) >> 3)
        {
          v54 = (const void **)"may only insert into an output block argument";
          v57 = 259;
          mlir::Operation::emitOpError(v21, &v54, (uint64_t)&v58);
          v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
          if (v58)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v58);
          if (!v68)
            return v5;
          v43 = __p;
          if (__p)
          {
            v44 = v67;
            v45 = __p;
            if (v67 != __p)
            {
              do
                v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
              while (v44 != v43);
              v45 = __p;
            }
            v67 = v43;
            operator delete(v45);
          }
          v9 = v64;
          if (!v64)
            goto LABEL_74;
          v46 = v65;
          v11 = v64;
          if (v65 == v64)
            goto LABEL_73;
          do
          {
            v48 = *--v46;
            v47 = v48;
            *v46 = 0;
            if (v48)
              MEMORY[0x20BD002D4](v47, 0x1000C8077774924);
          }
          while (v46 != v9);
          goto LABEL_72;
        }
        v17 = (ZinIrHalH13g *)*((_QWORD *)v17 + 1);
        if (v17 == v16)
          return 1;
      }
      v52 = (const void **)"expected only ";
      v53 = 259;
      mlir::OpState::emitOpError(this, &v52, (uint64_t)&v58);
      if (v58)
      {
        v57 = 262;
        v54 = (const void **)"tensor.parallel_insert_slice";
        v55 = 28;
        mlir::Diagnostic::operator<<((uint64_t)&v59, &v54);
        if (v58)
        {
          LODWORD(v54) = 3;
          v55 = (uint64_t)" ops";
          v56 = 4;
          v33 = &v54;
          v34 = (char *)v60;
          if (v61 >= v62)
          {
            v50 = v61 + 1;
            if (v60 <= &v54 && (char *)v60 + 24 * v61 > (char *)&v54)
            {
              v51 = (char *)&v54 - (_BYTE *)v60;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
              v34 = (char *)v60;
              v33 = (const void ***)((char *)v60 + v51);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
              v33 = &v54;
              v34 = (char *)v60;
            }
          }
          v35 = &v34[24 * v61];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v61;
        }
      }
      v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
      if (v58)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v58);
      if (!v68)
        return v5;
      v37 = __p;
      if (__p)
      {
        v38 = v67;
        v39 = __p;
        if (v67 != __p)
        {
          do
            v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
          while (v38 != v37);
          v39 = __p;
        }
        v67 = v37;
        operator delete(v39);
      }
      v9 = v64;
      if (!v64)
        goto LABEL_74;
      v40 = v65;
      v11 = v64;
      if (v65 == v64)
        goto LABEL_73;
      do
      {
        v42 = *--v40;
        v41 = v42;
        *v40 = 0;
        if (v42)
          MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
      }
      while (v40 != v9);
      goto LABEL_72;
    }
  }
  v54 = (const void **)"expected forall op parent";
  v57 = 259;
  mlir::OpState::emitOpError(this, &v54, (uint64_t)&v58);
  v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
  if (v58)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v58);
  if (v68)
  {
    v6 = __p;
    if (__p)
    {
      v7 = v67;
      v8 = __p;
      if (v67 != __p)
      {
        do
          v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
        while (v7 != v6);
        v8 = __p;
      }
      v67 = v6;
      operator delete(v8);
    }
    v9 = v64;
    if (!v64)
      goto LABEL_74;
    v10 = v65;
    v11 = v64;
    if (v65 == v64)
    {
LABEL_73:
      v65 = v9;
      operator delete(v11);
LABEL_74:
      if (v60 != v63)
        free(v60);
      return v5;
    }
    do
    {
      v13 = *--v10;
      v12 = v13;
      *v10 = 0;
      if (v13)
        MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
    }
    while (v10 != v9);
LABEL_72:
    v11 = v64;
    goto LABEL_73;
  }
  return v5;
}

uint64_t mlir::scf::InParallelOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v9;
  unint64_t AttrDictionary;

  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, " ", 1uLL);
  }
  else
  {
    *v5 = 32;
    ++*((_QWORD *)v4 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a2 + 224))(a2, (((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), 0, 0, 0);
  v6 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v6);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v6 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v9, 0, 0);
}

BOOL mlir::scf::InParallelOp::parse(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  mlir::Region *v5;
  _BOOL8 v6;
  void *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[4];
  mlir::Region *v14;
  unint64_t v15[2];
  void *v16;
  uint64_t v17;
  _QWORD v18[65];

  v18[64] = *MEMORY[0x24BDAC8D0];
  v4 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v16 = v18;
  v17 = 0x800000000;
  v5 = (mlir::Region *)operator new();
  *(_QWORD *)v5 = v5;
  *((_QWORD *)v5 + 1) = v5;
  *((_QWORD *)v5 + 2) = 0;
  v14 = v5;
  if (!(*(unsigned __int8 (**)(uint64_t, mlir::Region *, void *, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v5, v16, v17, 0))
  {
    v6 = 0;
    v14 = 0;
    goto LABEL_9;
  }
  if (*(mlir::Region **)v5 == v5)
  {
    v13[0] = *v4;
    memset(&v13[1], 0, 24);
    mlir::ValueRange::ValueRange(v15, 0, 0);
    mlir::OpBuilder::createBlock(v13, (uint64_t)v5, 0, v15[0], v15[1], 0, 0);
  }
  mlir::OperationState::addRegion(a2, (unint64_t)&v14);
  v6 = (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112) != 0;
  v5 = v14;
  v14 = 0;
  if (v5)
  {
LABEL_9:
    mlir::Region::~Region(v5);
    MEMORY[0x20BD002F8](v9, 0x20C40960023A9, v10, v11, v12);
    v7 = v16;
    if (v16 == v18)
      return v6;
    goto LABEL_6;
  }
  v7 = v16;
  if (v16 != v18)
LABEL_6:
    free(v7);
  return v6;
}

uint64_t mlir::scf::IfOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18[2];
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a4 + 32))
    return 0;
  v6 = (_QWORD *)mlir::RegionRange::dereference_iterator((_QWORD *)(a4 + 24), 0);
  if ((_QWORD *)*v6 == v6)
    return 0;
  v7 = v6[1];
  v8 = v7 ? v7 - 8 : 0;
  v9 = *(ZinIrHalH13g **)(v8 + 32);
  if (v9 == (ZinIrHalH13g *)(v8 + 32))
    return 0;
  ZinIrHalH13g::~ZinIrHalH13g(v9);
  if (!v10
    || *(_QWORD *)(*(_QWORD *)(v10 + 48) + 16) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id)
  {
    return 0;
  }
  if ((*(_BYTE *)(v10 + 46) & 0x80) != 0)
  {
    v13 = *(_QWORD *)(v10 + 72);
    v14 = *(unsigned int *)(v10 + 68);
  }
  else
  {
    v13 = 0;
    v14 = 0;
  }
  v19 = v13;
  v20 = v14;
  mlir::OperandRange::getTypes(&v19, &v15);
  mlir::ValueRange::ValueRange((unint64_t *)&v19, v15 + 32 * v16, v17 - v16);
  mlir::TypeRange::TypeRange(v18, v19, v20);
  llvm::SmallVectorImpl<mlir::Type>::insert<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,void>(a5, *(_QWORD *)a5 + 8 * *(unsigned int *)(a5 + 8), v18[0], 0, v18[0], v18[1]);
  return 1;
}

unint64_t *llvm::SmallVectorImpl<mlir::Type>::insert<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,void>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t *v23;
  BOOL v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 *v37;
  _OWORD *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  unint64_t *v42;

  v8 = a4;
  v11 = *(_QWORD *)a1;
  v12 = (a2 - *(_QWORD *)a1) >> 3;
  v14 = *(unsigned int *)(a1 + 8);
  v13 = *(unsigned int *)(a1 + 12);
  v15 = *(_DWORD *)(a1 + 8);
  v16 = a6 - a4;
  v17 = a6 - a4 + v14;
  if (*(_QWORD *)a1 + 8 * v14 != a2)
  {
    if (v17 > v13)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v17, 8);
      v11 = *(_QWORD *)a1;
      v14 = *(unsigned int *)(a1 + 8);
      v15 = *(_DWORD *)(a1 + 8);
    }
    v18 = (unint64_t *)(v11 + 8 * v12);
    v19 = v12;
    v20 = (unint64_t *)(v11 + 8 * v14);
    v21 = v20 - v18;
    if (v21 < v16)
    {
      v22 = v15 + v16;
      *(_DWORD *)(a1 + 8) = v22;
      if (v19 != v14)
      {
        memcpy((void *)(v11 + 8 * v22 - 8 * v21), v18, (char *)v20 - (char *)v18);
        v23 = v18;
        do
        {
          *v23++ = mlir::TypeRange::dereference_iterator(a3, v8++);
          --v21;
        }
        while (v21);
      }
      if (a3 != a5 || v8 != a6)
      {
        if (a3 != a5)
        {
          while (1)
            *v20++ = mlir::TypeRange::dereference_iterator(a3, v8++);
        }
        do
          *v20++ = mlir::TypeRange::dereference_iterator(a3, v8++);
        while (a6 != v8);
      }
      return v18;
    }
    v26 = 8 * v16;
    v27 = v14 + ((uint64_t)(8 * v16) >> 3);
    v28 = v14;
    if (v27 > *(unsigned int *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v27, 8);
      v28 = *(unsigned int *)(a1 + 8);
      v15 = *(_DWORD *)(a1 + 8);
    }
    v29 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
    if (a6 == v8)
      goto LABEL_33;
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    v31 = 8 * a6;
    v32 = 8 * a6 - 8 * v8 - 8;
    if (v32 >= 0x98)
    {
      v34 = 8 * v28 + *(_QWORD *)a1;
      v33 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
      if ((unint64_t)(v31 - (v11 + 8 * (v8 + v14)) + v34) >= 0x20)
      {
        v35 = (v32 >> 3) + 1;
        v36 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        v30 = (_QWORD *)((char *)v30 + v36 * 8);
        v33 = &v29[v36];
        v37 = (__int128 *)(8 * v8 + 8 * v14 - v31 + v11 + 16);
        v38 = (_OWORD *)(v34 + 16);
        v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v40 = *v37;
          *(v38 - 1) = *(v37 - 1);
          *v38 = v40;
          v37 += 2;
          v38 += 2;
          v39 -= 4;
        }
        while (v39);
        if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_33;
      }
    }
    else
    {
      v33 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      v41 = *v33++;
      *v30++ = v41;
    }
    while (v33 != v20);
LABEL_33:
    *(_DWORD *)(a1 + 8) = v15 + v16;
    if (v29 != v18)
      memmove(&v18[(unint64_t)v26 / 8], v18, (char *)&v20[v26 / 0xFFFFFFFFFFFFFFF8] - (char *)v18);
    if (a3 != a5 || a6 != v8)
    {
      if (a3 != a5)
      {
        while (1)
          *v18++ = mlir::TypeRange::dereference_iterator(a3, v8++);
      }
      v42 = v18;
      do
        *v42++ = mlir::TypeRange::dereference_iterator(a3, v8++);
      while (a6 != v8);
    }
    return v18;
  }
  if (v17 > v13)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v17, 8);
    v15 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  v24 = a3 != a5;
  if (a6 != v8 || a3 != a5)
  {
    v25 = (unint64_t *)(v11 + 8 * v15);
    if (v24)
    {
      while (1)
        *v25++ = mlir::TypeRange::dereference_iterator(a3, v8++);
    }
    do
      *v25++ = mlir::TypeRange::dereference_iterator(a3, v8++);
    while (a6 != v8);
    v15 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  *(_DWORD *)(a1 + 8) = v15 + v16;
  return (unint64_t *)(v11 + 8 * v12);
}

uint64_t mlir::scf::IfOp::build(_QWORD *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::scf::IfOp::build(a1, a2, a3, a4, a5, 0, 0);
}

uint64_t mlir::scf::IfOp::build(_QWORD *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t result;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  unint64_t v25[2];
  unint64_t v26[3];

  v26[2] = *MEMORY[0x24BDAC8D0];
  v24 = a5;
  v13 = a2 + 16;
  v14 = a2[18];
  if (a4 + v14 > (unint64_t)a2[19])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v13, a2 + 20, a4 + v14, 8);
    LODWORD(v14) = a2[18];
  }
  if (a4)
  {
    v15 = 0;
    v16 = *v13 + 8 * v14;
    do
    {
      *(_QWORD *)(v16 + 8 * v15) = mlir::TypeRange::dereference_iterator(a3, v15);
      ++v15;
    }
    while (a4 != v15);
    LODWORD(v14) = a2[18];
  }
  a2[18] = v14 + a4;
  mlir::OperationState::addOperands((uint64_t)a2, (uint64_t)&v24, 1);
  v17 = a1 + 2;
  v23 = *((_OWORD *)a1 + 1);
  v18 = mlir::OperationState::addRegion((mlir::OperationState *)a2);
  if (!a6)
  {
    result = mlir::OperationState::addRegion((mlir::OperationState *)a2);
    if (!a7)
      goto LABEL_9;
LABEL_13:
    v22 = result;
    mlir::ValueRange::ValueRange(v25, 0, 0);
    result = mlir::OpBuilder::createBlock(a1, v22, 0, v25[0], v25[1], 0, 0);
    v20 = v23;
    if ((_QWORD)v23)
      goto LABEL_10;
LABEL_14:
    *v17 = 0;
    a1[3] = 0;
    return result;
  }
  v21 = v18;
  mlir::ValueRange::ValueRange(v26, 0, 0);
  mlir::OpBuilder::createBlock(a1, v21, 0, v26[0], v26[1], 0, 0);
  result = mlir::OperationState::addRegion((mlir::OperationState *)a2);
  if (a7)
    goto LABEL_13;
LABEL_9:
  v20 = v23;
  if (!(_QWORD)v23)
    goto LABEL_14;
LABEL_10:
  *(_OWORD *)v17 = v20;
  return result;
}

uint64_t mlir::scf::IfOp::build(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  _QWORD *v16;
  uint64_t result;
  _QWORD *v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  unint64_t v22[2];
  unint64_t v23[3];

  v23[2] = *MEMORY[0x24BDAC8D0];
  v21 = a5;
  v11 = a2 + 16;
  v12 = a2[18];
  if (a4 + v12 > (unint64_t)a2[19])
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v11, a2 + 20, a4 + v12, 8);
    LODWORD(v12) = a2[18];
  }
  if (a4)
  {
    v13 = 0;
    v14 = *v11 + 8 * v12;
    do
    {
      *(_QWORD *)(v14 + 8 * v13) = mlir::TypeRange::dereference_iterator(a3, v13);
      ++v13;
    }
    while (a4 != v13);
    LODWORD(v12) = a2[18];
  }
  a2[18] = v12 + a4;
  mlir::OperationState::addOperands((uint64_t)a2, (uint64_t)&v21, 1);
  v15 = (_OWORD *)(a1 + 16);
  v20 = *(_OWORD *)(a1 + 16);
  v16 = (_QWORD *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  mlir::ValueRange::ValueRange(v23, 0, 0);
  mlir::OpBuilder::createBlock((_QWORD *)a1, (uint64_t)v16, 0, v23[0], v23[1], 0, 0);
  if (a4)
  {
    result = mlir::OperationState::addRegion((mlir::OperationState *)a2);
    if (!a6)
      goto LABEL_12;
  }
  else
  {
    mlir::impl::ensureRegionTerminator(v16, a1, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>::buildTerminator);
    result = mlir::OperationState::addRegion((mlir::OperationState *)a2);
    if (!a6)
      goto LABEL_12;
  }
  v18 = (_QWORD *)result;
  mlir::ValueRange::ValueRange(v22, 0, 0);
  result = mlir::OpBuilder::createBlock((_QWORD *)a1, (uint64_t)v18, 0, v22[0], v22[1], 0, 0);
  if (!a4)
  {
    result = mlir::impl::ensureRegionTerminator(v18, a1, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>::buildTerminator);
    v19 = v20;
    if ((_QWORD)v20)
      goto LABEL_13;
    goto LABEL_15;
  }
LABEL_12:
  v19 = v20;
  if ((_QWORD)v20)
  {
LABEL_13:
    *v15 = v19;
    return result;
  }
LABEL_15:
  *(_QWORD *)v15 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  return result;
}

uint64_t mlir::scf::IfOp::verify(uint64_t **this)
{
  uint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const void **v14;
  __int16 v15;
  _QWORD v16[3];
  void *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *__p;
  _QWORD *v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v1 = *this;
  if (!*((_DWORD *)*this + 9))
    return 1;
  v2 = *((unsigned int *)v1 + 11);
  if ((v2 & 0x7FFFFF) != 0)
  {
    v3 = (((unint64_t)&v1[2 * ((v2 >> 23) & 1) + 8] + ((v2 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)v1 + 10);
    if (*(_QWORD *)(v3 + 24) != v3 + 24)
      return 1;
  }
  else if (MEMORY[0x18] != 24)
  {
    return 1;
  }
  v14 = (const void **)"must have an else block if defining values";
  v15 = 259;
  mlir::OpState::emitOpError(this, &v14, (uint64_t)v16);
  v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
  if (v16[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
  if (v23)
  {
    v6 = __p;
    if (__p)
    {
      v7 = v22;
      v8 = __p;
      if (v22 != __p)
      {
        do
          v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
        while (v7 != v6);
        v8 = __p;
      }
      v22 = v6;
      operator delete(v8);
    }
    v9 = v19;
    if (v19)
    {
      v10 = v20;
      v11 = v19;
      if (v20 != v19)
      {
        do
        {
          v13 = *--v10;
          v12 = v13;
          *v10 = 0;
          if (v13)
            MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
        }
        while (v10 != v9);
        v11 = v19;
      }
      v20 = v9;
      operator delete(v11);
    }
    if (v17 != &v18)
      free(v17);
  }
  return v4;
}

BOOL mlir::scf::IfOp::parse(uint64_t a1, mlir::OperationState *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  mlir::Builder *v6;
  uint64_t IntegerType;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD v11[4];

  llvm::SmallVectorImpl<std::unique_ptr<mlir::Region>>::reserve((uint64_t)a2 + 224, 2uLL);
  v4 = (_QWORD *)mlir::OperationState::addRegion(a2);
  v5 = (_QWORD *)mlir::OperationState::addRegion(a2);
  v6 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  memset(v11, 0, 24);
  IntegerType = mlir::Builder::getIntegerType(v6, 1u);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v11, 1)
    && (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v11, IntegerType, (uint64_t)a2 + 16)&& (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 536))(a1, (uint64_t)a2 + 64)&& (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, 0, 0, 0))
  {
    v8 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    mlir::impl::ensureRegionTerminator(v4, v8, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>::buildTerminator);
    if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "else", 4))
      return (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, (uint64_t)a2 + 112) != 0;
    if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v5, 0, 0, 0))
    {
      v9 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
      mlir::impl::ensureRegionTerminator(v5, v9, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>::buildTerminator);
      return (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, (uint64_t)a2 + 112) != 0;
    }
  }
  return 0;
}

uint64_t mlir::scf::IfOp::print(unsigned int **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  llvm::raw_ostream *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  llvm::raw_ostream *v11;
  _BYTE *v12;
  llvm::raw_ostream *v13;
  _BYTE *v14;
  unsigned int *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::ArrayAttr *v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  uint64_t Value;
  uint64_t v24;
  uint64_t v26[4];
  const char *v27;
  uint64_t v28;

  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, " ", 1uLL);
  }
  else
  {
    *v5 = 32;
    ++*((_QWORD *)v4 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (*this)[9];
  if (v6)
  {
    v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v8 = *((_QWORD *)v7 + 4);
    if ((unint64_t)(*((_QWORD *)v7 + 3) - v8) > 4)
    {
      *(_BYTE *)(v8 + 4) = 40;
      *(_DWORD *)v8 = 540945696;
      *((_QWORD *)v7 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v7, " -> (", 5uLL);
    }
    v9 = (*this)[9];
    v10 = (const char *)(*this - 4);
    if (!(_DWORD)v9)
      v10 = 0;
    v27 = v10;
    v28 = v9;
    mlir::OperandRange::getTypes((uint64_t *)&v27, v26);
    v27 = ", ";
    v28 = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(v26[0], v26[1], v26[2], v26[3], (uint64_t)a2, (uint64_t)a2, (uint64_t)&v27);
    v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v12 = (_BYTE *)*((_QWORD *)v11 + 4);
    if (*((_BYTE **)v11 + 3) == v12)
    {
      llvm::raw_ostream::write(v11, ")", 1uLL);
    }
    else
    {
      *v12 = 41;
      ++*((_QWORD *)v11 + 4);
    }
  }
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v14 = (_BYTE *)*((_QWORD *)v13 + 4);
  if ((unint64_t)v14 >= *((_QWORD *)v13 + 3))
  {
    llvm::raw_ostream::write(v13, 32);
  }
  else
  {
    *((_QWORD *)v13 + 4) = v14 + 1;
    *v14 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, BOOL, _QWORD))(*(_QWORD *)a2 + 224))(a2, (((unint64_t)&(*this)[4 * (((unint64_t)(*this)[11] >> 23) & 1) + 17]+ (((unint64_t)(*this)[11] >> 21) & 0x7F8)+ 3) & 0xFFFFFFFFFFFFFFF8)+ 32 * (*this)[10], 0, v6 != 0, 0);
  v15 = *this;
  v16 = (*this)[11];
  if ((v16 & 0x7FFFFF) != 0)
  {
    v17 = (((unint64_t)&v15[4 * ((v16 >> 23) & 1) + 17] + ((v16 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
        + 32 * v15[10];
    v19 = *(_QWORD *)(v17 + 24);
    v18 = v17 + 24;
    if (v19 == v18)
      goto LABEL_18;
LABEL_21:
    v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v22 = *((_QWORD *)v21 + 4);
    if ((unint64_t)(*((_QWORD *)v21 + 3) - v22) > 5)
    {
      *(_WORD *)(v22 + 4) = 8293;
      *(_DWORD *)v22 = 1936483616;
      *((_QWORD *)v21 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v21, " else ", 6uLL);
    }
    (*(void (**)(mlir::OpAsmPrinter *, uint64_t, _QWORD, BOOL, _QWORD))(*(_QWORD *)a2 + 224))(a2, v18, 0, v6 != 0, 0);
    v15 = *this;
    if (!HIBYTE((*this)[11]))
      goto LABEL_19;
LABEL_25:
    v26[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)v15);
    v20 = (mlir::ArrayAttr *)v26;
    goto LABEL_26;
  }
  v18 = 24;
  if (MEMORY[0x18] != 24)
    goto LABEL_21;
LABEL_18:
  if (BYTE3(v16))
    goto LABEL_25;
LABEL_19:
  v20 = (mlir::ArrayAttr *)(v15 + 14);
LABEL_26:
  Value = mlir::ArrayAttr::getValue(v20);
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v24, 0, 0);
}

__n128 mlir::scf::IfOp::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  __n128 *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int128 v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __n128 *v21;
  __n128 result;
  unint64_t v23;
  BOOL v24;
  unint64_t v25;
  BOOL v26;
  char *v27;
  char *v28;
  unint64_t v29;
  unint64_t v30[3];

  v30[2] = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v10 = *(unsigned int *)(*(_QWORD *)a1 + 44);
    if ((v10 & 0x7FFFFF) != 0)
      v11 = ((*(_QWORD *)a1 + 16 * ((v10 >> 23) & 1) + ((v10 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *(unsigned int *)(*(_QWORD *)a1 + 40);
    else
      v11 = 0;
    v29 = v11;
    v12 = (char *)&v29;
    mlir::ValueRange::ValueRange(v30, 0, 0);
    v13 = *(unsigned int *)(a3 + 8);
    v14 = *(_QWORD *)a3;
    if (v13 >= *(_DWORD *)(a3 + 12))
    {
      v25 = v13 + 1;
      v26 = v14 + 24 * v13 > (unint64_t)&v29;
      if (v14 <= (unint64_t)&v29 && v26)
      {
        v28 = (char *)&v30[-1] - v14;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v25, 24);
        v14 = *(_QWORD *)a3;
        v12 = &v28[*(_QWORD *)a3];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v25, 24);
        v14 = *(_QWORD *)a3;
        v12 = (char *)&v29;
      }
    }
    v15 = v14 + 24 * *(unsigned int *)(a3 + 8);
    v16 = *(_OWORD *)v12;
    *(_QWORD *)(v15 + 16) = *((_QWORD *)v12 + 2);
    *(_OWORD *)v15 = v16;
    ++*(_DWORD *)(a3 + 8);
    v17 = *(unsigned int *)(*(_QWORD *)a1 + 44);
    if ((v17 & 0x7FFFFF) != 0)
    {
      v18 = ((*(_QWORD *)a1 + 16 * ((v17 >> 23) & 1) + ((v17 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *(unsigned int *)(*(_QWORD *)a1 + 40);
      v20 = *(_QWORD *)(v18 + 24);
      v19 = v18 + 24;
      if (v20 != v19)
      {
LABEL_13:
        v29 = v19;
        goto LABEL_16;
      }
    }
    else
    {
      v19 = 24;
      if (MEMORY[0x18] != 24)
        goto LABEL_13;
    }
    v29 = 0;
LABEL_16:
    v7 = (__n128 *)&v29;
    mlir::ValueRange::ValueRange(v30, 0, 0);
    v8 = *(unsigned int *)(a3 + 8);
    v9 = *(_QWORD *)a3;
    if (v8 < *(_DWORD *)(a3 + 12))
      goto LABEL_17;
    goto LABEL_18;
  }
  v5 = *(unsigned int *)(*(_QWORD *)a1 + 36);
  if ((_DWORD)v5)
    v6 = *(_QWORD *)a1 - 16;
  else
    v6 = 0;
  v29 = 0;
  v7 = (__n128 *)&v29;
  mlir::ValueRange::ValueRange(v30, v6, v5);
  v8 = *(unsigned int *)(a3 + 8);
  v9 = *(_QWORD *)a3;
  if (v8 >= *(_DWORD *)(a3 + 12))
  {
LABEL_18:
    v23 = v8 + 1;
    v24 = v9 + 24 * v8 > (unint64_t)&v29;
    if (v9 <= (unint64_t)&v29 && v24)
    {
      v27 = (char *)&v30[-1] - v9;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v23, 24);
      v9 = *(_QWORD *)a3;
      v7 = (__n128 *)&v27[*(_QWORD *)a3];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v23, 24);
      v9 = *(_QWORD *)a3;
      v7 = (__n128 *)&v29;
    }
  }
LABEL_17:
  v21 = (__n128 *)(v9 + 24 * *(unsigned int *)(a3 + 8));
  result = *v7;
  v21[1].n128_u64[0] = v7[1].n128_u64[0];
  *v21 = result;
  ++*(_DWORD *)(a3 + 8);
  return result;
}

void mlir::scf::IfOp::getEntrySuccessorRegions(unsigned int **a1, _QWORD **a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  unsigned int *v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t *v14;
  unsigned int *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  __int128 v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  unsigned int v32;
  _QWORD *v33;
  uint64_t v34;
  __int128 v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  BOOL v39;
  char *v40;
  char *v41;
  _QWORD *v42;
  char v43[40];
  _QWORD **v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47[3];

  v47[2] = *MEMORY[0x24BDAC8D0];
  mlir::scf::detail::IfOpGenericAdaptorBase::IfOpGenericAdaptorBase((uint64_t)v43, *a1);
  v44 = a2;
  v45 = a3;
  v8 = *a2;
  if (!*a2)
  {
    v42 = 0;
    v10 = *a1;
    v11 = (*a1)[11];
    if ((v11 & 0x7FFFFF) != 0)
    {
LABEL_8:
      v12 = (((unint64_t)&v10[4 * ((v11 >> 23) & 1) + 17] + ((v11 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
          + 32 * v10[10];
      v13 = *(_DWORD *)(a4 + 8);
      if (v13 < *(_DWORD *)(a4 + 12))
      {
LABEL_9:
        v14 = (unint64_t *)(*(_QWORD *)a4 + 24 * v13);
        *v14 = v12;
        mlir::ValueRange::ValueRange(v14 + 1, 0, 0);
LABEL_10:
        ++*(_DWORD *)(a4 + 8);
        goto LABEL_11;
      }
LABEL_19:
      v46 = v12;
      v21 = (char *)&v46;
      mlir::ValueRange::ValueRange(v47, 0, 0);
      v22 = *(unsigned int *)(a4 + 8);
      v23 = *(_QWORD *)a4;
      if (v22 >= *(_DWORD *)(a4 + 12))
      {
        v36 = v22 + 1;
        v37 = v23 + 24 * v22 > (unint64_t)&v46;
        if (v23 <= (unint64_t)&v46 && v37)
        {
          v40 = (char *)&v47[-1] - v23;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v36, 24);
          v23 = *(_QWORD *)a4;
          v21 = &v40[*(_QWORD *)a4];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v36, 24);
          v23 = *(_QWORD *)a4;
          v21 = (char *)&v46;
        }
      }
      v24 = v23 + 24 * *(unsigned int *)(a4 + 8);
      v25 = *(_OWORD *)v21;
      *(_QWORD *)(v24 + 16) = *((_QWORD *)v21 + 2);
      *(_OWORD *)v24 = v25;
      goto LABEL_10;
    }
LABEL_18:
    v12 = 0;
    v13 = *(_DWORD *)(a4 + 8);
    if (v13 < *(_DWORD *)(a4 + 12))
      goto LABEL_9;
    goto LABEL_19;
  }
  if (mlir::BoolAttr::classof(*a2))
    v9 = v8;
  else
    v9 = 0;
  v42 = v9;
  if (!v9 || mlir::BoolAttr::getValue((mlir::BoolAttr *)&v42))
  {
    v10 = *a1;
    v11 = (*a1)[11];
    if ((v11 & 0x7FFFFF) != 0)
      goto LABEL_8;
    goto LABEL_18;
  }
LABEL_11:
  if (!v42 || !mlir::BoolAttr::getValue((mlir::BoolAttr *)&v42))
  {
    v15 = *a1;
    v16 = (*a1)[11];
    if ((v16 & 0x7FFFFF) != 0)
    {
      v17 = (((unint64_t)&v15[4 * ((v16 >> 23) & 1) + 17] + ((v16 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
          + 32 * v15[10];
      if (*(_QWORD *)(v17 + 24) != v17 + 24)
      {
        v18 = v17 + 24;
        v19 = *(_DWORD *)(a4 + 8);
        if (v19 < *(_DWORD *)(a4 + 12))
        {
LABEL_16:
          v20 = (uint64_t *)(*(_QWORD *)a4 + 24 * v19);
          *v20 = v18;
          mlir::ValueRange::ValueRange((unint64_t *)v20 + 1, 0, 0);
LABEL_30:
          ++*(_DWORD *)(a4 + 8);
          return;
        }
LABEL_23:
        v46 = v18;
        v26 = (char *)&v46;
        mlir::ValueRange::ValueRange(v47, 0, 0);
        v27 = *(unsigned int *)(a4 + 8);
        v28 = *(_QWORD *)a4;
        if (v27 >= *(_DWORD *)(a4 + 12))
        {
LABEL_37:
          v38 = v27 + 1;
          v39 = v28 + 24 * v27 > (unint64_t)&v46;
          if (v28 <= (unint64_t)&v46 && v39)
          {
            v41 = (char *)&v47[-1] - v28;
            llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v38, 24);
            v28 = *(_QWORD *)a4;
            v26 = &v41[*(_QWORD *)a4];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v38, 24);
            v28 = *(_QWORD *)a4;
            v26 = (char *)&v46;
          }
        }
LABEL_33:
        v34 = v28 + 24 * *(unsigned int *)(a4 + 8);
        v35 = *(_OWORD *)v26;
        *(_QWORD *)(v34 + 16) = *((_QWORD *)v26 + 2);
        *(_OWORD *)v34 = v35;
        goto LABEL_30;
      }
    }
    else if (MEMORY[0x18] != 24)
    {
      v18 = 24;
      v19 = *(_DWORD *)(a4 + 8);
      if (v19 < *(_DWORD *)(a4 + 12))
        goto LABEL_16;
      goto LABEL_23;
    }
    v29 = v15[9];
    v30 = v15 - 4;
    if ((_DWORD)v29)
      v31 = (uint64_t)v30;
    else
      v31 = 0;
    v32 = *(_DWORD *)(a4 + 8);
    if (v32 < *(_DWORD *)(a4 + 12))
    {
      v33 = (_QWORD *)(*(_QWORD *)a4 + 24 * v32);
      *v33 = 0;
      mlir::ValueRange::ValueRange(v33 + 1, v31, v29);
      goto LABEL_30;
    }
    v46 = 0;
    v26 = (char *)&v46;
    mlir::ValueRange::ValueRange(v47, v31, v29);
    v27 = *(unsigned int *)(a4 + 8);
    v28 = *(_QWORD *)a4;
    if (v27 >= *(_DWORD *)(a4 + 12))
      goto LABEL_37;
    goto LABEL_33;
  }
}

uint64_t mlir::scf::IfOp::fold(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  void *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *Input;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL (*v33)(llvm::APInt *);
  uint64_t v34;
  uint64_t Filter;

  v2 = *a1;
  v3 = *(unsigned int *)(*a1 + 44);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = ((v2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(v2 + 40);
    if (*(_QWORD *)(v4 + 24) != v4 + 24)
      goto LABEL_3;
    return 0;
  }
  if (MEMORY[0x18] == 24)
    return 0;
LABEL_3:
  Filter = *(_QWORD *)(*(_QWORD *)(v2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (result)
  {
    v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id)
      v8 = result;
    else
      v8 = 0;
    v34 = v8;
    if (v7)
    {
      v33 = mlir::m_One(void)::{lambda(llvm::APInt const&)#1}::__invoke;
      Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v34);
      result = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
      if (result)
      {
        result = mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(uint64_t *))&v33, (mlir::Operation *)result);
        if ((_DWORD)result)
        {
          v9 = *(uint64_t **)(*a1 + 72);
          Input = (uint64_t *)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v34);
          v11 = (uint64_t *)v9[1];
          if (v11)
          {
            *v11 = *v9;
            if (*v9)
              *(_QWORD *)(*v9 + 8) = v9[1];
          }
          v9[3] = (uint64_t)Input;
          v9[1] = (uint64_t)Input;
          v12 = *Input;
          *v9 = *Input;
          if (v12)
            *(_QWORD *)(v12 + 8) = v9;
          *Input = (uint64_t)v9;
          v13 = *(unsigned int *)(*a1 + 44);
          if ((v13 & 0x7FFFFF) != 0)
          {
            v14 = (_QWORD *)(((*a1 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                           + 32 * *(unsigned int *)(*a1 + 40));
            v15 = (uint64_t *)v14[1];
          }
          else
          {
            v14 = 0;
            v15 = (uint64_t *)MEMORY[8];
          }
          if (v15)
            v16 = v15 - 1;
          else
            v16 = 0;
          v17 = v14 + 3;
          if ((_QWORD *)v14[3] != v14 + 3 && v15 != v17)
          {
            v18 = (uint64_t *)v14[4];
            llvm::ilist_traits<mlir::Block>::transferNodesFromList((uint64_t)v14, (uint64_t)(v14 + 3), (uint64_t)v18, (uint64_t)(v14 + 3));
            if (v18 != v17)
            {
              v19 = *v17;
              v20 = *v18;
              *(_QWORD *)(v20 + 8) = v17;
              *v17 = v20;
              v21 = *v15;
              *(_QWORD *)(v19 + 8) = v15;
              *v18 = v21;
              *(_QWORD *)(v21 + 8) = v18;
              *v15 = v19;
            }
          }
          v22 = *(unsigned int *)(*a1 + 44);
          if ((v22 & 0x7FFFFF) != 0)
          {
            v23 = ((*a1 + 16 * ((v22 >> 23) & 1) + ((v22 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(*a1 + 40);
            v24 = v23 + 24;
            v25 = v23 + 32;
          }
          else
          {
            v23 = 0;
            v24 = 24;
            v25 = 32;
          }
          v26 = *(uint64_t **)v25;
          if (v15)
            v27 = v16 + 1;
          else
            v27 = 0;
          v28 = (uint64_t *)v27[1];
          if (v27 != v26 && v28 != v26)
          {
            llvm::ilist_traits<mlir::Block>::transferNodesFromList(v24, v23, (uint64_t)v27, v27[1]);
            if (v28 != v27)
            {
              v30 = *v28;
              v31 = *v27;
              *(_QWORD *)(v31 + 8) = v28;
              *v28 = v31;
              v32 = *v26;
              *(_QWORD *)(v30 + 8) = v26;
              *v27 = v32;
              *(_QWORD *)(v32 + 8) = v27;
              *v26 = v30;
            }
          }
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void mlir::scf::IfOp::getRegionInvocationBounds(uint64_t a1, _QWORD **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _BOOL4 v6;
  uint64_t v7;
  _BOOL4 Value;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[2];

  v5 = (uint64_t)*a2;
  if (!*a2 || (!(v6 = mlir::BoolAttr::classof(*a2)) ? (v7 = 0) : (v7 = v5), v22 = v7, !v6))
  {
    if (*(_DWORD *)(a4 + 12) > 1u)
    {
      v15 = *(unsigned int *)(a4 + 8);
      v16 = 2;
      if (v15 < 2)
        v16 = *(unsigned int *)(a4 + 8);
      if (v16)
      {
        v17 = *(_QWORD *)a4;
        *(_QWORD *)v17 = 0x100000000;
        *(_DWORD *)(v17 + 8) = 1;
        if (v16 != 1)
        {
          *(_QWORD *)(v17 + 12) = 0x100000000;
          *(_DWORD *)(v17 + 20) = 1;
        }
        v15 = *(unsigned int *)(a4 + 8);
      }
      if (v15 > 1)
        goto LABEL_22;
      v14 = *(_QWORD *)a4 + 12 * v15;
      *(_QWORD *)v14 = 0x100000000;
      *(_DWORD *)(v14 + 8) = 1;
      if (v15 == 1)
        goto LABEL_22;
    }
    else
    {
      *(_DWORD *)(a4 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), 2uLL, 12);
      v14 = *(_QWORD *)a4;
      *(_QWORD *)v14 = 0x100000000;
      *(_DWORD *)(v14 + 8) = 1;
    }
    *(_QWORD *)(v14 + 12) = 0x100000000;
    *(_DWORD *)(v14 + 20) = 1;
LABEL_22:
    *(_DWORD *)(a4 + 8) = 2;
    return;
  }
  Value = mlir::BoolAttr::getValue((mlir::BoolAttr *)&v22);
  v9 = *(unsigned int *)(a4 + 8);
  if (v9 >= *(_DWORD *)(a4 + 12))
  {
    LODWORD(v23[0]) = 0;
    *(_QWORD *)((char *)v23 + 4) = Value | 0x100000000;
    v18 = v23[0];
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 12);
    v19 = *(_QWORD *)a4 + 12 * *(unsigned int *)(a4 + 8);
    *(_QWORD *)v19 = v18;
    *(_DWORD *)(v19 + 8) = 1;
  }
  else
  {
    v10 = *(_QWORD *)a4 + 12 * v9;
    *(_DWORD *)v10 = 0;
    *(_QWORD *)(v10 + 4) = Value | 0x100000000;
  }
  ++*(_DWORD *)(a4 + 8);
  v11 = !mlir::BoolAttr::getValue((mlir::BoolAttr *)&v22);
  v12 = *(unsigned int *)(a4 + 8);
  if (v12 >= *(_DWORD *)(a4 + 12))
  {
    LODWORD(v23[0]) = 0;
    *(_QWORD *)((char *)v23 + 4) = v11 | 0x100000000;
    v20 = v23[0];
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v12 + 1, 12);
    v21 = *(_QWORD *)a4 + 12 * *(unsigned int *)(a4 + 8);
    *(_QWORD *)v21 = v20;
    *(_DWORD *)(v21 + 8) = 1;
  }
  else
  {
    v13 = *(_QWORD *)a4 + 12 * v12;
    *(_DWORD *)v13 = 0;
    *(_QWORD *)(v13 + 4) = v11 | 0x100000000;
  }
  ++*(_DWORD *)(a4 + 8);
}

void mlir::scf::IfOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  const char *v147;
  unint64_t v148;
  uint64_t v149;
  const char *v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  uint64_t *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  unint64_t v176;
  char *v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  const char *v181;
  unint64_t v182;
  uint64_t v183;
  const char *v184;
  unint64_t v185;
  char *v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  char *v191;
  uint64_t *v192;
  char *v193;
  char *v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  uint64_t v201;
  __int128 v202;
  __int128 v203;
  uint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  char *v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  const char *v215;
  unint64_t v216;
  uint64_t v217;
  const char *v218;
  unint64_t v219;
  char *v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  char *v225;
  uint64_t *v226;
  char *v227;
  char *v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  char *v232;
  char *v233;
  char *v234;
  uint64_t v235;
  __int128 v236;
  __int128 v237;
  uint64_t v238;
  char *v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  unint64_t v243;
  unint64_t v244;
  char *v245;
  uint64_t v246;
  unint64_t v247;
  unint64_t v248;
  const char *v249;
  unint64_t v250;
  uint64_t v251;
  const char *v252;
  unint64_t v253;
  char *v254;
  uint64_t v255;
  unint64_t v256;
  uint64_t v257;
  unint64_t v258;
  char *v259;
  uint64_t *v260;
  char *v261;
  char *v262;
  unint64_t v263;
  uint64_t v264;
  uint64_t v265;
  char *v266;
  char *v267;
  char *v268;
  uint64_t v269;
  __int128 v270;
  __int128 v271;
  uint64_t v272;
  char *v273;
  uint64_t v274;
  uint64_t v275;
  const char *v276;
  unint64_t v277;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v4 = &off_24BFF2648;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::CombineIfs]";
  v277 = 83;
  v9 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v9)
    v10 = v9;
  else
    v10 = v277;
  v11 = &v276[v10];
  v12 = v277 - v10;
  if (v277 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v277 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_306;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_307;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_310;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_310:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v38 = &off_24BFF2750;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::CombineNestedIfs]";
  v277 = 89;
  v43 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v43)
    v44 = v43;
  else
    v44 = v277;
  v45 = &v276[v44];
  v46 = v277 - v44;
  if (v277 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v277 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_306;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_307;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_311;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_311:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v72 = &off_24BFF2978;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ConditionPropagation]";
  v277 = 93;
  v77 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v77)
    v78 = v77;
  else
    v78 = v277;
  v79 = &v276[v78];
  v80 = v277 - v78;
  if (v277 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v277 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_306;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_307;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_312;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_312:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v106 = &off_24BFF2B88;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ConvertTrivialIfToSelect]";
  v277 = 97;
  v111 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v111)
    v112 = v111;
  else
    v112 = v277;
  v113 = &v276[v112];
  v114 = v277 - v112;
  if (v277 - v112 >= 0x12)
    v115 = 18;
  else
    v115 = v277 - v112;
  v116 = &v113[v115];
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
    goto LABEL_306;
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (v122)
  {
    if (v122 >> 61)
      goto LABEL_307;
    v123 = (char *)operator new(8 * v122);
    v124 = (uint64_t *)&v123[8 * v119];
    v125 = &v123[8 * v122];
    *v124 = v106;
    v110 = (uint64_t)(v124 + 1);
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
  }
  else
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_313;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v109[-v129];
      v124 = (uint64_t *)((char *)v124 - v129);
      v131 = &v123[8 * v119 - 16];
      v132 = v109 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_313:
        do
        {
          v136 = *((_QWORD *)v109 - 1);
          v109 -= 8;
          *(_QWORD *)v109 = 0;
          *--v124 = v136;
        }
        while (v109 != v118);
      }
      v109 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
  v140 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v140 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v140 = &off_24BFF2A80;
  if (*(_QWORD *)(v140 + 72))
  {
    v141 = *(unsigned int *)(v140 + 88);
    if (v141 <= *(_DWORD *)(v140 + 92))
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v140 + 80, (void *)(v140 + 96), v141, 16);
    *(_DWORD *)(v140 + 88) = *(_DWORD *)(v140 + 88);
    v143 = (char *)a1[2];
    v142 = a1[3];
    if ((unint64_t)v143 < v142)
      goto LABEL_156;
    goto LABEL_167;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::RemoveEmptyElseBranch]";
  v277 = 94;
  v145 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v145)
    v146 = v145;
  else
    v146 = v277;
  v147 = &v276[v146];
  v148 = v277 - v146;
  if (v277 - v146 >= 0x12)
    v149 = 18;
  else
    v149 = v277 - v146;
  v150 = &v147[v149];
  v151 = v148 - v149;
  if (v151 >= v151 - 1)
    --v151;
  *(_QWORD *)(v140 + 64) = v150;
  *(_QWORD *)(v140 + 72) = v151;
  v141 = *(unsigned int *)(v140 + 88);
  if (v141 > *(_DWORD *)(v140 + 92))
    goto LABEL_166;
LABEL_155:
  *(_DWORD *)(v140 + 88) = v141;
  v143 = (char *)a1[2];
  v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(_QWORD *)v143 = v140;
    v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v152 = (char *)a1[1];
  v153 = (v143 - v152) >> 3;
  v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61)
    goto LABEL_306;
  v155 = v142 - (_QWORD)v152;
  if (v155 >> 2 > v154)
    v154 = v155 >> 2;
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8)
    v156 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v156 = v154;
  if (v156)
  {
    if (v156 >> 61)
      goto LABEL_307;
    v157 = (char *)operator new(8 * v156);
    v158 = (uint64_t *)&v157[8 * v153];
    v159 = &v157[8 * v156];
    *v158 = v140;
    v144 = (uint64_t)(v158 + 1);
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
      goto LABEL_176;
  }
  else
  {
    v157 = 0;
    v158 = (uint64_t *)(8 * v153);
    v159 = 0;
    *(_QWORD *)(8 * v153) = v140;
    v144 = 8 * v153 + 8;
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
    {
LABEL_176:
      v161 = (unint64_t)(v160 - 8);
      if (v161 < 0x78
        || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v158
        && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
      {
        goto LABEL_314;
      }
      v162 = (v161 >> 3) + 1;
      v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      v164 = &v143[-v163];
      v158 = (uint64_t *)((char *)v158 - v163);
      v165 = &v157[8 * v153 - 16];
      v166 = v143 - 16;
      v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v169 = *((_OWORD *)v166 - 1);
        v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      v143 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_314:
        do
        {
          v170 = *((_QWORD *)v143 - 1);
          v143 -= 8;
          *(_QWORD *)v143 = 0;
          *--v158 = v170;
        }
        while (v143 != v152);
      }
      v143 = (char *)a1[1];
      v171 = (char *)a1[2];
      a1[1] = v158;
      a1[2] = v144;
      a1[3] = v159;
      while (v171 != v143)
      {
        v173 = *((_QWORD *)v171 - 1);
        v171 -= 8;
        v172 = v173;
        *(_QWORD *)v171 = 0;
        if (v173)
          (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
      }
      goto LABEL_189;
    }
  }
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143)
    operator delete(v143);
LABEL_191:
  a1[2] = v144;
  v174 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v174 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v174 = &off_24BFF2AD8;
  if (*(_QWORD *)(v174 + 72))
  {
    v175 = *(unsigned int *)(v174 + 88);
    if (v175 <= *(_DWORD *)(v174 + 92))
      goto LABEL_193;
LABEL_204:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v174 + 80, (void *)(v174 + 96), v175, 16);
    *(_DWORD *)(v174 + 88) = *(_DWORD *)(v174 + 88);
    v177 = (char *)a1[2];
    v176 = a1[3];
    if ((unint64_t)v177 < v176)
      goto LABEL_194;
    goto LABEL_205;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::RemoveStaticCondition]";
  v277 = 94;
  v179 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v179)
    v180 = v179;
  else
    v180 = v277;
  v181 = &v276[v180];
  v182 = v277 - v180;
  if (v277 - v180 >= 0x12)
    v183 = 18;
  else
    v183 = v277 - v180;
  v184 = &v181[v183];
  v185 = v182 - v183;
  if (v185 >= v185 - 1)
    --v185;
  *(_QWORD *)(v174 + 64) = v184;
  *(_QWORD *)(v174 + 72) = v185;
  v175 = *(unsigned int *)(v174 + 88);
  if (v175 > *(_DWORD *)(v174 + 92))
    goto LABEL_204;
LABEL_193:
  *(_DWORD *)(v174 + 88) = v175;
  v177 = (char *)a1[2];
  v176 = a1[3];
  if ((unint64_t)v177 < v176)
  {
LABEL_194:
    *(_QWORD *)v177 = v174;
    v178 = (uint64_t)(v177 + 8);
    goto LABEL_229;
  }
LABEL_205:
  v186 = (char *)a1[1];
  v187 = (v177 - v186) >> 3;
  v188 = v187 + 1;
  if ((unint64_t)(v187 + 1) >> 61)
    goto LABEL_306;
  v189 = v176 - (_QWORD)v186;
  if (v189 >> 2 > v188)
    v188 = v189 >> 2;
  if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8)
    v190 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v190 = v188;
  if (v190)
  {
    if (v190 >> 61)
      goto LABEL_307;
    v191 = (char *)operator new(8 * v190);
    v192 = (uint64_t *)&v191[8 * v187];
    v193 = &v191[8 * v190];
    *v192 = v174;
    v178 = (uint64_t)(v192 + 1);
    v194 = (char *)(v177 - v186);
    if (v177 != v186)
      goto LABEL_214;
  }
  else
  {
    v191 = 0;
    v192 = (uint64_t *)(8 * v187);
    v193 = 0;
    *(_QWORD *)(8 * v187) = v174;
    v178 = 8 * v187 + 8;
    v194 = (char *)(v177 - v186);
    if (v177 != v186)
    {
LABEL_214:
      v195 = (unint64_t)(v194 - 8);
      if (v195 < 0x78
        || &v177[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v192
        && &v191[v177 - v186 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v177)
      {
        goto LABEL_315;
      }
      v196 = (v195 >> 3) + 1;
      v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      v198 = &v177[-v197];
      v192 = (uint64_t *)((char *)v192 - v197);
      v199 = &v191[8 * v187 - 16];
      v200 = v177 - 16;
      v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v203 = *((_OWORD *)v200 - 1);
        v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      v177 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_315:
        do
        {
          v204 = *((_QWORD *)v177 - 1);
          v177 -= 8;
          *(_QWORD *)v177 = 0;
          *--v192 = v204;
        }
        while (v177 != v186);
      }
      v177 = (char *)a1[1];
      v205 = (char *)a1[2];
      a1[1] = v192;
      a1[2] = v178;
      a1[3] = v193;
      while (v205 != v177)
      {
        v207 = *((_QWORD *)v205 - 1);
        v205 -= 8;
        v206 = v207;
        *(_QWORD *)v205 = 0;
        if (v207)
          (*(void (**)(uint64_t))(*(_QWORD *)v206 + 8))(v206);
      }
      goto LABEL_227;
    }
  }
  a1[1] = v192;
  a1[2] = v178;
  a1[3] = v193;
LABEL_227:
  if (v177)
    operator delete(v177);
LABEL_229:
  a1[2] = v178;
  v208 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v208 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v208 = &off_24BFF2858;
  if (*(_QWORD *)(v208 + 72))
  {
    v209 = *(unsigned int *)(v208 + 88);
    if (v209 <= *(_DWORD *)(v208 + 92))
      goto LABEL_231;
LABEL_242:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v208 + 80, (void *)(v208 + 96), v209, 16);
    *(_DWORD *)(v208 + 88) = *(_DWORD *)(v208 + 88);
    v211 = (char *)a1[2];
    v210 = a1[3];
    if ((unint64_t)v211 < v210)
      goto LABEL_232;
    goto LABEL_243;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::RemoveUnusedResults]";
  v277 = 92;
  v213 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v213)
    v214 = v213;
  else
    v214 = v277;
  v215 = &v276[v214];
  v216 = v277 - v214;
  if (v277 - v214 >= 0x12)
    v217 = 18;
  else
    v217 = v277 - v214;
  v218 = &v215[v217];
  v219 = v216 - v217;
  if (v219 >= v219 - 1)
    --v219;
  *(_QWORD *)(v208 + 64) = v218;
  *(_QWORD *)(v208 + 72) = v219;
  v209 = *(unsigned int *)(v208 + 88);
  if (v209 > *(_DWORD *)(v208 + 92))
    goto LABEL_242;
LABEL_231:
  *(_DWORD *)(v208 + 88) = v209;
  v211 = (char *)a1[2];
  v210 = a1[3];
  if ((unint64_t)v211 < v210)
  {
LABEL_232:
    *(_QWORD *)v211 = v208;
    v212 = (uint64_t)(v211 + 8);
    goto LABEL_267;
  }
LABEL_243:
  v220 = (char *)a1[1];
  v221 = (v211 - v220) >> 3;
  v222 = v221 + 1;
  if ((unint64_t)(v221 + 1) >> 61)
    goto LABEL_306;
  v223 = v210 - (_QWORD)v220;
  if (v223 >> 2 > v222)
    v222 = v223 >> 2;
  if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8)
    v224 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v224 = v222;
  if (v224)
  {
    if (v224 >> 61)
      goto LABEL_307;
    v225 = (char *)operator new(8 * v224);
    v226 = (uint64_t *)&v225[8 * v221];
    v227 = &v225[8 * v224];
    *v226 = v208;
    v212 = (uint64_t)(v226 + 1);
    v228 = (char *)(v211 - v220);
    if (v211 != v220)
      goto LABEL_252;
  }
  else
  {
    v225 = 0;
    v226 = (uint64_t *)(8 * v221);
    v227 = 0;
    *(_QWORD *)(8 * v221) = v208;
    v212 = 8 * v221 + 8;
    v228 = (char *)(v211 - v220);
    if (v211 != v220)
    {
LABEL_252:
      v229 = (unint64_t)(v228 - 8);
      if (v229 < 0x78
        || &v211[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v226
        && &v225[v211 - v220 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v211)
      {
        goto LABEL_316;
      }
      v230 = (v229 >> 3) + 1;
      v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
      v232 = &v211[-v231];
      v226 = (uint64_t *)((char *)v226 - v231);
      v233 = &v225[8 * v221 - 16];
      v234 = v211 - 16;
      v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v237 = *((_OWORD *)v234 - 1);
        v236 = *(_OWORD *)v234;
        *((_OWORD *)v234 - 1) = 0uLL;
        *(_OWORD *)v234 = 0uLL;
        *((_OWORD *)v233 - 1) = v237;
        *(_OWORD *)v233 = v236;
        v233 -= 32;
        v234 -= 32;
        v235 -= 4;
      }
      while (v235);
      v211 = v232;
      if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_316:
        do
        {
          v238 = *((_QWORD *)v211 - 1);
          v211 -= 8;
          *(_QWORD *)v211 = 0;
          *--v226 = v238;
        }
        while (v211 != v220);
      }
      v211 = (char *)a1[1];
      v239 = (char *)a1[2];
      a1[1] = v226;
      a1[2] = v212;
      a1[3] = v227;
      while (v239 != v211)
      {
        v241 = *((_QWORD *)v239 - 1);
        v239 -= 8;
        v240 = v241;
        *(_QWORD *)v239 = 0;
        if (v241)
          (*(void (**)(uint64_t))(*(_QWORD *)v240 + 8))(v240);
      }
      goto LABEL_265;
    }
  }
  a1[1] = v226;
  a1[2] = v212;
  a1[3] = v227;
LABEL_265:
  if (v211)
    operator delete(v211);
LABEL_267:
  a1[2] = v212;
  v242 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v276, 1);
  mlir::Pattern::Pattern(v242 + 8, (uint64_t)"scf.if", 6, (__int16)v276, a2, 0, 0);
  *(_QWORD *)v242 = &off_24BFF2DF0;
  if (*(_QWORD *)(v242 + 72))
  {
    v243 = *(unsigned int *)(v242 + 88);
    if (v243 <= *(_DWORD *)(v242 + 92))
      goto LABEL_269;
LABEL_280:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v242 + 80, (void *)(v242 + 96), v243, 16);
    *(_DWORD *)(v242 + 88) = *(_DWORD *)(v242 + 88);
    v245 = (char *)a1[2];
    v244 = a1[3];
    if ((unint64_t)v245 < v244)
      goto LABEL_270;
    goto LABEL_281;
  }
  v276 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ReplaceIfYieldWithConditionOrValue]";
  v277 = 107;
  v247 = llvm::StringRef::find((uint64_t *)&v276, "DesiredTypeName = ", 0x12uLL, 0);
  if (v277 >= v247)
    v248 = v247;
  else
    v248 = v277;
  v249 = &v276[v248];
  v250 = v277 - v248;
  if (v277 - v248 >= 0x12)
    v251 = 18;
  else
    v251 = v277 - v248;
  v252 = &v249[v251];
  v253 = v250 - v251;
  if (v253 >= v253 - 1)
    --v253;
  *(_QWORD *)(v242 + 64) = v252;
  *(_QWORD *)(v242 + 72) = v253;
  v243 = *(unsigned int *)(v242 + 88);
  if (v243 > *(_DWORD *)(v242 + 92))
    goto LABEL_280;
LABEL_269:
  *(_DWORD *)(v242 + 88) = v243;
  v245 = (char *)a1[2];
  v244 = a1[3];
  if ((unint64_t)v245 < v244)
  {
LABEL_270:
    *(_QWORD *)v245 = v242;
    v246 = (uint64_t)(v245 + 8);
    goto LABEL_305;
  }
LABEL_281:
  v254 = (char *)a1[1];
  v255 = (v245 - v254) >> 3;
  v256 = v255 + 1;
  if ((unint64_t)(v255 + 1) >> 61)
LABEL_306:
    abort();
  v257 = v244 - (_QWORD)v254;
  if (v257 >> 2 > v256)
    v256 = v257 >> 2;
  if ((unint64_t)v257 >= 0x7FFFFFFFFFFFFFF8)
    v258 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v258 = v256;
  if (!v258)
  {
    v259 = 0;
    v260 = (uint64_t *)(8 * v255);
    v261 = 0;
    *(_QWORD *)(8 * v255) = v242;
    v246 = 8 * v255 + 8;
    v262 = (char *)(v245 - v254);
    if (v245 != v254)
      goto LABEL_290;
    goto LABEL_302;
  }
  if (v258 >> 61)
LABEL_307:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v259 = (char *)operator new(8 * v258);
  v260 = (uint64_t *)&v259[8 * v255];
  v261 = &v259[8 * v258];
  *v260 = v242;
  v246 = (uint64_t)(v260 + 1);
  v262 = (char *)(v245 - v254);
  if (v245 != v254)
  {
LABEL_290:
    v263 = (unint64_t)(v262 - 8);
    if (v263 < 0x78
      || &v245[-(v263 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v260
      && &v259[v245 - v254 - (v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v245)
    {
      goto LABEL_317;
    }
    v264 = (v263 >> 3) + 1;
    v265 = 8 * (v264 & 0x3FFFFFFFFFFFFFFCLL);
    v266 = &v245[-v265];
    v260 = (uint64_t *)((char *)v260 - v265);
    v267 = &v259[8 * v255 - 16];
    v268 = v245 - 16;
    v269 = v264 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v271 = *((_OWORD *)v268 - 1);
      v270 = *(_OWORD *)v268;
      *((_OWORD *)v268 - 1) = 0uLL;
      *(_OWORD *)v268 = 0uLL;
      *((_OWORD *)v267 - 1) = v271;
      *(_OWORD *)v267 = v270;
      v267 -= 32;
      v268 -= 32;
      v269 -= 4;
    }
    while (v269);
    v245 = v266;
    if (v264 != (v264 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_317:
      do
      {
        v272 = *((_QWORD *)v245 - 1);
        v245 -= 8;
        *(_QWORD *)v245 = 0;
        *--v260 = v272;
      }
      while (v245 != v254);
    }
    v245 = (char *)a1[1];
    v273 = (char *)a1[2];
    a1[1] = v260;
    a1[2] = v246;
    a1[3] = v261;
    while (v273 != v245)
    {
      v275 = *((_QWORD *)v273 - 1);
      v273 -= 8;
      v274 = v275;
      *(_QWORD *)v273 = 0;
      if (v275)
        (*(void (**)(uint64_t))(*(_QWORD *)v274 + 8))(v274);
    }
    goto LABEL_303;
  }
LABEL_302:
  a1[1] = v260;
  a1[2] = v246;
  a1[3] = v261;
LABEL_303:
  if (v245)
    operator delete(v245);
LABEL_305:
  a1[2] = v246;
}

void mlir::scf::ParallelOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, void (*a10)(uint64_t, uint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t), uint64_t a11)
{
  int v15;
  uint64_t DenseI32ArrayAttr;
  mlir::StringAttr *Context;
  uint64_t v20;
  mlir::MLIRContext *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  _OWORD *v32;
  unint64_t v33;
  uint64_t IndexType;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  int64x2_t v39;
  int64x2_t *v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  int64x2_t v46;
  int64x2_t *v47;
  _QWORD *v48;
  _QWORD *Block;
  _QWORD *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  __int128 v55;
  unint64_t v56[2];
  unint64_t v57[2];
  unint64_t v58[2];
  void *v59;
  uint64_t v60;
  _QWORD v61[8];
  __n128 v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _DWORD v71[4];
  __n128 v72;
  uint64_t v73;

  v15 = a4;
  v73 = *MEMORY[0x24BDAC8D0];
  v72 = a9;
  mlir::OperationState::addOperands(a2, a3, a4);
  mlir::OperationState::addOperands(a2, a5, a6);
  mlir::OperationState::addOperands(a2, a7, a8);
  mlir::OperationState::addOperands(a2, a9.n128_i64[0], a9.n128_i64[1]);
  v71[0] = v15;
  v71[1] = a6;
  v71[2] = a8;
  v71[3] = a9.n128_u32[2];
  DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v71, 4);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  LOWORD(v65) = 261;
  v62.n128_u64[0] = (unint64_t)"operandSegmentSizes";
  v62.n128_u64[1] = 19;
  v20 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v62);
  ZinMirCacheTensors::ZinMirCacheTensors(&v59, v20, DenseI32ArrayAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v59, v60);
  mlir::ValueRange::getTypes(&v72, &v62);
  v22 = v62.n128_i64[1];
  v23 = (void *)v62.n128_u64[0];
  v24 = v63;
  v25 = v64;
  v26 = v64 - v62.n128_u32[2];
  v27 = *(unsigned int *)(a2 + 72);
  v28 = v64 - v62.n128_u64[1] + v27;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    v27 = *(unsigned int *)(a2 + 72);
  }
  v29 = *(_QWORD *)(a2 + 64);
  v59 = v23;
  v60 = v22;
  if (v25 != v22 || v23 != v24)
  {
    v30 = (unint64_t *)(v29 + 8 * v27);
    do
    {
      *v30++ = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v59, v22) + 8) & 0xFFFFFFFFFFFFFFF8;
      v22 = ++v60;
    }
    while (v59 != v24 || v22 != v25);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  v32 = (_OWORD *)(a1 + 16);
  v55 = *(_OWORD *)(a1 + 16);
  v33 = a8;
  IndexType = mlir::Builder::getIndexType((mlir::IndexType **)a1, v21);
  v35 = IndexType;
  v62.n128_u64[0] = (unint64_t)&v63;
  v62.n128_u32[3] = 8;
  if (a8 < 9uLL)
  {
    if (!(_DWORD)a8)
    {
      v62.n128_u32[2] = a8;
      v59 = v61;
      HIDWORD(v60) = 8;
      LODWORD(a8) = 0;
      goto LABEL_44;
    }
    v63 = (void *)IndexType;
    if (a8 != 1)
    {
      v64 = IndexType;
      if (a8 != 2)
      {
        v65 = IndexType;
        if (a8 != 3)
        {
          v66 = IndexType;
          if (a8 != 4)
          {
            v67 = IndexType;
            if (a8 != 5)
            {
              v68 = IndexType;
              if (a8 != 6)
              {
                v69 = IndexType;
                if (a8 != 7)
                {
                  v41 = (unint64_t *)&v70;
                  goto LABEL_19;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v62.n128_u32[2] = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, &v63, a8, 8);
    v36 = a8 & 3;
    v37 = a8 - v36;
    v38 = (unint64_t *)(v62.n128_u64[0] + 8 * v37);
    v39 = vdupq_n_s64(v35);
    v40 = (int64x2_t *)(v62.n128_u64[0] + 16);
    do
    {
      v40[-1] = v39;
      *v40 = v39;
      v40 += 2;
      v37 -= 4;
    }
    while (v37);
    if ((a8 & 3) != 0)
    {
      *v38 = v35;
      if (v36 != 1)
      {
        v38[1] = v35;
        if (v36 != 2)
        {
          v41 = v38 + 2;
LABEL_19:
          *v41 = v35;
        }
      }
    }
  }
  v62.n128_u32[2] = a8;
  v59 = v61;
  v60 = 0x800000000;
  v42 = *(_QWORD *)a2;
  if (a8 < 9uLL)
  {
    v61[0] = *(_QWORD *)a2;
    if (a8 != 1)
    {
      v61[1] = v42;
      if (a8 != 2)
      {
        v61[2] = v42;
        if (a8 != 3)
        {
          v61[3] = v42;
          if (a8 != 4)
          {
            v61[4] = v42;
            if (a8 != 5)
            {
              v61[5] = v42;
              if (a8 != 6)
              {
                v61[6] = v42;
                if (a8 != 7)
                  v61[7] = v42;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v61, a8, 8);
    v43 = a8 & 3;
    v44 = a8 - v43;
    v45 = (unint64_t *)((char *)v59 + 8 * v44);
    v46 = vdupq_n_s64(v42);
    v47 = (int64x2_t *)((char *)v59 + 16);
    do
    {
      v47[-1] = v46;
      *v47 = v46;
      v47 += 2;
      v44 -= 4;
    }
    while (v44);
    if ((a8 & 3) != 0)
    {
      *v45 = v42;
      if (v43 != 1)
      {
        v45[1] = v42;
        if (v43 != 2)
          v45[2] = v42;
      }
    }
  }
LABEL_44:
  LODWORD(v60) = a8;
  v48 = (_QWORD *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  mlir::ValueRange::ValueRange(v58, v62.n128_i64[0], v62.n128_u32[2]);
  Block = (_QWORD *)mlir::OpBuilder::createBlock((_QWORD *)a1, (uint64_t)v48, 0, v58[0], v58[1], (uint64_t)v59, v60);
  if (a10)
  {
    v50 = Block;
    v51 = Block[5];
    *(_QWORD *)(a1 + 16) = Block;
    *(_QWORD *)(a1 + 24) = v51;
    v52 = *(_QWORD *)a2;
    v53 = Block[6];
    if ((Block[7] - v53) >> 3 >= v33)
      v54 = v33;
    else
      v54 = (Block[7] - v53) >> 3;
    mlir::ValueRange::ValueRange(v57, v53, v54);
    mlir::ValueRange::ValueRange(v56, v50[6] + 8 * v33, ((uint64_t)(v50[7] - v50[6]) >> 3) - v33);
    a10(a11, a1, v52, v57[0], v57[1], v56[0], v56[1]);
  }
  mlir::impl::ensureRegionTerminator(v48, a1, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ParallelOp>::buildTerminator);
  if (v59 != v61)
    free(v59);
  if ((void **)v62.n128_u64[0] != &v63)
    free((void *)v62.n128_u64[0]);
  if ((_QWORD)v55)
  {
    *v32 = v55;
  }
  else
  {
    *(_QWORD *)v32 = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t mlir::scf::ParallelOp::verify(uint64_t **this)
{
  unint64_t v2;
  uint64_t *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  int64_t ConstantIntValue;
  char v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const void **v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  const void **v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  void *v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  BOOL v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  unint64_t v102;
  uint64_t *v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  __int128 v107;
  __int128 v108;
  __int16 v109;
  uint64_t *v110;
  _OWORD v111[2];
  const void **v112;
  uint64_t v113;
  _BYTE v114[16];
  __int16 v115;
  __int128 v116;
  __int128 v117;
  _OWORD v118[6];
  void *v119;
  _QWORD *v120;
  void *__p;
  _QWORD *v122;
  char v123;
  uint64_t v124;

  v124 = *MEMORY[0x24BDAC8D0];
  v2 = *((unsigned int *)*this + 11);
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * ((v2 >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *((_DWORD *)v3 + 2);
  if ((v2 & 0x800000) != 0)
  {
    v5 = (*this)[9];
    if (v4)
      goto LABEL_6;
  }
  else
  {
    v5 = 0;
    if (v4)
    {
LABEL_6:
      v6 = (*((_DWORD *)v3 + 1) + *(_DWORD *)v3);
      v7 = (v4 + v6) - v6;
      v8 = (_QWORD *)(v5 + 32 * v6 + 24);
      v9 = v7;
      do
      {
        ConstantIntValue = mlir::getConstantIntValue(*v8 | 4);
        if (v11)
          v12 = ConstantIntValue <= 0;
        else
          v12 = 0;
        if (v12)
        {
          v112 = (const void **)"constant step operand must be positive";
          v115 = 259;
          mlir::OpState::emitOpError(this, &v112, (uint64_t)&v116);
          v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v116);
          if ((_QWORD)v116)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v116);
          if (!v123)
            return v22;
          v23 = __p;
          if (__p)
          {
            v24 = v122;
            v25 = __p;
            if (v122 != __p)
            {
              do
                v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
              while (v24 != v23);
              v25 = __p;
            }
            v122 = v23;
            operator delete(v25);
          }
          v26 = v119;
          if (!v119)
            goto LABEL_117;
          v27 = v120;
          v28 = v119;
          if (v120 == v119)
            goto LABEL_116;
          do
          {
            v30 = *--v27;
            v29 = v30;
            *v27 = 0;
            if (v30)
              MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
          }
          while (v27 != v26);
          goto LABEL_115;
        }
        v8 += 4;
        --v9;
      }
      while (v9);
      v13 = *(_QWORD *)((((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                                                   + 8]
                        + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                        + 7) & 0xFFFFFFFFFFFFFFF8)
                      + 32 * *((unsigned int *)*this + 10)
                      + 8);
      if (v13)
        v14 = v13 - 8;
      else
        v14 = 0;
      v16 = *(_QWORD *)(v14 + 48);
      v15 = *(_QWORD *)(v14 + 56);
      if (v7 == ((unint64_t)(v15 - v16) >> 3))
      {
        if (v15 != v16)
        {
          v17 = 8 * ((v15 - v16) >> 3);
          while (1)
          {
            *(_QWORD *)&v116 = *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8;
            if (!mlir::Type::isIndex((mlir::Type *)&v116))
              break;
            v16 += 8;
            v17 -= 8;
            if (!v17)
              goto LABEL_20;
          }
          v112 = (const void **)"expects arguments for the induction variable to be of index type";
          v115 = 259;
          mlir::OpState::emitOpError(this, &v112, (uint64_t)&v116);
          v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v116);
          if ((_QWORD)v116)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v116);
          if (v123)
          {
            v56 = __p;
            if (__p)
            {
              v57 = v122;
              v58 = __p;
              if (v122 != __p)
              {
                do
                  v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
                while (v57 != v56);
                v58 = __p;
              }
              v122 = v56;
              operator delete(v58);
            }
            v59 = v119;
            if (v119)
            {
              v60 = v120;
              v61 = v119;
              if (v120 != v119)
              {
                do
                {
                  v63 = *--v60;
                  v62 = v63;
                  *v60 = 0;
                  if (v63)
                    MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
                }
                while (v60 != v59);
                v61 = v119;
              }
              v120 = v59;
              operator delete(v61);
            }
            v78 = (const void **)*((_QWORD *)&v117 + 1);
            if (*((_OWORD **)&v117 + 1) != (_OWORD *)((char *)v118 + 8))
              goto LABEL_118;
          }
          return v22;
        }
LABEL_20:
        v18 = verifyAndGetTerminator<mlir::scf::YieldOp>(*this, (_QWORD *)((((unint64_t)&(*this)[2* (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ 8]+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10)), (const void **)"expects body to terminate with 'scf.yield'", (const char *)0x2A);
        v110 = (uint64_t *)v18;
        if (!v18)
          return 0;
        if ((*(_BYTE *)(v18 + 46) & 0x80) != 0 && *(_DWORD *)(v18 + 68))
        {
          v109 = 257;
          mlir::OpState::emitOpError(&v110, (const void ***)&v107, (uint64_t)&v116);
          v19 = (_QWORD *)mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v116, "not allowed to have operands inside '");
          v20 = (uint64_t)v19;
          if (*v19)
          {
            v115 = 262;
            v112 = (const void **)"scf.parallel";
            v113 = 12;
            mlir::Diagnostic::operator<<((uint64_t)(v19 + 1), &v112);
          }
          v21 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v20, "'");
          v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v21);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v116);
          return v22;
        }
        mlir::Block::getOps<mlir::scf::ReduceOp>(v14, (ZinIrHalH13g **)&v116);
        v112 = (const void **)v114;
        v113 = 0x400000000;
        v107 = v116;
        v108 = v117;
        v111[0] = v118[0];
        v111[1] = v118[1];
        llvm::SmallVectorImpl<mlir::scf::ReduceOp>::append<mlir::detail::op_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>,void>((uint64_t)&v112, (uint64_t)&v107, (ZinIrHalH13g **)v111);
        v64 = *this;
        v65 = *((unsigned int *)*this + 9);
        *(_QWORD *)&v111[0] = v65;
        v66 = v113;
        v106 = v113;
        mlir::scf::ParallelOp::getInitVals((mlir::scf::ParallelOp *)this);
        v105 = v67;
        if ((_DWORD)v65 != (_DWORD)v66)
        {
          v109 = 257;
          mlir::OpState::emitOpError(this, (const void ***)&v107, (uint64_t)&v116);
          v74 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v116, "expects number of results: ");
          v75 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v74, (uint64_t *)v111);
          v76 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v75, " to be the same as number of reductions: ");
          v77 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v76, &v106);
          goto LABEL_97;
        }
        if (v67 == v65)
        {
          if ((_DWORD)v65)
            v68 = (uint64_t)(v64 - 2);
          else
            v68 = 0;
          if ((_DWORD)v65)
          {
            v69 = 0;
            v70 = v112;
            v71 = 8 * v66 - 8;
            v72 = v65 - 1;
            v22 = 1;
            while (1)
            {
              v104 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v68, v69) + 8) & 0xFFFFFFFFFFFFFFF8;
              v103 = (uint64_t *)v70[v69];
              v102 = *(_QWORD *)(*(_QWORD *)(v103[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
              if (v104 != v102)
                break;
              if (v72 != v69)
              {
                ++v69;
                v73 = v71;
                v71 -= 8;
                if (v73)
                  continue;
              }
              goto LABEL_98;
            }
            v109 = 257;
            mlir::OpState::emitOpError(&v103, (const void ***)&v107, (uint64_t)&v116);
            v82 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v116, "expects type of reduce: ");
            v83 = mlir::InFlightDiagnostic::append<mlir::Type &>(v82, (uint64_t *)&v102);
            v84 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v83, " to be the same as result type: ");
            v77 = mlir::InFlightDiagnostic::append<mlir::Type &>(v84, (uint64_t *)&v104);
LABEL_97:
            v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v77);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v116);
          }
          else
          {
            v22 = 1;
          }
LABEL_98:
          v78 = v112;
          if (v112 != (const void **)v114)
            goto LABEL_118;
          return v22;
        }
        v109 = 257;
        mlir::OpState::emitOpError(this, (const void ***)&v107, (uint64_t)&v116);
        v79 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)&v116, "expects number of results: ");
        v80 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v79, (uint64_t *)v111);
        v81 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v80, " to be the same as number of initial values: ");
        v77 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v81, &v105);
        goto LABEL_97;
      }
      v115 = 257;
      mlir::OpState::emitOpError(this, &v112, (uint64_t)&v116);
      if ((_QWORD)v116)
      {
        LODWORD(v107) = 3;
        *((_QWORD *)&v107 + 1) = "expects the same number of induction variables: ";
        *(_QWORD *)&v108 = 48;
        v31 = (char *)&v107;
        v32 = *((_QWORD *)&v117 + 1);
        if (LODWORD(v118[0]) >= DWORD1(v118[0]))
        {
          v92 = LODWORD(v118[0]) + 1;
          if (*((_QWORD *)&v117 + 1) <= (unint64_t)&v107
            && *((_QWORD *)&v117 + 1) + 24 * (unint64_t)LODWORD(v118[0]) > (unint64_t)&v107)
          {
            v98 = (char *)&v107 - *((_QWORD *)&v117 + 1);
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v92, 24);
            v32 = *((_QWORD *)&v117 + 1);
            v31 = &v98[*((_QWORD *)&v117 + 1)];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v92, 24);
            v31 = (char *)&v107;
            v32 = *((_QWORD *)&v117 + 1);
          }
        }
        v33 = v32 + 24 * LODWORD(v118[0]);
        v34 = *(_OWORD *)v31;
        *(_QWORD *)(v33 + 16) = *((_QWORD *)v31 + 2);
        *(_OWORD *)v33 = v34;
        ++LODWORD(v118[0]);
        if ((_QWORD)v116)
        {
          v35 = *(_QWORD *)(v14 + 56) - *(_QWORD *)(v14 + 48);
          LODWORD(v107) = 5;
          *((_QWORD *)&v107 + 1) = (v35 >> 3);
          v36 = (char *)&v107;
          v37 = *((_QWORD *)&v117 + 1);
          if (LODWORD(v118[0]) >= DWORD1(v118[0]))
          {
            v93 = LODWORD(v118[0]) + 1;
            if (*((_QWORD *)&v117 + 1) <= (unint64_t)&v107
              && *((_QWORD *)&v117 + 1) + 24 * (unint64_t)LODWORD(v118[0]) > (unint64_t)&v107)
            {
              v99 = (char *)&v107 - *((_QWORD *)&v117 + 1);
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v93, 24);
              v37 = *((_QWORD *)&v117 + 1);
              v36 = &v99[*((_QWORD *)&v117 + 1)];
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v93, 24);
              v36 = (char *)&v107;
              v37 = *((_QWORD *)&v117 + 1);
            }
          }
          v38 = v37 + 24 * LODWORD(v118[0]);
          v39 = *(_OWORD *)v36;
          *(_QWORD *)(v38 + 16) = *((_QWORD *)v36 + 2);
          *(_OWORD *)v38 = v39;
          v40 = ++LODWORD(v118[0]);
          if ((_QWORD)v116)
          {
            LODWORD(v107) = 3;
            *((_QWORD *)&v107 + 1) = " as bound and step values: ";
            *(_QWORD *)&v108 = 27;
            v41 = (char *)&v107;
            v42 = *((_QWORD *)&v117 + 1);
            if (v40 >= DWORD1(v118[0]))
            {
              v94 = v40 + 1;
              v95 = *((_QWORD *)&v117 + 1) + 24 * (unint64_t)v40 > (unint64_t)&v107;
              if (*((_QWORD *)&v117 + 1) <= (unint64_t)&v107 && v95)
              {
                v100 = (char *)&v107 - *((_QWORD *)&v117 + 1);
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v94, 24);
                v42 = *((_QWORD *)&v117 + 1);
                v41 = &v100[*((_QWORD *)&v117 + 1)];
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v94, 24);
                v41 = (char *)&v107;
                v42 = *((_QWORD *)&v117 + 1);
              }
            }
            v43 = v42 + 24 * LODWORD(v118[0]);
            v44 = *(_OWORD *)v41;
            *(_QWORD *)(v43 + 16) = *((_QWORD *)v41 + 2);
            *(_OWORD *)v43 = v44;
            v45 = ++LODWORD(v118[0]);
            if ((_QWORD)v116)
            {
              LODWORD(v107) = 5;
              *((_QWORD *)&v107 + 1) = v7;
              v46 = (char *)&v107;
              v47 = *((_QWORD *)&v117 + 1);
              if (v45 >= DWORD1(v118[0]))
              {
                v96 = v45 + 1;
                v97 = *((_QWORD *)&v117 + 1) + 24 * (unint64_t)v45 > (unint64_t)&v107;
                if (*((_QWORD *)&v117 + 1) <= (unint64_t)&v107 && v97)
                {
                  v101 = (char *)&v107 - *((_QWORD *)&v117 + 1);
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v96, 24);
                  v47 = *((_QWORD *)&v117 + 1);
                  v46 = &v101[*((_QWORD *)&v117 + 1)];
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117 + 8, (char *)v118 + 8, v96, 24);
                  v46 = (char *)&v107;
                  v47 = *((_QWORD *)&v117 + 1);
                }
              }
              v48 = v47 + 24 * LODWORD(v118[0]);
              v49 = *(_OWORD *)v46;
              *(_QWORD *)(v48 + 16) = *((_QWORD *)v46 + 2);
              *(_OWORD *)v48 = v49;
              ++LODWORD(v118[0]);
            }
          }
        }
      }
      v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v116);
      if ((_QWORD)v116)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v116);
      if (!v123)
        return v22;
      v50 = __p;
      if (__p)
      {
        v51 = v122;
        v52 = __p;
        if (v122 != __p)
        {
          do
            v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
          while (v51 != v50);
          v52 = __p;
        }
        v122 = v50;
        operator delete(v52);
      }
      v26 = v119;
      if (!v119)
        goto LABEL_117;
      v53 = v120;
      v28 = v119;
      if (v120 == v119)
        goto LABEL_116;
      do
      {
        v55 = *--v53;
        v54 = v55;
        *v53 = 0;
        if (v55)
          MEMORY[0x20BD002D4](v54, 0x1000C8077774924);
      }
      while (v53 != v26);
      goto LABEL_115;
    }
  }
  v112 = (const void **)"needs at least one tuple element for lowerBound, upperBound and step";
  v115 = 259;
  mlir::OpState::emitOpError(this, &v112, (uint64_t)&v116);
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v116);
  if ((_QWORD)v116)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v116);
  if (!v123)
    return v22;
  v85 = __p;
  if (__p)
  {
    v86 = v122;
    v87 = __p;
    if (v122 != __p)
    {
      do
        v86 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v86 - 1);
      while (v86 != v85);
      v87 = __p;
    }
    v122 = v85;
    operator delete(v87);
  }
  v26 = v119;
  if (!v119)
    goto LABEL_117;
  v88 = v120;
  v28 = v119;
  if (v120 != v119)
  {
    do
    {
      v90 = *--v88;
      v89 = v90;
      *v88 = 0;
      if (v90)
        MEMORY[0x20BD002D4](v89, 0x1000C8077774924);
    }
    while (v88 != v26);
LABEL_115:
    v28 = v119;
  }
LABEL_116:
  v120 = v26;
  operator delete(v28);
LABEL_117:
  v78 = (const void **)*((_QWORD *)&v117 + 1);
  if (*((_OWORD **)&v117 + 1) != (_OWORD *)((char *)v118 + 8))
LABEL_118:
    free(v78);
  return v22;
}

uint64_t verifyAndGetTerminator<mlir::scf::YieldOp>(uint64_t *a1, _QWORD *a2, const void **a3, const char *a4)
{
  uint64_t v7;
  uint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const void ***v16;
  uint64_t v17;
  __int128 v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v28;
  BOOL v29;
  char *v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if ((_QWORD *)*a2 == a2
    || ((v7 = a2[1]) != 0 ? (v8 = v7 - 8) : (v8 = 0), v9 = *(ZinIrHalH13g **)(v8 + 32),
                                                        v9 == (ZinIrHalH13g *)(v8 + 32)))
  {
    v11 = 0;
  }
  else
  {
    ZinIrHalH13g::~ZinIrHalH13g(v9);
    v11 = v10;
    if (v10
      && *(_UNKNOWN **)(*(_QWORD *)(v10 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id)
    {
      return v11;
    }
  }
  v34 = 261;
  v31 = a3;
  v32 = a4;
  mlir::Operation::emitOpError(a1, &v31, (uint64_t)&v35);
  if (v11)
  {
    v12 = mlir::Diagnostic::attachNote(&v36, *(_QWORD *)(v11 + 24), 1);
    v13 = v12 + 16;
    v14 = *(_QWORD *)(v12 + 16);
    LODWORD(v31) = 3;
    v32 = "terminator here";
    v33 = 15;
    v15 = *(unsigned int *)(v12 + 24);
    v16 = &v31;
    if (v15 >= *(_DWORD *)(v12 + 28))
    {
      v28 = v15 + 1;
      v29 = v14 + 24 * v15 > (unint64_t)&v31;
      if (v14 <= (unint64_t)&v31 && v29)
      {
        v30 = (char *)&v31 - v14;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v13, (void *)(v12 + 32), v28, 24);
        v14 = *(_QWORD *)(v12 + 16);
        v16 = (const void ***)&v30[v14];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v13, (void *)(v12 + 32), v28, 24);
        v14 = *(_QWORD *)(v12 + 16);
        v16 = &v31;
      }
    }
    v17 = v14 + 24 * *(unsigned int *)(v12 + 24);
    v18 = *(_OWORD *)v16;
    *(_QWORD *)(v17 + 16) = v16[2];
    *(_OWORD *)v17 = v18;
    ++*(_DWORD *)(v12 + 24);
  }
  if (v35)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v35);
  if (v43)
  {
    v19 = __p;
    if (__p)
    {
      v20 = v42;
      v21 = __p;
      if (v42 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v42 = v19;
      operator delete(v21);
    }
    v22 = v39;
    if (v39)
    {
      v23 = v40;
      v24 = v39;
      if (v40 != v39)
      {
        do
        {
          v26 = *--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
        }
        while (v23 != v22);
        v24 = v39;
      }
      v40 = v22;
      operator delete(v24);
    }
    if (v37 != &v38)
      free(v37);
  }
  return 0;
}

void mlir::Block::getOps<mlir::scf::ReduceOp>(uint64_t a1@<X0>, ZinIrHalH13g **a2@<X8>)
{
  ZinIrHalH13g *v3;
  ZinIrHalH13g *v4;
  uint64_t v5;

  v3 = (ZinIrHalH13g *)(a1 + 32);
  v4 = (ZinIrHalH13g *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) != a1 + 32)
  {
    v4 = *(ZinIrHalH13g **)(a1 + 40);
    while (1)
    {
      ZinIrHalH13g::~ZinIrHalH13g(v4);
      if (*(_UNKNOWN **)(*(_QWORD *)(v5 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ReduceOp,void>::id)
        break;
      v4 = (ZinIrHalH13g *)*((_QWORD *)v4 + 1);
      if (v4 == v3)
      {
        v4 = v3;
        break;
      }
    }
  }
  *a2 = v4;
  a2[1] = v3;
  a2[2] = (ZinIrHalH13g *)mlir::detail::op_filter_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::filter;
  a2[3] = (ZinIrHalH13g *)mlir::detail::op_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::unwrap;
  a2[4] = v3;
  a2[5] = v3;
  a2[6] = (ZinIrHalH13g *)mlir::detail::op_filter_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::filter;
  a2[7] = (ZinIrHalH13g *)mlir::detail::op_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::unwrap;
}

uint64_t mlir::scf::ParallelOp::getInitVals(mlir::scf::ParallelOp *this)
{
  unint64_t v1;
  _DWORD *v2;
  uint64_t v3;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = (_DWORD *)(*(_QWORD *)this + 16 * ((v1 >> 23) & 1) + 64);
  else
    v2 = 0;
  v3 = (v2[2] + v2[1] + *v2);
  if ((v1 & 0x800000) != 0)
    return *(_QWORD *)(*(_QWORD *)this + 72) + 32 * v3;
  else
    return 32 * v3;
}

uint64_t mlir::scf::ParallelOp::parse(uint64_t a1, mlir::OperationState *a2)
{
  mlir::IndexType **v4;
  mlir::MLIRContext *v5;
  uint64_t IndexType;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  mlir::MLIRContext *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  mlir::MLIRContext *v22;
  _QWORD *v23;
  void *v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t DenseI32ArrayAttr;
  uint64_t v32;
  _QWORD *v33;
  _DWORD v34[4];
  void *v35;
  uint64_t v36;
  _WORD v37[64];
  void *v38;
  uint64_t v39;
  _WORD v40[64];
  void *v41;
  uint64_t v42;
  _BYTE v43[128];
  void *v44;
  uint64_t v45;
  _BYTE v46[128];
  void *v47;
  uint64_t v48;
  _QWORD v49[34];

  v49[32] = *MEMORY[0x24BDAC8D0];
  v4 = (mlir::IndexType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v47 = v49;
  v48 = 0x400000000;
  if (!(*(unsigned __int8 (**)(uint64_t, void **, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 736))(a1, &v47, 1, 0, 0))
  {
    v28 = 0;
    v29 = v47;
    if (v47 == v49)
      return v28;
    goto LABEL_31;
  }
  v44 = v46;
  v45 = 0x400000000;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 136))(a1)
    || !(*(unsigned __int8 (**)(uint64_t, void **, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 688))(a1, &v44, 1, 1, v48))
  {
    goto LABEL_27;
  }
  IndexType = mlir::Builder::getIndexType(v4, v5);
  if ((_DWORD)v45)
  {
    v7 = IndexType;
    v8 = (char *)v44;
    v9 = 32 * v45;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v8, v7, (uint64_t)a2 + 16))
    {
      v8 += 32;
      v9 -= 32;
      if (!v9)
        goto LABEL_8;
    }
LABEL_27:
    v28 = 0;
    goto LABEL_28;
  }
LABEL_8:
  v41 = v43;
  v42 = 0x400000000;
  v40[8] = 257;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "to", 2, &v38)&& (*(unsigned __int8 (**)(uint64_t, void **, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 688))(a1, &v41, 1, 1, v48))
  {
    v11 = mlir::Builder::getIndexType(v4, v10);
    if (!(_DWORD)v42)
    {
LABEL_14:
      v38 = v40;
      v39 = 0x400000000;
      v37[8] = 257;
      if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "step", 4, &v35)&& (*(unsigned __int8 (**)(uint64_t, void **, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 688))(a1, &v38, 1, 1, v48))
      {
        v16 = mlir::Builder::getIndexType(v4, v15);
        if ((_DWORD)v39)
        {
          v17 = v16;
          v18 = (char *)v38;
          v19 = 32 * v39;
          while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v18, v17, (uint64_t)a2 + 16))
          {
            v18 += 32;
            v19 -= 32;
            if (!v19)
              goto LABEL_20;
          }
          v28 = 0;
        }
        else
        {
LABEL_20:
          v35 = v37;
          v36 = 0x400000000;
          if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "init", 4)&& !(*(unsigned __int8 (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v35, 1, 1, 0xFFFFFFFFLL))
          {
            goto LABEL_45;
          }
          v20 = (uint64_t)a2 + 64;
          if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 536))(a1, (uint64_t)a2 + 64))
            goto LABEL_45;
          v21 = mlir::OperationState::addRegion(a2);
          v23 = (_QWORD *)v21;
          v24 = v47;
          if ((_DWORD)v48)
          {
            v33 = (_QWORD *)v21;
            v25 = (unint64_t)v48 << 6;
            v26 = (uint64_t *)((char *)v47 + 32);
            do
            {
              *v26 = mlir::Builder::getIndexType(v4, v22);
              v26 += 8;
              v25 -= 64;
            }
            while (v25);
            v24 = v47;
            v27 = v48;
            v23 = v33;
            v20 = (uint64_t)a2 + 64;
          }
          else
          {
            v27 = 0;
          }
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, void *, uint64_t, _QWORD))(*(_QWORD *)a1 + 744))(a1, v23, v24, v27, 0)&& (v34[0] = v45, v34[1] = v42, v34[2] = v39, v34[3] = v36, DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(v4, (uint64_t)v34, 4), mlir::OperationState::addAttribute(a2, (uint64_t)"operandSegmentSizes", 19, DenseI32ArrayAttr), (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, (uint64_t)a2 + 112))&& (v32 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1), mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v35, v20, v32, (uint64_t)a2 + 16)))
          {
            mlir::impl::ensureRegionTerminator(v23, v4, *(_QWORD *)a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::buildTerminator);
            v28 = 1;
          }
          else
          {
LABEL_45:
            v28 = 0;
          }
          if (v35 != v37)
            free(v35);
        }
      }
      else
      {
        v28 = 0;
      }
      if (v38 != v40)
        free(v38);
      goto LABEL_36;
    }
    v12 = v11;
    v13 = (char *)v41;
    v14 = 32 * v42;
    while ((*(unsigned __int8 (**)(uint64_t, char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v13, v12, (uint64_t)a2 + 16))
    {
      v13 += 32;
      v14 -= 32;
      if (!v14)
        goto LABEL_14;
    }
  }
  v28 = 0;
LABEL_36:
  if (v41 != v43)
    free(v41);
LABEL_28:
  if (v44 != v46)
    free(v44);
  v29 = v47;
  if (v47 != v49)
LABEL_31:
    free(v29);
  return v28;
}

uint64_t mlir::scf::ParallelOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _WORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  llvm::raw_ostream *v18;
  llvm::raw_ostream *v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  llvm::raw_ostream *v28;
  llvm::raw_ostream *v29;
  _QWORD *v30;
  unint64_t v31;
  int *v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  llvm::raw_ostream *v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  unint64_t v43;
  llvm::raw_ostream *v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  _WORD *v50;
  unint64_t v51;
  int *v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  llvm::raw_ostream *v61;
  llvm::raw_ostream *v62;
  _BYTE *v63;
  uint64_t v64;
  uint64_t v65;
  llvm::raw_ostream *v66;
  _BYTE *v67;
  mlir::Operation *v68;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v71;
  const char *AttrDictionary;
  uint64_t v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77[2];

  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_WORD *)*((_QWORD *)v4 + 4);
  if (*((_QWORD *)v4 + 3) - (_QWORD)v5 > 1uLL)
  {
    *v5 = 10272;
    *((_QWORD *)v4 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v4, " (", 2uLL);
  }
  v6 = *(_QWORD *)((((unint64_t)*this
                   + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)
                   + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)*this + 10)
                 + 8);
  if (v6)
    v7 = v6 - 8;
  else
    v7 = 0;
  v8 = *(_QWORD **)(v7 + 48);
  v9 = *(_QWORD *)(v7 + 56);
  v10 = (*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = v9 - (_QWORD)v8;
  if (v11)
  {
    v12 = (llvm::raw_ostream *)v10;
    (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *v8);
    if (v11 != 8)
    {
      v46 = v11 >> 3;
      v47 = v8 + 1;
      v48 = 8 * v46 - 8;
      do
      {
        v50 = (_WORD *)*((_QWORD *)v12 + 4);
        if (*((_QWORD *)v12 + 3) - (_QWORD)v50 > 1uLL)
        {
          *v50 = 8236;
          *((_QWORD *)v12 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v12, ", ", 2uLL);
        }
        v49 = *v47++;
        (*(void (**)(mlir::OpAsmPrinter *, uint64_t))(*(_QWORD *)a2 + 160))(a2, v49);
        v48 -= 8;
      }
      while (v48);
    }
  }
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v14 = *((_QWORD *)v13 + 4);
  if ((unint64_t)(*((_QWORD *)v13 + 3) - v14) > 4)
  {
    *(_BYTE *)(v14 + 4) = 40;
    *(_DWORD *)v14 = 540876841;
    *((_QWORD *)v13 + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(v13, ") = (", 5uLL);
  }
  v15 = *((unsigned int *)*this + 11);
  v16 = *((unsigned int *)*this + 4 * ((v15 >> 23) & 1) + 16);
  if ((v15 & 0x800000) != 0)
    v17 = *((_QWORD *)*this + 9);
  else
    v17 = 0;
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  AttrDictionary = ", ";
  v74 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v17, 0, v17, v16, (uint64_t)a2, v18, (uint64_t)&AttrDictionary);
  v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v20 = *((_QWORD *)v19 + 4);
  if ((unint64_t)(*((_QWORD *)v19 + 3) - v20) > 5)
  {
    *(_WORD *)(v20 + 4) = 10272;
    *(_DWORD *)v20 = 1869881385;
    *((_QWORD *)v19 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v19, ") to (", 6uLL);
  }
  v21 = *((unsigned int *)*this + 11);
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v22 = (unsigned int *)((char *)*this + 16 * ((v21 >> 23) & 1) + 64);
  else
    v22 = 0;
  v23 = *v22;
  v24 = v22[1];
  if ((v21 & 0x800000) != 0)
    v25 = *((_QWORD *)*this + 9);
  else
    v25 = 0;
  v26 = v25 + 32 * v23;
  v27 = v24 + v23 - v23;
  v28 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  AttrDictionary = ", ";
  v74 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v26, 0, v26, v27, (uint64_t)a2, v28, (uint64_t)&AttrDictionary);
  v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v30 = (_QWORD *)*((_QWORD *)v29 + 4);
  if (*((_QWORD *)v29 + 3) - (_QWORD)v30 > 7uLL)
  {
    *v30 = 0x2820706574732029;
    *((_QWORD *)v29 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v29, ") step (", 8uLL);
  }
  v31 = *((unsigned int *)*this + 11);
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v32 = (int *)((char *)*this + 16 * ((v31 >> 23) & 1) + 64);
  else
    v32 = 0;
  v33 = *v32;
  v34 = v32[1];
  v35 = v32[2];
  if ((v31 & 0x800000) != 0)
    v36 = *((_QWORD *)*this + 9);
  else
    v36 = 0;
  v37 = (v34 + v33);
  v38 = v36 + 32 * v37;
  v39 = (v35 + v37) - v37;
  v40 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  AttrDictionary = ", ";
  v74 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v38, 0, v38, v39, (uint64_t)a2, v40, (uint64_t)&AttrDictionary);
  v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v42 = (_BYTE *)*((_QWORD *)v41 + 4);
  if (*((_BYTE **)v41 + 3) == v42)
  {
    llvm::raw_ostream::write(v41, ")", 1uLL);
  }
  else
  {
    *v42 = 41;
    ++*((_QWORD *)v41 + 4);
  }
  v43 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v43 = 0;
  if (*(_DWORD *)(v43 + 12))
  {
    v44 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v45 = (_DWORD *)*((_QWORD *)v44 + 4);
    if (*((_QWORD *)v44 + 3) - (_QWORD)v45 > 6uLL)
    {
      *(_DWORD *)((char *)v45 + 3) = 673215593;
      *v45 = 1768843552;
      *((_QWORD *)v44 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v44, " init (", 7uLL);
    }
    v51 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v52 = (int *)((char *)*this + 16 * ((v51 >> 23) & 1) + 64);
    else
      v52 = 0;
    v53 = *v52;
    v54 = v52[1];
    v56 = v52[2];
    v55 = v52[3];
    if ((v51 & 0x800000) != 0)
      v57 = *((_QWORD *)*this + 9);
    else
      v57 = 0;
    v58 = (v54 + v53 + v56);
    v59 = v57 + 32 * v58;
    v60 = (v55 + v58) - v58;
    v61 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    AttrDictionary = ", ";
    v74 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v59, 0, v59, v60, (uint64_t)a2, v61, (uint64_t)&AttrDictionary);
    v62 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v63 = (_BYTE *)*((_QWORD *)v62 + 4);
    if (*((_BYTE **)v62 + 3) == v63)
    {
      llvm::raw_ostream::write(v62, ")", 1uLL);
    }
    else
    {
      *v63 = 41;
      ++*((_QWORD *)v62 + 4);
    }
  }
  v64 = *((unsigned int *)*this + 9);
  v65 = (uint64_t)*this - 16;
  if (!(_DWORD)v64)
    v65 = 0;
  v77[0] = v65;
  v77[1] = v64;
  mlir::OperandRange::getTypes(v77, (uint64_t *)&AttrDictionary);
  if (AttrDictionary != v75 || v74 != v76)
    mlir::AsmPrinter::printArrowTypeList<mlir::ValueTypeRange<mlir::ResultRange> &>((uint64_t)a2, (uint64_t *)&AttrDictionary);
  v66 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v67 = (_BYTE *)*((_QWORD *)v66 + 4);
  if ((unint64_t)v67 >= *((_QWORD *)v66 + 3))
  {
    llvm::raw_ostream::write(v66, 32);
  }
  else
  {
    *((_QWORD *)v66 + 4) = v67 + 1;
    *v67 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)a2 + 224))(a2, (((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), 0, 1, 0);
  v68 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = (const char *)mlir::Operation::getAttrDictionary(v68);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v68 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  AttrDictionary = "operandSegmentSizes";
  v74 = 19;
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, const char **, uint64_t))(*(_QWORD *)a2 + 192))(a2, Value, v71, &AttrDictionary, 1);
}

void mlir::scf::ParallelOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  unint64_t v73;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"scf.parallel", 12, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v4 = &off_24BFF2EF8;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::ParallelOpSingleOrZeroIterationDimsFolder]";
  v73 = 114;
  v9 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v9)
    v10 = v9;
  else
    v10 = v73;
  v11 = &v72[v10];
  v12 = v73 - v10;
  if (v73 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v73 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_78;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_79;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_82;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_82:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v72, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"scf.parallel", 12, (__int16)v72, a2, 0, 0);
  *(_QWORD *)v38 = &off_24BFF2BE0;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v72 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::MergeNestedParallelLoops]";
  v73 = 97;
  v43 = llvm::StringRef::find((uint64_t *)&v72, "DesiredTypeName = ", 0x12uLL, 0);
  if (v73 >= v43)
    v44 = v43;
  else
    v44 = v73;
  v45 = &v72[v44];
  v46 = v73 - v44;
  if (v73 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v73 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
LABEL_78:
    abort();
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (!v54)
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
    goto LABEL_74;
  }
  if (v54 >> 61)
LABEL_79:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v55 = (char *)operator new(8 * v54);
  v56 = (uint64_t *)&v55[8 * v51];
  v57 = &v55[8 * v54];
  *v56 = v38;
  v42 = (uint64_t)(v56 + 1);
  v58 = (char *)(v41 - v50);
  if (v41 != v50)
  {
LABEL_62:
    v59 = (unint64_t)(v58 - 8);
    if (v59 < 0x78
      || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
      && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
    {
      goto LABEL_83;
    }
    v60 = (v59 >> 3) + 1;
    v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
    v62 = &v41[-v61];
    v56 = (uint64_t *)((char *)v56 - v61);
    v63 = &v55[8 * v51 - 16];
    v64 = v41 - 16;
    v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v67 = *((_OWORD *)v64 - 1);
      v66 = *(_OWORD *)v64;
      *((_OWORD *)v64 - 1) = 0uLL;
      *(_OWORD *)v64 = 0uLL;
      *((_OWORD *)v63 - 1) = v67;
      *(_OWORD *)v63 = v66;
      v63 -= 32;
      v64 -= 32;
      v65 -= 4;
    }
    while (v65);
    v41 = v62;
    if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_83:
      do
      {
        v68 = *((_QWORD *)v41 - 1);
        v41 -= 8;
        *(_QWORD *)v41 = 0;
        *--v56 = v68;
      }
      while (v41 != v50);
    }
    v41 = (char *)a1[1];
    v69 = (char *)a1[2];
    a1[1] = v56;
    a1[2] = v42;
    a1[3] = v57;
    while (v69 != v41)
    {
      v71 = *((_QWORD *)v69 - 1);
      v69 -= 8;
      v70 = v71;
      *(_QWORD *)v69 = 0;
      if (v71)
        (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
    }
    goto LABEL_75;
  }
LABEL_74:
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
}

uint64_t mlir::scf::ReduceOp::verifyRegions(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v40;
  unint64_t v41;
  int64_t v42;
  int64_t v43;
  const void **v44[4];
  __int16 v45;
  int v46;
  const char *v47;
  uint64_t v48;
  _QWORD v49[3];
  void *v50;
  unsigned int v51;
  unsigned int v52;
  _BYTE v53[96];
  void *v54;
  _QWORD *v55;
  void *__p;
  _QWORD *v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = *(_QWORD *)((((unint64_t)*this + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8) + 87) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)*this + 10)
                 + 8);
  if (v3)
    v4 = v3 - 8;
  else
    v4 = 0;
  if (*(_QWORD *)(v4 + 32) == v4 + 32)
  {
    v44[0] = (const void **)"the block inside reduce should not be empty";
    v45 = 259;
    mlir::OpState::emitOpError(this, v44, (uint64_t)v49);
    v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v49);
    if (v49[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v49);
    if (v58)
    {
      v33 = __p;
      if (__p)
      {
        v34 = v57;
        v35 = __p;
        if (v57 != __p)
        {
          do
            v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          v35 = __p;
        }
        v57 = v33;
        operator delete(v35);
      }
      v14 = v54;
      if (!v54)
        goto LABEL_60;
      v36 = v55;
      v16 = v54;
      if (v55 == v54)
        goto LABEL_59;
      do
      {
        v38 = *--v36;
        v37 = v38;
        *v36 = 0;
        if (v38)
          MEMORY[0x20BD002D4](v37, 0x1000C8077774924);
      }
      while (v36 != v14);
      goto LABEL_58;
    }
    return v10;
  }
  v5 = *(_QWORD *)(*(_QWORD *)(v2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(v4 + 48);
  v7 = *(_QWORD *)(v4 + 56);
  if (((v7 - v6) & 0x7FFFFFFF8) != 0x10)
    goto LABEL_25;
  if (v7 != v6)
  {
    v8 = 8 * ((v7 - v6) >> 3);
    while (v5 == (*(_QWORD *)(*(_QWORD *)v6 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v6 += 8;
      v8 -= 8;
      if (!v8)
        goto LABEL_10;
    }
LABEL_25:
    v45 = 257;
    mlir::OpState::emitOpError(this, v44, (uint64_t)v49);
    if (v49[0])
    {
      v46 = 3;
      v47 = "expects two arguments to reduce block of type ";
      v48 = 46;
      v19 = &v46;
      v20 = (char *)v50;
      if (v51 >= v52)
      {
        v40 = v51 + 1;
        if (v50 <= &v46 && (char *)v50 + 24 * v51 > (char *)&v46)
        {
          v42 = (char *)&v46 - (_BYTE *)v50;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v40, 24);
          v20 = (char *)v50;
          v19 = (int *)((char *)v50 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v40, 24);
          v19 = &v46;
          v20 = (char *)v50;
        }
      }
      v21 = &v20[24 * v51];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      ++v51;
      if (v49[0])
      {
        v23 = &v46;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v46, v5);
        v24 = (char *)v50;
        if (v51 >= v52)
        {
          v41 = v51 + 1;
          if (v50 <= &v46 && (char *)v50 + 24 * v51 > (char *)&v46)
          {
            v43 = (char *)&v46 - (_BYTE *)v50;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v41, 24);
            v24 = (char *)v50;
            v23 = (int *)((char *)v50 + v43);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v41, 24);
            v23 = &v46;
            v24 = (char *)v50;
          }
        }
        v25 = &v24[24 * v51];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v51;
      }
    }
    v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v49);
    if (v49[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v49);
    if (v58)
    {
      v27 = __p;
      if (__p)
      {
        v28 = v57;
        v29 = __p;
        if (v57 != __p)
        {
          do
            v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
          while (v28 != v27);
          v29 = __p;
        }
        v57 = v27;
        operator delete(v29);
      }
      v14 = v54;
      if (!v54)
        goto LABEL_60;
      v30 = v55;
      v16 = v54;
      if (v55 == v54)
        goto LABEL_59;
      do
      {
        v32 = *--v30;
        v31 = v32;
        *v30 = 0;
        if (v32)
          MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
      }
      while (v30 != v14);
      goto LABEL_58;
    }
    return v10;
  }
LABEL_10:
  mlir::Block::getTerminator((ZinIrHalH13g **)v4);
  if (*(_UNKNOWN **)(*(_QWORD *)(v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ReduceReturnOp,void>::id)
    return 1;
  v44[0] = (const void **)"the block inside reduce should be terminated with a 'scf.reduce.return' op";
  v45 = 259;
  mlir::OpState::emitOpError(this, v44, (uint64_t)v49);
  v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v49);
  if (v49[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v49);
  if (v58)
  {
    v11 = __p;
    if (__p)
    {
      v12 = v57;
      v13 = __p;
      if (v57 != __p)
      {
        do
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        v13 = __p;
      }
      v57 = v11;
      operator delete(v13);
    }
    v14 = v54;
    if (!v54)
      goto LABEL_60;
    v15 = v55;
    v16 = v54;
    if (v55 == v54)
    {
LABEL_59:
      v55 = v14;
      operator delete(v16);
LABEL_60:
      if (v50 != v53)
        free(v50);
      return v10;
    }
    do
    {
      v18 = *--v15;
      v17 = v18;
      *v15 = 0;
      if (v18)
        MEMORY[0x20BD002D4](v17, 0x1000C8077774924);
    }
    while (v15 != v14);
LABEL_58:
    v16 = v54;
    goto LABEL_59;
  }
  return v10;
}

BOOL mlir::scf::ReduceOp::parse(uint64_t a1, mlir::OperationState *a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[4];

  memset(v7, 0, 24);
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v7, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    return 0;
  v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 544))(a1, &v6)
    || !(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v7, v6, (uint64_t)a2 + 16))
  {
    return 0;
  }
  v4 = mlir::OperationState::addRegion(a2);
  return (*(unsigned __int8 (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, 0, 0, 0) != 0;
}

uint64_t mlir::scf::ReduceOp::print(mlir::scf::ReduceOp *this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _WORD *v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;

  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "(", 1uLL);
  }
  else
  {
    *v5 = 40;
    ++*((_QWORD *)v4 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_WORD *)*((_QWORD *)v6 + 4);
  if (*((_QWORD *)v6 + 3) - (_QWORD)v7 > 1uLL)
  {
    *v7 = 8233;
    *((_QWORD *)v6 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v6, ") ", 2uLL);
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = *((_QWORD *)v8 + 4);
  if ((unint64_t)(*((_QWORD *)v8 + 3) - v9) > 2)
  {
    *(_BYTE *)(v9 + 2) = 32;
    *(_WORD *)v9 = 14880;
    *((_QWORD *)v8 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v8, " : ", 3uLL);
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, unint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a2 + 224))(a2, ((*(_QWORD *)this+ 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(*(_QWORD *)this + 40), 1, 1, 0);
}

uint64_t mlir::scf::ReduceReturnOp::verify(uint64_t **this)
{
  unint64_t v2;
  int *v3;
  char *v4;
  char *v5;
  __int128 v6;
  int *v7;
  char *v8;
  char *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  BOOL v29;
  int64_t v30;
  int64_t v31;
  int64_t v32;
  const void **v33;
  __int16 v34;
  int v35;
  const char *v36;
  uint64_t v37;
  _QWORD v38[3];
  void *v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE v42[96];
  void *v43;
  _QWORD *v44;
  void *__p;
  _QWORD *v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(mlir::Block::getParentOp((mlir::Block *)(*this)[2]) + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v2 == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
    return 1;
  v34 = 257;
  mlir::OpState::emitOpError(this, &v33, (uint64_t)v38);
  if (v38[0])
  {
    v35 = 3;
    v36 = "needs to have type ";
    v37 = 19;
    v3 = &v35;
    v4 = (char *)v39;
    if (v40 >= v41)
    {
      v26 = v40 + 1;
      if (v39 <= &v35 && (char *)v39 + 24 * v40 > (char *)&v35)
      {
        v30 = (char *)&v35 - (_BYTE *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v4 = (char *)v39;
        v3 = (int *)((char *)v39 + v30);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v3 = &v35;
        v4 = (char *)v39;
      }
    }
    v5 = &v4[24 * v40];
    v6 = *(_OWORD *)v3;
    *((_QWORD *)v5 + 2) = *((_QWORD *)v3 + 2);
    *(_OWORD *)v5 = v6;
    ++v40;
    if (v38[0])
    {
      v7 = &v35;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v35, v2);
      v8 = (char *)v39;
      if (v40 >= v41)
      {
        v27 = v40 + 1;
        if (v39 <= &v35 && (char *)v39 + 24 * v40 > (char *)&v35)
        {
          v31 = (char *)&v35 - (_BYTE *)v39;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v27, 24);
          v8 = (char *)v39;
          v7 = (int *)((char *)v39 + v31);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v27, 24);
          v7 = &v35;
          v8 = (char *)v39;
        }
      }
      v9 = &v8[24 * v40];
      v10 = *(_OWORD *)v7;
      *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
      *(_OWORD *)v9 = v10;
      v11 = ++v40;
      if (v38[0])
      {
        v35 = 3;
        v36 = " (the type of the enclosing ReduceOp)";
        v37 = 37;
        v12 = &v35;
        v13 = (char *)v39;
        if (v11 >= v41)
        {
          v28 = v11 + 1;
          v29 = (char *)v39 + 24 * v11 > (char *)&v35;
          if (v39 <= &v35 && v29)
          {
            v32 = (char *)&v35 - (_BYTE *)v39;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v28, 24);
            v13 = (char *)v39;
            v12 = (int *)((char *)v39 + v32);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v28, 24);
            v12 = &v35;
            v13 = (char *)v39;
          }
        }
        v14 = &v13[24 * v40];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        ++v40;
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v38);
  if (v38[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  if (v47)
  {
    v17 = __p;
    if (__p)
    {
      v18 = v46;
      v19 = __p;
      if (v46 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v46 = v17;
      operator delete(v19);
    }
    v20 = v43;
    if (v43)
    {
      v21 = v44;
      v22 = v43;
      if (v44 != v43)
      {
        do
        {
          v24 = *--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
            MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
        }
        while (v21 != v20);
        v22 = v43;
      }
      v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42)
      free(v39);
  }
  return v16;
}

void mlir::scf::WhileOp::build(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, void (*a7)(uint64_t, uint64_t, unint64_t, unint64_t, unint64_t), uint64_t a8, void (*a9)(uint64_t, uint64_t, unint64_t, unint64_t, unint64_t), uint64_t a10)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  __int128 v21;
  uint64_t v22;
  uint64_t Loc;
  uint64_t v24;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t Block;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  int64x2_t v35;
  int64x2_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  __int128 v42;
  uint64_t v43;
  unint64_t v44[2];
  __n128 v45;
  _QWORD v46[4];
  unint64_t v47[2];
  __n128 v48;
  uint64_t v49;
  unint64_t v50[2];
  void *v51;
  uint64_t v52;
  _BYTE v53[32];
  __n128 v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v54.n128_u64[0] = a5;
  v54.n128_u64[1] = a6;
  mlir::OperationState::addOperands(a2, a5, a6);
  v17 = *(unsigned int *)(a2 + 72);
  if (a4 + v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v17, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if (a4)
  {
    v18 = 0;
    v19 = *(_QWORD *)(a2 + 64) + 8 * v17;
    do
    {
      *(_QWORD *)(v19 + 8 * v18) = mlir::TypeRange::dereference_iterator(a3, v18);
      ++v18;
    }
    while (a4 != v18);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + a4;
  v20 = (_OWORD *)(a1 + 16);
  v21 = *(_OWORD *)(a1 + 16);
  v51 = v53;
  v52 = 0x400000000;
  v42 = v21;
  if (a6 < 5)
  {
    v45 = (__n128)(unint64_t)a5;
    if (!a6)
      goto LABEL_18;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, a6, 8);
    v45 = (__n128)(unint64_t)a5;
  }
  v22 = 0;
  do
  {
    v43 = mlir::ValueRange::dereference_iterator(&v45, v22);
    Loc = mlir::Value::getLoc((mlir::Value *)&v43);
    v24 = v52;
    if (v52 >= (unint64_t)HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 8);
      v24 = v52;
    }
    *((_QWORD *)v51 + v24) = Loc;
    LODWORD(v52) = v52 + 1;
    v22 = ++v45.n128_u64[1];
  }
  while (v45.n128_u64[0] != a5 || v22 != a6);
LABEL_18:
  v26 = mlir::OperationState::addRegion((mlir::OperationState *)a2);
  mlir::ValueRange::getTypes(&v54, &v48);
  v28 = v48.n128_u64[1];
  v27 = v48.n128_u64[0];
  v29 = v49;
  v45 = v48;
  if (v48.n128_u64[1])
  {
    v27 = mlir::ValueRange::offset_base(&v45, v48.n128_i64[1]);
    v28 = v45.n128_u64[1];
  }
  mlir::TypeRange::TypeRange(v50, v27, v29 - v28);
  Block = mlir::OpBuilder::createBlock((_QWORD *)a1, v26, 0, v50[0], v50[1], (uint64_t)v51, v52);
  if (a7)
  {
    v31 = *(_QWORD *)a2;
    mlir::ValueRange::ValueRange(v47, *(_QWORD *)(Block + 48), (uint64_t)(*(_QWORD *)(Block + 56) - *(_QWORD *)(Block + 48)) >> 3);
    a7(a8, a1, v31, v47[0], v47[1]);
  }
  v45.n128_u64[0] = (unint64_t)v46;
  v45.n128_u64[1] = 0x400000000;
  v32 = *(_QWORD *)a2;
  if (a4 < 5)
  {
    if (a4)
    {
      v46[0] = *(_QWORD *)a2;
      if (a4 != 1)
      {
        v46[1] = v32;
        if (a4 != 2)
        {
          v46[2] = v32;
          if (a4 != 3)
            v46[3] = v32;
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v45, v46, a4, 8);
    v33 = (unint64_t *)(v45.n128_u64[0] + 8 * (a4 & 0xFFFFFFFFFFFFFFFCLL));
    v34 = a4 & 3;
    v35 = vdupq_n_s64(v32);
    v36 = (int64x2_t *)(v45.n128_u64[0] + 16);
    v37 = a4 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v36[-1] = v35;
      *v36 = v35;
      v36 += 2;
      v37 -= 4;
    }
    while (v37);
    if (a4 != (a4 & 0xFFFFFFFFFFFFFFFCLL))
    {
      do
      {
        *v33++ = v32;
        --v34;
      }
      while (v34);
    }
  }
  v45.n128_u32[2] = a4;
  v38 = mlir::OperationState::addRegion((mlir::OperationState *)a2);
  v39 = mlir::OpBuilder::createBlock((_QWORD *)a1, v38, 0, a3, a4, v45.n128_i64[0], v45.n128_u32[2]);
  if (a9)
  {
    v40 = *(_QWORD *)a2;
    mlir::ValueRange::ValueRange(v44, *(_QWORD *)(v39 + 48), (uint64_t)(*(_QWORD *)(v39 + 56) - *(_QWORD *)(v39 + 48)) >> 3);
    a9(a10, a1, v40, v44[0], v44[1]);
  }
  if ((_QWORD *)v45.n128_u64[0] != v46)
    free((void *)v45.n128_u64[0]);
  if (v51 != v53)
    free(v51);
  if ((_QWORD)v42)
  {
    *v20 = v42;
  }
  else
  {
    *(_QWORD *)v20 = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void mlir::scf::WhileOp::getSuccessorRegions(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  _QWORD *v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  unint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  _QWORD *v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  __int128 v30;
  char *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  __int128 v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  BOOL v39;
  char *v40;
  char *v41;
  _QWORD *v42;
  unint64_t v43[3];

  v43[2] = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 44);
  if (!a2)
  {
    v7 = (_QWORD *)(((v4 + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v4 + 40));
    if ((_QWORD *)*v7 == v7)
      goto LABEL_28;
    goto LABEL_17;
  }
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (_QWORD *)(((v4 + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v4 + 40));
    if (v7 + 3 == a2)
    {
      if ((_QWORD *)*v7 == v7)
      {
LABEL_28:
        v18 = 0;
        v19 = 0;
        v24 = *(_DWORD *)(a3 + 8);
        if (v24 >= *(_DWORD *)(a3 + 12))
        {
LABEL_29:
          v42 = v7;
          goto LABEL_30;
        }
LABEL_21:
        v25 = (_QWORD *)(*(_QWORD *)a3 + 24 * v24);
        *v25 = v7;
        v21 = v25 + 1;
        goto LABEL_22;
      }
LABEL_17:
      v22 = v7[1];
      if (v22)
        v23 = v22 - 8;
      else
        v23 = 0;
      v18 = *(_QWORD *)(v23 + 48);
      v19 = (*(_QWORD *)(v23 + 56) - v18) >> 3;
      v24 = *(_DWORD *)(a3 + 8);
      if (v24 >= *(_DWORD *)(a3 + 12))
        goto LABEL_29;
      goto LABEL_21;
    }
  }
  v8 = *(unsigned int *)(v4 + 36);
  if ((_DWORD)v8)
    v9 = v4 - 16;
  else
    v9 = 0;
  v10 = *(_DWORD *)(a3 + 8);
  if (v10 >= *(_DWORD *)(a3 + 12))
  {
    v42 = 0;
    v31 = (char *)&v42;
    mlir::ValueRange::ValueRange(v43, v9, v8);
    v32 = *(unsigned int *)(a3 + 8);
    v33 = *(_QWORD *)a3;
    if (v32 >= *(_DWORD *)(a3 + 12))
    {
      v38 = v32 + 1;
      v39 = v33 + 24 * v32 > (unint64_t)&v42;
      if (v33 <= (unint64_t)&v42 && v39)
      {
        v41 = (char *)&v43[-1] - v33;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v38, 24);
        v33 = *(_QWORD *)a3;
        v31 = &v41[*(_QWORD *)a3];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v38, 24);
        v33 = *(_QWORD *)a3;
        v31 = (char *)&v42;
      }
    }
    v34 = v33 + 24 * *(unsigned int *)(a3 + 8);
    v35 = *(_OWORD *)v31;
    *(_QWORD *)(v34 + 16) = *((_QWORD *)v31 + 2);
    *(_OWORD *)v34 = v35;
  }
  else
  {
    v11 = (_QWORD *)(*(_QWORD *)a3 + 24 * v10);
    *v11 = 0;
    mlir::ValueRange::ValueRange(v11 + 1, v9, v8);
  }
  v12 = *(_DWORD *)(a3 + 8) + 1;
  *(_DWORD *)(a3 + 8) = v12;
  v13 = *(unsigned int *)(*a1 + 44);
  if ((v13 & 0x7FFFFF) != 0)
  {
    v14 = ((*a1 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(*a1 + 40);
    v15 = v14 + 24;
    if (*(_QWORD *)(v14 + 24) != v14 + 24)
      goto LABEL_11;
LABEL_25:
    v18 = 0;
    v19 = 0;
    if (v12 < *(_DWORD *)(a3 + 12))
    {
LABEL_15:
      v20 = (uint64_t *)(*(_QWORD *)a3 + 24 * v12);
      *v20 = v15;
      v21 = (unint64_t *)(v20 + 1);
LABEL_22:
      mlir::ValueRange::ValueRange(v21, v18, v19);
      goto LABEL_23;
    }
    goto LABEL_26;
  }
  v14 = 0;
  v15 = 24;
  if (MEMORY[0x18] == 24)
    goto LABEL_25;
LABEL_11:
  v16 = *(_QWORD *)(v14 + 32);
  if (v16)
    v17 = v16 - 8;
  else
    v17 = 0;
  v18 = *(_QWORD *)(v17 + 48);
  v19 = (*(_QWORD *)(v17 + 56) - v18) >> 3;
  if (v12 < *(_DWORD *)(a3 + 12))
    goto LABEL_15;
LABEL_26:
  v42 = (_QWORD *)v15;
LABEL_30:
  v26 = (char *)&v42;
  mlir::ValueRange::ValueRange(v43, v18, v19);
  v27 = *(unsigned int *)(a3 + 8);
  v28 = *(_QWORD *)a3;
  if (v27 >= *(_DWORD *)(a3 + 12))
  {
    v36 = v27 + 1;
    v37 = v28 + 24 * v27 > (unint64_t)&v42;
    if (v28 <= (unint64_t)&v42 && v37)
    {
      v40 = (char *)&v43[-1] - v28;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v36, 24);
      v28 = *(_QWORD *)a3;
      v26 = &v40[*(_QWORD *)a3];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v36, 24);
      v28 = *(_QWORD *)a3;
      v26 = (char *)&v42;
    }
  }
  v29 = v28 + 24 * *(unsigned int *)(a3 + 8);
  v30 = *(_OWORD *)v26;
  *(_QWORD *)(v29 + 16) = *((_QWORD *)v26 + 2);
  *(_OWORD *)v29 = v30;
LABEL_23:
  ++*(_DWORD *)(a3 + 8);
}

uint64_t mlir::scf::WhileOp::parse(uint64_t a1, mlir::OperationState *this)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  BOOL v7;
  uint64_t v8;
  const void *Results;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  unint64_t v14;
  int Kind;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Inputs;
  uint64_t v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  char *v33;
  char *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  char *v38;
  char *v39;
  __int128 v40;
  unsigned int v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  char *v48;
  char *v49;
  __int128 v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  int64_t v75;
  int64_t v76;
  char v77[32];
  __int16 v78;
  uint64_t v79;
  int v80;
  const char *v81;
  uint64_t v82;
  _QWORD v83[3];
  void *v84;
  unsigned int v85;
  unsigned int v86;
  _BYTE v87[96];
  void *v88;
  _QWORD *v89;
  void *__p;
  _QWORD *v91;
  char v92;
  void *v93;
  uint64_t v94;
  _BYTE v95[128];
  void *v96;
  uint64_t v97;
  _QWORD v98[34];

  v98[32] = *MEMORY[0x24BDAC8D0];
  v96 = v98;
  v97 = 0x400000000;
  v93 = v95;
  v94 = 0x400000000;
  v4 = mlir::OperationState::addRegion(this);
  v5 = mlir::OperationState::addRegion(this);
  v6 = (*(uint64_t (**)(uint64_t, void **, void **))(*(_QWORD *)a1 + 792))(a1, &v96, &v93);
  v7 = v6 >= 0x100u && v6 == 0;
  if (v7
    || (v79 = 0,
        v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        !mlir::AsmParser::parseColonType<mlir::FunctionType>(a1, &v79)))
  {
LABEL_53:
    v51 = 0;
    goto LABEL_54;
  }
  Results = (const void *)mlir::FunctionType::getResults((mlir::FunctionType *)&v79);
  v11 = v10;
  v12 = 8 * v10;
  v13 = *((unsigned int *)this + 18);
  v14 = v13 + ((8 * v10) >> 3);
  if (v14 > *((unsigned int *)this + 19))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 64, (char *)this + 80, v14, 8);
    LODWORD(v13) = *((_DWORD *)this + 18);
  }
  if (v11)
  {
    memcpy((void *)(*((_QWORD *)this + 8) + 8 * v13), Results, v12);
    LODWORD(v13) = *((_DWORD *)this + 18);
  }
  *((_DWORD *)this + 18) = v13 + (v12 >> 3);
  Kind = mlir::AffineExpr::getKind((mlir::AffineExpr *)&v79);
  if ((_DWORD)v94 == Kind)
  {
    v83[0] = mlir::FunctionType::getInputs((mlir::FunctionType *)&v79);
    v83[1] = v16;
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    if (mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)&v93, v83, v17, (uint64_t)this + 16))
    {
      if ((_DWORD)v97)
      {
        v18 = 0;
        v19 = 8 * v97;
        do
        {
          Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&v79);
          *((_QWORD *)v96 + v18 + 4) = *(_QWORD *)(Inputs + v18);
          v18 += 8;
        }
        while (v19 != v18);
        v21 = v97;
      }
      else
      {
        v21 = 0;
      }
      if ((*(unsigned __int8 (**)(uint64_t, uint64_t, void *, uint64_t, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, v96, v21, 0))
      {
        LOWORD(v85) = 257;
        if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "do", 2, v83))
        {
          if ((*(unsigned __int8 (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v5, 0, 0, 0))
          {
            v51 = (*(unsigned __int8 (**)(uint64_t, char *))(*(_QWORD *)a1 + 464))(a1, (char *)this + 112) != 0;
            goto LABEL_54;
          }
        }
      }
    }
    goto LABEL_53;
  }
  v78 = 257;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)a1 + 24))(v83, a1, v8, v77);
  if (v83[0])
  {
    v80 = 3;
    v81 = "expected as many input types as operands ";
    v82 = 41;
    v22 = &v80;
    v23 = (char *)v84;
    if (v85 >= v86)
    {
      v61 = v85 + 1;
      if (v84 <= &v80 && (char *)v84 + 24 * v85 > (char *)&v80)
      {
        v71 = (char *)&v80 - (_BYTE *)v84;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v61, 24);
        v23 = (char *)v84;
        v22 = (int *)((char *)v84 + v71);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v61, 24);
        v22 = &v80;
        v23 = (char *)v84;
      }
    }
    v24 = &v23[24 * v85];
    v25 = *(_OWORD *)v22;
    *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
    *(_OWORD *)v24 = v25;
    v26 = ++v85;
    if (v83[0])
    {
      v80 = 3;
      v81 = "(expected ";
      v82 = 10;
      v27 = &v80;
      v28 = (char *)v84;
      if (v26 >= v86)
      {
        v63 = v26 + 1;
        v64 = (char *)v84 + 24 * v26 > (char *)&v80;
        if (v84 <= &v80 && v64)
        {
          v73 = (char *)&v80 - (_BYTE *)v84;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v63, 24);
          v28 = (char *)v84;
          v27 = (int *)((char *)v84 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v63, 24);
          v27 = &v80;
          v28 = (char *)v84;
        }
      }
      v29 = &v28[24 * v85];
      v30 = *(_OWORD *)v27;
      *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
      *(_OWORD *)v29 = v30;
      v31 = ++v85;
      if (v83[0])
      {
        v80 = 5;
        v81 = (const char *)v94;
        v32 = &v80;
        v33 = (char *)v84;
        if (v31 >= v86)
        {
          v67 = v31 + 1;
          v68 = (char *)v84 + 24 * v31 > (char *)&v80;
          if (v84 <= &v80 && v68)
          {
            v75 = (char *)&v80 - (_BYTE *)v84;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v67, 24);
            v33 = (char *)v84;
            v32 = (int *)((char *)v84 + v75);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v67, 24);
            v32 = &v80;
            v33 = (char *)v84;
          }
        }
        v34 = &v33[24 * v85];
        v35 = *(_OWORD *)v32;
        *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
        *(_OWORD *)v34 = v35;
        v36 = ++v85;
        if (v83[0])
        {
          v80 = 3;
          v81 = " got ";
          v82 = 5;
          v37 = &v80;
          v38 = (char *)v84;
          if (v36 >= v86)
          {
            v69 = v36 + 1;
            v70 = (char *)v84 + 24 * v36 > (char *)&v80;
            if (v84 <= &v80 && v70)
            {
              v76 = (char *)&v80 - (_BYTE *)v84;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v69, 24);
              v38 = (char *)v84;
              v37 = (int *)((char *)v84 + v76);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v69, 24);
              v37 = &v80;
              v38 = (char *)v84;
            }
          }
          v39 = &v38[24 * v85];
          v40 = *(_OWORD *)v37;
          *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
          *(_OWORD *)v39 = v40;
          ++v85;
        }
      }
    }
  }
  v41 = mlir::AffineExpr::getKind((mlir::AffineExpr *)&v79);
  if (v83[0])
  {
    v80 = 5;
    v81 = (const char *)v41;
    v42 = &v80;
    v43 = (char *)v84;
    if (v85 >= v86)
    {
      v62 = v85 + 1;
      if (v84 <= &v80 && (char *)v84 + 24 * v85 > (char *)&v80)
      {
        v72 = (char *)&v80 - (_BYTE *)v84;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v62, 24);
        v43 = (char *)v84;
        v42 = (int *)((char *)v84 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v62, 24);
        v42 = &v80;
        v43 = (char *)v84;
      }
    }
    v44 = &v43[24 * v85];
    v45 = *(_OWORD *)v42;
    *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
    *(_OWORD *)v44 = v45;
    v46 = ++v85;
    if (v83[0])
    {
      v80 = 3;
      v81 = ")";
      v82 = 1;
      v47 = &v80;
      v48 = (char *)v84;
      if (v46 >= v86)
      {
        v65 = v46 + 1;
        v66 = (char *)v84 + 24 * v46 > (char *)&v80;
        if (v84 <= &v80 && v66)
        {
          v74 = (char *)&v80 - (_BYTE *)v84;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v65, 24);
          v48 = (char *)v84;
          v47 = (int *)((char *)v84 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v65, 24);
          v47 = &v80;
          v48 = (char *)v84;
        }
      }
      v49 = &v48[24 * v85];
      v50 = *(_OWORD *)v47;
      *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
      *(_OWORD *)v49 = v50;
      ++v85;
    }
  }
  v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v83);
  if (v83[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v83);
  if (v92)
  {
    v52 = __p;
    if (__p)
    {
      v53 = v91;
      v54 = __p;
      if (v91 != __p)
      {
        do
          v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
        while (v53 != v52);
        v54 = __p;
      }
      v91 = v52;
      operator delete(v54);
    }
    v55 = v88;
    if (v88)
    {
      v56 = v89;
      v57 = v88;
      if (v89 != v88)
      {
        do
        {
          v59 = *--v56;
          v58 = v59;
          *v56 = 0;
          if (v59)
            MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
        }
        while (v56 != v55);
        v57 = v88;
      }
      v89 = v55;
      operator delete(v57);
    }
    if (v84 != v87)
      free(v84);
  }
LABEL_54:
  if (v93 != v95)
    free(v93);
  if (v96 != v98)
    free(v96);
  return v51;
}

uint64_t mlir::AsmParser::parseColonType<mlir::FunctionType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 544))(a1, &v18))
    return 0;
  v5 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v19, a1, v4, &v16);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

uint64_t mlir::scf::WhileOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  mlir::Operation *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  llvm::raw_ostream *v12;
  uint64_t v13;
  mlir::Operation *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  llvm::raw_ostream *v19;
  _BYTE *v20;
  llvm::raw_ostream *v21;
  _DWORD *v22;
  mlir::Operation *v23;
  unint64_t v24;
  unint64_t v25;
  mlir::Operation *v26;
  mlir::ArrayAttr *v27;
  uint64_t Value;
  uint64_t v29;
  uint64_t v31[2];
  uint64_t v32[4];
  uint64_t v33[2];
  uint64_t v34[4];
  unint64_t v35[3];

  v35[2] = *MEMORY[0x24BDAC8D0];
  v4 = *this;
  v5 = *((unsigned int *)*this + 11);
  v6 = *(_QWORD *)((((unint64_t)*this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)*this + 10)
                 + 8);
  if (v6)
    v7 = v6 - 8;
  else
    v7 = 0;
  v8 = *(_QWORD **)(v7 + 48);
  v9 = (uint64_t)(*(_QWORD *)(v7 + 56) - (_QWORD)v8) >> 3;
  if ((v5 & 0x800000) != 0)
  {
    v10 = *((unsigned int *)v4 + 17);
    v11 = *((_QWORD *)v4 + 9);
  }
  else
  {
    v11 = 0;
    v10 = 0;
  }
  mlir::ValueRange::ValueRange(v35, v11, v10);
  printInitializationList(a2, v8, v9, v35[0], v35[1], " ", 1uLL);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = *((_QWORD *)v12 + 4);
  if ((unint64_t)(*((_QWORD *)v12 + 3) - v13) > 2)
  {
    *(_BYTE *)(v13 + 2) = 32;
    *(_WORD *)v13 = 14880;
    *((_QWORD *)v12 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v12, " : ", 3uLL);
  }
  v14 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v15 = *((unsigned int *)v14 + 17);
    v16 = *((_QWORD *)v14 + 9);
  }
  else
  {
    v16 = 0;
    v15 = 0;
  }
  v33[0] = v16;
  v33[1] = v15;
  mlir::OperandRange::getTypes(v33, v34);
  v17 = *((unsigned int *)*this + 9);
  v18 = (uint64_t)*this - 16;
  if (!(_DWORD)v17)
    v18 = 0;
  v31[0] = v18;
  v31[1] = v17;
  mlir::OperandRange::getTypes(v31, v32);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>((uint64_t)a2, v34, v32);
  v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v20 = (_BYTE *)*((_QWORD *)v19 + 4);
  if ((unint64_t)v20 >= *((_QWORD *)v19 + 3))
  {
    llvm::raw_ostream::write(v19, 32);
  }
  else
  {
    *((_QWORD *)v19 + 4) = v20 + 1;
    *v20 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)a2 + 224))(a2, (((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), 0, 1, 0);
  v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v22 = (_DWORD *)*((_QWORD *)v21 + 4);
  if (*((_QWORD *)v21 + 3) - (_QWORD)v22 > 3uLL)
  {
    *v22 = 544171040;
    *((_QWORD *)v21 + 4) += 4;
    v23 = *this;
    v24 = *((unsigned int *)*this + 11);
    if ((v24 & 0x7FFFFF) != 0)
      goto LABEL_18;
  }
  else
  {
    llvm::raw_ostream::write(v21, " do ", 4uLL);
    v23 = *this;
    v24 = *((unsigned int *)*this + 11);
    if ((v24 & 0x7FFFFF) != 0)
    {
LABEL_18:
      v25 = (((unint64_t)v23 + 16 * ((v24 >> 23) & 1) + ((v24 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *((unsigned int *)v23 + 10);
      goto LABEL_21;
    }
  }
  v25 = 0;
LABEL_21:
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a2 + 224))(a2, v25 + 24, 1, 1, 0);
  v26 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v34[0] = mlir::Operation::getAttrDictionary(v26);
    v27 = (mlir::ArrayAttr *)v34;
  }
  else
  {
    v27 = (mlir::Operation *)((char *)v26 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v27);
  return (*(uint64_t (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 200))(a2, Value, v29, 0, 0);
}

BOOL mlir::scf::WhileOp::verify(mlir::scf::WhileOp *this)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  const void ***v17;
  uint64_t v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v29;
  BOOL v30;
  char *v31;
  const void **v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  void *v40;
  _QWORD *v41;
  void *__p;
  _QWORD *v43;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)this;
  v3 = *(unsigned int *)(*(_QWORD *)this + 44);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (_QWORD *)(((v2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v2 + 40));
    if ((_QWORD *)*v4 == v4)
      goto LABEL_13;
  }
  else
  {
    v4 = 0;
    if (!MEMORY[0])
    {
LABEL_13:
      v9 = 0;
      goto LABEL_14;
    }
  }
  v5 = v4[1];
  if (v5)
    v6 = v5 - 8;
  else
    v6 = 0;
  v7 = *(ZinIrHalH13g **)(v6 + 32);
  if (v7 == (ZinIrHalH13g *)(v6 + 32))
    goto LABEL_13;
  ZinIrHalH13g::~ZinIrHalH13g(v7);
  v9 = v8;
  if (v8
    && *(_UNKNOWN **)(*(_QWORD *)(v8 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ConditionOp,void>::id)
  {
    v10 = *(_QWORD *)this;
    v11 = *(unsigned int *)(*(_QWORD *)this + 44);
    if ((v11 & 0x7FFFFF) != 0)
      v12 = ((v10 + 16 * ((v11 >> 23) & 1) + ((v11 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *(unsigned int *)(v10 + 40);
    else
      v12 = 0;
    return verifyAndGetTerminator<mlir::scf::YieldOp>((uint64_t *)v10, (_QWORD *)(v12 + 24), (const void **)"expects the 'after' region to terminate with 'scf.yield'", (const char *)0x38) != 0;
  }
LABEL_14:
  v35 = 261;
  v32 = (const void **)"expects the 'before' region to terminate with 'scf.condition'";
  v33 = 61;
  mlir::Operation::emitOpError((uint64_t *)v2, &v32, (uint64_t)&v36);
  if (v9)
  {
    v13 = mlir::Diagnostic::attachNote(&v37, *(_QWORD *)(v9 + 24), 1);
    v14 = v13 + 16;
    v15 = *(_QWORD *)(v13 + 16);
    LODWORD(v32) = 3;
    v33 = (uint64_t)"terminator here";
    v34 = 15;
    v16 = *(unsigned int *)(v13 + 24);
    v17 = &v32;
    if (v16 >= *(_DWORD *)(v13 + 28))
    {
      v29 = v16 + 1;
      v30 = v15 + 24 * v16 > (unint64_t)&v32;
      if (v15 <= (unint64_t)&v32 && v30)
      {
        v31 = (char *)&v32 - v15;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v14, (void *)(v13 + 32), v29, 24);
        v15 = *(_QWORD *)(v13 + 16);
        v17 = (const void ***)&v31[v15];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v14, (void *)(v13 + 32), v29, 24);
        v15 = *(_QWORD *)(v13 + 16);
        v17 = &v32;
      }
    }
    v18 = v15 + 24 * *(unsigned int *)(v13 + 24);
    v19 = *(_OWORD *)v17;
    *(_QWORD *)(v18 + 16) = v17[2];
    *(_OWORD *)v18 = v19;
    ++*(_DWORD *)(v13 + 24);
  }
  if (v36)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v36);
  if (v44)
  {
    v20 = __p;
    if (__p)
    {
      v21 = v43;
      v22 = __p;
      if (v43 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v43 = v20;
      operator delete(v22);
    }
    v23 = v40;
    if (v40)
    {
      v24 = v41;
      v25 = v40;
      if (v41 != v40)
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v40;
      }
      v41 = v23;
      operator delete(v25);
    }
    if (v38 != &v39)
      free(v38);
  }
  return 0;
}

void mlir::scf::WhileOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  uint64_t *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  const char *v147;
  unint64_t v148;
  uint64_t v149;
  const char *v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  uint64_t *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  unint64_t v176;
  char *v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  const char *v181;
  unint64_t v182;
  uint64_t v183;
  const char *v184;
  unint64_t v185;
  char *v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  char *v191;
  uint64_t *v192;
  char *v193;
  char *v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  uint64_t v201;
  __int128 v202;
  __int128 v203;
  uint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  char *v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  const char *v215;
  unint64_t v216;
  uint64_t v217;
  const char *v218;
  unint64_t v219;
  char *v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  char *v225;
  uint64_t *v226;
  char *v227;
  char *v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  char *v232;
  char *v233;
  char *v234;
  uint64_t v235;
  __int128 v236;
  __int128 v237;
  uint64_t v238;
  char *v239;
  uint64_t v240;
  uint64_t v241;
  const char *v242;
  unint64_t v243;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v4 = &off_24BFF2E48;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::RemoveLoopInvariantArgsFromBeforeBlock]";
  v243 = 111;
  v9 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v9)
    v10 = v9;
  else
    v10 = v243;
  v11 = &v242[v10];
  v12 = v243 - v10;
  if (v243 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v243 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_268;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_269;
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_272;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_272:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v38 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v38 = &off_24BFF2D40;
  if (*(_QWORD *)(v38 + 72))
  {
    v39 = *(unsigned int *)(v38 + 88);
    if (v39 <= *(_DWORD *)(v38 + 92))
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v38 + 80, (void *)(v38 + 96), v39, 16);
    *(_DWORD *)(v38 + 88) = *(_DWORD *)(v38 + 88);
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::RemoveLoopInvariantValueYielded]";
  v243 = 104;
  v43 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v43)
    v44 = v43;
  else
    v44 = v243;
  v45 = &v242[v44];
  v46 = v243 - v44;
  if (v243 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v243 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *(_QWORD *)(v38 + 64) = v48;
  *(_QWORD *)(v38 + 72) = v49;
  v39 = *(unsigned int *)(v38 + 88);
  if (v39 > *(_DWORD *)(v38 + 92))
    goto LABEL_52;
LABEL_41:
  *(_DWORD *)(v38 + 88) = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_268;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_269;
    v55 = (char *)operator new(8 * v54);
    v56 = (uint64_t *)&v55[8 * v51];
    v57 = &v55[8 * v54];
    *v56 = v38;
    v42 = (uint64_t)(v56 + 1);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (uint64_t *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v56
        && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_273;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 = (uint64_t *)((char *)v56 - v61);
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_273:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *--v56 = v68;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v72 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v72 = &off_24BFF2920;
  if (*(_QWORD *)(v72 + 72))
  {
    v73 = *(unsigned int *)(v72 + 88);
    if (v73 <= *(_DWORD *)(v72 + 92))
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v72 + 80, (void *)(v72 + 96), v73, 16);
    *(_DWORD *)(v72 + 88) = *(_DWORD *)(v72 + 88);
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::WhileConditionTruth]";
  v243 = 92;
  v77 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v77)
    v78 = v77;
  else
    v78 = v243;
  v79 = &v242[v78];
  v80 = v243 - v78;
  if (v243 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v243 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *(_QWORD *)(v72 + 64) = v82;
  *(_QWORD *)(v72 + 72) = v83;
  v73 = *(unsigned int *)(v72 + 88);
  if (v73 > *(_DWORD *)(v72 + 92))
    goto LABEL_90;
LABEL_79:
  *(_DWORD *)(v72 + 88) = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_268;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_269;
    v89 = (char *)operator new(8 * v88);
    v90 = (uint64_t *)&v89[8 * v85];
    v91 = &v89[8 * v88];
    *v90 = v72;
    v76 = (uint64_t)(v90 + 1);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (uint64_t *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v90
        && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_274;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 = (uint64_t *)((char *)v90 - v95);
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_274:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *--v90 = v102;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v106 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v106 = &off_24BFF26A0;
  if (*(_QWORD *)(v106 + 72))
  {
    v107 = *(unsigned int *)(v106 + 88);
    if (v107 <= *(_DWORD *)(v106 + 92))
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v106 + 80, (void *)(v106 + 96), v107, 16);
    *(_DWORD *)(v106 + 88) = *(_DWORD *)(v106 + 88);
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::WhileCmpCond]";
  v243 = 85;
  v111 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v111)
    v112 = v111;
  else
    v112 = v243;
  v113 = &v242[v112];
  v114 = v243 - v112;
  if (v243 - v112 >= 0x12)
    v115 = 18;
  else
    v115 = v243 - v112;
  v116 = &v113[v115];
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *(_QWORD *)(v106 + 64) = v116;
  *(_QWORD *)(v106 + 72) = v117;
  v107 = *(unsigned int *)(v106 + 88);
  if (v107 > *(_DWORD *)(v106 + 92))
    goto LABEL_128;
LABEL_117:
  *(_DWORD *)(v106 + 88) = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
    goto LABEL_268;
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (v122)
  {
    if (v122 >> 61)
      goto LABEL_269;
    v123 = (char *)operator new(8 * v122);
    v124 = (uint64_t *)&v123[8 * v119];
    v125 = &v123[8 * v122];
    *v124 = v106;
    v110 = (uint64_t)(v124 + 1);
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
  }
  else
  {
    v123 = 0;
    v124 = (uint64_t *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_275;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v109[-v129];
      v124 = (uint64_t *)((char *)v124 - v129);
      v131 = &v123[8 * v119 - 16];
      v132 = v109 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_275:
        do
        {
          v136 = *((_QWORD *)v109 - 1);
          v109 -= 8;
          *(_QWORD *)v109 = 0;
          *--v124 = v136;
        }
        while (v109 != v118);
      }
      v109 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
  v140 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v140 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v140 = &off_24BFF27A8;
  if (*(_QWORD *)(v140 + 72))
  {
    v141 = *(unsigned int *)(v140 + 88);
    if (v141 <= *(_DWORD *)(v140 + 92))
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v140 + 80, (void *)(v140 + 96), v141, 16);
    *(_DWORD *)(v140 + 88) = *(_DWORD *)(v140 + 88);
    v143 = (char *)a1[2];
    v142 = a1[3];
    if ((unint64_t)v143 < v142)
      goto LABEL_156;
    goto LABEL_167;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::WhileUnusedResult]";
  v243 = 90;
  v145 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v145)
    v146 = v145;
  else
    v146 = v243;
  v147 = &v242[v146];
  v148 = v243 - v146;
  if (v243 - v146 >= 0x12)
    v149 = 18;
  else
    v149 = v243 - v146;
  v150 = &v147[v149];
  v151 = v148 - v149;
  if (v151 >= v151 - 1)
    --v151;
  *(_QWORD *)(v140 + 64) = v150;
  *(_QWORD *)(v140 + 72) = v151;
  v141 = *(unsigned int *)(v140 + 88);
  if (v141 > *(_DWORD *)(v140 + 92))
    goto LABEL_166;
LABEL_155:
  *(_DWORD *)(v140 + 88) = v141;
  v143 = (char *)a1[2];
  v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(_QWORD *)v143 = v140;
    v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v152 = (char *)a1[1];
  v153 = (v143 - v152) >> 3;
  v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61)
    goto LABEL_268;
  v155 = v142 - (_QWORD)v152;
  if (v155 >> 2 > v154)
    v154 = v155 >> 2;
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8)
    v156 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v156 = v154;
  if (v156)
  {
    if (v156 >> 61)
      goto LABEL_269;
    v157 = (char *)operator new(8 * v156);
    v158 = (uint64_t *)&v157[8 * v153];
    v159 = &v157[8 * v156];
    *v158 = v140;
    v144 = (uint64_t)(v158 + 1);
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
      goto LABEL_176;
  }
  else
  {
    v157 = 0;
    v158 = (uint64_t *)(8 * v153);
    v159 = 0;
    *(_QWORD *)(8 * v153) = v140;
    v144 = 8 * v153 + 8;
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
    {
LABEL_176:
      v161 = (unint64_t)(v160 - 8);
      if (v161 < 0x78
        || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v158
        && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
      {
        goto LABEL_276;
      }
      v162 = (v161 >> 3) + 1;
      v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      v164 = &v143[-v163];
      v158 = (uint64_t *)((char *)v158 - v163);
      v165 = &v157[8 * v153 - 16];
      v166 = v143 - 16;
      v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v169 = *((_OWORD *)v166 - 1);
        v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      v143 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_276:
        do
        {
          v170 = *((_QWORD *)v143 - 1);
          v143 -= 8;
          *(_QWORD *)v143 = 0;
          *--v158 = v170;
        }
        while (v143 != v152);
      }
      v143 = (char *)a1[1];
      v171 = (char *)a1[2];
      a1[1] = v158;
      a1[2] = v144;
      a1[3] = v159;
      while (v171 != v143)
      {
        v173 = *((_QWORD *)v171 - 1);
        v171 -= 8;
        v172 = v173;
        *(_QWORD *)v171 = 0;
        if (v173)
          (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
      }
      goto LABEL_189;
    }
  }
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143)
    operator delete(v143);
LABEL_191:
  a1[2] = v144;
  v174 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v174 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v174 = &off_24BFF2C38;
  if (*(_QWORD *)(v174 + 72))
  {
    v175 = *(unsigned int *)(v174 + 88);
    if (v175 <= *(_DWORD *)(v174 + 92))
      goto LABEL_193;
LABEL_204:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v174 + 80, (void *)(v174 + 96), v175, 16);
    *(_DWORD *)(v174 + 88) = *(_DWORD *)(v174 + 88);
    v177 = (char *)a1[2];
    v176 = a1[3];
    if ((unint64_t)v177 < v176)
      goto LABEL_194;
    goto LABEL_205;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::WhileRemoveDuplicatedResults]";
  v243 = 101;
  v179 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v179)
    v180 = v179;
  else
    v180 = v243;
  v181 = &v242[v180];
  v182 = v243 - v180;
  if (v243 - v180 >= 0x12)
    v183 = 18;
  else
    v183 = v243 - v180;
  v184 = &v181[v183];
  v185 = v182 - v183;
  if (v185 >= v185 - 1)
    --v185;
  *(_QWORD *)(v174 + 64) = v184;
  *(_QWORD *)(v174 + 72) = v185;
  v175 = *(unsigned int *)(v174 + 88);
  if (v175 > *(_DWORD *)(v174 + 92))
    goto LABEL_204;
LABEL_193:
  *(_DWORD *)(v174 + 88) = v175;
  v177 = (char *)a1[2];
  v176 = a1[3];
  if ((unint64_t)v177 < v176)
  {
LABEL_194:
    *(_QWORD *)v177 = v174;
    v178 = (uint64_t)(v177 + 8);
    goto LABEL_229;
  }
LABEL_205:
  v186 = (char *)a1[1];
  v187 = (v177 - v186) >> 3;
  v188 = v187 + 1;
  if ((unint64_t)(v187 + 1) >> 61)
    goto LABEL_268;
  v189 = v176 - (_QWORD)v186;
  if (v189 >> 2 > v188)
    v188 = v189 >> 2;
  if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8)
    v190 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v190 = v188;
  if (v190)
  {
    if (v190 >> 61)
      goto LABEL_269;
    v191 = (char *)operator new(8 * v190);
    v192 = (uint64_t *)&v191[8 * v187];
    v193 = &v191[8 * v190];
    *v192 = v174;
    v178 = (uint64_t)(v192 + 1);
    v194 = (char *)(v177 - v186);
    if (v177 != v186)
      goto LABEL_214;
  }
  else
  {
    v191 = 0;
    v192 = (uint64_t *)(8 * v187);
    v193 = 0;
    *(_QWORD *)(8 * v187) = v174;
    v178 = 8 * v187 + 8;
    v194 = (char *)(v177 - v186);
    if (v177 != v186)
    {
LABEL_214:
      v195 = (unint64_t)(v194 - 8);
      if (v195 < 0x78
        || &v177[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v192
        && &v191[v177 - v186 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v177)
      {
        goto LABEL_277;
      }
      v196 = (v195 >> 3) + 1;
      v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      v198 = &v177[-v197];
      v192 = (uint64_t *)((char *)v192 - v197);
      v199 = &v191[8 * v187 - 16];
      v200 = v177 - 16;
      v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v203 = *((_OWORD *)v200 - 1);
        v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      v177 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_277:
        do
        {
          v204 = *((_QWORD *)v177 - 1);
          v177 -= 8;
          *(_QWORD *)v177 = 0;
          *--v192 = v204;
        }
        while (v177 != v186);
      }
      v177 = (char *)a1[1];
      v205 = (char *)a1[2];
      a1[1] = v192;
      a1[2] = v178;
      a1[3] = v193;
      while (v205 != v177)
      {
        v207 = *((_QWORD *)v205 - 1);
        v205 -= 8;
        v206 = v207;
        *(_QWORD *)v205 = 0;
        if (v207)
          (*(void (**)(uint64_t))(*(_QWORD *)v206 + 8))(v206);
      }
      goto LABEL_227;
    }
  }
  a1[1] = v192;
  a1[2] = v178;
  a1[3] = v193;
LABEL_227:
  if (v177)
    operator delete(v177);
LABEL_229:
  a1[2] = v178;
  v208 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v242, 1);
  mlir::Pattern::Pattern(v208 + 8, (uint64_t)"scf.while", 9, (__int16)v242, a2, 0, 0);
  *(_QWORD *)v208 = &off_24BFF2B30;
  if (*(_QWORD *)(v208 + 72))
  {
    v209 = *(unsigned int *)(v208 + 88);
    if (v209 <= *(_DWORD *)(v208 + 92))
      goto LABEL_231;
LABEL_242:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v208 + 80, (void *)(v208 + 96), v209, 16);
    *(_DWORD *)(v208 + 88) = *(_DWORD *)(v208 + 88);
    v211 = (char *)a1[2];
    v210 = a1[3];
    if ((unint64_t)v211 < v210)
      goto LABEL_232;
    goto LABEL_243;
  }
  v242 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::WhileRemoveUnusedArgs]";
  v243 = 94;
  v213 = llvm::StringRef::find((uint64_t *)&v242, "DesiredTypeName = ", 0x12uLL, 0);
  if (v243 >= v213)
    v214 = v213;
  else
    v214 = v243;
  v215 = &v242[v214];
  v216 = v243 - v214;
  if (v243 - v214 >= 0x12)
    v217 = 18;
  else
    v217 = v243 - v214;
  v218 = &v215[v217];
  v219 = v216 - v217;
  if (v219 >= v219 - 1)
    --v219;
  *(_QWORD *)(v208 + 64) = v218;
  *(_QWORD *)(v208 + 72) = v219;
  v209 = *(unsigned int *)(v208 + 88);
  if (v209 > *(_DWORD *)(v208 + 92))
    goto LABEL_242;
LABEL_231:
  *(_DWORD *)(v208 + 88) = v209;
  v211 = (char *)a1[2];
  v210 = a1[3];
  if ((unint64_t)v211 < v210)
  {
LABEL_232:
    *(_QWORD *)v211 = v208;
    v212 = (uint64_t)(v211 + 8);
    goto LABEL_267;
  }
LABEL_243:
  v220 = (char *)a1[1];
  v221 = (v211 - v220) >> 3;
  v222 = v221 + 1;
  if ((unint64_t)(v221 + 1) >> 61)
LABEL_268:
    abort();
  v223 = v210 - (_QWORD)v220;
  if (v223 >> 2 > v222)
    v222 = v223 >> 2;
  if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8)
    v224 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v224 = v222;
  if (!v224)
  {
    v225 = 0;
    v226 = (uint64_t *)(8 * v221);
    v227 = 0;
    *(_QWORD *)(8 * v221) = v208;
    v212 = 8 * v221 + 8;
    v228 = (char *)(v211 - v220);
    if (v211 != v220)
      goto LABEL_252;
    goto LABEL_264;
  }
  if (v224 >> 61)
LABEL_269:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v225 = (char *)operator new(8 * v224);
  v226 = (uint64_t *)&v225[8 * v221];
  v227 = &v225[8 * v224];
  *v226 = v208;
  v212 = (uint64_t)(v226 + 1);
  v228 = (char *)(v211 - v220);
  if (v211 != v220)
  {
LABEL_252:
    v229 = (unint64_t)(v228 - 8);
    if (v229 < 0x78
      || &v211[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v226
      && &v225[v211 - v220 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v211)
    {
      goto LABEL_278;
    }
    v230 = (v229 >> 3) + 1;
    v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
    v232 = &v211[-v231];
    v226 = (uint64_t *)((char *)v226 - v231);
    v233 = &v225[8 * v221 - 16];
    v234 = v211 - 16;
    v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v237 = *((_OWORD *)v234 - 1);
      v236 = *(_OWORD *)v234;
      *((_OWORD *)v234 - 1) = 0uLL;
      *(_OWORD *)v234 = 0uLL;
      *((_OWORD *)v233 - 1) = v237;
      *(_OWORD *)v233 = v236;
      v233 -= 32;
      v234 -= 32;
      v235 -= 4;
    }
    while (v235);
    v211 = v232;
    if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_278:
      do
      {
        v238 = *((_QWORD *)v211 - 1);
        v211 -= 8;
        *(_QWORD *)v211 = 0;
        *--v226 = v238;
      }
      while (v211 != v220);
    }
    v211 = (char *)a1[1];
    v239 = (char *)a1[2];
    a1[1] = v226;
    a1[2] = v212;
    a1[3] = v227;
    while (v239 != v211)
    {
      v241 = *((_QWORD *)v239 - 1);
      v239 -= 8;
      v240 = v241;
      *(_QWORD *)v239 = 0;
      if (v241)
        (*(void (**)(uint64_t))(*(_QWORD *)v240 + 8))(v240);
    }
    goto LABEL_265;
  }
LABEL_264:
  a1[1] = v226;
  a1[2] = v212;
  a1[3] = v227;
LABEL_265:
  if (v211)
    operator delete(v211);
LABEL_267:
  a1[2] = v212;
}

uint64_t mlir::scf::IndexSwitchOp::verify(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  const char *v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  __int128 v28;
  uint64_t v29;
  uint64_t *v30;
  char *v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  char *v44;
  char *v45;
  __int128 v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  _QWORD *v50;
  _QWORD *v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  const void **v55;
  uint64_t v56;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  BOOL v61;
  unint64_t v62;
  BOOL v63;
  unint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  const char *v70;
  llvm *v71[2];
  unsigned int v72;
  const void **v73[4];
  __int16 v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  const void **v78[2];
  const void ***v79;
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD *v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  v78[0] = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v78);
  v2 = *this;
  v3 = *((unsigned int *)*this + 11);
  if (v4 == (v3 & 0x7FFFFF) - 1)
  {
    v71[0] = 0;
    v71[1] = 0;
    v72 = 0;
    v78[0] = (const void **)v2[2 * ((v3 >> 23) & 1) + 8];
    v5 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v78);
    if (v6)
    {
      v7 = (uint64_t *)v5;
      v8 = 8 * v6;
      while (1)
      {
        v70 = 0;
        v70 = (const char *)*v7;
        llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::try_emplace<llvm::detail::DenseSetEmpty&>((uint64_t)v71, (uint64_t *)&v70, (uint64_t)v78);
        if (!(_BYTE)v79)
          break;
        ++v7;
        v8 -= 8;
        if (!v8)
          goto LABEL_6;
      }
      v73[0] = (const void **)"has duplicate case value: ";
      v74 = 259;
      mlir::OpState::emitOpError(this, v73, (uint64_t)v78);
      if (v78[0])
      {
        LODWORD(v75) = 2;
        v76 = v70;
        v43 = &v75;
        v44 = (char *)v80;
        if (v81 >= v82)
        {
          v64 = v81 + 1;
          if (v80 <= &v75 && (char *)v80 + 24 * v81 > (char *)&v75)
          {
            v69 = (char *)&v75 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v44 = (char *)v80;
            v43 = (uint64_t *)((char *)v80 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v43 = &v75;
            v44 = (char *)v80;
          }
        }
        v45 = &v44[24 * v81];
        v46 = *(_OWORD *)v43;
        *((_QWORD *)v45 + 2) = v43[2];
        *(_OWORD *)v45 = v46;
        ++v81;
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v78);
      if (v78[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
      if (v88)
      {
        v47 = __p;
        if (__p)
        {
          v48 = v87;
          v49 = __p;
          if (v87 != __p)
          {
            do
              v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v48 - 1);
            while (v48 != v47);
            v49 = __p;
          }
          v87 = v47;
          operator delete(v49);
        }
        v50 = v84;
        if (v84)
        {
          v51 = v85;
          v52 = v84;
          if (v85 != v84)
          {
            do
            {
              v54 = *--v51;
              v53 = v54;
              *v51 = 0;
              if (v54)
                MEMORY[0x20BD002D4](v53, 0x1000C8077774924);
            }
            while (v51 != v50);
            v52 = v84;
          }
          v85 = v50;
          operator delete(v52);
        }
        if (v80 != v83)
          free(v80);
      }
    }
    else
    {
LABEL_6:
      v9 = (((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8]
           + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
           + 7) & 0xFFFFFFFFFFFFFFF8)
         + 32 * *((unsigned int *)*this + 10);
      v78[0] = (const void **)"default region";
      LOWORD(v81) = 259;
      if (mlir::scf::IndexSwitchOp::verify(void)::$_0::operator()(this, v9, v78))
      {
        v10 = *((unsigned int *)*this + 11);
        v11 = v10 & 0x7FFFFF;
        if ((v10 & 0x7FFFFF) != 0)
        {
          if (v11 == 1)
            goto LABEL_65;
          v12 = (((unint64_t)&(*this)[2 * ((v10 >> 23) & 1) + 8] + ((v10 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
              + 32 * *((unsigned int *)*this + 10);
          v13 = v12 + 24 * v11;
        }
        else
        {
          v13 = 0;
          v12 = 0;
        }
        v55 = 0;
        v56 = v12 + 24;
        do
        {
          v73[0] = v55;
          v78[0] = (const void **)"case region #";
          v79 = v73;
          LOWORD(v81) = 2819;
          if (!mlir::scf::IndexSwitchOp::verify(void)::$_0::operator()(this, v56, v78))
            break;
          v55 = (const void **)((char *)v55 + 1);
          v56 += 24;
        }
        while (v56 != v13);
      }
    }
LABEL_65:
    llvm::deallocate_buffer(v71[0], (void *)(8 * v72));
  }
  v73[0] = (const void **)"has ";
  v74 = 259;
  mlir::OpState::emitOpError(this, v73, (uint64_t)v78);
  if (v78[0])
  {
    v14 = (*((_DWORD *)*this + 11) & 0x7FFFFF) - 1;
    LODWORD(v75) = 5;
    v76 = (const char *)v14;
    v15 = &v75;
    v16 = (char *)v80;
    if (v81 >= v82)
    {
      v58 = v81 + 1;
      if (v80 <= &v75 && (char *)v80 + 24 * v81 > (char *)&v75)
      {
        v65 = (char *)&v75 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v58, 24);
        v16 = (char *)v80;
        v15 = (uint64_t *)((char *)v80 + v65);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v58, 24);
        v15 = &v75;
        v16 = (char *)v80;
      }
    }
    v17 = &v16[24 * v81];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v81;
    if (v78[0])
    {
      LODWORD(v75) = 3;
      v76 = " case regions but ";
      v77 = 18;
      v20 = &v75;
      v21 = (char *)v80;
      if (v19 >= v82)
      {
        v60 = v19 + 1;
        v61 = (char *)v80 + 24 * v19 > (char *)&v75;
        if (v80 <= &v75 && v61)
        {
          v67 = (char *)&v75 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v60, 24);
          v21 = (char *)v80;
          v20 = (uint64_t *)((char *)v80 + v67);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v60, 24);
          v20 = &v75;
          v21 = (char *)v80;
        }
      }
      v22 = &v21[24 * v81];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      ++v81;
    }
  }
  v75 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v75);
  if (v78[0])
  {
    LODWORD(v75) = 5;
    v76 = v24;
    v25 = &v75;
    v26 = (char *)v80;
    if (v81 >= v82)
    {
      v59 = v81 + 1;
      if (v80 <= &v75 && (char *)v80 + 24 * v81 > (char *)&v75)
      {
        v66 = (char *)&v75 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v59, 24);
        v26 = (char *)v80;
        v25 = (uint64_t *)((char *)v80 + v66);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v59, 24);
        v25 = &v75;
        v26 = (char *)v80;
      }
    }
    v27 = &v26[24 * v81];
    v28 = *(_OWORD *)v25;
    *((_QWORD *)v27 + 2) = v25[2];
    *(_OWORD *)v27 = v28;
    v29 = ++v81;
    if (v78[0])
    {
      LODWORD(v75) = 3;
      v76 = " case values";
      v77 = 12;
      v30 = &v75;
      v31 = (char *)v80;
      if (v29 >= v82)
      {
        v62 = v29 + 1;
        v63 = (char *)v80 + 24 * v29 > (char *)&v75;
        if (v80 <= &v75 && v63)
        {
          v68 = (char *)&v75 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v62, 24);
          v31 = (char *)v80;
          v30 = (uint64_t *)((char *)v80 + v68);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v62, 24);
          v30 = &v75;
          v31 = (char *)v80;
        }
      }
      v32 = &v31[24 * v81];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = v30[2];
      *(_OWORD *)v32 = v33;
      ++v81;
    }
  }
  v34 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v78);
  if (v78[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
  if (v88)
  {
    v35 = __p;
    if (__p)
    {
      v36 = v87;
      v37 = __p;
      if (v87 != __p)
      {
        do
          v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
        while (v36 != v35);
        v37 = __p;
      }
      v87 = v35;
      operator delete(v37);
    }
    v38 = v84;
    if (v84)
    {
      v39 = v85;
      v40 = v84;
      if (v85 != v84)
      {
        do
        {
          v42 = *--v39;
          v41 = v42;
          *v39 = 0;
          if (v42)
            MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
        }
        while (v39 != v38);
        v40 = v84;
      }
      v85 = v38;
      operator delete(v40);
    }
    if (v80 != v83)
      free(v80);
  }
  return v34;
}

uint64_t mlir::scf::IndexSwitchOp::verify(void)::$_0::operator()(uint64_t **a1, uint64_t a2, const void ***a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t IsGraphInitialization;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t *v24;
  const void **v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const void **v31;
  const void **v32;
  const char *v33;
  const void **v34;
  uint64_t v35;
  BOOL v36;
  _BOOL4 v37;
  BOOL v38;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  const void ***v43;
  uint64_t *v44;
  char *v45;
  char *v46;
  __int128 v47;
  uint64_t v48;
  uint64_t *v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t *v53;
  char *v54;
  char *v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  __int128 v65;
  uint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  __int128 v70;
  unsigned int v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  __int128 v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  const char *v86;
  uint64_t *v87;
  char *v88;
  char *v89;
  __int128 v90;
  uint64_t v91;
  uint64_t *v92;
  char *v93;
  char *v94;
  __int128 v95;
  uint64_t *v96;
  char *v97;
  char *v98;
  __int128 v99;
  const char *v100;
  uint64_t *v101;
  char *v102;
  char *v103;
  __int128 v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  __int128 v111;
  _QWORD *v112;
  _QWORD *v113;
  void *v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  BOOL v134;
  unint64_t v135;
  char *v136;
  int64_t v137;
  int64_t v138;
  int64_t v139;
  char *v140;
  char *v141;
  char *v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  uint64_t **v147;
  const void ***v148;
  uint64_t v149;
  const char *v150;
  const void **v151;
  uint64_t v152;
  const void **v153;
  uint64_t v154;
  __int16 v155;
  uint64_t v156;
  const char *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160[2];
  void *v161;
  unsigned int v162;
  unsigned int v163;
  _BYTE v164[96];
  void *v165;
  _QWORD *v166;
  void *__p;
  _QWORD *v168;
  char v169;
  uint64_t v170;

  v170 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
    v7 = v6 - 8;
  else
    v7 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v7 + 32));
  if (v8)
    v9 = *(_QWORD *)(*(_QWORD *)(v8 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id;
  else
    v9 = 0;
  if (!v9)
  {
    v151 = (const void **)"expected region to end with scf.yield, but got ";
    v155 = 259;
    mlir::OpState::emitOpError(a1, &v151, (uint64_t)&v159);
    v10 = *(_QWORD *)(a2 + 8);
    if (v10)
      v11 = v10 - 8;
    else
      v11 = 0;
    ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v11 + 32));
    if (v159)
      mlir::Diagnostic::operator<<((uint64_t)v160, *(_QWORD *)(v12 + 48));
    IsGraphInitialization = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v159);
    if (v159)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v159);
    if (!v169)
      return IsGraphInitialization;
    v14 = __p;
    if (__p)
    {
      v15 = v168;
      v16 = __p;
      if (v168 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v168 = v14;
      operator delete(v16);
    }
    v17 = v165;
    if (!v165)
      goto LABEL_108;
    v18 = v166;
    v19 = v165;
    if (v166 == v165)
      goto LABEL_107;
    do
    {
      v21 = *--v18;
      v20 = v21;
      *v18 = 0;
      if (v21)
        MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
    }
    while (v18 != v17);
    goto LABEL_106;
  }
  v22 = v8;
  if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
  {
    v23 = *(_DWORD *)(v8 + 68);
    v24 = *a1;
    if (v23 == *((_DWORD *)*a1 + 9))
      goto LABEL_29;
  }
  else
  {
    v23 = 0;
    v24 = *a1;
    if (!*((_DWORD *)*a1 + 9))
    {
LABEL_29:
      v25 = (const void **)(v24 - 2);
      if (!v23)
        v25 = 0;
      v150 = (const char *)v23;
      v151 = v25;
      v152 = v23;
      mlir::OperandRange::getTypes((uint64_t *)&v151, &v159);
      if ((*(_BYTE *)(v22 + 46) & 0x80) != 0)
      {
        v26 = (const char *)*(unsigned int *)(v22 + 68);
        v156 = *(_QWORD *)(v22 + 72);
        v157 = v26;
        mlir::OperandRange::getTypes(&v156, (uint64_t *)&v151);
        if (v23)
          goto LABEL_33;
      }
      else
      {
        v156 = 0;
        v157 = 0;
        mlir::OperandRange::getTypes(&v156, (uint64_t *)&v151);
        if (v23)
        {
LABEL_33:
          v147 = a1;
          v148 = a3;
          v149 = v22;
          v27 = 0;
          v29 = v159;
          v28 = v160[0];
          v30 = v160[1];
          v31 = v151;
          v32 = v153;
          v33 = (const char *)(v154 - v152);
          v34 = &v151[4 * v152 + 3];
          v35 = v160[0] - (_QWORD)v161;
          do
          {
            v36 = v31 == v32 && v33 == v27;
            v37 = !v36;
            v38 = !&v27[v35] && v29 == v30;
            if (v38 || !v37)
              break;
            v40 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v29, (uint64_t)&v27[v28]) + 8) & 0xFFFFFFFFFFFFFFF8;
            if (v40 != (*((_QWORD *)*v34 + 1) & 0xFFFFFFFFFFFFFFF8))
            {
              v41 = *((_QWORD *)*v34 + 1) & 0xFFFFFFFFFFFFFFF8;
              v151 = (const void **)"expected result #";
              v155 = 259;
              mlir::OpState::emitOpError(v147, &v151, (uint64_t)&v159);
              v43 = v148;
              v42 = v149;
              if (v159)
              {
                LODWORD(v156) = 5;
                v157 = v27;
                v44 = &v156;
                v45 = (char *)v161;
                if (v162 >= v163)
                {
                  v132 = v162 + 1;
                  if (v161 <= &v156 && (char *)v161 + 24 * v162 > (char *)&v156)
                  {
                    v144 = (char *)&v156 - (_BYTE *)v161;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v132, 24);
                    v45 = (char *)v161;
                    v44 = (uint64_t *)((char *)v161 + v144);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v132, 24);
                    v44 = &v156;
                    v45 = (char *)v161;
                  }
                  v43 = v148;
                  v42 = v149;
                }
                v46 = &v45[24 * v162];
                v47 = *(_OWORD *)v44;
                *((_QWORD *)v46 + 2) = v44[2];
                *(_OWORD *)v46 = v47;
                v48 = ++v162;
                if (v159)
                {
                  LODWORD(v156) = 3;
                  v157 = " of each region to be ";
                  v158 = 22;
                  v49 = &v156;
                  v50 = (char *)v161;
                  if (v48 >= v163)
                  {
                    v133 = v48 + 1;
                    v134 = (char *)v161 + 24 * v48 > (char *)&v156;
                    if (v161 <= &v156 && v134)
                    {
                      v145 = (char *)&v156 - (_BYTE *)v161;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v133, 24);
                      v50 = (char *)v161;
                      v49 = (uint64_t *)((char *)v161 + v145);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v133, 24);
                      v49 = &v156;
                      v50 = (char *)v161;
                    }
                    v43 = v148;
                    v42 = v149;
                  }
                  v51 = &v50[24 * v162];
                  v52 = *(_OWORD *)v49;
                  *((_QWORD *)v51 + 2) = v49[2];
                  *(_OWORD *)v51 = v52;
                  ++v162;
                  if (v159)
                  {
                    v53 = &v156;
                    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v156, v40);
                    v54 = (char *)v161;
                    if (v162 >= v163)
                    {
                      v135 = v162 + 1;
                      if (v161 <= &v156 && (char *)v161 + 24 * v162 > (char *)&v156)
                      {
                        v146 = (char *)&v156 - (_BYTE *)v161;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v135, 24);
                        v54 = (char *)v161;
                        v53 = (uint64_t *)((char *)v161 + v146);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v135, 24);
                        v53 = &v156;
                        v54 = (char *)v161;
                      }
                      v43 = v148;
                      v42 = v149;
                    }
                    v55 = &v54[24 * v162];
                    v56 = *(_OWORD *)v53;
                    *((_QWORD *)v55 + 2) = v53[2];
                    *(_OWORD *)v55 = v56;
                    ++v162;
                  }
                }
              }
              v57 = mlir::Diagnostic::attachNote(v160, *(_QWORD *)(v42 + 24), 1);
              v58 = mlir::Diagnostic::operator<<(v57, v43);
              v59 = v58;
              v61 = v58 + 16;
              v60 = *(_QWORD *)(v58 + 16);
              LODWORD(v156) = 3;
              v157 = " returns ";
              v158 = 9;
              v62 = *(unsigned int *)(v58 + 24);
              v63 = &v156;
              if (v62 >= *(_DWORD *)(v58 + 28))
              {
                v125 = v62 + 1;
                v126 = v60 + 24 * v62 > (unint64_t)&v156;
                if (v60 <= (unint64_t)&v156 && v126)
                {
                  v140 = (char *)&v156 - v60;
                  llvm::SmallVectorBase<unsigned int>::grow_pod(v58 + 16, (void *)(v58 + 32), v125, 24);
                  v60 = *(_QWORD *)(v59 + 16);
                  v63 = (uint64_t *)&v140[v60];
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod(v58 + 16, (void *)(v58 + 32), v125, 24);
                  v60 = *(_QWORD *)(v59 + 16);
                  v63 = &v156;
                }
              }
              v64 = v60 + 24 * *(unsigned int *)(v59 + 24);
              v65 = *(_OWORD *)v63;
              *(_QWORD *)(v64 + 16) = v63[2];
              *(_OWORD *)v64 = v65;
              ++*(_DWORD *)(v59 + 24);
              v66 = &v156;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v156, v41);
              v67 = *(unsigned int *)(v59 + 24);
              v68 = *(_QWORD *)(v59 + 16);
              if (v67 >= *(_DWORD *)(v59 + 28))
              {
                v127 = v67 + 1;
                v128 = v68 + 24 * v67 > (unint64_t)&v156;
                if (v68 <= (unint64_t)&v156 && v128)
                {
                  v141 = (char *)&v156 - v68;
                  llvm::SmallVectorBase<unsigned int>::grow_pod(v61, (void *)(v59 + 32), v127, 24);
                  v68 = *(_QWORD *)(v59 + 16);
                  v66 = (uint64_t *)&v141[v68];
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod(v61, (void *)(v59 + 32), v127, 24);
                  v68 = *(_QWORD *)(v59 + 16);
                  v66 = &v156;
                }
              }
              v69 = v68 + 24 * *(unsigned int *)(v59 + 24);
              v70 = *(_OWORD *)v66;
              *(_QWORD *)(v69 + 16) = v66[2];
              *(_OWORD *)v69 = v70;
              v71 = *(_DWORD *)(v59 + 28);
              v72 = (*(_DWORD *)(v59 + 24) + 1);
              *(_DWORD *)(v59 + 24) = v72;
              LODWORD(v156) = 3;
              v157 = " here";
              v158 = 5;
              v73 = *(_QWORD *)(v59 + 16);
              v74 = &v156;
              if (v72 >= v71)
              {
                v129 = v72 + 1;
                v130 = v73 + 24 * v72 > (unint64_t)&v156;
                if (v73 <= (unint64_t)&v156 && v130)
                {
                  v142 = (char *)&v156 - v73;
                  llvm::SmallVectorBase<unsigned int>::grow_pod(v61, (void *)(v59 + 32), v129, 24);
                  v73 = *(_QWORD *)(v59 + 16);
                  v74 = (uint64_t *)&v142[v73];
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod(v61, (void *)(v59 + 32), v129, 24);
                  v73 = *(_QWORD *)(v59 + 16);
                  v74 = &v156;
                }
              }
              v75 = v73 + 24 * *(unsigned int *)(v59 + 24);
              v76 = *(_OWORD *)v74;
              *(_QWORD *)(v75 + 16) = v74[2];
              *(_OWORD *)v75 = v76;
              ++*(_DWORD *)(v59 + 24);
              IsGraphInitialization = Layer2TDMapper::SourceLayer::IsGraphInitialization((Layer2TDMapper::SourceLayer *)v59);
              if (v159)
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v159);
              if (v169)
              {
                v77 = __p;
                if (__p)
                {
                  v78 = v168;
                  v79 = __p;
                  if (v168 != __p)
                  {
                    do
                      v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
                    while (v78 != v77);
                    v79 = __p;
                  }
                  v168 = v77;
                  operator delete(v79);
                }
                v80 = v165;
                if (v165)
                {
                  v81 = v166;
                  v82 = v165;
                  if (v166 != v165)
                  {
                    do
                    {
                      v84 = *--v81;
                      v83 = v84;
                      *v81 = 0;
                      if (v84)
                        MEMORY[0x20BD002D4](v83, 0x1000C8077774924);
                    }
                    while (v81 != v80);
                    v82 = v165;
                  }
                  v166 = v80;
                  operator delete(v82);
                }
                v85 = v161;
                if (v161 != v164)
                  goto LABEL_109;
              }
              return IsGraphInitialization;
            }
            ++v27;
            v34 += 4;
          }
          while (v150 != v27);
        }
      }
      return 1;
    }
  }
  v151 = (const void **)"expected each region to return ";
  v155 = 259;
  mlir::OpState::emitOpError(a1, &v151, (uint64_t)&v159);
  if (v159)
  {
    v86 = (const char *)*((unsigned int *)*a1 + 9);
    LODWORD(v156) = 5;
    v157 = v86;
    v87 = &v156;
    v88 = (char *)v161;
    if (v162 >= v163)
    {
      v121 = v162 + 1;
      if (v161 <= &v156 && (char *)v161 + 24 * v162 > (char *)&v156)
      {
        v137 = (char *)&v156 - (_BYTE *)v161;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v121, 24);
        v88 = (char *)v161;
        v87 = (uint64_t *)((char *)v161 + v137);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v121, 24);
        v87 = &v156;
        v88 = (char *)v161;
      }
    }
    v89 = &v88[24 * v162];
    v90 = *(_OWORD *)v87;
    *((_QWORD *)v89 + 2) = v87[2];
    *(_OWORD *)v89 = v90;
    v91 = ++v162;
    if (v159)
    {
      LODWORD(v156) = 3;
      v157 = " values, but ";
      v158 = 13;
      v92 = &v156;
      v93 = (char *)v161;
      if (v91 >= v163)
      {
        v123 = v91 + 1;
        v124 = (char *)v161 + 24 * v91 > (char *)&v156;
        if (v161 <= &v156 && v124)
        {
          v139 = (char *)&v156 - (_BYTE *)v161;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v123, 24);
          v93 = (char *)v161;
          v92 = (uint64_t *)((char *)v161 + v139);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v123, 24);
          v92 = &v156;
          v93 = (char *)v161;
        }
      }
      v94 = &v93[24 * v162];
      v95 = *(_OWORD *)v92;
      *((_QWORD *)v94 + 2) = v92[2];
      *(_OWORD *)v94 = v95;
      ++v162;
      if (v159)
      {
        mlir::Diagnostic::operator<<((uint64_t)v160, a3);
        if (v159)
        {
          LODWORD(v156) = 3;
          v157 = " returns ";
          v158 = 9;
          v96 = &v156;
          v97 = (char *)v161;
          if (v162 >= v163)
          {
            v131 = v162 + 1;
            if (v161 <= &v156 && (char *)v161 + 24 * v162 > (char *)&v156)
            {
              v143 = (char *)&v156 - (_BYTE *)v161;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v131, 24);
              v97 = (char *)v161;
              v96 = (uint64_t *)((char *)v161 + v143);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v131, 24);
              v96 = &v156;
              v97 = (char *)v161;
            }
          }
          v98 = &v97[24 * v162];
          v99 = *(_OWORD *)v96;
          *((_QWORD *)v98 + 2) = v96[2];
          *(_OWORD *)v98 = v99;
          ++v162;
        }
      }
    }
  }
  if ((*(_BYTE *)(v22 + 46) & 0x80) != 0)
  {
    v100 = (const char *)*(unsigned int *)(v22 + 68);
    if (!v159)
      goto LABEL_91;
  }
  else
  {
    v100 = 0;
    if (!v159)
      goto LABEL_91;
  }
  LODWORD(v156) = 5;
  v157 = v100;
  v101 = &v156;
  v102 = (char *)v161;
  if (v162 >= v163)
  {
    v122 = v162 + 1;
    if (v161 <= &v156 && (char *)v161 + 24 * v162 > (char *)&v156)
    {
      v138 = (char *)&v156 - (_BYTE *)v161;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v122, 24);
      v102 = (char *)v161;
      v101 = (uint64_t *)((char *)v161 + v138);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v161, v164, v122, 24);
      v101 = &v156;
      v102 = (char *)v161;
    }
  }
  v103 = &v102[24 * v162];
  v104 = *(_OWORD *)v101;
  *((_QWORD *)v103 + 2) = v101[2];
  *(_OWORD *)v103 = v104;
  ++v162;
LABEL_91:
  v105 = mlir::Diagnostic::attachNote(v160, *(_QWORD *)(v22 + 24), 1);
  v106 = v105 + 16;
  v107 = *(_QWORD *)(v105 + 16);
  LODWORD(v156) = 3;
  v157 = "see yield operation here";
  v158 = 24;
  v108 = *(unsigned int *)(v105 + 24);
  v109 = &v156;
  if (v108 >= *(_DWORD *)(v105 + 28))
  {
    v119 = v108 + 1;
    v120 = v107 + 24 * v108 > (unint64_t)&v156;
    if (v107 <= (unint64_t)&v156 && v120)
    {
      v136 = (char *)&v156 - v107;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v106, (void *)(v105 + 32), v119, 24);
      v107 = *(_QWORD *)(v105 + 16);
      v109 = (uint64_t *)&v136[v107];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v106, (void *)(v105 + 32), v119, 24);
      v107 = *(_QWORD *)(v105 + 16);
      v109 = &v156;
    }
  }
  v110 = v107 + 24 * *(unsigned int *)(v105 + 24);
  v111 = *(_OWORD *)v109;
  *(_QWORD *)(v110 + 16) = v109[2];
  *(_OWORD *)v110 = v111;
  ++*(_DWORD *)(v105 + 24);
  IsGraphInitialization = Layer2TDMapper::SourceLayer::IsGraphInitialization((Layer2TDMapper::SourceLayer *)v105);
  if (v159)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v159);
  if (!v169)
    return IsGraphInitialization;
  v112 = __p;
  if (__p)
  {
    v113 = v168;
    v114 = __p;
    if (v168 != __p)
    {
      do
        v113 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v113 - 1);
      while (v113 != v112);
      v114 = __p;
    }
    v168 = v112;
    operator delete(v114);
  }
  v17 = v165;
  if (v165)
  {
    v115 = v166;
    v19 = v165;
    if (v166 == v165)
      goto LABEL_107;
    do
    {
      v117 = *--v115;
      v116 = v117;
      *v115 = 0;
      if (v117)
        MEMORY[0x20BD002D4](v116, 0x1000C8077774924);
    }
    while (v115 != v17);
LABEL_106:
    v19 = v165;
LABEL_107:
    v166 = v17;
    operator delete(v19);
  }
LABEL_108:
  v85 = v161;
  if (v161 != v164)
LABEL_109:
    free(v85);
  return IsGraphInitialization;
}

double mlir::scf::IndexSwitchOp::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  _QWORD *v7;
  __int128 v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  char *v18;
  uint64_t v20;
  unint64_t v21[3];

  v21[2] = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v4 = *(unsigned int *)(*(_QWORD *)a1 + 36);
    if ((_DWORD)v4)
      v5 = *(_QWORD *)a1 - 16;
    else
      v5 = 0;
    v6 = *(_DWORD *)(a3 + 8);
    if (v6 >= *(_DWORD *)(a3 + 12))
    {
      v20 = 0;
      v12 = &v20;
      mlir::ValueRange::ValueRange(v21, v5, v4);
      v13 = *(unsigned int *)(a3 + 8);
      v14 = *(_QWORD *)a3;
      if (v13 >= *(_DWORD *)(a3 + 12))
      {
        v16 = v13 + 1;
        v17 = v14 + 24 * v13 > (unint64_t)&v20;
        if (v14 <= (unint64_t)&v20 && v17)
        {
          v18 = (char *)&v21[-1] - v14;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16, 24);
          v14 = *(_QWORD *)a3;
          v12 = (uint64_t *)&v18[*(_QWORD *)a3];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16, 24);
          v14 = *(_QWORD *)a3;
          v12 = &v20;
        }
      }
      v15 = v14 + 24 * *(unsigned int *)(a3 + 8);
      v8 = *(_OWORD *)v12;
      *(_QWORD *)(v15 + 16) = v12[2];
      *(_OWORD *)v15 = v8;
    }
    else
    {
      v7 = (_QWORD *)(*(_QWORD *)a3 + 24 * v6);
      *v7 = 0;
      mlir::ValueRange::ValueRange(v7 + 1, v5, v4);
    }
    ++*(_DWORD *)(a3 + 8);
  }
  else
  {
    v9 = *(unsigned int *)(*(_QWORD *)a1 + 44);
    v10 = v9 & 0x7FFFFF;
    if ((v9 & 0x7FFFFF) != 0)
    {
      v11 = ((*(_QWORD *)a1 + 16 * ((v9 >> 23) & 1) + ((v9 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *(unsigned int *)(*(_QWORD *)a1 + 40);
    }
    else
    {
      v11 = 0;
      v10 = 0;
    }
    mlir::ValueRange::ValueRange((unint64_t *)&v20, v11, v10);
    *(double *)&v8 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::RegionRange,llvm::PointerUnion<mlir::Region *,std::unique_ptr<mlir::Region> const*,mlir::Region **>,mlir::Region *,mlir::Region *,mlir::Region *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::RegionRange,llvm::PointerUnion<mlir::Region *,std::unique_ptr<mlir::Region> const*,mlir::Region **>,mlir::Region *,mlir::Region *,mlir::Region *>::iterator,std::back_insert_iterator<llvm::SmallVectorImpl<mlir::RegionSuccessor>>>(v20, 0, v20, v21[0], a3, (uint64_t)&v20);
  }
  return *(double *)&v8;
}

void mlir::scf::IndexSwitchOp::getEntrySuccessorRegions(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v31;
  unint64_t *v32;
  unint64_t *v33;
  unsigned int v34;
  unint64_t *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  __int128 v40;
  unint64_t v41;
  BOOL v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  char v46[8];
  char v47;
  uint64_t v48;
  __int128 v49;
  _QWORD *v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(*a1 + 56);
  v9 = *(unsigned int *)(*a1 + 44);
  v10 = (uint64_t *)(*a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(*a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v52, v12, v11);
  v45 = v8;
  v46[0] = 0;
  v47 = 0;
  v48 = *v10;
  v49 = v52;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v45);
    if (v47)
      v47 = 0;
    mlir::OperationName::OperationName(v46, "scf.index_switch", 16, Context);
    v47 = 1;
  }
  v50 = a2;
  v51 = a3;
  v14 = *a2;
  if (*a2)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v14 = 0;
    v44 = v14;
    if (v14)
    {
      *(_QWORD *)&v52 = *(_QWORD *)(*a1 + 16 * (((unint64_t)*(unsigned int *)(*a1 + 44) >> 23) & 1) + 64);
      v16 = (uint64_t *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v52);
      v17 = *a1;
      v18 = *(unsigned int *)(*a1 + 44);
      v19 = v18 & 0x7FFFFF;
      if ((v18 & 0x7FFFFF) != 0)
      {
        v20 = ((v17 + 16 * ((v18 >> 23) & 1) + ((v18 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
            + 32 * *(unsigned int *)(v17 + 40);
        v21 = v19 - 1;
        if (!v15)
          goto LABEL_26;
      }
      else
      {
        v20 = 0;
        v21 = -1;
        if (!v15)
          goto LABEL_26;
      }
      if (v21)
      {
        v25 = v20 + 24;
        v26 = 24 * ((int)v21 + 1) - 48;
        v27 = 8 * v15 - 8;
        while (1)
        {
          v28 = *v16;
          if (v28 == mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v44))
            break;
          if (v27)
          {
            ++v16;
            v25 += 24;
            v29 = v26;
            v26 -= 24;
            v27 -= 8;
            if (v29)
              continue;
          }
          v17 = *a1;
          LODWORD(v18) = *(_DWORD *)(*a1 + 44);
          LODWORD(v19) = v18 & 0x7FFFFF;
          goto LABEL_26;
        }
        v34 = *(_DWORD *)(a4 + 8);
        if (v34 < *(_DWORD *)(a4 + 12))
        {
          v35 = (unint64_t *)(*(_QWORD *)a4 + 24 * v34);
          *v35 = v25;
          v33 = v35 + 1;
          goto LABEL_33;
        }
        *(_QWORD *)&v52 = v25;
        goto LABEL_36;
      }
LABEL_26:
      if ((_DWORD)v19)
      {
        v30 = ((v17 + 16 * ((v18 >> 23) & 1) + ((v18 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
            + 32 * *(unsigned int *)(v17 + 40);
        v31 = *(_DWORD *)(a4 + 8);
        if (v31 < *(_DWORD *)(a4 + 12))
        {
LABEL_28:
          v32 = (unint64_t *)(*(_QWORD *)a4 + 24 * v31);
          *v32 = v30;
          v33 = v32 + 1;
LABEL_33:
          mlir::ValueRange::ValueRange(v33, 0, 0);
LABEL_34:
          ++*(_DWORD *)(a4 + 8);
          return;
        }
      }
      else
      {
        v30 = 0;
        v31 = *(_DWORD *)(a4 + 8);
        if (v31 < *(_DWORD *)(a4 + 12))
          goto LABEL_28;
      }
      *(_QWORD *)&v52 = v30;
LABEL_36:
      v36 = (char *)&v52;
      mlir::ValueRange::ValueRange((unint64_t *)&v52 + 1, 0, 0);
      v37 = *(unsigned int *)(a4 + 8);
      v38 = *(_QWORD *)a4;
      if (v37 >= *(_DWORD *)(a4 + 12))
      {
        v41 = v37 + 1;
        v42 = v38 + 24 * v37 > (unint64_t)&v52;
        if (v38 <= (unint64_t)&v52 && v42)
        {
          v43 = (char *)&v52 - v38;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v41, 24);
          v38 = *(_QWORD *)a4;
          v36 = &v43[*(_QWORD *)a4];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v41, 24);
          v38 = *(_QWORD *)a4;
          v36 = (char *)&v52;
        }
      }
      v39 = v38 + 24 * *(unsigned int *)(a4 + 8);
      v40 = *(_OWORD *)v36;
      *(_QWORD *)(v39 + 16) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v39 = v40;
      goto LABEL_34;
    }
  }
  v22 = *(unsigned int *)(*a1 + 44);
  v23 = v22 & 0x7FFFFF;
  if ((v22 & 0x7FFFFF) != 0)
  {
    v24 = ((*a1 + 16 * ((v22 >> 23) & 1) + ((v22 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(*a1 + 40);
  }
  else
  {
    v24 = 0;
    v23 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v52, v24, v23);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::RegionRange,llvm::PointerUnion<mlir::Region *,std::unique_ptr<mlir::Region> const*,mlir::Region **>,mlir::Region *,mlir::Region *,mlir::Region *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::RegionRange,llvm::PointerUnion<mlir::Region *,std::unique_ptr<mlir::Region> const*,mlir::Region **>,mlir::Region *,mlir::Region *,mlir::Region *>::iterator,std::back_insert_iterator<llvm::SmallVectorImpl<mlir::RegionSuccessor>>>(v52, 0, v52, *((uint64_t *)&v52 + 1), a4, (uint64_t)&v52);
}

void mlir::scf::IndexSwitchOp::getRegionInvocationBounds(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t Int;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE v27[12];

  v6 = *a2;
  if (!*a2)
    goto LABEL_13;
  if (*(_UNKNOWN **)(*(_QWORD *)v6 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v6 = 0;
  v26 = v6;
  if (!v6)
  {
LABEL_13:
    v18 = *(_DWORD *)(*(_QWORD *)a1 + 44) & 0x7FFFFF;
    v19 = *(unsigned int *)(a4 + 8);
    if (v19 + v18 > (unint64_t)*(unsigned int *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + v18, 12);
      LODWORD(v19) = *(_DWORD *)(a4 + 8);
      if ((_DWORD)v18)
      {
LABEL_15:
        v20 = *(_QWORD *)a4 + 12 * v19;
        v21 = v18;
        do
        {
          *(_QWORD *)v20 = 0x100000000;
          *(_DWORD *)(v20 + 8) = 1;
          v20 += 12;
          --v21;
        }
        while (v21);
        LODWORD(v19) = *(_DWORD *)(a4 + 8);
      }
    }
    else if ((_DWORD)v18)
    {
      goto LABEL_15;
    }
    *(_DWORD *)(a4 + 8) = v19 + v18;
    return;
  }
  v7 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  *(_QWORD *)v27 = *(_QWORD *)(*(_QWORD *)a1 + 16 * ((v7 >> 23) & 1) + 64);
  v8 = (_QWORD *)mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v27);
  v10 = v9;
  Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v26);
  if (v10)
  {
    v12 = 8 * v10;
    v13 = &v8[v10];
    while (*v8 != Int)
    {
      ++v8;
      v12 -= 8;
      if (!v12)
      {
        v8 = v13;
        break;
      }
    }
  }
  *(_QWORD *)v27 = *(_QWORD *)(*(_QWORD *)a1
                             + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1)
                             + 64);
  v14 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v27);
  if (v8 == (_QWORD *)(v14 + 8 * v15))
  {
    LODWORD(v16) = (v7 & 0x7FFFFF) - 1;
    v17 = *(_DWORD *)(*(_QWORD *)a1 + 44) & 0x7FFFFF;
    if (!v17)
      return;
  }
  else
  {
    *(_QWORD *)v27 = *(_QWORD *)(*(_QWORD *)a1
                               + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1)
                               + 64);
    v16 = ((unint64_t)v8
         - mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v27)) >> 3;
    v17 = *(_DWORD *)(*(_QWORD *)a1 + 44) & 0x7FFFFF;
    if (!v17)
      return;
  }
  v22 = *(_DWORD *)(a4 + 8);
  do
  {
    while (v22 < *(_DWORD *)(a4 + 12))
    {
      v23 = *(_QWORD *)a4 + 12 * v22;
      *(_DWORD *)v23 = 0;
      *(_QWORD *)(v23 + 4) = ((_DWORD)v16 == 0) | 0x100000000;
      v22 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v22;
      LODWORD(v16) = v16 - 1;
      if (!--v17)
        return;
    }
    *(_DWORD *)v27 = 0;
    *(_QWORD *)&v27[4] = ((_DWORD)v16 == 0) | 0x100000000;
    v24 = *(_QWORD *)v27;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v22 + 1, 12);
    v25 = *(_QWORD *)a4 + 12 * *(unsigned int *)(a4 + 8);
    *(_QWORD *)v25 = v24;
    *(_DWORD *)(v25 + 8) = 1;
    v22 = *(_DWORD *)(a4 + 8) + 1;
    *(_DWORD *)(a4 + 8) = v22;
    LODWORD(v16) = v16 - 1;
    --v17;
  }
  while (v17);
}

uint64_t mlir::scf::IndexSwitchOp::fold(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  unint64_t ConstantIntValue;
  char v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _DWORD *v23;
  unsigned int v24;
  BOOL v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *i;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  BOOL v42;
  uint64_t v43;
  unint64_t v44;
  const double *v45;
  int8x16_t *v46;
  unint64_t v47;
  const double *v48;
  unsigned __int128 v49;
  unsigned __int128 v50;
  int8x16_t v51;
  unint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;

  ConstantIntValue = mlir::getConstantIntValue(*(_QWORD *)((*a1)[9] + 24) | 4);
  if (!v6)
    return 0;
  v7 = ConstantIntValue;
  v55 = (*a1)[2 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1) + 8];
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v55);
  v8 = 0;
  v10 = v9;
  if (v9)
  {
    while (1)
    {
      v55 = (*a1)[2 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1) + 8];
      if (v7 == *(_QWORD *)(mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v55)
                           + 8 * v8))
        break;
      if (v10 == ++v8)
      {
        v8 = v10;
        break;
      }
    }
  }
  v55 = (*a1)[2 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1) + 8];
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v55);
  v11 = *a1;
  v12 = *((unsigned int *)*a1 + 11);
  if (v8 >= v13)
  {
    v15 = (((unint64_t)&v11[2 * ((v12 >> 23) & 1) + 8] + ((v12 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v11 + 10);
  }
  else
  {
    if ((v12 & 0x7FFFFF) != 0)
      v14 = (((unint64_t)&v11[2 * ((v12 >> 23) & 1) + 8] + ((v12 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *((unsigned int *)v11 + 10);
    else
      v14 = 0;
    v15 = v14 + 24 * v8 + 24;
  }
  v16 = *(_QWORD *)(v15 + 8);
  if (v16)
    v17 = v16 - 8;
  else
    v17 = 0;
  mlir::Block::getTerminator((ZinIrHalH13g **)v17);
  if ((*(_BYTE *)(v18 + 46) & 0x80) != 0)
  {
    v19 = *(_QWORD *)(v18 + 72);
    mlir::Block::getTerminator((ZinIrHalH13g **)v17);
    if ((*(_BYTE *)(v20 + 46) & 0x80) != 0)
      goto LABEL_17;
LABEL_30:
    v22 = 0;
    v24 = 0;
    *(_DWORD *)(a3 + 8) = 0;
    v23 = (_DWORD *)(a3 + 8);
    v25 = v19 != 0;
    goto LABEL_21;
  }
  v19 = 0;
  mlir::Block::getTerminator((ZinIrHalH13g **)v17);
  if ((*(_BYTE *)(v20 + 46) & 0x80) == 0)
    goto LABEL_30;
LABEL_17:
  v21 = *(_QWORD *)(v20 + 72);
  v22 = *(unsigned int *)(v20 + 68);
  *(_DWORD *)(a3 + 8) = 0;
  v23 = (_DWORD *)(a3 + 8);
  if (v22 <= *(_DWORD *)(a3 + 12))
  {
    v24 = 0;
    v25 = v19 != v21;
    if (v22)
      goto LABEL_31;
    goto LABEL_21;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v22, 8);
  v24 = *(_DWORD *)(a3 + 8);
  v25 = v19 != v21;
  if (!v22)
  {
LABEL_21:
    if (v25)
      goto LABEL_31;
    *v23 = v24 + v22;
    v26 = *a1;
    v27 = (*a1)[2];
    if (v27)
      goto LABEL_23;
    return 0;
  }
LABEL_31:
  v36 = *(_QWORD *)a3;
  v37 = (uint64_t *)(*(_QWORD *)a3 + 8 * v24);
  if (v25)
  {
    for (i = (uint64_t *)(v19 + 24); ; i += 4)
    {
      v39 = *i;
      *v37++ = v39 | 4;
    }
  }
  if (v22 > 0xA
    && ((v40 = v24, v41 = v36 + 8 * (v22 + v24), (unint64_t)v37 < v19 + 32 * v22)
      ? (v42 = v19 + 24 >= v41)
      : (v42 = 1),
        v42))
  {
    v43 = v22 & 3;
    if ((v22 & 3) == 0)
      v43 = 4;
    v44 = v22 - v43;
    v37 += v44;
    v45 = (const double *)(v19 + 88);
    v46 = (int8x16_t *)(v36 + 8 * v40 + 16);
    v47 = v44;
    do
    {
      v48 = v45 - 8;
      v49 = (unsigned __int128)vld4q_f64(v48);
      v50 = (unsigned __int128)vld4q_f64(v45);
      v51 = (int8x16_t)vdupq_n_s64(4uLL);
      v46[-1] = vorrq_s8((int8x16_t)v49, v51);
      *v46 = vorrq_s8((int8x16_t)v50, v51);
      v45 += 16;
      v46 += 2;
      v47 -= 4;
    }
    while (v47);
  }
  else
  {
    v44 = 0;
  }
  v52 = v22 - v44;
  v53 = (uint64_t *)(v19 + 32 * v44 + 24);
  do
  {
    v54 = *v53;
    v53 += 4;
    *v37++ = v54 | 4;
    --v52;
  }
  while (v52);
  *v23 += v22;
  v26 = *a1;
  v27 = (*a1)[2];
  if (!v27)
    return 0;
LABEL_23:
  v29 = *(uint64_t **)(v17 + 32);
  v28 = *(uint64_t **)(v17 + 40);
  v30 = v17 + 32;
  if (v28 != v29 && v26 != v29)
  {
    llvm::ilist_traits<mlir::Operation>::transferNodesFromList(v27 + 32, v30, (uint64_t)v28, (uint64_t)v29);
    v32 = *v29;
    v33 = *v28;
    *(_QWORD *)(v33 + 8) = v29;
    *v29 = v33;
    v34 = *v26;
    *(_QWORD *)(v32 + 8) = v26;
    *v28 = v34;
    *(_QWORD *)(v34 + 8) = v28;
    *v26 = v32;
  }
  return 1;
}

uint64_t mlir::scf::detail::ConditionOpGenericAdaptorBase::ConditionOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "scf.condition", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::scf::ConditionOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  mlir::OperationState::addOperands(a2, a6, a7);
  v12 = *(unsigned int *)(a2 + 72);
  if (a4 + v12 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v12, 8);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  if (a4)
  {
    v13 = 0;
    v14 = *(_QWORD *)(a2 + 64) + 8 * v12;
    do
    {
      *(_QWORD *)(v14 + 8 * v13) = mlir::TypeRange::dereference_iterator(a3, v13);
      ++v13;
    }
    while (a4 != v13);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v12 + a4;
}

BOOL mlir::scf::ConditionOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::Builder *v5;
  uint64_t IntegerType;
  uint64_t v7;
  _BOOL8 v8;
  void *v10[2];
  uint64_t v11;
  void *v12;
  uint64_t v13;
  _BYTE v14[128];
  _QWORD v15[5];

  v15[4] = *MEMORY[0x24BDAC8D0];
  memset(v15, 0, 24);
  v12 = v14;
  v13 = 0x400000000;
  v10[0] = &v11;
  v10[1] = (void *)0x100000000;
  v8 = (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1)
    && ((*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v15, 1))
    && (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1)
    && ((*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        (*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    && (v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        (*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v12, 0, 1, 0xFFFFFFFFLL))&& (!(_DWORD)v13|| (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)&& mlir::AsmParser::parseTypeList(a1, (uint64_t)v10))&& (v5 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1), IntegerType = mlir::Builder::getIntegerType(v5, 1u), v7 = a2 + 16, (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v15, IntegerType, v7))&& mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v12,
                          (uint64_t)v10,
                          v4,
                          v7) != 0;
  if (v10[0] != &v11)
    free(v10[0]);
  if (v12 != v14)
    free(v12);
  return v8;
}

void mlir::scf::ConditionOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  mlir::Operation *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  mlir::Operation *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30[2];
  const char *AttrDictionary;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[2];
  void *v36;
  uint64_t v37;
  _QWORD v38[5];

  v38[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "(", 1uLL);
  }
  else
  {
    *v5 = 40;
    ++*((_QWORD *)v4 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, ")", 1uLL);
  }
  else
  {
    *v7 = 41;
    ++*((_QWORD *)v6 + 4);
  }
  v36 = v38;
  v37 = 0x200000000;
  v8 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = (const char *)mlir::Operation::getAttrDictionary(v8);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v8 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v11, v36, v37);
  if ((*((_BYTE *)*this + 46) & 0x80) == 0 || *((_DWORD *)*this + 17) != 1)
  {
    v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v13 = (_BYTE *)*((_QWORD *)v12 + 4);
    if ((unint64_t)v13 >= *((_QWORD *)v12 + 3))
    {
      llvm::raw_ostream::write(v12, 32);
    }
    else
    {
      *((_QWORD *)v12 + 4) = v13 + 1;
      *v13 = 32;
    }
    v14 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
      v15 = *((unsigned int *)v14 + 17);
      v16 = *((_QWORD *)v14 + 9);
      v17 = v15 - 1;
    }
    else
    {
      v16 = 0;
      v17 = -1;
    }
    v18 = v16 + 32;
    v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    AttrDictionary = ", ";
    v32 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v18, 0, v18, v17, (uint64_t)a2, v19, (uint64_t)&AttrDictionary);
    v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v21 = (_BYTE *)*((_QWORD *)v20 + 4);
    if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
    {
      llvm::raw_ostream::write(v20, 32);
    }
    else
    {
      *((_QWORD *)v20 + 4) = v21 + 1;
      *v21 = 32;
    }
    v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v23 = (_BYTE *)*((_QWORD *)v22 + 4);
    if (*((_BYTE **)v22 + 3) == v23)
    {
      llvm::raw_ostream::write(v22, ":", 1uLL);
    }
    else
    {
      *v23 = 58;
      ++*((_QWORD *)v22 + 4);
    }
    v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v25 = (_BYTE *)*((_QWORD *)v24 + 4);
    if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
    {
      llvm::raw_ostream::write(v24, 32);
    }
    else
    {
      *((_QWORD *)v24 + 4) = v25 + 1;
      *v25 = 32;
    }
    v26 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
      v27 = *((unsigned int *)v26 + 17);
      v28 = *((_QWORD *)v26 + 9);
      v29 = v27 - 1;
    }
    else
    {
      v28 = 0;
      v29 = -1;
    }
    v30[0] = v28 + 32;
    v30[1] = v29;
    mlir::OperandRange::getTypes(v30, (uint64_t *)&AttrDictionary);
    v35[0] = ", ";
    v35[1] = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)AttrDictionary, v32, v33, v34, (uint64_t)a2, (uint64_t)a2, (uint64_t)v35);
  }
  if (v36 != v38)
    free(v36);
}

BOOL mlir::scf::ForOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (!mlir::scf::__mlir_ods_local_type_constraint_SCFOps2(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::scf::__mlir_ods_local_type_constraint_SCFOps2(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::scf::__mlir_ods_local_type_constraint_SCFOps2(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 2u))
  {
    return 0;
  }
  v2 = *this;
  v3 = *((unsigned int *)*this + 9);
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  if ((_DWORD)v3)
  {
    for (i = 0; i != v3; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, i);
    v2 = *this;
  }
  v6 = (_QWORD *)v2[9];
  v7 = *(_QWORD *)(v6[3] + 8) & 0xFFFFFFFFFFFFFFF8;
  if (v7 == (*(_QWORD *)(v6[7] + 8) & 0xFFFFFFFFFFFFFFF8)
    && v7 == (*(_QWORD *)(v6[11] + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(v2, (((unint64_t)&v2[2 * (((unint64_t)*((unsigned int *)v2 + 11) >> 23) & 1) + 8]+ ((*((_DWORD *)v2 + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v2 + 10), (uint64_t)"region", 6, 0) != 0;
  }
  v18 = (const void **)"failed to verify that all of {lowerBound, upperBound, step} have same type";
  v19 = 259;
  mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
  if (v20[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
  if (v27)
  {
    v9 = __p;
    if (__p)
    {
      v10 = v26;
      v11 = __p;
      if (v26 != __p)
      {
        do
          v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
        while (v10 != v9);
        v11 = __p;
      }
      v26 = v9;
      operator delete(v11);
    }
    v12 = v23;
    if (v23)
    {
      v13 = v24;
      v14 = v23;
      if (v24 != v23)
      {
        do
        {
          v16 = *--v13;
          v15 = v16;
          *v13 = 0;
          if (v16)
            MEMORY[0x20BD002D4](v15, 0x1000C8077774924);
        }
        while (v13 != v12);
        v14 = v23;
      }
      v24 = v12;
      operator delete(v14);
    }
    if (v21 != &v22)
      free(v21);
  }
  return v8;
}

uint64_t mlir::scf::__mlir_ods_local_type_constraint_SCFOps2(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  char *v21;
  char *v22;
  __int128 v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  int64_t v43;
  int64_t v44;
  int64_t v45;
  int64_t v46;
  const void **v47[4];
  __int16 v48;
  uint64_t v49;
  int v50;
  const char *v51;
  uint64_t v52;
  _QWORD v53[3];
  void *v54;
  unsigned int v55;
  unsigned int v56;
  _BYTE v57[96];
  void *v58;
  _QWORD *v59;
  void *__p;
  _QWORD *v61;
  char v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  v49 = a2;
  if (mlir::Type::isSignlessIntOrIndex((mlir::Type *)&v49))
    return 1;
  v48 = 261;
  v47[0] = a3;
  v47[1] = a4;
  mlir::Operation::emitOpError(a1, v47, (uint64_t)v53);
  if (v53[0])
  {
    v50 = 3;
    v51 = " #";
    v52 = 2;
    v10 = &v50;
    v11 = (char *)v54;
    if (v55 >= v56)
    {
      v37 = v55 + 1;
      if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
      {
        v43 = (char *)&v50 - (_BYTE *)v54;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v37, 24);
        v11 = (char *)v54;
        v10 = (int *)((char *)v54 + v43);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v37, 24);
        v10 = &v50;
        v11 = (char *)v54;
      }
    }
    v12 = &v11[24 * v55];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    v14 = ++v55;
    if (v53[0])
    {
      v50 = 5;
      v51 = (const char *)a5;
      v15 = &v50;
      v16 = (char *)v54;
      if (v14 >= v56)
      {
        v38 = v14 + 1;
        v39 = (char *)v54 + 24 * v14 > (char *)&v50;
        if (v54 <= &v50 && v39)
        {
          v44 = (char *)&v50 - (_BYTE *)v54;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
          v16 = (char *)v54;
          v15 = (int *)((char *)v54 + v44);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
          v15 = &v50;
          v16 = (char *)v54;
        }
      }
      v17 = &v16[24 * v55];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v17 = v18;
      v19 = ++v55;
      if (v53[0])
      {
        v50 = 3;
        v51 = " must be signless integer or index, but got ";
        v52 = 44;
        v20 = &v50;
        v21 = (char *)v54;
        if (v19 >= v56)
        {
          v40 = v19 + 1;
          v41 = (char *)v54 + 24 * v19 > (char *)&v50;
          if (v54 <= &v50 && v41)
          {
            v45 = (char *)&v50 - (_BYTE *)v54;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v40, 24);
            v21 = (char *)v54;
            v20 = (int *)((char *)v54 + v45);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v40, 24);
            v20 = &v50;
            v21 = (char *)v54;
          }
        }
        v22 = &v21[24 * v55];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
        *(_OWORD *)v22 = v23;
        ++v55;
        if (v53[0])
        {
          v24 = &v50;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v50, v49);
          v25 = (char *)v54;
          if (v55 >= v56)
          {
            v42 = v55 + 1;
            if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
            {
              v46 = (char *)&v50 - (_BYTE *)v54;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v42, 24);
              v25 = (char *)v54;
              v24 = (int *)((char *)v54 + v46);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v42, 24);
              v24 = &v50;
              v25 = (char *)v54;
            }
          }
          v26 = &v25[24 * v55];
          v27 = *(_OWORD *)v24;
          *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
          *(_OWORD *)v26 = v27;
          ++v55;
        }
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
  if (v53[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
  if (v62)
  {
    v28 = __p;
    if (__p)
    {
      v29 = v61;
      v30 = __p;
      if (v61 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v61 = v28;
      operator delete(v30);
    }
    v31 = v58;
    if (v58)
    {
      v32 = v59;
      v33 = v58;
      if (v59 != v58)
      {
        do
        {
          v35 = *--v32;
          v34 = v35;
          *v32 = 0;
          if (v35)
            MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
        }
        while (v32 != v31);
        v33 = v58;
      }
      v59 = v31;
      operator delete(v33);
    }
    if (v54 != v57)
      free(v54);
  }
  return v9;
}

uint64_t mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v8;
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  _QWORD v31[4];
  __int16 v32;
  const void **v33[4];
  __int16 v34;
  const void **v35;
  __int16 v36;
  int v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  unsigned int v43;
  unsigned int v44;
  _BYTE v45[96];
  void *v46;
  _QWORD *v47;
  void *__p;
  _QWORD *v49;
  char v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a2 + 8);
  if (v8 != a2 && *(_QWORD *)(v8 + 8) == a2)
    return 1;
  v35 = (const void **)"region #";
  v36 = 259;
  mlir::Operation::emitOpError(a1, &v35, (uint64_t)&v40);
  if (v40)
  {
    LODWORD(v33[0]) = 5;
    v33[1] = (const void **)a5;
    v9 = v33;
    v10 = (char *)v42;
    if (v43 >= v44)
    {
      v27 = v43 + 1;
      if (v42 <= v33 && (char *)v42 + 24 * v43 > (char *)v33)
      {
        v29 = (char *)v33 - (_BYTE *)v42;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v27, 24);
        v10 = (char *)v42;
        v9 = (const void ***)((char *)v42 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v27, 24);
        v9 = v33;
        v10 = (char *)v42;
      }
    }
    v11 = &v10[24 * v43];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v43;
  }
  if (a4)
  {
    v32 = 1283;
    v31[0] = " ('";
    v31[2] = a3;
    v31[3] = a4;
    v33[0] = (const void **)v31;
    v33[2] = (const void **)"') ";
    v34 = 770;
    if (!v40)
      goto LABEL_13;
LABEL_10:
    mlir::Diagnostic::operator<<((uint64_t)&v41, v33);
    if (v40)
    {
      v37 = 3;
      v38 = "failed to verify constraint: region with 1 blocks";
      v39 = 49;
      v13 = &v37;
      v14 = (char *)v42;
      if (v43 >= v44)
      {
        v28 = v43 + 1;
        if (v42 <= &v37 && (char *)v42 + 24 * v43 > (char *)&v37)
        {
          v30 = (char *)&v37 - (_BYTE *)v42;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v28, 24);
          v14 = (char *)v42;
          v13 = (int *)((char *)v42 + v30);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v28, 24);
          v13 = &v37;
          v14 = (char *)v42;
        }
      }
      v15 = &v14[24 * v43];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
      *(_OWORD *)v15 = v16;
      ++v43;
    }
    goto LABEL_13;
  }
  v33[0] = (const void **)" ";
  v34 = 259;
  if (v40)
    goto LABEL_10;
LABEL_13:
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v40);
  if (v40)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v40);
  if (v50)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v49;
      v20 = __p;
      if (v49 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v49 = v18;
      operator delete(v20);
    }
    v21 = v46;
    if (v46)
    {
      v22 = v47;
      v23 = v46;
      if (v47 != v46)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v46;
      }
      v47 = v21;
      operator delete(v23);
    }
    if (v42 != v45)
      free(v42);
  }
  return v17;
}

BOOL mlir::scf::ForallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t *v44;
  char *v45;
  char *v46;
  __int128 v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  char *v55;
  char *v56;
  __int128 v57;
  uint64_t *v58;
  char *v59;
  char *v60;
  __int128 v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  char *v69;
  char *v70;
  __int128 v71;
  _QWORD *v72;
  _QWORD *v73;
  void *v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t *v78;
  char *v79;
  char *v80;
  __int128 v81;
  uint64_t *v82;
  char *v83;
  char *v84;
  __int128 v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  int64_t v108;
  int64_t v109;
  int64_t v110;
  uint64_t v111;
  _QWORD *v112;
  const char *v113;
  uint64_t v114;
  _QWORD v115[3];
  void *v116;
  unsigned int v117;
  unsigned int v118;
  _BYTE v119[96];
  void *v120;
  _QWORD *v121;
  void *__p;
  _QWORD *v123;
  char v124;
  uint64_t v125;

  v125 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v111 = v6;
  if (!v6)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v113 = "expected DictionaryAttr to set properties";
      v114 = 41;
      v26 = (uint64_t *)&v112;
      v27 = (char *)v116;
      if (v117 >= v118)
      {
        v93 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v102 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          v27 = (char *)v116;
          v26 = (uint64_t *)((char *)v116 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          v26 = (uint64_t *)&v112;
          v27 = (char *)v116;
        }
      }
      v28 = &v27[24 * v117];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v117;
      if (v115[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
    }
    if (!v124)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v123;
      v32 = __p;
      if (v123 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v123 = v30;
      operator delete(v32);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_122;
    v33 = v121;
    v23 = v120;
    if (v121 == v120)
    {
LABEL_121:
      v121 = v21;
      operator delete(v23);
LABEL_122:
      if (v116 != v119)
        free(v116);
      return 0;
    }
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
LABEL_120:
    v23 = v120;
    goto LABEL_121;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v111, "mapping", 7uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      a3(v115, a4);
      if (v115[0])
      {
        LODWORD(v112) = 3;
        v114 = 52;
        v10 = (uint64_t *)&v112;
        v11 = (char *)v116;
        if (v117 >= v118)
        {
          v94 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            v103 = (char *)&v112 - (_BYTE *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            v11 = (char *)v116;
            v10 = (uint64_t *)((char *)v116 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            v10 = (uint64_t *)&v112;
            v11 = (char *)v116;
          }
        }
        v12 = &v11[24 * v117];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v117;
        if (v115[0])
        {
          v14 = (uint64_t *)&v112;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v9);
          v15 = (char *)v116;
          if (v117 >= v118)
          {
            v95 = v117 + 1;
            if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
            {
              v104 = (char *)&v112 - (_BYTE *)v116;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              v15 = (char *)v116;
              v14 = (uint64_t *)((char *)v116 + v104);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              v14 = (uint64_t *)&v112;
              v15 = (char *)v116;
            }
          }
          v16 = &v15[24 * v117];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v117;
          if (v115[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
      }
      if (!v124)
        return 0;
      v18 = __p;
      if (__p)
      {
        v19 = v123;
        v20 = __p;
        if (v123 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v123 = v18;
        operator delete(v20);
      }
      v21 = v120;
      if (!v120)
        goto LABEL_122;
      v22 = v121;
      v23 = v120;
      if (v121 == v120)
        goto LABEL_121;
      do
      {
        v25 = *--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v22 != v21);
      goto LABEL_120;
    }
    *a1 = v8;
  }
  v36 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v111, "staticLowerBound", 0x10uLL);
  if (!v36)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v113 = "expected key entry for staticLowerBound in DictionaryAttr to set Properties.";
      v114 = 76;
      v44 = (uint64_t *)&v112;
      v45 = (char *)v116;
      if (v117 >= v118)
      {
        v96 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v105 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          v45 = (char *)v116;
          v44 = (uint64_t *)((char *)v116 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          v44 = (uint64_t *)&v112;
          v45 = (char *)v116;
        }
      }
      v46 = &v45[24 * v117];
      v47 = *(_OWORD *)v44;
      *((_QWORD *)v46 + 2) = v44[2];
      *(_OWORD *)v46 = v47;
      ++v117;
      if (v115[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
    }
    if (!v124)
      return 0;
    v48 = __p;
    if (__p)
    {
      v49 = v123;
      v50 = __p;
      if (v123 != __p)
      {
        do
          v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        v50 = __p;
      }
      v123 = v48;
      operator delete(v50);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_122;
    v51 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_121;
    do
    {
      v53 = *--v51;
      v52 = v53;
      *v51 = 0;
      if (v53)
        MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
    }
    while (v51 != v21);
    goto LABEL_120;
  }
  v37 = (uint64_t)v36;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v36))
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v114 = 61;
      v54 = (uint64_t *)&v112;
      v55 = (char *)v116;
      if (v117 >= v118)
      {
        v97 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v106 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          v55 = (char *)v116;
          v54 = (uint64_t *)((char *)v116 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          v54 = (uint64_t *)&v112;
          v55 = (char *)v116;
        }
      }
      v56 = &v55[24 * v117];
      v57 = *(_OWORD *)v54;
      *((_QWORD *)v56 + 2) = v54[2];
      *(_OWORD *)v56 = v57;
      ++v117;
      if (v115[0])
      {
        v58 = (uint64_t *)&v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v37);
        v59 = (char *)v116;
        if (v117 >= v118)
        {
          v98 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            v107 = (char *)&v112 - (_BYTE *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            v59 = (char *)v116;
            v58 = (uint64_t *)((char *)v116 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            v58 = (uint64_t *)&v112;
            v59 = (char *)v116;
          }
        }
        v60 = &v59[24 * v117];
        v61 = *(_OWORD *)v58;
        *((_QWORD *)v60 + 2) = v58[2];
        *(_OWORD *)v60 = v61;
        ++v117;
        if (v115[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124)
      return 0;
    v62 = __p;
    if (__p)
    {
      v63 = v123;
      v64 = __p;
      if (v123 != __p)
      {
        do
          v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
        while (v63 != v62);
        v64 = __p;
      }
      v123 = v62;
      operator delete(v64);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_122;
    v65 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_121;
    do
    {
      v67 = *--v65;
      v66 = v67;
      *v65 = 0;
      if (v67)
        MEMORY[0x20BD002D4](v66, 0x1000C8077774924);
    }
    while (v65 != v21);
    goto LABEL_120;
  }
  a1[1] = v37;
  v38 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v111, "staticStep", 0xAuLL);
  if (!v38)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v113 = "expected key entry for staticStep in DictionaryAttr to set Properties.";
      v114 = 70;
      v68 = (uint64_t *)&v112;
      v69 = (char *)v116;
      if (v117 >= v118)
      {
        v99 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v108 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          v69 = (char *)v116;
          v68 = (uint64_t *)((char *)v116 + v108);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          v68 = (uint64_t *)&v112;
          v69 = (char *)v116;
        }
      }
      v70 = &v69[24 * v117];
      v71 = *(_OWORD *)v68;
      *((_QWORD *)v70 + 2) = v68[2];
      *(_OWORD *)v70 = v71;
      ++v117;
      if (v115[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
    }
    if (!v124)
      return 0;
    v72 = __p;
    if (__p)
    {
      v73 = v123;
      v74 = __p;
      if (v123 != __p)
      {
        do
          v73 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v73 - 1);
        while (v73 != v72);
        v74 = __p;
      }
      v123 = v72;
      operator delete(v74);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_122;
    v75 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_121;
    do
    {
      v77 = *--v75;
      v76 = v77;
      *v75 = 0;
      if (v77)
        MEMORY[0x20BD002D4](v76, 0x1000C8077774924);
    }
    while (v75 != v21);
    goto LABEL_120;
  }
  v39 = (uint64_t)v38;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v38))
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v114 = 55;
      v78 = (uint64_t *)&v112;
      v79 = (char *)v116;
      if (v117 >= v118)
      {
        v100 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v109 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          v79 = (char *)v116;
          v78 = (uint64_t *)((char *)v116 + v109);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          v78 = (uint64_t *)&v112;
          v79 = (char *)v116;
        }
      }
      v80 = &v79[24 * v117];
      v81 = *(_OWORD *)v78;
      *((_QWORD *)v80 + 2) = v78[2];
      *(_OWORD *)v80 = v81;
      ++v117;
      if (v115[0])
      {
        v82 = (uint64_t *)&v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v39);
        v83 = (char *)v116;
        if (v117 >= v118)
        {
          v101 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            v110 = (char *)&v112 - (_BYTE *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            v83 = (char *)v116;
            v82 = (uint64_t *)((char *)v116 + v110);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            v82 = (uint64_t *)&v112;
            v83 = (char *)v116;
          }
        }
        v84 = &v83[24 * v117];
        v85 = *(_OWORD *)v82;
        *((_QWORD *)v84 + 2) = v82[2];
        *(_OWORD *)v84 = v85;
        ++v117;
        if (v115[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124)
      return 0;
    v86 = __p;
    if (__p)
    {
      v87 = v123;
      v88 = __p;
      if (v123 != __p)
      {
        do
          v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
        while (v87 != v86);
        v88 = __p;
      }
      v123 = v86;
      operator delete(v88);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_122;
    v89 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_121;
    do
    {
      v91 = *--v89;
      v90 = v91;
      *v89 = 0;
      if (v91)
        MEMORY[0x20BD002D4](v90, 0x1000C8077774924);
    }
    while (v89 != v21);
    goto LABEL_120;
  }
  a1[2] = v39;
  v40 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v111, "staticUpperBound", 0x10uLL);
  v112 = v40;
  if (!v40)
  {
    a3(v115, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for staticUpperBound in DictionaryAttr to set Properties.");
LABEL_128:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v115);
    return 0;
  }
  v41 = v40;
  if (!mlir::detail::DenseArrayAttrImpl<long long>::classof(v40))
  {
    a3(v115, a4);
    mlir::InFlightDiagnostic::append<mlir::Attribute>(v92, (uint64_t *)&v112);
    goto LABEL_128;
  }
  a1[3] = (uint64_t)v41;
  v42 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v111, "operandSegmentSizes", 0x13uLL);
  if (!v42)
  {
    v42 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v111, "operand_segment_sizes", 0x15uLL);
    if (!v42)
    {
      a3(v115, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_128;
    }
  }
  return mlir::convertFromAttribute(a1 + 4, (const char *)4, v42, a3, a4) != 0;
}

uint64_t mlir::scf::ForallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  BOOL v33;
  uint64_t v34;
  uint64_t DictionaryAttr;
  void *v36;
  mlir::DictionaryAttr *v38;
  void *v39;
  uint64_t v40;
  _QWORD v41[7];

  v41[6] = *MEMORY[0x24BDAC8D0];
  v38 = a1;
  v39 = v41;
  v40 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v38, (uint64_t)"mapping", 7, *a2);
    v6 = v5;
    v7 = v40;
    if (v40 >= HIDWORD(v40))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 16);
      v7 = v40;
    }
    v8 = (uint64_t *)((char *)v39 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v40) = v40 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v38, (uint64_t)"staticLowerBound", 16, v9);
    v12 = v11;
    v13 = v40;
    if (v40 >= HIDWORD(v40))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 16);
      v13 = v40;
    }
    v14 = (uint64_t *)((char *)v39 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v40) = v40 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v38, (uint64_t)"staticStep", 10, v15);
    v18 = v17;
    v19 = v40;
    if (v40 >= HIDWORD(v40))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 16);
      v19 = v40;
    }
    v20 = (uint64_t *)((char *)v39 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v40) = v40 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v38, (uint64_t)"staticUpperBound", 16, v21);
    v24 = v23;
    v25 = v40;
    if (v40 >= HIDWORD(v40))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 16);
      v25 = v40;
    }
    v26 = (uint64_t *)((char *)v39 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    LODWORD(v40) = v40 + 1;
  }
  v27 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 4), 4);
  v28 = mlir::Builder::getNamedAttr(&v38, (uint64_t)"operandSegmentSizes", 19, v27);
  v30 = v29;
  v31 = v40;
  if (v40 >= HIDWORD(v40))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 16);
    v31 = v40;
  }
  v32 = (uint64_t *)((char *)v39 + 16 * v31);
  *v32 = v28;
  v32[1] = v30;
  v33 = __CFADD__((_DWORD)v40, 1);
  v34 = (v40 + 1);
  LODWORD(v40) = v40 + 1;
  if (v33)
  {
    DictionaryAttr = 0;
    v36 = v39;
    if (v39 == v41)
      return DictionaryAttr;
    goto LABEL_24;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v38, (mlir::MLIRContext *)v39, v34);
  v36 = v39;
  if (v39 != v41)
LABEL_24:
    free(v36);
  return DictionaryAttr;
}

unint64_t mlir::scf::ForallOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v19;
  int v20;
  unint64_t v21;
  int v22;
  int v23;
  unint64_t v24;
  int v25;
  int v26;
  unint64_t v27;
  int v28;
  int v29;
  unint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;

  v1 = *a1;
  v3 = &unk_254519000;
  if ((v2 & 1) == 0)
  {
    v34 = *a1;
    v38 = a1;
    v3 = &unk_254519000;
    v20 = v19;
    v1 = v34;
    a1 = v38;
    if (v20)
    {
      v21 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v21 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v21;
      v1 = v34;
      a1 = v38;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v4 = HIDWORD(v1);
  v5 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v1) ^ HIDWORD(v1));
  v47 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v6 = a1[1];
  if ((v4 & 1) == 0)
  {
    v35 = a1[1];
    v39 = a1;
    v3 = &unk_254519000;
    v23 = v22;
    v6 = v35;
    a1 = v39;
    if (v23)
    {
      v24 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v24 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v24;
      v6 = v35;
      a1 = v39;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v7 = HIDWORD(v6);
  v8 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v6) ^ HIDWORD(v6));
  v46 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v36 = a1[2];
    v40 = a1;
    v3 = &unk_254519000;
    v26 = v25;
    v9 = v36;
    a1 = v40;
    if (v26)
    {
      v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v27 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v27;
      v9 = v36;
      a1 = v40;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v9) ^ HIDWORD(v9));
  v45 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v37 = a1[3];
    v41 = a1;
    v3 = &unk_254519000;
    v29 = v28;
    v12 = v37;
    a1 = v41;
    if (v29)
    {
      v30 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v30 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v30;
      v12 = v37;
      a1 = v41;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v12) ^ HIDWORD(v12));
  v44 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  if ((v13 & 1) == 0)
  {
    v42 = a1;
    v3 = &unk_254519000;
    v32 = v31;
    a1 = v42;
    if (v32)
    {
      v33 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v33 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v33;
      v3 = (_QWORD *)&unk_254519000;
      a1 = v42;
    }
  }
  v15 = a1[5];
  v16 = __ROR8__(v15 + 16, 16);
  v17 = 0x9DDFEA08EB382D69 * (a1[4] ^ v3[373] ^ v16);
  v43 = (0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47))) ^ v15;
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v47, (uint64_t *)&v46, (uint64_t *)&v45, (uint64_t *)&v44, (uint64_t *)&v43);
}

uint64_t mlir::scf::ForallOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, _DWORD *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 7uLL:
      if (*__s1 != 1886413165 || *(_DWORD *)((char *)__s1 + 3) != 1735289200)
        goto LABEL_14;
      return *a2;
    case 8uLL:
    case 9uLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_14;
    case 0xAuLL:
      if (memcmp(__s1, "staticStep", __n))
        goto LABEL_14;
      return a2[2];
    case 0x10uLL:
      if (!memcmp(__s1, "staticLowerBound", __n))
      {
        result = a2[1];
      }
      else if (!memcmp(__s1, "staticUpperBound", __n))
      {
        result = a2[3];
      }
      else
      {
LABEL_14:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_14;
      goto LABEL_16;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_14;
LABEL_16:
      result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 4), 4);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::scf::ForallOp::setInherentAttr(uint64_t result, _DWORD *__s1, size_t __n, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 7uLL:
      if (*__s1 == 1886413165 && *(_DWORD *)((char *)__s1 + 3) == 1735289200)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
            v13 = a4;
          else
            v13 = 0;
          *(_QWORD *)result = v13;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xAuLL:
      result = memcmp(__s1, "staticStep", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v7[2] = v9;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "staticLowerBound", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "staticUpperBound", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
            if ((_DWORD)result)
              v10 = a4;
            else
              v10 = 0;
            v7[3] = v10;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
        if ((_DWORD)result)
          v14 = a4;
        else
          v14 = 0;
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!(_DWORD)result)
        goto LABEL_23;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!(_DWORD)result)
      {
LABEL_23:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v11 = (_DWORD)result ? a4 : 0;
          v15 = v11;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v15);
            if (result == 4)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v15);
              if (v12)
                result = (uint64_t)memmove(v7 + 4, (const void *)result, 4 * v12);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::scf::ForallOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"mapping", 7, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"staticLowerBound", 16, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"staticStep", 10, v7);
  v8 = a2[3];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"staticUpperBound", 16, v8);
  v9 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 4), 4);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v9);
}

BOOL mlir::scf::ForallOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::scf::__mlir_ods_local_attr_constraint_SCFOps1(v8, (const void **)"mapping", (const char *)7, a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v9, (const void **)"staticLowerBound", (const char *)0x10, a3, a4))
    {
      v10 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v10, (const void **)"staticStep", (const char *)0xA, a3, a4))
      {
        v11 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v11, (const void **)"staticUpperBound", (const char *)0x10, a3, a4))
        {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t mlir::scf::__mlir_ods_local_attr_constraint_SCFOps1(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *Value;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  const void **v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    v39 = a1;
    Value = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v27 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v29 = (_QWORD *)(v27 + 8 * v28);
    if (v29 != Value)
    {
      while (*Value && mlir::detail::InterfaceMap::lookup<mlir::DeviceMappingAttrInterface>(*(_QWORD *)*Value + 8))
      {
        if (++Value == v29)
          return 1;
      }
      goto LABEL_3;
    }
    return 1;
  }
LABEL_3:
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    v36 = "attribute '";
    v37 = 11;
    v9 = &v35;
    v10 = (char *)v41;
    if (v42 >= v43)
    {
      v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        v33 = (char *)&v35 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v10 = (char *)v41;
        v9 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v9 = &v35;
        v10 = (char *)v41;
      }
    }
    v11 = &v10[24 * v42];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v42;
    if (v39)
    {
      v38 = 261;
      v35 = a2;
      v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        v36 = "' failed to satisfy constraint: Device Mapping array attribute";
        v37 = 62;
        v13 = &v35;
        v14 = (char *)v41;
        if (v42 >= v43)
        {
          v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            v34 = (char *)&v35 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v14 = (char *)v41;
            v13 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v13 = &v35;
            v14 = (char *)v41;
          }
        }
        v15 = &v14[24 * v42];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = v13[2];
        *(_OWORD *)v15 = v16;
        ++v42;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  if (v49)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v48;
      v20 = __p;
      if (v48 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v48 = v18;
      operator delete(v20);
    }
    v21 = v45;
    if (v45)
    {
      v22 = v46;
      v23 = v45;
      if (v46 != v45)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v45;
      }
      v46 = v21;
      operator delete(v23);
    }
    if (v41 != v44)
      free(v41);
  }
  return v17;
}

BOOL mlir::scf::ForallOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3))
    return 0;
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 5)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 4, v12, 4 * v13);
  }
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3 + 3)&& ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6|| mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 8, (const char *)4));
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  uint64_t *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_OWORD *)operator new();
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::scf::detail::ForallOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[160];
    return a1[32];
  }
  return result;
}

uint64_t mlir::scf::ForallOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)v4);
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 32, 4);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 16));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)(v4 + 24));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 32), 4);
  return result;
}

BOOL mlir::scf::ForallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t ODSOperands;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t i;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  void *v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  const void **v52[4];
  __int16 v53;
  _QWORD v54[3];
  void *v55;
  uint64_t v56;
  void *v57;
  _QWORD *v58;
  void *__p;
  _QWORD *v60;
  char v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = (_QWORD *)v3[1];
  if (!v4)
  {
    v52[0] = (const void **)"requires attribute 'staticLowerBound'";
    v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v54);
    v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
    if (v54[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
    if (!v61)
      return v30;
    v31 = __p;
    if (__p)
    {
      v32 = v60;
      v33 = __p;
      if (v60 != __p)
      {
        do
          v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v32 - 1);
        while (v32 != v31);
        v33 = __p;
      }
      v60 = v31;
      operator delete(v33);
    }
    v34 = v57;
    if (v57)
    {
      v35 = v58;
      v36 = v57;
      if (v58 == v57)
        goto LABEL_82;
      do
      {
        v38 = *--v35;
        v37 = v38;
        *v35 = 0;
        if (v38)
          MEMORY[0x20BD002D4](v37, 0x1000C8077774924);
      }
      while (v35 != v34);
LABEL_81:
      v36 = v57;
LABEL_82:
      v58 = v34;
      operator delete(v36);
    }
LABEL_83:
    if (v55 != &v56)
      free(v55);
    return v30;
  }
  v5 = (_QWORD *)v3[2];
  if (!v5)
  {
    v52[0] = (const void **)"requires attribute 'staticStep'";
    v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v54);
    v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
    if (v54[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
    if (!v61)
      return v30;
    v39 = __p;
    if (__p)
    {
      v40 = v60;
      v41 = __p;
      if (v60 != __p)
      {
        do
          v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
        while (v40 != v39);
        v41 = __p;
      }
      v60 = v39;
      operator delete(v41);
    }
    v34 = v57;
    if (v57)
    {
      v42 = v58;
      v36 = v57;
      if (v58 == v57)
        goto LABEL_82;
      do
      {
        v44 = *--v42;
        v43 = v44;
        *v42 = 0;
        if (v44)
          MEMORY[0x20BD002D4](v43, 0x1000C8077774924);
      }
      while (v42 != v34);
      goto LABEL_81;
    }
    goto LABEL_83;
  }
  v6 = (_QWORD *)v3[3];
  if (!v6)
  {
    v52[0] = (const void **)"requires attribute 'staticUpperBound'";
    v53 = 259;
    mlir::OpState::emitOpError(this, v52, (uint64_t)v54);
    v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
    if (v54[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
    if (!v61)
      return v30;
    v45 = __p;
    if (__p)
    {
      v46 = v60;
      v47 = __p;
      if (v60 != __p)
      {
        do
          v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
        while (v46 != v45);
        v47 = __p;
      }
      v60 = v45;
      operator delete(v47);
    }
    v34 = v57;
    if (v57)
    {
      v48 = v58;
      v36 = v57;
      if (v58 == v57)
        goto LABEL_82;
      do
      {
        v50 = *--v48;
        v49 = v50;
        *v48 = 0;
        if (v50)
          MEMORY[0x20BD002D4](v49, 0x1000C8077774924);
      }
      while (v48 != v34);
      goto LABEL_81;
    }
    goto LABEL_83;
  }
  v7 = *v3;
  v54[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v4, (const void **)"staticLowerBound", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0;
  v54[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"staticUpperBound", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0;
  v54[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v5, (const void **)"staticStep", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0;
  v54[0] = *this;
  if (!mlir::scf::__mlir_ods_local_attr_constraint_SCFOps1(v7, (const void **)"mapping", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0;
  v8 = *((unsigned int *)*this + 11);
  v9 = (uint64_t)&(*this)[2 * ((v8 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v9 = 0;
  v10 = *(unsigned int *)(v9 + 32);
  if ((v8 & 0x800000) != 0)
  {
    v11 = (*this)[9];
    if ((_DWORD)v10)
      goto LABEL_15;
  }
  else
  {
    v11 = 0;
    if ((_DWORD)v10)
    {
LABEL_15:
      v12 = 0;
      v13 = v11 + 24;
      while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v13 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v12))
      {
        ++v12;
        v13 += 32;
        if (v10 == v12)
          goto LABEL_18;
      }
      return 0;
    }
  }
LABEL_18:
  ODSOperands = mlir::pdl_interp::RecordMatchOp::getODSOperands((mlir::pdl_interp::RecordMatchOp *)this, 1u);
  if (v15)
  {
    v16 = v15;
    v17 = ODSOperands + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v17 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v10))
    {
      LODWORD(v10) = v10 + 1;
      v17 += 32;
      if (!--v16)
        goto LABEL_22;
    }
    return 0;
  }
LABEL_22:
  v18 = mlir::pdl_interp::RecordMatchOp::getODSOperands((mlir::pdl_interp::RecordMatchOp *)this, 2u);
  if (v19)
  {
    v20 = v19;
    v21 = v18 + 24;
    while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v21 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v10))
    {
      LODWORD(v10) = v10 + 1;
      v21 += 32;
      if (!--v20)
        goto LABEL_26;
    }
    return 0;
  }
LABEL_26:
  v22 = mlir::pdl_interp::RecordMatchOp::getODSOperands((mlir::pdl_interp::RecordMatchOp *)this, 3u);
  if (v23)
  {
    v24 = v23;
    v25 = v22 + 24;
    while (mlir::scf::__mlir_ods_local_type_constraint_SCFOps4(*this, *(_QWORD *)(*(_QWORD *)v25 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v10))
    {
      LODWORD(v10) = v10 + 1;
      v25 += 32;
      if (!--v24)
        goto LABEL_30;
    }
    return 0;
  }
LABEL_30:
  v26 = *this;
  v27 = *((unsigned int *)*this + 9);
  if (*((_DWORD *)*this + 9))
    v28 = (uint64_t)(*this - 2);
  else
    v28 = 0;
  if ((_DWORD)v27)
  {
    for (i = 0; i != v27; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v28, i);
    v26 = *this;
  }
  return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(v26, (((unint64_t)&v26[2 * (((unint64_t)*((unsigned int *)v26 + 11) >> 23) & 1) + 8]+ (((unint64_t)*((unsigned int *)v26 + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v26 + 10), (uint64_t)"region", 6, 0) != 0;
}

uint64_t mlir::scf::__mlir_ods_local_type_constraint_SCFOps4(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v6;
  int *v8;
  char *v9;
  char *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v36;
  unint64_t v37;
  BOOL v38;
  unint64_t v39;
  BOOL v40;
  unint64_t v41;
  int64_t v42;
  int64_t v43;
  int64_t v44;
  int64_t v45;
  const void **v46[4];
  __int16 v47;
  int v48;
  const char *v49;
  uint64_t v50;
  _QWORD v51[3];
  void *v52;
  unsigned int v53;
  unsigned int v54;
  _BYTE v55[96];
  void *v56;
  _QWORD *v57;
  void *__p;
  _QWORD *v59;
  char v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v51[0] = a2;
    v51[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v6 + 8);
    mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
    return 1;
  }
  else
  {
    v47 = 261;
    v46[0] = a3;
    v46[1] = a4;
    mlir::Operation::emitOpError(a1, v46, (uint64_t)v51);
    if (v51[0])
    {
      v48 = 3;
      v49 = " #";
      v50 = 2;
      v8 = &v48;
      v9 = (char *)v52;
      if (v53 >= v54)
      {
        v36 = v53 + 1;
        if (v52 <= &v48 && (char *)v52 + 24 * v53 > (char *)&v48)
        {
          v42 = (char *)&v48 - (_BYTE *)v52;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v36, 24);
          v9 = (char *)v52;
          v8 = (int *)((char *)v52 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v36, 24);
          v8 = &v48;
          v9 = (char *)v52;
        }
      }
      v10 = &v9[24 * v53];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v53;
      if (v51[0])
      {
        v48 = 5;
        v49 = (const char *)a5;
        v13 = &v48;
        v14 = (char *)v52;
        if (v12 >= v54)
        {
          v37 = v12 + 1;
          v38 = (char *)v52 + 24 * v12 > (char *)&v48;
          if (v52 <= &v48 && v38)
          {
            v43 = (char *)&v48 - (_BYTE *)v52;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v37, 24);
            v14 = (char *)v52;
            v13 = (int *)((char *)v52 + v43);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v37, 24);
            v13 = &v48;
            v14 = (char *)v52;
          }
        }
        v15 = &v14[24 * v53];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v53;
        if (v51[0])
        {
          v48 = 3;
          v49 = " must be variadic of ranked tensor of any type values, but got ";
          v50 = 63;
          v18 = &v48;
          v19 = (char *)v52;
          if (v17 >= v54)
          {
            v39 = v17 + 1;
            v40 = (char *)v52 + 24 * v17 > (char *)&v48;
            if (v52 <= &v48 && v40)
            {
              v44 = (char *)&v48 - (_BYTE *)v52;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v39, 24);
              v19 = (char *)v52;
              v18 = (int *)((char *)v52 + v44);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v39, 24);
              v18 = &v48;
              v19 = (char *)v52;
            }
          }
          v20 = &v19[24 * v53];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          ++v53;
          if (v51[0])
          {
            v22 = &v48;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v48, a2);
            v23 = (char *)v52;
            if (v53 >= v54)
            {
              v41 = v53 + 1;
              if (v52 <= &v48 && (char *)v52 + 24 * v53 > (char *)&v48)
              {
                v45 = (char *)&v48 - (_BYTE *)v52;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v41, 24);
                v23 = (char *)v52;
                v22 = (int *)((char *)v52 + v45);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, v41, 24);
                v22 = &v48;
                v23 = (char *)v52;
              }
            }
            v24 = &v23[24 * v53];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
            *(_OWORD *)v24 = v25;
            ++v53;
          }
        }
      }
    }
    v26 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v51);
    if (v51[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v51);
    if (v60)
    {
      v27 = __p;
      if (__p)
      {
        v28 = v59;
        v29 = __p;
        if (v59 != __p)
        {
          do
            v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
          while (v28 != v27);
          v29 = __p;
        }
        v59 = v27;
        operator delete(v29);
      }
      v30 = v56;
      if (v56)
      {
        v31 = v57;
        v32 = v56;
        if (v57 != v56)
        {
          do
          {
            v34 = *--v31;
            v33 = v34;
            *v31 = 0;
            if (v34)
              MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
          }
          while (v31 != v30);
          v32 = v56;
        }
        v57 = v30;
        operator delete(v32);
      }
      if (v52 != v55)
        free(v52);
    }
  }
  return v26;
}

uint64_t mlir::scf::detail::IfOpGenericAdaptorBase::IfOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "scf.if", 6, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::scf::IfOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  BOOL v14;
  int *v15;
  char *v16;
  char *v17;
  __int128 v18;
  char v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v29;
  unint64_t v30;
  int64_t v31;
  int64_t v32;
  _QWORD v33[4];
  __int16 v34;
  const void **v35[4];
  __int16 v36;
  const void **v37;
  __int16 v38;
  int v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48;
  _QWORD *v49;
  void *__p;
  _QWORD *v51;
  char v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
  v2 = *this;
  v3 = *((unsigned int *)*this + 9);
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  if ((_DWORD)v3)
  {
    for (i = 0; i != v3; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, i);
    v2 = *this;
  }
  if (!mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(v2, (((unint64_t)&v2[2 * (((unint64_t)*((unsigned int *)v2 + 11) >> 23) & 1) + 8]+ (((unint64_t)*((unsigned int *)v2 + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v2 + 10), (uint64_t)"thenRegion", 10, 0))return 0;
  v6 = *this;
  v7 = (((unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8]
       + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)
       + 7) & 0xFFFFFFFFFFFFFFF8)
     + 32 * *((unsigned int *)*this + 10);
  v8 = v7 + 24;
  v9 = *(_QWORD *)(v7 + 32);
  if (v9 == v8 || *(_QWORD *)(v9 + 8) == v8)
    return 1;
  v37 = (const void **)"region #";
  v38 = 259;
  mlir::Operation::emitOpError(v6, &v37, (uint64_t)&v42);
  if (v42)
  {
    LODWORD(v35[0]) = 5;
    v35[1] = (const void **)1;
    v10 = v35;
    v11 = (char *)v44;
    if (v45 >= v46)
    {
      v29 = v45 + 1;
      if (v44 <= v35 && (char *)v44 + 24 * v45 > (char *)v35)
      {
        v31 = (char *)v35 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v29, 24);
        v11 = (char *)v44;
        v10 = (const void ***)((char *)v44 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v29, 24);
        v10 = v35;
        v11 = (char *)v44;
      }
    }
    v12 = &v11[24 * v45];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v45;
    v14 = v42 == 0;
  }
  else
  {
    v14 = 1;
  }
  v34 = 1283;
  v33[0] = " ('";
  v33[2] = "elseRegion";
  v33[3] = 10;
  v35[0] = (const void **)v33;
  v35[2] = (const void **)"') ";
  v36 = 770;
  if (!v14)
  {
    mlir::Diagnostic::operator<<((uint64_t)&v43, v35);
    if (v42)
    {
      v39 = 3;
      v40 = "failed to verify constraint: region with at most 1 blocks";
      v41 = 57;
      v15 = &v39;
      v16 = (char *)v44;
      if (v45 >= v46)
      {
        v30 = v45 + 1;
        if (v44 <= &v39 && (char *)v44 + 24 * v45 > (char *)&v39)
        {
          v32 = (char *)&v39 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v30, 24);
          v16 = (char *)v44;
          v15 = (int *)((char *)v44 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v30, 24);
          v15 = &v39;
          v16 = (char *)v44;
        }
      }
      v17 = &v16[24 * v45];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v17 = v18;
      ++v45;
    }
  }
  v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v42);
  if (v42)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v42);
  if (v52)
  {
    v20 = __p;
    if (__p)
    {
      v21 = v51;
      v22 = __p;
      if (v51 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v51 = v20;
      operator delete(v22);
    }
    v23 = v48;
    if (v48)
    {
      v24 = v49;
      v25 = v48;
      if (v49 != v48)
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v48;
      }
      v49 = v23;
      operator delete(v25);
    }
    if (v44 != v47)
      free(v44);
  }
  return v19 != 0;
}

uint64_t mlir::scf::IndexSwitchOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  int *v11;
  char *v12;
  char *v13;
  __int128 v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  char *v34;
  char *v35;
  __int128 v36;
  int *v37;
  char *v38;
  char *v39;
  __int128 v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD *v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected DictionaryAttr to set properties";
      v58 = 41;
      v11 = &v56;
      v12 = (char *)v60;
      if (v61 >= v62)
      {
        v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v51 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v12 = (char *)v60;
          v11 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v11 = &v56;
          v12 = (char *)v60;
        }
      }
      v13 = &v12[24 * v61];
      v14 = *(_OWORD *)v11;
      *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
      *(_OWORD *)v13 = v14;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v15 = __p;
    if (__p)
    {
      v16 = v67;
      v17 = __p;
      if (v67 != __p)
      {
        do
          v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v16 - 1);
        while (v16 != v15);
        v17 = __p;
      }
      v67 = v15;
      operator delete(v17);
    }
    v18 = v64;
    if (!v64)
      goto LABEL_60;
    v19 = v65;
    v20 = v64;
    if (v65 == v64)
      goto LABEL_59;
    do
    {
      v22 = *--v19;
      v21 = v22;
      *v19 = 0;
      if (v22)
        MEMORY[0x20BD002D4](v21, 0x1000C8077774924);
    }
    while (v19 != v18);
    goto LABEL_58;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v55, "cases", 5uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected key entry for cases in DictionaryAttr to set Properties.";
      v58 = 65;
      v23 = &v56;
      v24 = (char *)v60;
      if (v61 >= v62)
      {
        v48 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v52 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
          v24 = (char *)v60;
          v23 = (int *)((char *)v60 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
          v23 = &v56;
          v24 = (char *)v60;
        }
      }
      v25 = &v24[24 * v61];
      v26 = *(_OWORD *)v23;
      *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
      *(_OWORD *)v25 = v26;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v27 = __p;
    if (__p)
    {
      v28 = v67;
      v29 = __p;
      if (v67 != __p)
      {
        do
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        v29 = __p;
      }
      v67 = v27;
      operator delete(v29);
    }
    v18 = v64;
    if (!v64)
      goto LABEL_60;
    v30 = v65;
    v20 = v64;
    if (v65 == v64)
      goto LABEL_59;
    do
    {
      v32 = *--v30;
      v31 = v32;
      *v30 = 0;
      if (v32)
        MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
    }
    while (v30 != v18);
    goto LABEL_58;
  }
  v9 = (uint64_t)v8;
  if (mlir::detail::DenseArrayAttrImpl<long long>::classof(v8))
  {
    *a1 = v9;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    v56 = 3;
    v58 = 50;
    v33 = &v56;
    v34 = (char *)v60;
    if (v61 >= v62)
    {
      v49 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v53 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
        v34 = (char *)v60;
        v33 = (int *)((char *)v60 + v53);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
        v33 = &v56;
        v34 = (char *)v60;
      }
    }
    v35 = &v34[24 * v61];
    v36 = *(_OWORD *)v33;
    *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
    *(_OWORD *)v35 = v36;
    ++v61;
    if (v59[0])
    {
      v37 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      v38 = (char *)v60;
      if (v61 >= v62)
      {
        v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v54 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v38 = (char *)v60;
          v37 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v37 = &v56;
          v38 = (char *)v60;
        }
      }
      v39 = &v38[24 * v61];
      v40 = *(_OWORD *)v37;
      *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
      *(_OWORD *)v39 = v40;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
  }
  if (v68)
  {
    v41 = __p;
    if (__p)
    {
      v42 = v67;
      v43 = __p;
      if (v67 != __p)
      {
        do
          v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
        while (v42 != v41);
        v43 = __p;
      }
      v67 = v41;
      operator delete(v43);
    }
    v18 = v64;
    if (!v64)
      goto LABEL_60;
    v44 = v65;
    v20 = v64;
    if (v65 == v64)
    {
LABEL_59:
      v65 = v18;
      operator delete(v20);
LABEL_60:
      if (v60 != v63)
        free(v60);
      return 0;
    }
    do
    {
      v46 = *--v44;
      v45 = v46;
      *v44 = 0;
      if (v46)
        MEMORY[0x20BD002D4](v45, 0x1000C8077774924);
    }
    while (v44 != v18);
LABEL_58:
    v20 = v64;
    goto LABEL_59;
  }
  return 0;
}

uint64_t mlir::scf::IndexSwitchOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"cases", 5, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  uint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties]";
        v15 = 112;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v5[162];
    return a1[32];
  }
  return result;
}

uint64_t mlir::scf::IndexSwitchOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  _QWORD *v3;
  uint64_t *v4;
  unint64_t v5;
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  char *v17;
  char *v18;
  __int128 v19;
  int *v20;
  char *v21;
  char *v22;
  __int128 v23;
  char v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t i;
  unint64_t v46;
  unsigned int v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unsigned int j;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  int64_t v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  const void **v63[4];
  __int16 v64;
  int v65;
  const char *v66;
  uint64_t v67;
  _QWORD v68[3];
  void *v69;
  unsigned int v70;
  unsigned int v71;
  _BYTE v72[96];
  void *v73;
  _QWORD *v74;
  void *__p;
  _QWORD *v76;
  char v77;
  uint64_t v78;

  v78 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (_QWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v68[0] = v2;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v3, (const void **)"cases", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
    v4 = *this;
    v5 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*(_UNKNOWN **)(*(_QWORD *)v5 + 136) != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      v64 = 261;
      v63[0] = (const void **)"operand";
      v63[1] = (const void **)7;
      mlir::Operation::emitOpError(v4, v63, (uint64_t)v68);
      if (v68[0])
      {
        v65 = 3;
        v66 = " #";
        v67 = 2;
        v6 = &v65;
        v7 = (char *)v69;
        if (v70 >= v71)
        {
          v53 = v70 + 1;
          if (v69 <= &v65 && (char *)v69 + 24 * v70 > (char *)&v65)
          {
            v59 = (char *)&v65 - (_BYTE *)v69;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v53, 24);
            v7 = (char *)v69;
            v6 = (int *)((char *)v69 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v53, 24);
            v6 = &v65;
            v7 = (char *)v69;
          }
        }
        v8 = &v7[24 * v70];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v70;
        if (v68[0])
        {
          v65 = 5;
          v66 = 0;
          v11 = &v65;
          v12 = (char *)v69;
          if (v10 >= v71)
          {
            v54 = v10 + 1;
            v55 = (char *)v69 + 24 * v10 > (char *)&v65;
            if (v69 <= &v65 && v55)
            {
              v60 = (char *)&v65 - (_BYTE *)v69;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v54, 24);
              v12 = (char *)v69;
              v11 = (int *)((char *)v69 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v54, 24);
              v11 = &v65;
              v12 = (char *)v69;
            }
          }
          v13 = &v12[24 * v70];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v70;
          if (v68[0])
          {
            v65 = 3;
            v66 = " must be index, but got ";
            v67 = 24;
            v16 = &v65;
            v17 = (char *)v69;
            if (v15 >= v71)
            {
              v56 = v15 + 1;
              v57 = (char *)v69 + 24 * v15 > (char *)&v65;
              if (v69 <= &v65 && v57)
              {
                v61 = (char *)&v65 - (_BYTE *)v69;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v56, 24);
                v17 = (char *)v69;
                v16 = (int *)((char *)v69 + v61);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v56, 24);
                v16 = &v65;
                v17 = (char *)v69;
              }
            }
            v18 = &v17[24 * v70];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            ++v70;
            if (v68[0])
            {
              v20 = &v65;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v65, v5);
              v21 = (char *)v69;
              if (v70 >= v71)
              {
                v58 = v70 + 1;
                if (v69 <= &v65 && (char *)v69 + 24 * v70 > (char *)&v65)
                {
                  v62 = (char *)&v65 - (_BYTE *)v69;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v58, 24);
                  v21 = (char *)v69;
                  v20 = (int *)((char *)v69 + v62);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v72, v58, 24);
                  v20 = &v65;
                  v21 = (char *)v69;
                }
              }
              v22 = &v21[24 * v70];
              v23 = *(_OWORD *)v20;
              *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
              *(_OWORD *)v22 = v23;
              ++v70;
            }
          }
        }
      }
      v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
      if (v68[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
      if (v77)
      {
        v25 = __p;
        if (__p)
        {
          v26 = v76;
          v27 = __p;
          if (v76 != __p)
          {
            do
              v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
            while (v26 != v25);
            v27 = __p;
          }
          v76 = v25;
          operator delete(v27);
        }
        v28 = v73;
        if (v73)
        {
          v29 = v74;
          v30 = v73;
          if (v74 != v73)
          {
            do
            {
              v32 = *--v29;
              v31 = v32;
              *v29 = 0;
              if (v32)
                MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
            }
            while (v29 != v28);
            v30 = v73;
          }
          v74 = v28;
          operator delete(v30);
        }
        if (v69 != v72)
          free(v69);
      }
      if (!v24)
        return 0;
    }
    v42 = *this;
    v43 = *((unsigned int *)*this + 9);
    v44 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
    if ((_DWORD)v43)
    {
      for (i = 0; i != v43; ++i)
        mlir::detail::OpResultImpl::getNextResultAtOffset(v44, i);
      v42 = *this;
    }
    if (!mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(v42, (((unint64_t)&v42[2 * (((unint64_t)*((unsigned int *)v42 + 11) >> 23) & 1)+ 8]+ (((unint64_t)*((unsigned int *)v42 + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v42 + 10), (uint64_t)"defaultRegion", 13, 0))return 0;
    v46 = *((unsigned int *)*this + 11);
    v47 = v46 & 0x7FFFFF;
    if ((v46 & 0x7FFFFF) == 0)
    {
      v49 = 0;
      v48 = 0;
LABEL_62:
      v50 = v48 + 24;
      for (j = 1;
            mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(*this, v50, (uint64_t)"caseRegions", 11, j);
            ++j)
      {
        v50 += 24;
        if (v50 == v49)
          return 1;
      }
      return 0;
    }
    if (v47 != 1)
    {
      v48 = (((unint64_t)&(*this)[2 * ((v46 >> 23) & 1) + 8] + ((v46 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *((unsigned int *)*this + 10);
      v49 = v48 + 24 * v47;
      goto LABEL_62;
    }
    return 1;
  }
  else
  {
    v63[0] = (const void **)"requires attribute 'cases'";
    v64 = 259;
    mlir::OpState::emitOpError(this, v63, (uint64_t)v68);
    v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (v77)
    {
      v34 = __p;
      if (__p)
      {
        v35 = v76;
        v36 = __p;
        if (v76 != __p)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = __p;
        }
        v76 = v34;
        operator delete(v36);
      }
      v37 = v73;
      if (v73)
      {
        v38 = v74;
        v39 = v73;
        if (v74 != v73)
        {
          do
          {
            v41 = *--v38;
            v40 = v41;
            *v38 = 0;
            if (v41)
              MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
          }
          while (v38 != v37);
          v39 = v73;
        }
        v74 = v37;
        operator delete(v39);
      }
      if (v69 != v72)
        free(v69);
    }
  }
  return v33;
}

BOOL mlir::scf::IndexSwitchOp::parse(void *a1, uint64_t *a2)
{
  mlir::Region *v4;
  uint64_t v5;
  _QWORD *v6;
  mlir::Region *v7;
  int v8;
  mlir::Region *v9;
  mlir::Region *v10;
  uint64_t v11;
  uint64_t v12;
  mlir::MLIRContext **v13;
  uint64_t DenseI64ArrayAttr;
  char v15;
  void *v16;
  _QWORD *v17;
  mlir::IndexType **v18;
  mlir::MLIRContext *v19;
  uint64_t IndexType;
  _BOOL8 v21;
  _BYTE *v22;
  uint64_t v23;
  char *v24;
  mlir::Region *v25;
  mlir::Region *v27;
  mlir::Region *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  _BYTE v32[16];
  void *__src;
  uint64_t v34;
  uint64_t v35;
  void *v36[4];
  void *v37;
  uint64_t v38;
  _QWORD v39[2];
  __int16 v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  memset(v36, 0, 24);
  __src = &v35;
  v34 = 0x100000000;
  v30 = v32;
  v31 = 0x200000000;
  v4 = (mlir::Region *)operator new();
  *(_QWORD *)v4 = v4;
  *((_QWORD *)v4 + 1) = v4;
  *((_QWORD *)v4 + 2) = 0;
  v27 = v4;
  (*(void (**)(void *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(void *, void **, uint64_t))(*(_QWORD *)a1 + 672))(a1, v36, 1)
    || (v29 = (*(uint64_t (**)(void *))(*(_QWORD *)a1 + 40))(a1),
        !(*(unsigned __int8 (**)(void *, uint64_t *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    || (v5 = a2[1],
        v37 = a1,
        v38 = (uint64_t)&v29,
        v39[0] = a2,
        (v6 = (_QWORD *)mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96))) != 0)
    && !mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v6, (const void **)"cases", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::IndexSwitchOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v37)|| (*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 64))(a1)&& !mlir::AsmParser::parseTypeList((uint64_t)a1, (uint64_t)&__src))
  {
LABEL_26:
    v21 = 0;
    v27 = 0;
    goto LABEL_27;
  }
  v37 = v39;
  v38 = 0x600000000;
  if (!(*(unsigned __int8 (**)(void *, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "case", 4))
  {
LABEL_19:
    v13 = (mlir::MLIRContext **)(*(uint64_t (**)(void *))(*(_QWORD *)a1 + 32))(a1);
    DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(v13, (uint64_t)v37, v38);
    v15 = 0;
    v16 = v37;
    if (v37 != v39)
      goto LABEL_20;
    goto LABEL_21;
  }
  while (1)
  {
    v29 = 0;
    v7 = (mlir::Region *)operator new();
    *(_QWORD *)v7 = v7;
    *((_QWORD *)v7 + 1) = v7;
    *((_QWORD *)v7 + 2) = 0;
    v28 = v7;
    v8 = v31;
    if (v31 >= HIDWORD(v31))
    {
      v9 = *(mlir::Region **)llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::Region>,false>::growAndEmplaceBack<std::unique_ptr<mlir::Region>>((uint64_t)&v30, (uint64_t *)&v28);
      v10 = v28;
      v28 = 0;
      if (!v10)
        goto LABEL_11;
LABEL_10:
      mlir::Region::~Region(v10);
      MEMORY[0x20BD002F8]();
      goto LABEL_11;
    }
    v9 = v7;
    v28 = 0;
    *((_QWORD *)v30 + v31) = v7;
    LODWORD(v31) = v8 + 1;
    v10 = v28;
    v28 = 0;
    if (v10)
      goto LABEL_10;
LABEL_11:
    if (!mlir::AsmParser::parseInteger<long long>((uint64_t)a1, &v29)
      || !(*(unsigned __int8 (**)(void *, mlir::Region *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v9, 0, 0, 0))
    {
      break;
    }
    v11 = v29;
    v12 = v38;
    if (v38 >= (unint64_t)HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 8);
      v12 = v38;
    }
    *((_QWORD *)v37 + v12) = v11;
    LODWORD(v38) = v38 + 1;
    if (!(*(unsigned __int8 (**)(void *, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "case", 4))
      goto LABEL_19;
  }
  DenseI64ArrayAttr = 0;
  v15 = 1;
  v16 = v37;
  if (v37 == v39)
    goto LABEL_21;
LABEL_20:
  free(v16);
LABEL_21:
  if ((v15 & 1) != 0)
    goto LABEL_26;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(a2) = DenseI64ArrayAttr;
  v40 = 257;
  if (!(*(unsigned __int8 (**)(void *, const char *, uint64_t, void **))(*(_QWORD *)a1 + 368))(a1, "default", 7, &v37)|| !(*(unsigned __int8 (**)(void *, mlir::Region *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 744))(a1, v4, 0, 0, 0))
  {
    goto LABEL_26;
  }
  v17 = (_QWORD *)(*(uint64_t (**)(void *))(*(_QWORD *)a1 + 32))(a1);
  mlir::impl::ensureRegionTerminator(v4, v17, *a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t))llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>, (uint64_t)mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IndexSwitchOp>::buildTerminator);
  mlir::OperationState::addRegion((uint64_t)a2, (unint64_t)&v27);
  mlir::OperationState::addRegions((char *)a2, (unint64_t)v30, v31);
  v18 = (mlir::IndexType **)(*(uint64_t (**)(void *))(*(_QWORD *)a1 + 32))(a1);
  IndexType = mlir::Builder::getIndexType(v18, v19);
  mlir::OperationState::addTypes((uint64_t)a2, __src, v34);
  v21 = (*(unsigned __int8 (**)(void *, void **, uint64_t, uint64_t *))(*(_QWORD *)a1 + 696))(a1, v36, IndexType, a2 + 2) != 0;
  v4 = v27;
  v27 = 0;
  if (v4)
  {
LABEL_27:
    mlir::Region::~Region(v4);
    MEMORY[0x20BD002F8]();
  }
  v22 = v30;
  if ((_DWORD)v31)
  {
    v23 = 8 * v31;
    v24 = (char *)v30 - 8;
    do
    {
      v25 = *(mlir::Region **)&v24[v23];
      *(_QWORD *)&v24[v23] = 0;
      if (v25)
      {
        mlir::Region::~Region(v25);
        MEMORY[0x20BD002F8]();
      }
      v23 -= 8;
    }
    while (v23);
    v22 = v30;
  }
  if (v22 != v32)
    free(v22);
  if (__src != &v35)
    free(__src);
  return v21;
}

void mlir::scf::IndexSwitchOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _WORD *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  mlir::Operation *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v37;
  llvm::raw_ostream *v38;
  uint64_t v39;
  llvm::raw_ostream *v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::raw_ostream *v43;
  _DWORD *v44;
  llvm::raw_ostream *v45;
  _BYTE *v46;
  _QWORD *v47;
  uint64_t v48;
  ZinIrHalH13g **v49;
  mlir::Operation *v50;
  mlir::Operation *v51;
  _BOOL8 v52;
  mlir::scf::IndexSwitchOp *v53;
  uint64_t v54[2];
  _QWORD v55[2];
  unint64_t v56[2];
  unint64_t AttrDictionary;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  _QWORD v63[6];

  v63[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v61 = v63;
  v63[0] = "cases";
  v63[1] = 5;
  v62 = 0x200000001;
  v6 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v6);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v6 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v9, v61, v62);
  if (*((_DWORD *)*this + 9))
  {
    v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v11 = (_BYTE *)*((_QWORD *)v10 + 4);
    if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
    {
      llvm::raw_ostream::write(v10, 32);
    }
    else
    {
      *((_QWORD *)v10 + 4) = v11 + 1;
      *v11 = 32;
    }
    v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v13 = (_WORD *)*((_QWORD *)v12 + 4);
    if (*((_QWORD *)v12 + 3) - (_QWORD)v13 > 1uLL)
    {
      *v13 = 15917;
      *((_QWORD *)v12 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v12, "->", 2uLL);
    }
    v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v15 = (_BYTE *)*((_QWORD *)v14 + 4);
    if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
    {
      llvm::raw_ostream::write(v14, 32);
    }
    else
    {
      *((_QWORD *)v14 + 4) = v15 + 1;
      *v15 = 32;
    }
    v16 = *((unsigned int *)*this + 9);
    v17 = (uint64_t)*this - 16;
    if (!(_DWORD)v16)
      v17 = 0;
    v54[0] = v17;
    v54[1] = v16;
    mlir::OperandRange::getTypes(v54, (uint64_t *)&AttrDictionary);
    v55[0] = ", ";
    v55[1] = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(AttrDictionary, v58, v59, v60, (uint64_t)a2, (uint64_t)a2, (uint64_t)v55);
  }
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if ((unint64_t)v19 >= *((_QWORD *)v18 + 3))
  {
    llvm::raw_ostream::write(v18, 32);
  }
  else
  {
    *((_QWORD *)v18 + 4) = v19 + 1;
    *v19 = 32;
  }
  v53 = (mlir::scf::IndexSwitchOp *)this;
  v20 = *this;
  v21 = *((unsigned int *)*this + 11);
  v22 = (uint64_t)*this + 16 * ((v21 >> 23) & 1);
  v25 = *(_QWORD *)(v22 + 64);
  v23 = v22 + 64;
  v24 = v25;
  if ((v21 & 0x7FFFFF) != 0)
  {
    v26 = ((v23 + ((v21 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *((unsigned int *)v20 + 10);
    v27 = (v21 & 0x7FFFFF) - 1;
  }
  else
  {
    v26 = 0;
    v27 = -1;
  }
  mlir::ValueRange::ValueRange(v56, v26 + 24, v27);
  v28 = v56[0];
  v29 = v56[1];
  v55[0] = v24;
  v30 = mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v55);
  AttrDictionary = v30;
  v58 = v28;
  v59 = 0;
  if (v31)
  {
    v32 = (unint64_t *)v30;
    v33 = v31;
    v34 = 0;
    v35 = (unint64_t *)(v30 + 8 * v33);
    do
    {
      if (v58 == v28 && v34 == v29)
        break;
      v37 = mlir::RegionRange::dereference_iterator(&v58, v34);
      (*(void (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 128))(a2);
      v38 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      v39 = *((_QWORD *)v38 + 4);
      if ((unint64_t)(*((_QWORD *)v38 + 3) - v39) > 4)
      {
        *(_BYTE *)(v39 + 4) = 32;
        *(_DWORD *)v39 = 1702060387;
        *((_QWORD *)v38 + 4) += 5;
      }
      else
      {
        llvm::raw_ostream::write(v38, "case ", 5uLL);
      }
      v40 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      llvm::raw_ostream::operator<<(v40, *v32);
      v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      v42 = (_BYTE *)*((_QWORD *)v41 + 4);
      if ((unint64_t)v42 < *((_QWORD *)v41 + 3))
      {
        *((_QWORD *)v41 + 4) = v42 + 1;
        *v42 = 32;
      }
      else
      {
        llvm::raw_ostream::write(v41, 32);
      }
      (*(void (**)(mlir::OpAsmPrinter *, unint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)a2 + 224))(a2, v37, 0, 1, 0);
      v32 = (unint64_t *)(AttrDictionary + 8);
      v34 = v59 + 1;
      AttrDictionary = (unint64_t)v32;
      ++v59;
    }
    while (v32 != v35);
  }
  (*(void (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 128))(a2);
  v43 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v44 = (_DWORD *)*((_QWORD *)v43 + 4);
  if (*((_QWORD *)v43 + 3) - (_QWORD)v44 > 6uLL)
  {
    *(_DWORD *)((char *)v44 + 3) = 1953264993;
    *v44 = 1634100580;
    *((_QWORD *)v43 + 4) += 7;
  }
  else
  {
    llvm::raw_ostream::write(v43, "default", 7uLL);
  }
  v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v46 = (_BYTE *)*((_QWORD *)v45 + 4);
  if ((unint64_t)v46 >= *((_QWORD *)v45 + 3))
  {
    llvm::raw_ostream::write(v45, 32);
  }
  else
  {
    *((_QWORD *)v45 + 4) = v46 + 1;
    *v46 = 32;
  }
  v47 = (_QWORD *)(((*(_QWORD *)v53
                   + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)v53 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(*(_QWORD *)v53 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(*(_QWORD *)v53 + 40));
  v52 = (_QWORD *)*v47 == v47
     || ((v48 = v47[1]) != 0 ? (v49 = (ZinIrHalH13g **)(v48 - 8)) : (v49 = 0),
         (mlir::Block::getTerminator(v49), !v50)
      || (v51 = v50,
          AttrDictionary = mlir::Operation::getAttrDictionary(v50),
          mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&AttrDictionary))
      || (*((_BYTE *)v51 + 46) & 0x80) != 0 && *((_DWORD *)v51 + 17))
     || *((_DWORD *)v51 + 9) != 0;
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t, uint64_t, _BOOL8, _QWORD))(*(_QWORD *)a2 + 224))(a2, ((*(_QWORD *)v53+ 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)v53 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(*(_QWORD *)v53 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(*(_QWORD *)v53 + 40), 1, v52, 0);
  if (v61 != v63)
    free(v61);
}

BOOL mlir::scf::ParallelOp::setPropertiesFromAttr(void *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int64_t v34;
  int64_t v35;
  uint64_t v36;
  int v37;
  const char *v38;
  uint64_t v39;
  _QWORD v40[3];
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v36 = v6;
  if (!v6)
  {
    a3(v40, a4);
    if (v40[0])
    {
      v37 = 3;
      v38 = "expected DictionaryAttr to set properties";
      v39 = 41;
      v10 = &v37;
      v11 = (char *)v41;
      if (v42 >= v43)
      {
        v32 = v42 + 1;
        if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          v11 = (char *)v41;
          v10 = (int *)((char *)v41 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          v10 = &v37;
          v11 = (char *)v41;
        }
      }
      v12 = &v11[24 * v42];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v42;
      if (v40[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
    }
    if (!v49)
      return 0;
    v14 = __p;
    if (__p)
    {
      v15 = v48;
      v16 = __p;
      if (v48 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v48 = v14;
      operator delete(v16);
    }
    v17 = v45;
    if (!v45)
      goto LABEL_43;
    v18 = v46;
    v19 = v45;
    if (v46 == v45)
    {
LABEL_42:
      v46 = v17;
      operator delete(v19);
LABEL_43:
      if (v41 != v44)
        free(v41);
      return 0;
    }
    do
    {
      v21 = *--v18;
      v20 = v21;
      *v18 = 0;
      if (v21)
        MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
    }
    while (v18 != v17);
LABEL_41:
    v19 = v45;
    goto LABEL_42;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v36, "operandSegmentSizes", 0x13uLL);
  if (!v8)
  {
    v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v36, "operand_segment_sizes", 0x15uLL);
    if (!v8)
    {
      a3(v40, a4);
      if (v40[0])
      {
        v37 = 3;
        v38 = "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.";
        v39 = 79;
        v22 = &v37;
        v23 = (char *)v41;
        if (v42 >= v43)
        {
          v33 = v42 + 1;
          if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
          {
            v35 = (char *)&v37 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v33, 24);
            v23 = (char *)v41;
            v22 = (int *)((char *)v41 + v35);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v33, 24);
            v22 = &v37;
            v23 = (char *)v41;
          }
        }
        v24 = &v23[24 * v42];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
        *(_OWORD *)v24 = v25;
        ++v42;
        if (v40[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
      }
      if (!v49)
        return 0;
      v26 = __p;
      if (__p)
      {
        v27 = v48;
        v28 = __p;
        if (v48 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v48 = v26;
        operator delete(v28);
      }
      v17 = v45;
      if (!v45)
        goto LABEL_43;
      v29 = v46;
      v19 = v45;
      if (v46 == v45)
        goto LABEL_42;
      do
      {
        v31 = *--v29;
        v30 = v31;
        *v29 = 0;
        if (v31)
          MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
      }
      while (v29 != v17);
      goto LABEL_41;
    }
  }
  return mlir::convertFromAttribute(a1, (const char *)4, v8, a3, a4) != 0;
}

uint64_t mlir::scf::ParallelOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  void *v11;
  mlir::DictionaryAttr *v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[7];

  v16[6] = *MEMORY[0x24BDAC8D0];
  v13 = a1;
  v14 = v16;
  v15 = 0x300000000;
  v2 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, a2, 4);
  NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"operandSegmentSizes", 19, v2);
  v5 = v4;
  v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    v6 = v15;
  }
  v7 = (uint64_t *)((char *)v14 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = __CFADD__((_DWORD)v15, 1);
  v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    v11 = v14;
    if (v14 == v16)
      return DictionaryAttr;
    goto LABEL_8;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (mlir::MLIRContext *)v14, v9);
  v11 = v14;
  if (v14 != v16)
LABEL_8:
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::scf::ParallelOp::computePropertiesHash(_QWORD *a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v19 = a1;
    v2 = &unk_254519000;
    v13 = v12;
    a1 = v19;
    if (v13)
    {
      v14 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v14 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v14;
      v2 = (_QWORD *)&unk_254519000;
      a1 = v19;
    }
  }
  v3 = v2[373];
  v5 = *a1;
  v4 = a1[1];
  if ((v6 & 1) == 0)
  {
    v17 = a1[1];
    v20 = v2[373];
    v18 = *a1;
    v4 = v17;
    v5 = v18;
    v3 = v20;
    v2 = &unk_254519000;
    if (v15)
    {
      v16 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v16 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v16;
      v4 = v17;
      v5 = v18;
      v3 = v20;
      v2 = (_QWORD *)&unk_254519000;
    }
  }
  v7 = __ROR8__(v4 + 16, 16);
  v8 = (0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v7 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v3 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v3 ^ v7)))) ^ ((0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (v5 ^ v3 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v5 ^ v3 ^ v7)))) >> 47))) ^ v4;
  v9 = 8 * v8 + 8;
  v10 = v2[373] ^ HIDWORD(v8);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v9)))) ^ ((0x9DDFEA08EB382D69 * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v9)))) >> 47));
}

uint64_t mlir::scf::ParallelOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, _QWORD *a4)
{
  void *v5;
  BOOL v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;

  v5 = (void *)result;
  if (a3 == 19)
  {
    result = memcmp(__s1, "operandSegmentSizes", 0x13uLL);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    if (a3 != 21)
      return result;
    v6 = *(_QWORD *)__s1 == 0x5F646E617265706FLL && *((_QWORD *)__s1 + 1) == 0x5F746E656D676573;
    if (!v6 || *(_QWORD *)(__s1 + 13) != 0x73657A69735F746ELL)
      return result;
  }
  if (a4)
  {
    result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
    if ((_DWORD)result)
      v8 = a4;
    else
      v8 = 0;
    v10 = v8;
    if ((_DWORD)result)
    {
      result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v10);
      if (result == 4)
      {
        result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v10);
        if (v9)
          return (uint64_t)memmove(v5, (const void *)result, 4 * v9);
      }
    }
  }
  return result;
}

BOOL mlir::scf::ParallelOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(a2);
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 5)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = __p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = *--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3, v12, 4 * v13);
  }
  return (unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6
      || mlir::DialectBytecodeReader::readSparseArray<int>(a1, v3, (const char *)4);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  uint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v5[164];
    return a1[32];
  }
  return result;
}

BOOL mlir::scf::ParallelOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;

  v2 = *this;
  v3 = *((unsigned int *)v2 + 11);
  v4 = (v3 >> 23) & 1;
  v5 = LODWORD(v2[2 * v4 + 8]);
  if ((v3 & 0x800000) != 0)
  {
    v6 = v2[9];
    if ((_DWORD)v5)
      goto LABEL_3;
  }
  else
  {
    v6 = 0;
    if ((_DWORD)v5)
    {
LABEL_3:
      v7 = 0;
      v8 = v6 + 24;
      while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v8 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v7))
      {
        ++v7;
        v8 += 32;
        if (v5 == v7)
        {
          v2 = *this;
          v3 = *((unsigned int *)*this + 11);
          v4 = (v3 >> 23) & 1;
          v9 = v3 & 0x800000;
          goto LABEL_9;
        }
      }
      return 0;
    }
  }
  v9 = v3 & 0x800000;
LABEL_9:
  if (BYTE3(v3))
    v10 = &v2[2 * v4 + 8];
  else
    v10 = 0;
  v11 = *((_DWORD *)v10 + 1);
  if (v9)
  {
    v12 = v2[9];
    if (v11)
      goto LABEL_14;
  }
  else
  {
    v12 = 0;
    if (v11)
    {
LABEL_14:
      v13 = *(unsigned int *)v10;
      v14 = v11 + v13 - v13;
      v15 = v12 + 32 * v13 + 24;
      while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v15 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v5))
      {
        LODWORD(v5) = v5 + 1;
        v15 += 32;
        if (!--v14)
        {
          v2 = *this;
          v3 = *((unsigned int *)*this + 11);
          v4 = (v3 >> 23) & 1;
          v9 = v3 & 0x800000;
          goto LABEL_18;
        }
      }
      return 0;
    }
  }
LABEL_18:
  v16 = (uint64_t)&v2[2 * v4 + 8];
  if (BYTE3(v3))
    v17 = (_DWORD *)v16;
  else
    v17 = 0;
  v18 = v17[2];
  if (v9)
  {
    v19 = v2[9];
    if (v18)
      goto LABEL_23;
  }
  else
  {
    v19 = 0;
    if (v18)
    {
LABEL_23:
      v20 = (v17[1] + *v17);
      v21 = (v18 + v20) - v20;
      v22 = v19 + 32 * v20 + 24;
      while (mlir::memref::__mlir_ods_local_type_constraint_MemRefOps3(*this, *(_QWORD *)(*(_QWORD *)v22 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v5))
      {
        LODWORD(v5) = v5 + 1;
        v22 += 32;
        if (!--v21)
        {
          v2 = *this;
          goto LABEL_27;
        }
      }
      return 0;
    }
  }
LABEL_27:
  v23 = *((unsigned int *)v2 + 9);
  if (*((_DWORD *)v2 + 9))
    v24 = (uint64_t)(v2 - 2);
  else
    v24 = 0;
  if ((_DWORD)v23)
  {
    for (i = 0; i != v23; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v24, i);
    v2 = *this;
  }
  return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1(v2, (((unint64_t)&v2[2 * (((unint64_t)*((unsigned int *)v2 + 11) >> 23) & 1) + 8]+ (((unint64_t)*((unsigned int *)v2 + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v2 + 10), (uint64_t)"region", 6, 0) != 0;
}

BOOL mlir::scf::ReduceReturnOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[2];
  uint64_t v8[2];
  uint64_t v9;
  _QWORD v10[5];

  v10[4] = *MEMORY[0x24BDAC8D0];
  memset(v10, 0, 24);
  v8[0] = (uint64_t)v10;
  v8[1] = 1;
  v9 = 0;
  v7[0] = &v9;
  v7[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v10, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v6))
    return 0;
  v9 = v6;
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v8, v7, v4, a2 + 16) != 0;
}

void mlir::scf::WhileOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  mlir::OperationState::addOperands(a2, a5, a6);
  *(_QWORD *)(a2 + 192) = 0;
  v13 = *(unsigned int *)(a2 + 120);
  if (a8 + v13 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a8 + v13, 16);
    LODWORD(v13) = *(_DWORD *)(a2 + 120);
  }
  if (a8)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v13), a7, 16 * a8);
    LODWORD(v13) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v13 + a8;
  mlir::OperationState::addRegion((mlir::OperationState *)a2);
  mlir::OperationState::addRegion((mlir::OperationState *)a2);
  v14 = *(unsigned int *)(a2 + 72);
  if (a4 + v14 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v14, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if (a4)
  {
    v15 = 0;
    v16 = *(_QWORD *)(a2 + 64) + 8 * v14;
    do
    {
      *(_QWORD *)(v16 + 8 * v15) = mlir::TypeRange::dereference_iterator(a3, v15);
      ++v15;
    }
    while (a4 != v15);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + a4;
}

BOOL mlir::scf::WhileOp::verifyInvariantsImpl(mlir::scf::WhileOp *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *(_QWORD *)this;
  v3 = *(unsigned int *)(v2 + 36);
  if (*(_DWORD *)(v2 + 36))
    v4 = v2 - 16;
  else
    v4 = 0;
  if ((_DWORD)v3)
  {
    for (i = 0; i != v3; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, i);
    v2 = *(_QWORD *)this;
  }
  if (!mlir::scf::__mlir_ods_local_region_constraint_SCFOps1((uint64_t *)v2, ((v2+ 16 * (((unint64_t)*(unsigned int *)(v2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(v2 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(v2 + 40), (uint64_t)"before", 6, 0))return 0;
  v6 = *(_QWORD *)this;
  v7 = *(unsigned int *)(*(_QWORD *)this + 44);
  if ((v7 & 0x7FFFFF) != 0)
    v8 = ((v6 + 16 * ((v7 >> 23) & 1) + ((v7 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(v6 + 40);
  else
    v8 = 0;
  return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1((uint64_t *)v6, v8 + 24, (uint64_t)"after", 5, 1u) != 0;
}

BOOL mlir::scf::YieldOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 v5;
  void *v6;
  void *v8[2];
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _QWORD v12[17];

  v12[16] = *MEMORY[0x24BDAC8D0];
  v10 = v12;
  v11 = 0x400000000;
  v8[0] = &v9;
  v8[1] = (void *)0x100000000;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112)
    || (v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        !(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v10, 0, 1, 0xFFFFFFFFLL))|| (_DWORD)v11&& (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v8)))
  {
    v5 = 0;
    v6 = v8[0];
    if (v8[0] == &v9)
      goto LABEL_10;
    goto LABEL_9;
  }
  v5 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v10, (uint64_t)v8, v4, a2 + 16) != 0;
  v6 = v8[0];
  if (v8[0] != &v9)
LABEL_9:
    free(v6);
LABEL_10:
  if (v10 != v12)
    free(v10);
  return v5;
}

uint64_t mlir::OpInterface<mlir::LoopLikeOpInterface,mlir::detail::LoopLikeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  uint64_t result;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  unint64_t v31;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v30 = *(const char **)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v30);
    if (result)
    {
      if ((v8 & 1) == 0)
      {
        v12 = result;
        result = v12;
        if (v13)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
          v31 = 75;
          v14 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v14)
            v15 = v14;
          else
            v15 = v31;
          v16 = &v30[v15];
          v17 = v31 - v15;
          if (v31 - v15 >= 0x12)
            v18 = 18;
          else
            v18 = v31 - v15;
          v19 = v17 - v18;
          if (v19 >= v19 - 1)
            v20 = v19 - 1;
          else
            v20 = v19;
          mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
          result = v12;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 104))(result, mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    result = mlir::detail::InterfaceMap::lookup<mlir::LoopLikeOpInterface>(v6 + 32);
    if (!result)
    {
      v9 = *(_QWORD *)(v6 + 24);
      v10 = *(_QWORD *)(a1 + 48);
      if ((v11 & 1) == 0)
      {
        v29 = *(_QWORD *)(a1 + 48);
        v10 = v29;
        if (v21)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
          v31 = 75;
          v22 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v22)
            v23 = v22;
          else
            v23 = v31;
          v24 = &v30[v23];
          v25 = v31 - v23;
          if (v31 - v23 >= 0x12)
            v26 = 18;
          else
            v26 = v31 - v23;
          v27 = v25 - v26;
          if (v27 >= v27 - 1)
            v28 = v27 - 1;
          else
            v28 = v27;
          mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v24[v26], v28);
          v10 = v29;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id, v10);
    }
  }
  return result;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::LoopLikeOpInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
      v23 = 75;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[116];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::__mlir_ods_local_attr_constraint_SCFOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

uint64_t llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::Region>,false>::growAndEmplaceBack<std::unique_ptr<mlir::Region>>(uint64_t a1, uint64_t *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  unint64_t v11;
  char *v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  __int128 *v16;
  _OWORD *v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  mlir::Region *v24;
  int v25;
  unsigned int v26;
  unint64_t v28;

  v28 = 0;
  v4 = (char *)(a1 + 16);
  v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 8, &v28);
  v6 = *(unsigned int *)(a1 + 8);
  v7 = 8 * v6;
  v8 = *a2;
  *a2 = 0;
  *(_QWORD *)&v5[8 * v6] = v8;
  v9 = *(char **)a1;
  v10 = *(char **)a1;
  if (!(_DWORD)v6)
    goto LABEL_19;
  v11 = (v6 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v11 < 0xB)
  {
    v12 = v5;
LABEL_12:
    v21 = &v9[v7];
    do
    {
      v22 = *(_QWORD *)v10;
      *(_QWORD *)v10 = 0;
      v10 += 8;
      *(_QWORD *)v12 = v22;
      v12 += 8;
    }
    while (v10 != v21);
    goto LABEL_14;
  }
  v13 = v9 >= &v5[v7] || v5 >= &v9[v7];
  v12 = v5;
  if (!v13)
    goto LABEL_12;
  v14 = v11 + 1;
  v15 = 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
  v12 = &v5[v15];
  v10 = &v9[v15];
  v16 = (__int128 *)(v9 + 16);
  v17 = v5 + 16;
  v18 = v14 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v19 = *(v16 - 1);
    v20 = *v16;
    *(v16 - 1) = 0uLL;
    *v16 = 0uLL;
    *(v17 - 1) = v19;
    *v17 = v20;
    v16 += 2;
    v17 += 2;
    v18 -= 4;
  }
  while (v18);
  if (v14 != (v14 & 0x3FFFFFFFFFFFFFFCLL))
    goto LABEL_12;
LABEL_14:
  v23 = *(_QWORD *)a1 - 8;
  do
  {
    v24 = *(mlir::Region **)(v23 + v7);
    *(_QWORD *)(v23 + v7) = 0;
    if (v24)
    {
      mlir::Region::~Region(v24);
      MEMORY[0x20BD002F8]();
    }
    v7 -= 8;
  }
  while (v7);
  v10 = *(char **)a1;
LABEL_19:
  v25 = v28;
  if (v10 != v4)
    free(v10);
  *(_QWORD *)a1 = v5;
  v26 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v26;
  *(_DWORD *)(a1 + 12) = v25;
  return (uint64_t)&v5[8 * v26 - 8];
}

uint64_t mlir::RegisteredOperationName::insert<mlir::scf::ExecuteRegionOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"scf.execute_region", 18, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ExecuteRegionOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24BFF3AA8;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::scf::IfOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"scf.if", 6, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24BFF3B70;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::scf::IndexSwitchOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"scf.index_switch", 16, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::IndexSwitchOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24BFF3918;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::scf::IndexSwitchOp::getAttributeNames(void)::attrNames, 1);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::scf::ReduceOp>(uint64_t a1)
{
  _QWORD *v2;
  _OWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _OWORD v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  memset(v11, 0, sizeof(v11));
  v9 = v11;
  v10 = 0x300000000;
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"scf.reduce", 10, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ReduceOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24BFF3F58;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::scf::ReduceReturnOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ReduceReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::ReduceReturnOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"scf.reduce.return", 17, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ReduceReturnOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24BFF39E0;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::scf::WhileOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"scf.while", 9, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24BFF3D00;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ConditionOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"scf.condition", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ConditionOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24BFF3788;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::scf::ConditionOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ConditionOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>::getMutableSuccessorOperands;
  v2[1] = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>::getSuccessorRegions;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      v15 = 89;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[393], v2);
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>::getMutableSuccessorOperands@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v2;

  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a1 + 68) - 1;
  else
    v2 = -1;
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 1, v2, 0, 0);
}

void mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>::getSuccessorRegions(uint64_t a1, mlir::Operation *a2, _QWORD **a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;

  v5 = a2;
  mlir::scf::ConditionOp::getSuccessorRegions(&v5, a3, a4, a5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ConditionOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ConditionOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ConditionOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::ConditionOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v210 = 83;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v210 = 97;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[423];
  v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<Empty>]";
      v210 = 107;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[118];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451B000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451B000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface::Trait<Empty>]";
      v210 = 103;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451B000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[69];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[21];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v210 = 84;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[223] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::scf::ConditionOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::scf::ConditionOp>,mlir::OpTrait::ZeroResults<mlir::scf::ConditionOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ConditionOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::scf::ConditionOp>,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::scf::ConditionOp>,mlir::OpTrait::OpInvariants<mlir::scf::ConditionOp>,mlir::RegionBranchTerminatorOpInterface::Trait<mlir::scf::ConditionOp>,mlir::ConditionallySpeculatable::Trait<mlir::scf::ConditionOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::scf::ConditionOp>,mlir::MemoryEffectOpInterface::Trait<mlir::scf::ConditionOp>,mlir::OpTrait::IsTerminator<mlir::scf::ConditionOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::scf::ConditionOp>,mlir::OpTrait::ZeroResults<mlir::scf::ConditionOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ConditionOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::scf::ConditionOp>,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::scf::ConditionOp>,mlir::OpTrait::OpInvariants<mlir::scf::ConditionOp>,mlir::RegionBranchTerminatorOpInterface::Trait<mlir::scf::ConditionOp>,mlir::ConditionallySpeculatable::Trait<mlir::scf::ConditionOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::scf::ConditionOp>,mlir::MemoryEffectOpInterface::Trait<mlir::scf::ConditionOp>,mlir::OpTrait::IsTerminator<mlir::scf::ConditionOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;

  return mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
      && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
      && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)
      && mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::scf::ConditionOp>::verifyTrait((uint64_t *)a1)
      && mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3((uint64_t *)a1, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::OpTrait::impl::verifyIsTerminator(a1, v5) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl<mlir::scf::ConditionOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  const char **v4;
  char *v5;
  char *v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char **v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  int64_t v29;
  char *v30;
  const char *v31;
  const void **v32;
  __int16 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  _QWORD v37[2];
  _QWORD v38[3];
  void *v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE v42[96];
  void *v43;
  _QWORD *v44;
  void *__p;
  _QWORD *v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
        return 1;
    }
  }
  v33 = 257;
  mlir::Operation::emitOpError(a1, &v32, (uint64_t)v38);
  if (v38[0])
  {
    LODWORD(v34) = 3;
    v35 = "expects parent op ";
    v36 = 18;
    v4 = &v34;
    v5 = (char *)v39;
    if (v40 >= v41)
    {
      v26 = v40 + 1;
      if (v39 <= &v34 && (char *)v39 + 24 * v40 > (char *)&v34)
      {
        v29 = (char *)&v34 - (_BYTE *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v5 = (char *)v39;
        v4 = (const char **)((char *)v39 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v4 = &v34;
        v5 = (char *)v39;
      }
    }
    v6 = &v5[24 * v40];
    v7 = *(_OWORD *)v4;
    *((_QWORD *)v6 + 2) = v4[2];
    *(_OWORD *)v6 = v7;
    ++v40;
  }
  v31 = "'";
  v8 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v38, &v31);
  v9 = (uint64_t)v8;
  v37[0] = "scf.while";
  v37[1] = 9;
  if (*v8)
  {
    v34 = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)v37, (uint64_t)v38, (uint64_t)(v8 + 1), (uint64_t)(v8 + 1), &v34);
    if (*(_QWORD *)v9)
    {
      v10 = v9 + 24;
      v11 = *(_QWORD *)(v9 + 24);
      LODWORD(v34) = 3;
      v35 = "'";
      v36 = 1;
      v12 = *(unsigned int *)(v9 + 32);
      v13 = &v34;
      if (v12 >= *(_DWORD *)(v9 + 36))
      {
        v27 = v12 + 1;
        v28 = v11 + 24 * v12 > (unint64_t)&v34;
        if (v11 <= (unint64_t)&v34 && v28)
        {
          v30 = (char *)&v34 - v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = (const char **)&v30[v11];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = &v34;
        }
      }
      v14 = v11 + 24 * *(unsigned int *)(v9 + 32);
      v15 = *(_OWORD *)v13;
      *(_QWORD *)(v14 + 16) = v13[2];
      *(_OWORD *)v14 = v15;
      ++*(_DWORD *)(v9 + 32);
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v9);
  if (v38[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  if (v47)
  {
    v17 = __p;
    if (__p)
    {
      v18 = v46;
      v19 = __p;
      if (v46 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v46 = v17;
      operator delete(v19);
    }
    v20 = v43;
    if (v43)
    {
      v21 = v44;
      v22 = v43;
      if (v44 != v43)
      {
        do
        {
          v24 = *--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
            MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
        }
        while (v21 != v20);
        v22 = v43;
      }
      v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42)
      free(v39);
  }
  return v16;
}

uint64_t mlir::Op<mlir::scf::ConditionOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::HasParent<mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  mlir::RewritePatternSet::addImpl<SingleBlockExecuteInliner,mlir::MLIRContext *&>(a2, 0, 0, &v4);
  mlir::RewritePatternSet::addImpl<MultiBlockExecuteInliner,mlir::MLIRContext *&>(a2, 0, 0, &v4);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::scf::ExecuteRegionOp::parse;
  a1[3] = (BOOL (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                               + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  mlir::Operation *v6;
  mlir::OpAsmPrinter *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ExecuteRegionOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(a2 + 68);
  else
    return 0;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getEntrySuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;
  uint64_t v6;

  v6 = a2;
  *(_QWORD *)&result = mlir::memref::AllocaScopeOp::getSuccessorRegions((uint64_t)&v6, 0, a5).n128_u64[0];
  return result;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  uint64_t v5;

  v5 = a2;
  *(_QWORD *)&result = mlir::memref::AllocaScopeOp::getSuccessorRegions((uint64_t)&v5, a3, a4).n128_u64[0];
  return result;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_DWORD *)(a2 + 44) & 0x7FFFFF;
  v7 = *(unsigned int *)(a5 + 8);
  if (v7 + v6 > (unint64_t)*(unsigned int *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v7 + v6, 12);
    LODWORD(v7) = *(_DWORD *)(a5 + 8);
    if (!(_DWORD)v6)
      goto LABEL_6;
  }
  else if (!(_DWORD)v6)
  {
    goto LABEL_6;
  }
  v8 = *(_QWORD *)a5 + 12 * v7;
  v9 = v6;
  do
  {
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    v8 += 12;
    --v9;
  }
  while (v9);
  LODWORD(v7) = *(_DWORD *)(a5 + 8);
LABEL_6:
  *(_DWORD *)(a5 + 8) = v7 + v6;
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ExecuteRegionOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  unint64_t v100;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v93 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v25 = v24;
    a1 = v93;
    if (v25)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v100 = 81;
      v26 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v26)
        v27 = v26;
      else
        v27 = v100;
      v28 = &v99[v27];
      v29 = v100 - v27;
      if (v100 - v27 >= 0x12)
        v30 = 18;
      else
        v30 = v100 - v27;
      v31 = v29 - v30;
      if (v31 >= v31 - 1)
        v32 = v31 - 1;
      else
        v32 = v31;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v28[v30], v32);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v93;
    }
  }
  v3 = v2[415];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v88 = v3;
    v94 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v34 = v33;
    v3 = v88;
    a1 = v94;
    if (v34)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v100 = 87;
      v35 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v35)
        v36 = v35;
      else
        v36 = v100;
      v37 = &v99[v36];
      v38 = v100 - v36;
      if (v100 - v36 >= 0x12)
        v39 = 18;
      else
        v39 = v100 - v36;
      v40 = v38 - v39;
      if (v40 >= v40 - 1)
        v41 = v40 - 1;
      else
        v41 = v40;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v88;
      a1 = v94;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v89 = v3;
    v95 = a1;
    v84 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v84;
    v3 = v89;
    v43 = v42;
    a1 = v95;
    if (v43)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v100 = 86;
      v44 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v44)
        v45 = v44;
      else
        v45 = v100;
      v46 = &v99[v45];
      v47 = v100 - v45;
      if (v100 - v45 >= 0x12)
        v48 = 18;
      else
        v48 = v100 - v45;
      v49 = v47 - v48;
      if (v49 >= v49 - 1)
        v50 = v49 - 1;
      else
        v50 = v49;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v84;
      v3 = v89;
      a1 = v95;
    }
  }
  v9 = v8[419];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v90 = v3;
    v96 = a1;
    v81 = v9;
    v85 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v81;
    v6 = v85;
    v52 = v51;
    v3 = v90;
    a1 = v96;
    if (v52)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v100 = 84;
      v53 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v53)
        v54 = v53;
      else
        v54 = v100;
      v55 = &v99[v54];
      v56 = v100 - v54;
      if (v100 - v54 >= 0x12)
        v57 = 18;
      else
        v57 = v100 - v54;
      v58 = v56 - v57;
      if (v58 >= v58 - 1)
        v59 = v58 - 1;
      else
        v59 = v58;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v81;
      v6 = v85;
      v3 = v90;
      a1 = v96;
    }
  }
  v12 = v11[421];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v91 = v3;
    v97 = a1;
    v82 = v9;
    v86 = v6;
    v79 = v12;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v79;
    v9 = v82;
    v6 = v86;
    v3 = v91;
    v61 = v60;
    a1 = v97;
    if (v61)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v100 = 84;
      v62 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v62)
        v63 = v62;
      else
        v63 = v100;
      v64 = &v99[v63];
      v65 = v100 - v63;
      if (v100 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v100 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v79;
      v9 = v82;
      v6 = v86;
      v3 = v91;
      a1 = v97;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v92 = v3;
    v98 = a1;
    v83 = v9;
    v87 = v6;
    v78 = v15;
    v80 = v12;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v78;
    v12 = v80;
    v9 = v83;
    v6 = v87;
    v70 = v69;
    v3 = v92;
    a1 = v98;
    if (v70)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v100 = 93;
      v71 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v71)
        v72 = v71;
      else
        v72 = v100;
      v73 = &v99[v72];
      v74 = v100 - v72;
      if (v100 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v100 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v78;
      v12 = v80;
      v9 = v83;
      v6 = v87;
      v3 = v92;
      a1 = v98;
    }
  }
  return v3 == a1 || v6 == a1 || v9 == a1 || v12 == a1 || v15 == a1 || v17[217] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v8;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::ExecuteRegionOp::print(&v8, a3);
}

BOOL mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::verifyInvariants(unsigned int *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  unsigned int *v9;

  if (!mlir::OpTrait::impl::verifyOneRegion((mlir::OpTrait::impl *)a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v3)
    || !mlir::OpTrait::impl::verifyZeroOperands((mlir::OpTrait::impl *)a1, v4))
  {
    return 0;
  }
  v5 = a1[9];
  if (a1[9])
    v6 = (uint64_t)(a1 - 4);
  else
    v6 = 0;
  if ((_DWORD)v5)
  {
    for (i = 0; i != v5; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v6, i);
  }
  v9 = a1;
  return mlir::scf::ExecuteRegionOp::verify((uint64_t **)&v9) != 0;
}

BOOL mlir::Op<mlir::scf::ExecuteRegionOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyTypesAlongControlFlowEdges(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ForOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"scf.for", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24BFF3C38;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::scf::ForOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::scf::ForOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x68uLL, 0x80040FDC59921uLL);
  *v2 = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::isDefinedOutsideOfLoop;
  v2[1] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getLoopRegions;
  v2[2] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::moveOutOfLoop;
  v2[3] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::promoteIfSingleIteration;
  v2[4] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleInductionVar;
  v2[5] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleLowerBound;
  v2[6] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleStep;
  v2[7] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleUpperBound;
  v2[8] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getInitsMutable;
  v2[9] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getRegionIterArgs;
  v2[10] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getYieldedValuesMutable;
  v2[11] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getLoopResults;
  v2[12] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::replaceWithAdditionalYields;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[116], v2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::isDefinedOutsideOfLoop(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  Operation *v4;
  uint64_t v6;

  v6 = a3;
  v4 = (Operation *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v6) + 2);
  if (v4 == a2)
    return 0;
  else
    return mlir::Operation::isProperAncestor(a2, v4) ^ 1;
}

double mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getLoopRegions@<D0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *(unsigned int *)(a1 + 44);
  if ((v2 & 0x7FFFFF) != 0)
    v3 = ((a1 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a1 + 40);
  else
    v3 = 0;
  a2[2] = v3;
  *a2 = a2 + 2;
  *(_QWORD *)&result = 0x600000001;
  a2[1] = 0x600000001;
  return result;
}

mlir::Operation *mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::moveOutOfLoop(int a1, mlir::Operation *a2, mlir::Operation *this)
{
  return mlir::Operation::moveBefore(this, a2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::promoteIfSingleIteration(int a1, uint64_t a2, mlir::RewriterBase *a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::scf::ForOp::promoteIfSingleIteration((mlir::scf::ForOp *)&v4, a3);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleInductionVar(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  return **(_QWORD **)(v3 + 48);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleLowerBound(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) | 4;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleStep(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88) | 4;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSingleUpperBound(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56) | 4;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getInitsMutable(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  unsigned int v5[4];
  void *v6;
  _QWORD v7[4];

  v7[3] = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a2 + 68) - 3;
  else
    v2 = -3;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v5, a2, 3, v2, 0, 0);
  v3 = mlir::MutableOperandRange::operator mlir::OperandRange(v5);
  if (v6 != v7)
    free(v6);
  return v3;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getRegionIterArgs(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  return *(_QWORD *)(v3 + 48) + 8;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getYieldedValuesMutable(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  ZinIrHalH13g **v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v8[4];
  void *v9;
  _QWORD v10[4];

  v10[3] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v2)
    v3 = (ZinIrHalH13g **)(v2 - 8);
  else
    v3 = 0;
  mlir::Block::getTerminator(v3);
  if ((*(_BYTE *)(v4 + 46) & 0x80) != 0)
    v5 = *(_DWORD *)(v4 + 68);
  else
    v5 = 0;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v8, v4, 0, v5, 0, 0);
  v6 = mlir::MutableOperandRange::operator mlir::OperandRange(v8);
  if (v9 != v10)
    free(v9);
  return v6;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getLoopResults(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(unsigned int *)(a1 + 36);
  v3 = a1 - 16;
  if (!(_DWORD)v2)
    v3 = 0;
  *(_QWORD *)a2 = v3;
  *(_QWORD *)(a2 + 8) = v2;
  *(_BYTE *)(a2 + 16) = 1;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::replaceWithAdditionalYields(ZinIrHalH13g *a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, unint64_t a4@<X4>, int a5@<W5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  ZinIrHalH13g *v7;

  v7 = a1;
  mlir::scf::ForOp::replaceWithAdditionalYields(&v7, a2, a3, a4, a5, a6, a7);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ForOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ForOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ForOp>::getSpeculatability(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int v3;
  uint64_t v5;
  _QWORD *v6;
  unsigned int v7;
  char v8;

  v5 = a2;
  mlir::scf::ForOp::getConstantStep((mlir::scf::ForOp *)&v5, (uint64_t)&v6);
  if (!v8)
    return 0;
  v2 = v7;
  if (v7 < 0x41)
  {
    if (v6 != (_QWORD *)1)
      goto LABEL_9;
LABEL_7:
    v3 = 0;
    if (v2 < 0x41)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (v2 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v6) <= 0x40 && *v6 == 1)
    goto LABEL_7;
LABEL_9:
  v3 = 1;
  if (v2 < 0x41)
    goto LABEL_12;
LABEL_10:
  if (v6)
    MEMORY[0x20BD002D4](v6, 0x1000C8000313F17);
LABEL_12:
  if (v3)
    return 0;
  return 2;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 96;
  else
    return 96;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getEntrySuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;
  uint64_t v6;

  v6 = a2;
  *(_QWORD *)&result = mlir::scf::ForOp::getSuccessorRegions(&v6, a2, a5).n128_u64[0];
  return result;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  uint64_t v5;

  v5 = a2;
  *(_QWORD *)&result = mlir::scf::ForOp::getSuccessorRegions(&v5, a2, a4).n128_u64[0];
  return result;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_DWORD *)(a2 + 44) & 0x7FFFFF;
  v7 = *(unsigned int *)(a5 + 8);
  if (v7 + v6 > (unint64_t)*(unsigned int *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v7 + v6, 12);
    LODWORD(v7) = *(_DWORD *)(a5 + 8);
    if (!(_DWORD)v6)
      goto LABEL_6;
  }
  else if (!(_DWORD)v6)
  {
    goto LABEL_6;
  }
  v8 = *(_QWORD *)a5 + 12 * v7;
  v9 = v6;
  do
  {
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    v8 += 12;
    --v9;
  }
  while (v9);
  LODWORD(v7) = *(_DWORD *)(a5 + 8);
LABEL_6:
  *(_DWORD *)(a5 + 8) = v7 + v6;
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v235 = 81;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v222;
    }
  }
  v3 = v2[415];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v235 = 87;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>]";
      v235 = 97;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[437];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v235 = 83;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[433];
  v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::Yi"
             "eldOp>::Impl<Empty>]";
      v235 = 127;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[120];
  v20 = &unk_254519000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_254519000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_254519000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[423];
  v23 = &unk_25451B000;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = (_QWORD *)&unk_25451B000;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AutomaticAllocationScope<Empty>]";
      v235 = 96;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = (_QWORD *)&unk_25451B000;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[55];
  v26 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface::Trait<Empty>]";
      v235 = 89;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[122];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[312];
  v32 = &unk_25451B000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_25451B000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_25451B000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[217];
  v35 = &unk_25451B000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451B000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v235 = 97;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451B000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[219] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v8;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::ForOp::print(&v8, a3);
}

BOOL mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyOneRegion(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)3))
    return 0;
  if (!mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
    return 0;
  v5 = a1;
  if (!mlir::scf::ForOp::verifyInvariantsImpl((uint64_t **)&v5))
    return 0;
  v5 = a1;
  return mlir::scf::ForOp::verify((uint64_t **)&v5) != 0;
}

BOOL mlir::Op<mlir::scf::ForOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::RegionBranchOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyRegionInvariants(mlir::detail *a1)
{
  mlir::Operation *v2;
  mlir::Operation *v3;
  mlir::detail *v5;

  if (!mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::verifyRegionTrait((uint64_t)a1)
    || !mlir::detail::verifyLoopLikeOpInterface(a1, v2)
    || !mlir::detail::verifyTypesAlongControlFlowEdges(a1, v3))
  {
    return 0;
  }
  v5 = a1;
  return mlir::scf::ForOp::verifyRegions((uint64_t **)&v5) != 0;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::verifyRegionTrait(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AttrData;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void ***v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  Layer2TDMapper::SourceLayer *v22;
  uint64_t IsGraphInitialization;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v33;
  BOOL v34;
  char *v35;
  const void **v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  _QWORD v40[4];
  __int16 v41;
  _QWORD v42[4];
  __int16 v43;
  _QWORD v44[4];
  __int16 v45;
  const void **v46[4];
  __int16 v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v1 = *(_DWORD *)(a1 + 44) & 0x7FFFFF;
  if (!(_DWORD)v1)
    return 1;
  v3 = 0;
  v4 = a1 + 64;
  v5 = 24 * v1;
  while (1)
  {
    v6 = *(unsigned int *)(a1 + 44);
    if ((v6 & 0x7FFFFF) == 0)
      break;
    v7 = (_QWORD *)((char *)&v3[4 * *(unsigned int *)(a1 + 40)]
                  + ((v4 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8));
    if (v7 != (_QWORD *)*v7)
      goto LABEL_8;
LABEL_3:
    v3 += 3;
    if ((_QWORD *)v5 == v3)
      return 1;
  }
  v7 = v3;
  if (v3 == (_QWORD *)*v3)
    goto LABEL_3;
LABEL_8:
  v8 = v7[1];
  if (v8)
    v9 = v8 - 8;
  else
    v9 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v9 + 32));
  v11 = *(_QWORD *)(v10 + 48);
  if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id)
    goto LABEL_3;
  v41 = 1283;
  v40[0] = "expects regions to end with '";
  v40[2] = "scf.yield";
  v40[3] = 9;
  v42[0] = v40;
  v42[2] = "', found '";
  v43 = 770;
  v48 = *(_QWORD *)(v11 + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  v44[0] = v42;
  v44[2] = AttrData;
  v44[3] = v13;
  v45 = 1282;
  v46[0] = (const void **)v44;
  v46[2] = (const void **)"'";
  v47 = 770;
  mlir::Operation::emitOpError((uint64_t *)a1, v46, (uint64_t)&v48);
  v14 = mlir::Diagnostic::attachNote(&v49, 0, 0);
  v15 = v14 + 16;
  v16 = *(_QWORD *)(v14 + 16);
  LODWORD(v36) = 3;
  v37 = (uint64_t)"in custom textual format, the absence of terminator implies '";
  v38 = 61;
  v17 = *(unsigned int *)(v14 + 24);
  v18 = &v36;
  if (v17 >= *(_DWORD *)(v14 + 28))
  {
    v33 = v17 + 1;
    v34 = v16 + 24 * v17 > (unint64_t)&v36;
    if (v16 <= (unint64_t)&v36 && v34)
    {
      v35 = (char *)&v36 - v16;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 32), v33, 24);
      v16 = *(_QWORD *)(v14 + 16);
      v18 = (const void ***)&v35[v16];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 32), v33, 24);
      v16 = *(_QWORD *)(v14 + 16);
      v18 = &v36;
    }
  }
  v19 = v16 + 24 * *(unsigned int *)(v14 + 24);
  v20 = *(_OWORD *)v18;
  *(_QWORD *)(v19 + 16) = v18[2];
  *(_OWORD *)v19 = v20;
  ++*(_DWORD *)(v14 + 24);
  v39 = 262;
  v36 = (const void **)"scf.yield";
  v37 = 9;
  v21 = mlir::Diagnostic::operator<<(v14, &v36);
  v22 = (Layer2TDMapper::SourceLayer *)mlir::Diagnostic::operator<<(v21, 39);
  IsGraphInitialization = Layer2TDMapper::SourceLayer::IsGraphInitialization(v22);
  if (v48)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v48);
  if (v56)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v55;
      v26 = __p;
      if (v55 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v55 = v24;
      operator delete(v26);
    }
    v27 = v52;
    if (v52)
    {
      v28 = v53;
      v29 = v52;
      if (v53 != v52)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v52;
      }
      v53 = v27;
      operator delete(v29);
    }
    if (v50 != &v51)
      free(v50);
  }
  return IsGraphInitialization;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"scf.forall", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24BFF3E90;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::scf::ForallOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::getParseAssemblyFn(uint64_t (**a1)(mlir::AsmParser *a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::scf::ForallOp::parse;
  a1[3] = (uint64_t (*)(mlir::AsmParser *, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                             + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::getInherentAttr(uint64_t a1, uint64_t a2, _DWORD *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::scf::ForallOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  _DWORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::scf::ForallOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::scf::ForallOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::scf::ForallOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::scf::ForallOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::scf::ForallOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  return a3[4] == a2[4] && a3[5] == a2[5];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::scf::ForallOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::scf::ForallOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::scf::ForallOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x68uLL, 0x80040FDC59921uLL);
  *v2 = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::isDefinedOutsideOfLoop;
  v2[1] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getLoopRegions;
  v2[2] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::moveOutOfLoop;
  v2[3] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::promoteIfSingleIteration;
  v2[4] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleInductionVar;
  v2[5] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleLowerBound;
  v2[6] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleStep;
  v2[7] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleUpperBound;
  v2[8] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getInitsMutable;
  v2[9] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getRegionIterArgs;
  v2[10] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getYieldedValuesMutable;
  v2[11] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getLoopResults;
  v2[12] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::replaceWithAdditionalYields;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[116], v2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::isDefinedOutsideOfLoop(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  Operation *v4;
  uint64_t v6;

  v6 = a3;
  v4 = (Operation *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v6) + 2);
  if (v4 == a2)
    return 0;
  else
    return mlir::Operation::isProperAncestor(a2, v4) ^ 1;
}

double mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getLoopRegions@<D0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *(unsigned int *)(a1 + 44);
  if ((v2 & 0x7FFFFF) != 0)
    v3 = ((a1 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a1 + 40);
  else
    v3 = 0;
  a2[2] = v3;
  *a2 = a2 + 2;
  *(_QWORD *)&result = 0x600000001;
  a2[1] = 0x600000001;
  return result;
}

mlir::Operation *mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::moveOutOfLoop(int a1, mlir::Operation *a2, mlir::Operation *this)
{
  return mlir::Operation::moveBefore(this, a2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::promoteIfSingleIteration(int a1, uint64_t a2, mlir::RewriterBase *a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::scf::ForallOp::promoteIfSingleIteration((mlir::scf::ForallOp *)&v4, a3);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleInductionVar(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::scf::ForallOp::getSingleInductionVar((mlir::scf::ForallOp *)&v3);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleLowerBound(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  void *v8[2];
  _QWORD v9[7];

  v9[6] = *MEMORY[0x24BDAC8D0];
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  v3 = *(void **)(v2 + 8);
  v7 = a2;
  v8[0] = v3;
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v8);
  v4 = 0;
  if (v5 == 1)
  {
    mlir::scf::ForallOp::getMixedLowerBound((mlir::scf::ForallOp *)&v7, (uint64_t)v8);
    v4 = *(_QWORD *)v8[0];
    if (v8[0] != v9)
      free(v8[0]);
  }
  return v4;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleStep(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  void *v8[2];
  _QWORD v9[7];

  v9[6] = *MEMORY[0x24BDAC8D0];
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  v3 = *(void **)(v2 + 8);
  v7 = a2;
  v8[0] = v3;
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v8);
  v4 = 0;
  if (v5 == 1)
  {
    mlir::scf::ForallOp::getMixedStep((mlir::scf::ForallOp *)&v7, (uint64_t)v8);
    v4 = *(_QWORD *)v8[0];
    if (v8[0] != v9)
      free(v8[0]);
  }
  return v4;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSingleUpperBound(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  void *v8[2];
  _QWORD v9[7];

  v9[6] = *MEMORY[0x24BDAC8D0];
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  v3 = *(void **)(v2 + 8);
  v7 = a2;
  v8[0] = v3;
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v8);
  v4 = 0;
  if (v5 == 1)
  {
    mlir::scf::ForallOp::getMixedUpperBound((mlir::scf::ForallOp *)&v7, (uint64_t)v8);
    v4 = *(_QWORD *)v8[0];
    if (v8[0] != v9)
      free(v8[0]);
  }
  return v4;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getInitsMutable()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getRegionIterArgs()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getYieldedValuesMutable()
{
  return 0;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getLoopResults(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::replaceWithAdditionalYields(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(a2 + 68);
  else
    return 0;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getEntrySuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;
  uint64_t v6;

  v6 = a2;
  *(_QWORD *)&result = mlir::scf::ForallOp::getSuccessorRegions((uint64_t)&v6, a2, a5).n128_u64[0];
  return result;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  uint64_t v5;

  v5 = a2;
  *(_QWORD *)&result = mlir::scf::ForallOp::getSuccessorRegions((uint64_t)&v5, a2, a4).n128_u64[0];
  return result;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_DWORD *)(a2 + 44) & 0x7FFFFF;
  v7 = *(unsigned int *)(a5 + 8);
  if (v7 + v6 > (unint64_t)*(unsigned int *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v7 + v6, 12);
    LODWORD(v7) = *(_DWORD *)(a5 + 8);
    if (!(_DWORD)v6)
      goto LABEL_6;
  }
  else if (!(_DWORD)v6)
  {
    goto LABEL_6;
  }
  v8 = *(_QWORD *)a5 + 12 * v7;
  v9 = v6;
  do
  {
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    v8 += 12;
    --v9;
  }
  while (v9);
  LODWORD(v7) = *(_DWORD *)(a5 + 8);
LABEL_6:
  *(_DWORD *)(a5 + 8) = v7 + v6;
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getDpsInitsMutable;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface]";
      v15 = 83;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[124], v2);
}

uint64_t mlir::detail::DestinationStyleOpInterfaceInterfaceTraits::Model<mlir::scf::ForallOp>::getDpsInitsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;
  _DWORD *v5;
  int v6;
  int v7;
  uint64_t v8;
  mlir::MLIRContext *Context;
  unint64_t v10;
  uint64_t v11;
  __int128 v13;
  int v14;
  __int128 v15;

  v4 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v5 = (_DWORD *)(a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1));
  else
    v5 = 0;
  v6 = v5[11];
  v7 = v5[9] + v5[8] + v5[10];
  v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 48) + 104) - 8);
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = v4 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  else
    v10 = 0;
  v11 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v10 + 32, 4);
  ZinMirCacheTensors::ZinMirCacheTensors(&v13, v8, v11);
  v14 = 3;
  v15 = v13;
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, v7, v6, &v14, 1);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  uint64_t *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  const char *v287;
  unint64_t v288;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v288 = 81;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v273;
    }
  }
  v3 = v2[415];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v288 = 87;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v288 = 88;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[73];
  v14 = &unk_25451B000;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = (_QWORD *)&unk_25451B000;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v288 = 96;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = (_QWORD *)&unk_25451B000;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[37];
  v17 = &unk_25451A000;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = (_QWORD *)&unk_25451A000;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v288 = 83;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = (_QWORD *)&unk_25451A000;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[433];
  v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::In"
             "ParallelOp>::Impl<Empty>]";
      v288 = 132;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = v20[126];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[423];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[310];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AutomaticAllocationScope<Empty>]";
      v288 = 96;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[55];
  v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface::Trait<Empty>]";
      v288 = 89;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[122];
  v35 = &unk_25451B000;
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v35 = (_QWORD *)&unk_25451B000;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v288 = 97;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v35 = (_QWORD *)&unk_25451B000;
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[219];
  v38 = &unk_25451B000;
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v38 = (_QWORD *)&unk_25451B000;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v288 = 93;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v38 = (_QWORD *)&unk_25451B000;
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[217];
  v41 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DestinationStyleOpInterface::Trait<Empty>]";
      v288 = 97;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::DestinationStyleOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DestinationStyleOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v41[128] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::ForallOp::print((mlir::scf::ForallOp *)&v8, a3);
}

BOOL mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyOneRegion(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
    return 0;
  if (!mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
    return 0;
  v5 = a1;
  if (!mlir::scf::ForallOp::verifyInvariantsImpl((uint64_t **)&v5))
    return 0;
  v5 = a1;
  return mlir::scf::ForallOp::verify((uint64_t **)&v5);
}

BOOL mlir::Op<mlir::scf::ForallOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait,mlir::DestinationStyleOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1)
{
  mlir::Operation *v2;
  mlir::Operation *v3;
  mlir::Operation *v4;

  return mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::scf::ForallOp>::verifyRegionTrait((uint64_t)a1)
      && mlir::detail::verifyLoopLikeOpInterface(a1, v2)
      && mlir::detail::verifyTypesAlongControlFlowEdges(a1, v3)
      && mlir::detail::verifyDestinationStyleOpInterface(a1, v4) != 0;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::scf::ForallOp>::verifyRegionTrait(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AttrData;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void ***v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  Layer2TDMapper::SourceLayer *v22;
  uint64_t IsGraphInitialization;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v33;
  BOOL v34;
  char *v35;
  const void **v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  _QWORD v40[4];
  __int16 v41;
  _QWORD v42[4];
  __int16 v43;
  _QWORD v44[4];
  __int16 v45;
  const void **v46[4];
  __int16 v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v1 = *(_DWORD *)(a1 + 44) & 0x7FFFFF;
  if (!(_DWORD)v1)
    return 1;
  v3 = 0;
  v4 = a1 + 64;
  v5 = 24 * v1;
  while (1)
  {
    v6 = *(unsigned int *)(a1 + 44);
    if ((v6 & 0x7FFFFF) == 0)
      break;
    v7 = (_QWORD *)((char *)&v3[4 * *(unsigned int *)(a1 + 40)]
                  + ((v4 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8));
    if (v7 != (_QWORD *)*v7)
      goto LABEL_8;
LABEL_3:
    v3 += 3;
    if ((_QWORD *)v5 == v3)
      return 1;
  }
  v7 = v3;
  if (v3 == (_QWORD *)*v3)
    goto LABEL_3;
LABEL_8:
  v8 = v7[1];
  if (v8)
    v9 = v8 - 8;
  else
    v9 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v9 + 32));
  v11 = *(_QWORD *)(v10 + 48);
  if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<mlir::scf::InParallelOp,void>::id)
    goto LABEL_3;
  v41 = 1283;
  v40[0] = "expects regions to end with '";
  v40[2] = "scf.forall.in_parallel";
  v40[3] = 22;
  v42[0] = v40;
  v42[2] = "', found '";
  v43 = 770;
  v48 = *(_QWORD *)(v11 + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  v44[0] = v42;
  v44[2] = AttrData;
  v44[3] = v13;
  v45 = 1282;
  v46[0] = (const void **)v44;
  v46[2] = (const void **)"'";
  v47 = 770;
  mlir::Operation::emitOpError((uint64_t *)a1, v46, (uint64_t)&v48);
  v14 = mlir::Diagnostic::attachNote(&v49, 0, 0);
  v15 = v14 + 16;
  v16 = *(_QWORD *)(v14 + 16);
  LODWORD(v36) = 3;
  v37 = (uint64_t)"in custom textual format, the absence of terminator implies '";
  v38 = 61;
  v17 = *(unsigned int *)(v14 + 24);
  v18 = &v36;
  if (v17 >= *(_DWORD *)(v14 + 28))
  {
    v33 = v17 + 1;
    v34 = v16 + 24 * v17 > (unint64_t)&v36;
    if (v16 <= (unint64_t)&v36 && v34)
    {
      v35 = (char *)&v36 - v16;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 32), v33, 24);
      v16 = *(_QWORD *)(v14 + 16);
      v18 = (const void ***)&v35[v16];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 32), v33, 24);
      v16 = *(_QWORD *)(v14 + 16);
      v18 = &v36;
    }
  }
  v19 = v16 + 24 * *(unsigned int *)(v14 + 24);
  v20 = *(_OWORD *)v18;
  *(_QWORD *)(v19 + 16) = v18[2];
  *(_OWORD *)v19 = v20;
  ++*(_DWORD *)(v14 + 24);
  v39 = 262;
  v36 = (const void **)"scf.forall.in_parallel";
  v37 = 22;
  v21 = mlir::Diagnostic::operator<<(v14, &v36);
  v22 = (Layer2TDMapper::SourceLayer *)mlir::Diagnostic::operator<<(v21, 39);
  IsGraphInitialization = Layer2TDMapper::SourceLayer::IsGraphInitialization(v22);
  if (v48)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v48);
  if (v56)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v55;
      v26 = __p;
      if (v55 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v55 = v24;
      operator delete(v26);
    }
    v27 = v52;
    if (v52)
    {
      v28 = v53;
      v29 = v52;
      if (v53 != v52)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v52;
      }
      v53 = v27;
      operator delete(v29);
    }
    if (v50 != &v51)
      free(v50);
  }
  return IsGraphInitialization;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2, a3, a4);
  v5 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
      (*(void (__cdecl **)())((v8 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v5 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::scf::IfOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::scf::IfOp::parse;
  a1[3] = (BOOL (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                               + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::printAssembly(uint64_t a1, unsigned int *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  mlir::Operation *v6;
  mlir::OpAsmPrinter *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, unsigned int *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IfOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(a2 + 68);
  else
    return 0;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getEntrySuccessorRegions(uint64_t a1, unsigned int *a2, _QWORD **a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;

  v5 = a2;
  mlir::scf::IfOp::getEntrySuccessorRegions(&v5, a3, a4, a5);
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  uint64_t v5;

  v5 = a2;
  *(_QWORD *)&result = mlir::scf::IfOp::getSuccessorRegions((uint64_t)&v5, a3, a4).n128_u64[0];
  return result;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, _QWORD **a3, uint64_t a4, uint64_t a5)
{
  mlir::scf::IfOp::getRegionInvocationBounds(a1, a3, a4, a5);
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t Context;
  _OWORD v15[3];
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v17 = a6;
  BYTE8(v17) = 0;
  LOBYTE(v18) = 0;
  *((_QWORD *)&v18 + 1) = a9;
  *(_QWORD *)&v19 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v17);
    if ((_BYTE)v18)
      LOBYTE(v18) = 0;
    a1 = mlir::OperationName::OperationName((char *)&v17 + 8, "scf.if", 6, Context);
    LOBYTE(v18) = 1;
  }
  *((_QWORD *)&v19 + 1) = a4;
  v20 = a5;
  v15[0] = v17;
  v15[1] = v18;
  v16 = a5;
  v15[2] = v19;
  return mlir::scf::IfOp::inferReturnTypes(a1, a2, a3, (uint64_t)v15, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::scf::IfOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::scf::IfOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::scf::IfOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  uint64_t Context;
  uint64_t v16;
  void *v17;
  unint64_t v19[2];
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  _BYTE v24[32];
  _OWORD v25[3];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v13 = a3;
  v31 = *MEMORY[0x24BDAC8D0];
  v22 = v24;
  v23 = 0x400000000;
  *(_QWORD *)&v27 = a6;
  BYTE8(v27) = 0;
  LOBYTE(v28) = 0;
  *((_QWORD *)&v28 + 1) = a9;
  *(_QWORD *)&v29 = a10;
  if (a6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v27);
    if ((_BYTE)v28)
      LOBYTE(v28) = 0;
    a1 = mlir::OperationName::OperationName((char *)&v27 + 8, "scf.if", 6, Context);
    LOBYTE(v28) = 1;
  }
  *((_QWORD *)&v29 + 1) = a4;
  v30 = a5;
  v25[0] = v27;
  v25[1] = v28;
  v26 = a5;
  v25[2] = v29;
  if (!mlir::scf::IfOp::inferReturnTypes(a1, a2, a3, (uint64_t)v25, (uint64_t)&v22))
  {
    v16 = 0;
    v17 = v22;
    if (v22 == v24)
      return v16;
    goto LABEL_11;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v20, (uint64_t)v22, v23);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v21 == v19[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v20, 0, v20, v21, v19[0], 0, v19[0], v21))
  {
    v16 = 1;
    v17 = v22;
    if (v22 == v24)
      return v16;
    goto LABEL_11;
  }
  *(_QWORD *)&v27 = "scf.if";
  *((_QWORD *)&v27 + 1) = 6;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v13, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
  v17 = v22;
  if (v22 != v24)
LABEL_11:
    free(v17);
  return v16;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  unsigned int *v7;
  _BYTE v8[40];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v7 = a2;
  mlir::scf::detail::IfOpGenericAdaptorBase::IfOpGenericAdaptorBase((uint64_t)v8, a2);
  v9 = a3;
  v10 = a4;
  return mlir::scf::IfOp::fold((uint64_t *)&v7);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NRegions<2>::Impl<Empty>]";
      v235 = 89;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NRegions<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NRegions<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v222;
    }
  }
  v3 = v2[439];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v235 = 87;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v235 = 82;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[19];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v235 = 83;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[433];
  v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::Yi"
             "eldOp>::Impl<Empty>]";
      v235 = 127;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[120];
  v20 = &unk_25451B000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_25451B000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NoRegionArguments<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NoRegionArguments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoRegionArguments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_25451B000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[149];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[423];
  v26 = &unk_25451B000;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (_QWORD *)&unk_25451B000;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v235 = 93;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (_QWORD *)&unk_25451B000;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[217];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v235 = 90;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[27];
  v32 = &unk_25451B000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_25451B000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::InferTypeOpAdaptor<Empty>]";
      v235 = 90;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::OpTrait::InferTypeOpAdaptor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::InferTypeOpAdaptor>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_25451B000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[235];
  v35 = &unk_25451B000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451B000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v235 = 97;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451B000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[219] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, unsigned int *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v8;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::IfOp::print(&v8, a3);
}

BOOL mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyInvariants(mlir::OpTrait::impl *a1)
{
  mlir::OpTrait::impl *v3;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::NRegions<2u>::Impl<mlir::scf::IfOp>,mlir::OpTrait::VariadicResults<mlir::scf::IfOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::IfOp>,mlir::OpTrait::OneOperand<mlir::scf::IfOp>,mlir::OpTrait::SingleBlock<mlir::scf::IfOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>,mlir::OpTrait::NoRegionArguments<mlir::scf::IfOp>,mlir::OpTrait::OpInvariants<mlir::scf::IfOp>,mlir::RegionBranchOpInterface::Trait<mlir::scf::IfOp>,mlir::InferTypeOpInterface::Trait<mlir::scf::IfOp>,mlir::OpTrait::InferTypeOpAdaptor<mlir::scf::IfOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::scf::IfOp>>(a1))
    return 0;
  v3 = a1;
  return mlir::scf::IfOp::verify((uint64_t **)&v3) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::NRegions<2u>::Impl<mlir::scf::IfOp>,mlir::OpTrait::VariadicResults<mlir::scf::IfOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::IfOp>,mlir::OpTrait::OneOperand<mlir::scf::IfOp>,mlir::OpTrait::SingleBlock<mlir::scf::IfOp>,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>,mlir::OpTrait::NoRegionArguments<mlir::scf::IfOp>,mlir::OpTrait::OpInvariants<mlir::scf::IfOp>,mlir::RegionBranchOpInterface::Trait<mlir::scf::IfOp>,mlir::InferTypeOpInterface::Trait<mlir::scf::IfOp>,mlir::OpTrait::InferTypeOpAdaptor<mlir::scf::IfOp>,mlir::OpTrait::HasRecursiveMemoryEffects<mlir::scf::IfOp>>(mlir::OpTrait::impl *a1)
{
  mlir::Operation *v2;
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyNRegions(a1, (mlir::Operation *)2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v2)
    || !mlir::OpTrait::impl::verifyOneOperand(a1, v3)
    || !mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1)
    || !mlir::OpTrait::impl::verifyNoRegionArguments(a1, v4))
  {
    return 0;
  }
  v6 = a1;
  return mlir::scf::IfOp::verifyInvariantsImpl((uint64_t **)&v6);
}

BOOL mlir::Op<mlir::scf::IfOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::NoRegionArguments,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::OpTrait::InferTypeOpAdaptor,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyRegionInvariants(mlir::detail *a1)
{
  mlir::Operation *v2;
  mlir::Operation *v3;

  return mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::verifyRegionTrait((uint64_t)a1)
      && mlir::detail::verifyTypesAlongControlFlowEdges(a1, v2)
      && mlir::detail::verifyInferredResultTypes(a1, v3) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::InParallelOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionKindInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"scf.forall.in_parallel", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::InParallelOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24BFF3850;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::scf::InParallelOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::InParallelOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::InParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::InParallelOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::InParallelOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getParentResult;
  v2[1] = mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getYieldingOps;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ParallelCombiningOpInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[140], v2);
}

uint64_t mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getParentResult(uint64_t a1, uint64_t a2, unsigned int a3)
{
  mlir::Block *ParentOp;

  ParentOp = *(mlir::Block **)(a2 + 16);
  if (ParentOp)
    ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
  if (a3 <= 5)
    return (uint64_t)ParentOp - 16 * a3 - 16;
  else
    return (uint64_t)ParentOp - 24 * a3 + 24;
}

uint64_t mlir::detail::ParallelCombiningOpInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getYieldingOps(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  return *(_QWORD *)(v3 + 40);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionKindInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::RegionKindInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getRegionKind;
  v2[1] = mlir::detail::RegionKindInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::hasSSADominance;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionKindInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionKindInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[147], v2);
}

uint64_t mlir::detail::RegionKindInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::getRegionKind()
{
  return 1;
}

uint64_t mlir::detail::RegionKindInterfaceInterfaceTraits::Model<mlir::scf::InParallelOp>::hasSSADominance()
{
  return 0;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  uint64_t v42;
  unsigned __int8 v43;
  _QWORD *v44;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  unint64_t v80;
  unint64_t v81;
  const char *v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  unint64_t v89;
  unint64_t v90;
  const char *v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  unint64_t v98;
  unint64_t v99;
  const char *v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  int v105;
  int v106;
  unint64_t v107;
  unint64_t v108;
  const char *v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  int v114;
  int v115;
  unint64_t v116;
  unint64_t v117;
  const char *v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  int v123;
  int v124;
  unint64_t v125;
  unint64_t v126;
  const char *v127;
  unint64_t v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  int v132;
  int v133;
  unint64_t v134;
  unint64_t v135;
  const char *v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  int v141;
  int v142;
  unint64_t v143;
  unint64_t v144;
  const char *v145;
  unint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  int v150;
  int v151;
  unint64_t v152;
  unint64_t v153;
  const char *v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  int v159;
  int v160;
  unint64_t v161;
  unint64_t v162;
  const char *v163;
  unint64_t v164;
  uint64_t v165;
  unint64_t v166;
  uint64_t v167;
  int v168;
  int v169;
  unint64_t v170;
  unint64_t v171;
  const char *v172;
  unint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  int v177;
  int v178;
  unint64_t v179;
  unint64_t v180;
  const char *v181;
  unint64_t v182;
  uint64_t v183;
  unint64_t v184;
  uint64_t v185;
  int v186;
  int v187;
  unint64_t v188;
  unint64_t v189;
  const char *v190;
  unint64_t v191;
  uint64_t v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  const char *v315;
  unint64_t v316;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v300 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v61 = v60;
    a1 = v300;
    if (v61)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v316 = 81;
      v62 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v62)
        v63 = v62;
      else
        v63 = v316;
      v64 = &v315[v63];
      v65 = v316 - v63;
      if (v316 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v316 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v300;
    }
  }
  v3 = v2[415];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v286 = v3;
    v301 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v70 = v69;
    v3 = v286;
    a1 = v301;
    if (v70)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v316 = 83;
      v71 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v71)
        v72 = v71;
      else
        v72 = v316;
      v73 = &v315[v72];
      v74 = v316 - v72;
      if (v316 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v316 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v286;
      a1 = v301;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v287 = v3;
    v302 = a1;
    v273 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v273;
    v3 = v287;
    v79 = v78;
    a1 = v302;
    if (v79)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v316 = 86;
      v80 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v80)
        v81 = v80;
      else
        v81 = v316;
      v82 = &v315[v81];
      v83 = v316 - v81;
      if (v316 - v81 >= 0x12)
        v84 = 18;
      else
        v84 = v316 - v81;
      v85 = v83 - v84;
      if (v85 >= v85 - 1)
        v86 = v85 - 1;
      else
        v86 = v85;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v273;
      v3 = v287;
      a1 = v302;
    }
  }
  v9 = v8[419];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v288 = v3;
    v303 = a1;
    v261 = v9;
    v274 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v261;
    v6 = v274;
    v88 = v87;
    v3 = v288;
    a1 = v303;
    if (v88)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v316 = 84;
      v89 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v89)
        v90 = v89;
      else
        v90 = v316;
      v91 = &v315[v90];
      v92 = v316 - v90;
      if (v316 - v90 >= 0x12)
        v93 = 18;
      else
        v93 = v316 - v90;
      v94 = v92 - v93;
      if (v94 >= v94 - 1)
        v95 = v94 - 1;
      else
        v95 = v94;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v261;
      v6 = v274;
      v3 = v288;
      a1 = v303;
    }
  }
  v12 = v11[421];
  v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v289 = v3;
    v304 = a1;
    v262 = v9;
    v275 = v6;
    v250 = v12;
    v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v12 = v250;
    v9 = v262;
    v6 = v275;
    v3 = v289;
    v97 = v96;
    a1 = v304;
    if (v97)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<Empty>]";
      v316 = 108;
      v98 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v98)
        v99 = v98;
      else
        v99 = v316;
      v100 = &v315[v99];
      v101 = v316 - v99;
      if (v316 - v99 >= 0x12)
        v102 = 18;
      else
        v102 = v316 - v99;
      v103 = v101 - v102;
      if (v103 >= v103 - 1)
        v104 = v103 - 1;
      else
        v104 = v103;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v12 = v250;
      v9 = v262;
      v6 = v275;
      v3 = v289;
      a1 = v304;
    }
  }
  v15 = v14[142];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v290 = v3;
    v305 = a1;
    v263 = v9;
    v276 = v6;
    v251 = v12;
    v240 = v15;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v240;
    v12 = v251;
    v9 = v263;
    v6 = v276;
    v3 = v290;
    v106 = v105;
    a1 = v305;
    if (v106)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NoTerminator<Empty>]";
      v316 = 84;
      v107 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v107)
        v108 = v107;
      else
        v108 = v316;
      v109 = &v315[v108];
      v110 = v316 - v108;
      if (v316 - v108 >= 0x12)
        v111 = 18;
      else
        v111 = v316 - v108;
      v112 = v110 - v111;
      if (v112 >= v112 - 1)
        v113 = v112 - 1;
      else
        v113 = v112;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NoTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NoTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v240;
      v12 = v251;
      v9 = v263;
      v6 = v276;
      v3 = v290;
      a1 = v305;
    }
  }
  v18 = v17[151];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v291 = v3;
    v306 = a1;
    v264 = v9;
    v277 = v6;
    v252 = v12;
    v231 = v18;
    v241 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v231;
    v15 = v241;
    v12 = v252;
    v9 = v264;
    v6 = v277;
    v3 = v291;
    v115 = v114;
    a1 = v306;
    if (v115)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v316 = 83;
      v116 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v116)
        v117 = v116;
      else
        v117 = v316;
      v118 = &v315[v117];
      v119 = v316 - v117;
      if (v316 - v117 >= 0x12)
        v120 = 18;
      else
        v120 = v316 - v117;
      v121 = v119 - v120;
      if (v121 >= v121 - 1)
        v122 = v121 - 1;
      else
        v122 = v121;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v231;
      v15 = v241;
      v12 = v252;
      v9 = v264;
      v6 = v277;
      v3 = v291;
      a1 = v306;
    }
  }
  v21 = v20[433];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v292 = v3;
    v307 = a1;
    v265 = v9;
    v278 = v6;
    v253 = v12;
    v232 = v18;
    v242 = v15;
    v223 = v21;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v223;
    v18 = v232;
    v15 = v242;
    v12 = v253;
    v9 = v265;
    v6 = v278;
    v3 = v292;
    v124 = v123;
    a1 = v307;
    if (v124)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v316 = 84;
      v125 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v125)
        v126 = v125;
      else
        v126 = v316;
      v127 = &v315[v126];
      v128 = v316 - v126;
      if (v316 - v126 >= 0x12)
        v129 = 18;
      else
        v129 = v316 - v126;
      v130 = v128 - v129;
      if (v130 >= v130 - 1)
        v131 = v130 - 1;
      else
        v131 = v130;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v223;
      v18 = v232;
      v15 = v242;
      v12 = v253;
      v9 = v265;
      v6 = v278;
      v3 = v292;
      a1 = v307;
    }
  }
  v24 = v23[423];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v293 = v3;
    v308 = a1;
    v266 = v9;
    v279 = v6;
    v254 = v12;
    v233 = v18;
    v243 = v15;
    v216 = v24;
    v224 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v216;
    v21 = v224;
    v18 = v233;
    v15 = v243;
    v12 = v254;
    v9 = v266;
    v6 = v279;
    v3 = v293;
    v133 = v132;
    a1 = v308;
    if (v133)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v316 = 95;
      v134 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v134)
        v135 = v134;
      else
        v135 = v316;
      v136 = &v315[v135];
      v137 = v316 - v135;
      if (v316 - v135 >= 0x12)
        v138 = 18;
      else
        v138 = v316 - v135;
      v139 = v137 - v138;
      if (v139 >= v139 - 1)
        v140 = v139 - 1;
      else
        v140 = v139;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v136[v138], v140);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v216;
      v21 = v224;
      v18 = v233;
      v15 = v243;
      v12 = v254;
      v9 = v266;
      v6 = v279;
      v3 = v293;
      a1 = v308;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v294 = v3;
    v309 = a1;
    v267 = v9;
    v280 = v6;
    v255 = v12;
    v234 = v18;
    v244 = v15;
    v217 = v24;
    v225 = v21;
    v210 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v210;
    v24 = v217;
    v21 = v225;
    v18 = v234;
    v15 = v244;
    v12 = v255;
    v9 = v267;
    v6 = v280;
    v3 = v294;
    v142 = v141;
    a1 = v309;
    if (v142)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v316 = 99;
      v143 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v143)
        v144 = v143;
      else
        v144 = v316;
      v145 = &v315[v144];
      v146 = v316 - v144;
      if (v316 - v144 >= 0x12)
        v147 = 18;
      else
        v147 = v316 - v144;
      v148 = v146 - v147;
      if (v148 >= v148 - 1)
        v149 = v148 - 1;
      else
        v149 = v148;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v145[v147], v149);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v210;
      v24 = v217;
      v21 = v225;
      v18 = v234;
      v15 = v244;
      v12 = v255;
      v9 = v267;
      v6 = v280;
      v3 = v294;
      a1 = v309;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v295 = v3;
    v310 = a1;
    v268 = v9;
    v281 = v6;
    v256 = v12;
    v235 = v18;
    v245 = v15;
    v218 = v24;
    v226 = v21;
    v205 = v30;
    v211 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v205;
    v27 = v211;
    v24 = v218;
    v21 = v226;
    v18 = v235;
    v15 = v245;
    v12 = v256;
    v9 = v268;
    v6 = v281;
    v3 = v295;
    v151 = v150;
    a1 = v310;
    if (v151)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v316 = 93;
      v152 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v152)
        v153 = v152;
      else
        v153 = v316;
      v154 = &v315[v153];
      v155 = v316 - v153;
      if (v316 - v153 >= 0x12)
        v156 = 18;
      else
        v156 = v316 - v153;
      v157 = v155 - v156;
      if (v157 >= v157 - 1)
        v158 = v157 - 1;
      else
        v158 = v157;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v154[v156], v158);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v205;
      v27 = v211;
      v24 = v218;
      v21 = v226;
      v18 = v235;
      v15 = v245;
      v12 = v256;
      v9 = v268;
      v6 = v281;
      v3 = v295;
      a1 = v310;
    }
  }
  v33 = v32[21];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v296 = v3;
    v311 = a1;
    v269 = v9;
    v282 = v6;
    v257 = v12;
    v236 = v18;
    v246 = v15;
    v219 = v24;
    v227 = v21;
    v206 = v30;
    v212 = v27;
    v201 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v201;
    v30 = v206;
    v27 = v212;
    v24 = v219;
    v21 = v227;
    v18 = v236;
    v15 = v246;
    v12 = v257;
    v9 = v269;
    v6 = v282;
    v3 = v296;
    v160 = v159;
    a1 = v311;
    if (v160)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v316 = 84;
      v161 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v161)
        v162 = v161;
      else
        v162 = v316;
      v163 = &v315[v162];
      v164 = v316 - v162;
      if (v316 - v162 >= 0x12)
        v165 = 18;
      else
        v165 = v316 - v162;
      v166 = v164 - v165;
      if (v166 >= v166 - 1)
        v167 = v166 - 1;
      else
        v167 = v166;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v163[v165], v167);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v201;
      v30 = v206;
      v27 = v212;
      v24 = v219;
      v21 = v227;
      v18 = v236;
      v15 = v246;
      v12 = v257;
      v9 = v269;
      v6 = v282;
      v3 = v296;
      a1 = v311;
    }
  }
  v36 = v35[223];
  v38 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v37 & 1) == 0)
  {
    v297 = v3;
    v312 = a1;
    v270 = v9;
    v283 = v6;
    v258 = v12;
    v237 = v18;
    v247 = v15;
    v220 = v24;
    v228 = v21;
    v207 = v30;
    v213 = v27;
    v198 = v36;
    v202 = v33;
    v38 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v36 = v198;
    v33 = v202;
    v30 = v207;
    v27 = v213;
    v24 = v220;
    v21 = v228;
    v18 = v237;
    v15 = v247;
    v12 = v258;
    v9 = v270;
    v6 = v283;
    v3 = v297;
    v169 = v168;
    a1 = v312;
    if (v169)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ParallelCombiningOpInterface::Trait<Empty>]";
      v316 = 98;
      v170 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v170)
        v171 = v170;
      else
        v171 = v316;
      v172 = &v315[v171];
      v173 = v316 - v171;
      if (v316 - v171 >= 0x12)
        v174 = 18;
      else
        v174 = v316 - v171;
      v175 = v173 - v174;
      if (v175 >= v175 - 1)
        v176 = v175 - 1;
      else
        v176 = v175;
      mlir::detail::TypeIDResolver<mlir::ParallelCombiningOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ParallelCombiningOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v172[v174], v176);
      v38 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v36 = v198;
      v33 = v202;
      v30 = v207;
      v27 = v213;
      v24 = v220;
      v21 = v228;
      v18 = v237;
      v15 = v247;
      v12 = v258;
      v9 = v270;
      v6 = v283;
      v3 = v297;
      a1 = v312;
    }
  }
  v39 = v38[144];
  v41 = &unk_25451B000;
  if ((v40 & 1) == 0)
  {
    v298 = v3;
    v313 = a1;
    v271 = v9;
    v284 = v6;
    v259 = v12;
    v238 = v18;
    v248 = v15;
    v221 = v24;
    v229 = v21;
    v208 = v30;
    v214 = v27;
    v199 = v36;
    v203 = v33;
    v196 = v39;
    v41 = (_QWORD *)&unk_25451B000;
    v39 = v196;
    v36 = v199;
    v33 = v203;
    v30 = v208;
    v27 = v214;
    v24 = v221;
    v21 = v229;
    v18 = v238;
    v15 = v248;
    v12 = v259;
    v9 = v271;
    v6 = v284;
    v3 = v298;
    v178 = v177;
    a1 = v313;
    if (v178)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionKindInterface::Trait<Empty>]";
      v316 = 89;
      v179 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v179)
        v180 = v179;
      else
        v180 = v316;
      v181 = &v315[v180];
      v182 = v316 - v180;
      if (v316 - v180 >= 0x12)
        v183 = 18;
      else
        v183 = v316 - v180;
      v184 = v182 - v183;
      if (v184 >= v184 - 1)
        v185 = v184 - 1;
      else
        v185 = v184;
      mlir::detail::TypeIDResolver<mlir::RegionKindInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionKindInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v181[v183], v185);
      v41 = (_QWORD *)&unk_25451B000;
      v39 = v196;
      v36 = v199;
      v33 = v203;
      v30 = v208;
      v27 = v214;
      v24 = v221;
      v21 = v229;
      v18 = v238;
      v15 = v248;
      v12 = v259;
      v9 = v271;
      v6 = v284;
      v3 = v298;
      a1 = v313;
    }
  }
  v42 = v41[153];
  v44 = &unk_25451B000;
  if ((v43 & 1) == 0)
  {
    v299 = v3;
    v314 = a1;
    v272 = v9;
    v285 = v6;
    v260 = v12;
    v239 = v18;
    v249 = v15;
    v222 = v24;
    v230 = v21;
    v209 = v30;
    v215 = v27;
    v200 = v36;
    v204 = v33;
    v195 = v42;
    v197 = v39;
    v44 = (_QWORD *)&unk_25451B000;
    v42 = v195;
    v39 = v197;
    v36 = v200;
    v33 = v204;
    v30 = v209;
    v27 = v215;
    v24 = v222;
    v21 = v230;
    v18 = v239;
    v15 = v249;
    v12 = v260;
    v9 = v272;
    v6 = v285;
    v3 = v299;
    v187 = v186;
    a1 = v314;
    if (v187)
    {
      v315 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasOnlyGraphRegion<Empty>]";
      v316 = 90;
      v188 = llvm::StringRef::find((uint64_t *)&v315, "DesiredTypeName = ", 0x12uLL, 0);
      if (v316 >= v188)
        v189 = v188;
      else
        v189 = v316;
      v190 = &v315[v189];
      v191 = v316 - v189;
      if (v316 - v189 >= 0x12)
        v192 = 18;
      else
        v192 = v316 - v189;
      v193 = v191 - v192;
      if (v193 >= v193 - 1)
        v194 = v193 - 1;
      else
        v194 = v193;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasOnlyGraphRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasOnlyGraphRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v190[v192], v194);
      v44 = (_QWORD *)&unk_25451B000;
      v42 = v195;
      v39 = v197;
      v36 = v200;
      v33 = v204;
      v30 = v209;
      v27 = v215;
      v24 = v222;
      v21 = v230;
      v18 = v239;
      v15 = v249;
      v12 = v260;
      v9 = v272;
      v6 = v285;
      v3 = v299;
      a1 = v314;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v42 == a1
      || v44[155] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v8;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::InParallelOp::print(&v8, a3);
}

BOOL mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::OpTrait::impl *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroResults<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroOperands<mlir::scf::InParallelOp>,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::scf::InParallelOp>,mlir::OpTrait::NoTerminator<mlir::scf::InParallelOp>,mlir::OpTrait::SingleBlock<mlir::scf::InParallelOp>,mlir::OpTrait::OpInvariants<mlir::scf::InParallelOp>,mlir::ConditionallySpeculatable::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::scf::InParallelOp>,mlir::MemoryEffectOpInterface::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::IsTerminator<mlir::scf::InParallelOp>,mlir::ParallelCombiningOpInterface::Trait<mlir::scf::InParallelOp>,mlir::RegionKindInterface::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::HasOnlyGraphRegion<mlir::scf::InParallelOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::scf::InParallelOp::verify((uint64_t **)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroResults<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::InParallelOp>,mlir::OpTrait::ZeroOperands<mlir::scf::InParallelOp>,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::scf::InParallelOp>,mlir::OpTrait::NoTerminator<mlir::scf::InParallelOp>,mlir::OpTrait::SingleBlock<mlir::scf::InParallelOp>,mlir::OpTrait::OpInvariants<mlir::scf::InParallelOp>,mlir::ConditionallySpeculatable::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::scf::InParallelOp>,mlir::MemoryEffectOpInterface::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::IsTerminator<mlir::scf::InParallelOp>,mlir::ParallelCombiningOpInterface::Trait<mlir::scf::InParallelOp>,mlir::RegionKindInterface::Trait<mlir::scf::InParallelOp>,mlir::OpTrait::HasOnlyGraphRegion<mlir::scf::InParallelOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::Operation *v7;

  return mlir::OpTrait::impl::verifyOneRegion(a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
      && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
      && mlir::OpTrait::impl::verifyZeroOperands(a1, v5)
      && mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::scf::InParallelOp>::verifyTrait((uint64_t *)a1)
      && mlir::OpTrait::SingleBlock<mlir::ModuleOp>::verifyTrait((uint64_t)a1)
      && mlir::op_definition_impl::verifyTrait<mlir::OpTrait::OpInvariants<mlir::scf::InParallelOp>>((uint64_t)a1)
      && mlir::OpTrait::impl::verifyIsTerminator(a1, v6)
      && mlir::detail::verifyParallelCombiningOpInterface(a1, v7) != 0;
}

BOOL mlir::op_definition_impl::verifyTrait<mlir::OpTrait::OpInvariants<mlir::scf::InParallelOp>>(uint64_t a1)
{
  return mlir::scf::__mlir_ods_local_region_constraint_SCFOps1((uint64_t *)a1, ((a1+ 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a1 + 40), (uint64_t)"region", 6, 0) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl<mlir::scf::InParallelOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  const char **v4;
  char *v5;
  char *v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char **v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  int64_t v29;
  char *v30;
  const char *v31;
  const void **v32;
  __int16 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  _QWORD v37[2];
  _QWORD v38[3];
  void *v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE v42[96];
  void *v43;
  _QWORD *v44;
  void *__p;
  _QWORD *v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id)
        return 1;
    }
  }
  v33 = 257;
  mlir::Operation::emitOpError(a1, &v32, (uint64_t)v38);
  if (v38[0])
  {
    LODWORD(v34) = 3;
    v35 = "expects parent op ";
    v36 = 18;
    v4 = &v34;
    v5 = (char *)v39;
    if (v40 >= v41)
    {
      v26 = v40 + 1;
      if (v39 <= &v34 && (char *)v39 + 24 * v40 > (char *)&v34)
      {
        v29 = (char *)&v34 - (_BYTE *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v5 = (char *)v39;
        v4 = (const char **)((char *)v39 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v4 = &v34;
        v5 = (char *)v39;
      }
    }
    v6 = &v5[24 * v40];
    v7 = *(_OWORD *)v4;
    *((_QWORD *)v6 + 2) = v4[2];
    *(_OWORD *)v6 = v7;
    ++v40;
  }
  v31 = "'";
  v8 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v38, &v31);
  v9 = (uint64_t)v8;
  v37[0] = "scf.forall";
  v37[1] = 10;
  if (*v8)
  {
    v34 = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)v37, (uint64_t)v38, (uint64_t)(v8 + 1), (uint64_t)(v8 + 1), &v34);
    if (*(_QWORD *)v9)
    {
      v10 = v9 + 24;
      v11 = *(_QWORD *)(v9 + 24);
      LODWORD(v34) = 3;
      v35 = "'";
      v36 = 1;
      v12 = *(unsigned int *)(v9 + 32);
      v13 = &v34;
      if (v12 >= *(_DWORD *)(v9 + 36))
      {
        v27 = v12 + 1;
        v28 = v11 + 24 * v12 > (unint64_t)&v34;
        if (v11 <= (unint64_t)&v34 && v28)
        {
          v30 = (char *)&v34 - v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = (const char **)&v30[v11];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = &v34;
        }
      }
      v14 = v11 + 24 * *(unsigned int *)(v9 + 32);
      v15 = *(_OWORD *)v13;
      *(_QWORD *)(v14 + 16) = v13[2];
      *(_OWORD *)v14 = v15;
      ++*(_DWORD *)(v9 + 32);
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v9);
  if (v38[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  if (v47)
  {
    v17 = __p;
    if (__p)
    {
      v18 = v46;
      v19 = __p;
      if (v46 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v46 = v17;
      operator delete(v19);
    }
    v20 = v43;
    if (v43)
    {
      v21 = v44;
      v22 = v43;
      if (v44 != v43)
      {
        do
        {
          v24 = *--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
            MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
        }
        while (v21 != v20);
        v22 = v43;
      }
      v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42)
      free(v39);
  }
  return v16;
}

uint64_t mlir::Op<mlir::scf::InParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::HasParent<mlir::scf::ForallOp>::Impl,mlir::OpTrait::NoTerminator,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator,mlir::ParallelCombiningOpInterface::Trait,mlir::RegionKindInterface::Trait,mlir::OpTrait::HasOnlyGraphRegion>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::getParseAssemblyFn(BOOL (**a1)(void *a1, uint64_t *a2)@<X8>)
{
  *a1 = mlir::scf::IndexSwitchOp::parse;
  a1[3] = (BOOL (*)(void *, uint64_t *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                 + 2);
}

void mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 5 && (*(_DWORD *)a3 == 1702060387 ? (v7 = *(_BYTE *)(a3 + 4) == 115) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  _QWORD *v9;
  uint64_t v10;

  v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 5 && *(_DWORD *)result == 1702060387 && *(_BYTE *)(result + 4) == 115)
  {
    if (a4)
    {
      result = mlir::detail::DenseArrayAttrImpl<long long>::classof(a4);
      if ((_DWORD)result)
        v9 = a4;
      else
        v9 = 0;
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"cases", 5, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  _QWORD *v7;

  v7 = (_QWORD *)mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps12(v7, (const void **)"cases", (const char *)5, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::scf::IndexSwitchOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::scf::IndexSwitchOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::scf::IndexSwitchOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<long long>>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(a2 + 68);
  else
    return 0;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getEntrySuccessorRegions(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = a2;
  mlir::scf::IndexSwitchOp::getEntrySuccessorRegions(&v5, a3, a4, a5);
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::scf::IndexSwitchOp::getSuccessorRegions((uint64_t)&v5, a3, a4);
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = a2;
  mlir::scf::IndexSwitchOp::getRegionInvocationBounds((uint64_t)&v5, a3, a4, a5);
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::IndexSwitchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::foldHook<mlir::scf::IndexSwitchOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::foldHook<mlir::scf::IndexSwitchOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t *v15;
  uint64_t v16;
  _BYTE v17[8];
  char v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[3];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v15 = (uint64_t *)a1;
  v7 = *(_QWORD *)(a1 + 56);
  v8 = *(unsigned int *)(a1 + 44);
  v9 = (uint64_t *)(a1 + 16 * ((v8 >> 23) & 1) + 64);
  v10 = v8 & 0x7FFFFF;
  if ((v8 & 0x7FFFFF) != 0)
  {
    v11 = (((unint64_t)v9 + ((v8 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v11 = 0;
    v10 = 0;
  }
  mlir::ValueRange::ValueRange(v23, v11, v10);
  v16 = v7;
  v17[0] = 0;
  v18 = 0;
  v19 = *v9;
  v20 = *(_OWORD *)v23;
  if (v7)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v16);
    if (v18)
      v18 = 0;
    mlir::OperationName::OperationName(v17, "scf.index_switch", 16, Context);
    v18 = 1;
  }
  v21 = a2;
  v22 = a3;
  return mlir::scf::IndexSwitchOp::fold(&v15, v12, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNRegions<1>::Impl<Empty>]";
      v186 = 96;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNRegions<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNRegions<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[146];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v186 = 87;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v186 = 82;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[19];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v186 = 83;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[433];
  v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::Yi"
             "eldOp>::Impl<Empty>]";
      v186 = 127;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[120];
  v20 = &unk_254519000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_254519000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_254519000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[423];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v186 = 89;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[310];
  v26 = &unk_25451B000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451B000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v186 = 97;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451B000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[219];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v186 = 93;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[217] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::scf::IndexSwitchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1)
{
  mlir::Operation *v2;
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyAtLeastNRegions(a1, (mlir::Operation *)1))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v3))
    return 0;
  if (!mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
    return 0;
  v5 = a1;
  if (!mlir::scf::IndexSwitchOp::verifyInvariantsImpl((uint64_t **)&v5))
    return 0;
  v5 = a1;
  return mlir::scf::IndexSwitchOp::verify((uint64_t **)&v5) != 0;
}

BOOL mlir::Op<mlir::scf::IndexSwitchOp,mlir::OpTrait::AtLeastNRegions<1u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1)
{
  mlir::Operation *v2;

  return mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::verifyRegionTrait((uint64_t)a1)
      && mlir::detail::verifyTypesAlongControlFlowEdges(a1, v2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"scf.parallel", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::ParallelOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24BFF36C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::scf::ParallelOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::scf::ParallelOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                                  + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  mlir::Operation *v6;
  mlir::OpAsmPrinter *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  unint64_t v8;
  BOOL v9;
  uint64_t v14;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = *(unsigned int *)(a2 + 44);
  if (a4 == 19)
  {
    if (*a3 != 0x53646E617265706FLL
      || a3[1] != 0x6953746E656D6765
      || *(_QWORD *)((char *)a3 + 11) != 0x73657A6953746E65)
    {
      return 0;
    }
  }
  else
  {
    if (a4 != 21)
      return 0;
    v9 = *a3 == 0x5F646E617265706FLL && a3[1] == 0x5F746E656D676573;
    if (!v9 || *(_QWORD *)((char *)a3 + 13) != 0x73657A69735F746ELL)
      return 0;
  }
  if (BYTE3(v8))
    v14 = a2 + 16 * ((v8 >> 23) & 1) + 64;
  else
    v14 = 0;
  return mlir::detail::DenseArrayAttrImpl<int>::get(Context, v14, 4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::scf::ParallelOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t v7;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v6 = 0;
  v7 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v6, 4);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v7);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::scf::ParallelOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  return mlir::scf::ParallelOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::scf::ParallelOp>::hashProperties(uint64_t a1, _QWORD *a2)
{
  return mlir::scf::ParallelOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v5;
  mlir::MLIRContext *Context;
  uint64_t v7;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (int *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 104))(a3) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    v7 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)v5, 4);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, v7);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 104))(a3);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a3, v5, 4);
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x68uLL, 0x80040FDC59921uLL);
  *v2 = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::isDefinedOutsideOfLoop;
  v2[1] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopRegions;
  v2[2] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::moveOutOfLoop;
  v2[3] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::promoteIfSingleIteration;
  v2[4] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleInductionVar;
  v2[5] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleLowerBound;
  v2[6] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleStep;
  v2[7] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleUpperBound;
  v2[8] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getInitsMutable;
  v2[9] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getRegionIterArgs;
  v2[10] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getYieldedValuesMutable;
  v2[11] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopResults;
  v2[12] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::replaceWithAdditionalYields;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[116], v2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::isDefinedOutsideOfLoop(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  Operation *v4;
  uint64_t v6;

  v6 = a3;
  v4 = (Operation *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v6) + 2);
  if (v4 == a2)
    return 0;
  else
    return mlir::Operation::isProperAncestor(a2, v4) ^ 1;
}

double mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopRegions@<D0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *(unsigned int *)(a1 + 44);
  if ((v2 & 0x7FFFFF) != 0)
    v3 = ((a1 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a1 + 40);
  else
    v3 = 0;
  a2[2] = v3;
  *a2 = a2 + 2;
  *(_QWORD *)&result = 0x600000001;
  a2[1] = 0x600000001;
  return result;
}

mlir::Operation *mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::moveOutOfLoop(int a1, mlir::Operation *a2, mlir::Operation *this)
{
  return mlir::Operation::moveBefore(this, a2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::promoteIfSingleIteration()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleInductionVar(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = 0;
  v3 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = a2 + 16 * ((v3 >> 23) & 1) + 64;
  else
    v4 = 0;
  if (*(_DWORD *)(v4 + 8) == 1)
  {
    v5 = *(_QWORD *)(((a2 + 16 * ((v3 >> 23) & 1) + 64 + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *(unsigned int *)(a2 + 40)
                   + 8);
    if (v5)
      v6 = v5 - 8;
    else
      v6 = 0;
    return **(_QWORD **)(v6 + 48);
  }
  return result;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleLowerBound(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v3;

  result = 0;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v3 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v3 = 0;
  if (*(_DWORD *)(v3 + 8) == 1)
    return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) | 4;
  return result;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleStep(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _DWORD *v3;

  result = 0;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v3 = (_DWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v3 = 0;
  if (v3[2] == 1)
    return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * (v3[1] + *v3) + 24) | 4;
  return result;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSingleUpperBound(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int *v3;

  result = 0;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v3 = (unsigned int *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v3 = 0;
  if (v3[2] == 1)
    return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * *v3 + 24) | 4;
  return result;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getInitsMutable()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getRegionIterArgs()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getYieldedValuesMutable()
{
  return 0;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getLoopResults(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::replaceWithAdditionalYields(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32 * *(unsigned int *)(a2 + 68);
  else
    return 0;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getEntrySuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;
  uint64_t v6;

  v6 = a2;
  *(_QWORD *)&result = mlir::scf::ForallOp::getSuccessorRegions((uint64_t)&v6, a2, a5).n128_u64[0];
  return result;
}

double mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;
  uint64_t v5;

  v5 = a2;
  *(_QWORD *)&result = mlir::scf::ForallOp::getSuccessorRegions((uint64_t)&v5, a2, a4).n128_u64[0];
  return result;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_DWORD *)(a2 + 44) & 0x7FFFFF;
  v7 = *(unsigned int *)(a5 + 8);
  if (v7 + v6 > (unint64_t)*(unsigned int *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v7 + v6, 12);
    LODWORD(v7) = *(_DWORD *)(a5 + 8);
    if (!(_DWORD)v6)
      goto LABEL_6;
  }
  else if (!(_DWORD)v6)
  {
    goto LABEL_6;
  }
  v8 = *(_QWORD *)a5 + 12 * v7;
  v9 = v6;
  do
  {
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    v8 += 12;
    --v9;
  }
  while (v9);
  LODWORD(v7) = *(_DWORD *)(a5 + 8);
LABEL_6:
  *(_DWORD *)(a5 + 8) = v7 + v6;
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::ParallelOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  const char *v260;
  unint64_t v261;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v261 = 81;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v247;
    }
  }
  v3 = v2[415];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v261 = 87;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v261 = 88;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[73];
  v14 = &unk_25451B000;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = (_QWORD *)&unk_25451B000;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v261 = 96;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = (_QWORD *)&unk_25451B000;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[37];
  v17 = &unk_25451A000;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = (_QWORD *)&unk_25451A000;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v261 = 83;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = (_QWORD *)&unk_25451A000;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[433];
  v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::Yi"
             "eldOp>::Impl<Empty>]";
      v261 = 127;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      v20 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = v20[120];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[423];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v261 = 89;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[310];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AutomaticAllocationScope<Empty>]";
      v261 = 96;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[55];
  v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface::Trait<Empty>]";
      v261 = 89;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v32 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[122];
  v35 = &unk_25451B000;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = (_QWORD *)&unk_25451B000;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v261 = 97;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = (_QWORD *)&unk_25451B000;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[219];
  v38 = &unk_25451B000;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = (_QWORD *)&unk_25451B000;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v261 = 93;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = (_QWORD *)&unk_25451B000;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v38[217] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v8;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::ParallelOp::print(&v8, a3);
}

BOOL mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyOneRegion(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
    return 0;
  if (!mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
    return 0;
  v5 = a1;
  if (!mlir::scf::ParallelOp::verifyInvariantsImpl((uint64_t **)&v5))
    return 0;
  v5 = a1;
  return mlir::scf::ParallelOp::verify((uint64_t **)&v5) != 0;
}

BOOL mlir::Op<mlir::scf::ParallelOp,mlir::OpTrait::OneRegion,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::SingleBlock,mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AutomaticAllocationScope,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects,mlir::RegionBranchOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1)
{
  mlir::Operation *v2;
  mlir::Operation *v3;

  return mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::verifyRegionTrait((uint64_t)a1)
      && mlir::detail::verifyLoopLikeOpInterface(a1, v2)
      && mlir::detail::verifyTypesAlongControlFlowEdges(a1, v3) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::scf::ReduceOp::parse;
  a1[3] = (BOOL (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                               + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceOp>::hashProperties()
{
  return 0;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  unint64_t v100;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v93 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v25 = v24;
    a1 = v93;
    if (v25)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v100 = 81;
      v26 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v26)
        v27 = v26;
      else
        v27 = v100;
      v28 = &v99[v27];
      v29 = v100 - v27;
      if (v100 - v27 >= 0x12)
        v30 = 18;
      else
        v30 = v100 - v27;
      v31 = v29 - v30;
      if (v31 >= v31 - 1)
        v32 = v31 - 1;
      else
        v32 = v31;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v28[v30], v32);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v93;
    }
  }
  v3 = v2[415];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v88 = v3;
    v94 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v34 = v33;
    v3 = v88;
    a1 = v94;
    if (v34)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v100 = 83;
      v35 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v35)
        v36 = v35;
      else
        v36 = v100;
      v37 = &v99[v36];
      v38 = v100 - v36;
      if (v100 - v36 >= 0x12)
        v39 = 18;
      else
        v39 = v100 - v36;
      v40 = v38 - v39;
      if (v40 >= v40 - 1)
        v41 = v40 - 1;
      else
        v41 = v40;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v88;
      a1 = v94;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v89 = v3;
    v95 = a1;
    v84 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v84;
    v3 = v89;
    v43 = v42;
    a1 = v95;
    if (v43)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v100 = 86;
      v44 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v44)
        v45 = v44;
      else
        v45 = v100;
      v46 = &v99[v45];
      v47 = v100 - v45;
      if (v100 - v45 >= 0x12)
        v48 = 18;
      else
        v48 = v100 - v45;
      v49 = v47 - v48;
      if (v49 >= v49 - 1)
        v50 = v49 - 1;
      else
        v50 = v49;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v84;
      v3 = v89;
      a1 = v95;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v90 = v3;
    v96 = a1;
    v81 = v9;
    v85 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v81;
    v6 = v85;
    v52 = v51;
    v3 = v90;
    a1 = v96;
    if (v52)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v100 = 82;
      v53 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v53)
        v54 = v53;
      else
        v54 = v100;
      v55 = &v99[v54];
      v56 = v100 - v54;
      if (v100 - v54 >= 0x12)
        v57 = 18;
      else
        v57 = v100 - v54;
      v58 = v56 - v57;
      if (v58 >= v58 - 1)
        v59 = v58 - 1;
      else
        v59 = v58;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v81;
      v6 = v85;
      v3 = v90;
      a1 = v96;
    }
  }
  v12 = v11[19];
  v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v91 = v3;
    v97 = a1;
    v82 = v9;
    v86 = v6;
    v79 = v12;
    v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v12 = v79;
    v9 = v82;
    v6 = v86;
    v3 = v91;
    v61 = v60;
    a1 = v97;
    if (v61)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<Empty>]";
      v100 = 110;
      v62 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v62)
        v63 = v62;
      else
        v63 = v100;
      v64 = &v99[v63];
      v65 = v100 - v63;
      if (v100 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v100 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v12 = v79;
      v9 = v82;
      v6 = v86;
      v3 = v91;
      a1 = v97;
    }
  }
  v15 = v14[152];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v92 = v3;
    v98 = a1;
    v83 = v9;
    v87 = v6;
    v78 = v15;
    v80 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v78;
    v12 = v80;
    v9 = v83;
    v6 = v87;
    v70 = v69;
    v3 = v92;
    a1 = v98;
    if (v70)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v100 = 84;
      v71 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v71)
        v72 = v71;
      else
        v72 = v100;
      v73 = &v99[v72];
      v74 = v100 - v72;
      if (v100 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v100 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v78;
      v12 = v80;
      v9 = v83;
      v6 = v87;
      v3 = v92;
      a1 = v98;
    }
  }
  return v3 == a1 || v6 == a1 || v9 == a1 || v12 == a1 || v15 == a1 || v17[423] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::ReduceOp::print((mlir::scf::ReduceOp *)&v8, a3);
}

BOOL mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::verifyInvariants(unsigned int *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::scf::ReduceOp>,mlir::OpTrait::ZeroResults<mlir::scf::ReduceOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ReduceOp>,mlir::OpTrait::OneOperand<mlir::scf::ReduceOp>,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::scf::ReduceOp>,mlir::OpTrait::OpInvariants<mlir::scf::ReduceOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::scf::ReduceOp>,mlir::OpTrait::ZeroResults<mlir::scf::ReduceOp>,mlir::OpTrait::ZeroSuccessors<mlir::scf::ReduceOp>,mlir::OpTrait::OneOperand<mlir::scf::ReduceOp>,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::scf::ReduceOp>,mlir::OpTrait::OpInvariants<mlir::scf::ReduceOp>>(unsigned int *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;

  return mlir::OpTrait::impl::verifyOneRegion((mlir::OpTrait::impl *)a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults((mlir::OpTrait::impl *)a1, v3)
      && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
      && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
      && mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::scf::ReduceOp>::verifyTrait((uint64_t *)a1)
      && mlir::scf::__mlir_ods_local_region_constraint_SCFOps1((uint64_t *)a1, (((unint64_t)&a1[4 * (((unint64_t)a1[11] >> 23) & 1) + 17]+ (((unint64_t)a1[11] >> 21) & 0x7F8)+ 3) & 0xFFFFFFFFFFFFFFF8)+ 32 * a1[10], (uint64_t)"reductionOperator", 17, 0) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<mlir::scf::ReduceOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  const char **v4;
  char *v5;
  char *v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char **v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  int64_t v29;
  char *v30;
  const char *v31;
  const void **v32;
  __int16 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  _QWORD v37[2];
  _QWORD v38[3];
  void *v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE v42[96];
  void *v43;
  _QWORD *v44;
  void *__p;
  _QWORD *v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ParallelOp,void>::id)
        return 1;
    }
  }
  v33 = 257;
  mlir::Operation::emitOpError(a1, &v32, (uint64_t)v38);
  if (v38[0])
  {
    LODWORD(v34) = 3;
    v35 = "expects parent op ";
    v36 = 18;
    v4 = &v34;
    v5 = (char *)v39;
    if (v40 >= v41)
    {
      v26 = v40 + 1;
      if (v39 <= &v34 && (char *)v39 + 24 * v40 > (char *)&v34)
      {
        v29 = (char *)&v34 - (_BYTE *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v5 = (char *)v39;
        v4 = (const char **)((char *)v39 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v4 = &v34;
        v5 = (char *)v39;
      }
    }
    v6 = &v5[24 * v40];
    v7 = *(_OWORD *)v4;
    *((_QWORD *)v6 + 2) = v4[2];
    *(_OWORD *)v6 = v7;
    ++v40;
  }
  v31 = "'";
  v8 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v38, &v31);
  v9 = (uint64_t)v8;
  v37[0] = "scf.parallel";
  v37[1] = 12;
  if (*v8)
  {
    v34 = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)v37, (uint64_t)v38, (uint64_t)(v8 + 1), (uint64_t)(v8 + 1), &v34);
    if (*(_QWORD *)v9)
    {
      v10 = v9 + 24;
      v11 = *(_QWORD *)(v9 + 24);
      LODWORD(v34) = 3;
      v35 = "'";
      v36 = 1;
      v12 = *(unsigned int *)(v9 + 32);
      v13 = &v34;
      if (v12 >= *(_DWORD *)(v9 + 36))
      {
        v27 = v12 + 1;
        v28 = v11 + 24 * v12 > (unint64_t)&v34;
        if (v11 <= (unint64_t)&v34 && v28)
        {
          v30 = (char *)&v34 - v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = (const char **)&v30[v11];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = &v34;
        }
      }
      v14 = v11 + 24 * *(unsigned int *)(v9 + 32);
      v15 = *(_OWORD *)v13;
      *(_QWORD *)(v14 + 16) = v13[2];
      *(_OWORD *)v14 = v15;
      ++*(_DWORD *)(v9 + 32);
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v9);
  if (v38[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  if (v47)
  {
    v17 = __p;
    if (__p)
    {
      v18 = v46;
      v19 = __p;
      if (v46 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v46 = v17;
      operator delete(v19);
    }
    v20 = v43;
    if (v43)
    {
      v21 = v44;
      v22 = v43;
      if (v44 != v43)
      {
        do
        {
          v24 = *--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
            MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
        }
        while (v21 != v20);
        v22 = v43;
      }
      v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42)
      free(v39);
  }
  return v16;
}

BOOL mlir::Op<mlir::scf::ReduceOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl,mlir::OpTrait::OpInvariants>::verifyRegionInvariants(uint64_t *a1)
{
  uint64_t *v2;

  v2 = a1;
  return mlir::scf::ReduceOp::verifyRegions(&v2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  llvm **v4;
  llvm *v6[2];
  unint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v7 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v3 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v7 & 4) != 0)
    {
      if ((v7 & 2) != 0)
        v4 = v6;
      else
        v4 = (llvm **)v6[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t))((v7 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v4, v0, v1, v2);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v6[0], v6[1]);
  }
  return v3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::scf::ReduceReturnOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, unsigned int *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                              + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::ReduceReturnOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ReduceReturnOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ReduceReturnOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::ReduceReturnOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::ReduceReturnOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::ReduceReturnOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v186 = 83;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v186 = 82;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[19];
  v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl<Empty>]";
      v186 = 108;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[154];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[21];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v186 = 84;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[223] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::AtomicYieldOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    || !mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl<mlir::scf::ReduceReturnOp>::verifyTrait((uint64_t *)a1)
    || !mlir::OpTrait::impl::verifyIsTerminator(a1, v6))
  {
    return 0;
  }
  v8 = a1;
  return mlir::scf::ReduceReturnOp::verify((uint64_t **)&v8) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl<mlir::scf::ReduceReturnOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  const char **v4;
  char *v5;
  char *v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char **v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  int64_t v29;
  char *v30;
  const char *v31;
  const void **v32;
  __int16 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  _QWORD v37[2];
  _QWORD v38[3];
  void *v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE v42[96];
  void *v43;
  _QWORD *v44;
  void *__p;
  _QWORD *v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ReduceOp,void>::id)
        return 1;
    }
  }
  v33 = 257;
  mlir::Operation::emitOpError(a1, &v32, (uint64_t)v38);
  if (v38[0])
  {
    LODWORD(v34) = 3;
    v35 = "expects parent op ";
    v36 = 18;
    v4 = &v34;
    v5 = (char *)v39;
    if (v40 >= v41)
    {
      v26 = v40 + 1;
      if (v39 <= &v34 && (char *)v39 + 24 * v40 > (char *)&v34)
      {
        v29 = (char *)&v34 - (_BYTE *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v5 = (char *)v39;
        v4 = (const char **)((char *)v39 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v4 = &v34;
        v5 = (char *)v39;
      }
    }
    v6 = &v5[24 * v40];
    v7 = *(_OWORD *)v4;
    *((_QWORD *)v6 + 2) = v4[2];
    *(_OWORD *)v6 = v7;
    ++v40;
  }
  v31 = "'";
  v8 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v38, &v31);
  v9 = (uint64_t)v8;
  v37[0] = "scf.reduce";
  v37[1] = 10;
  if (*v8)
  {
    v34 = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)v37, (uint64_t)v38, (uint64_t)(v8 + 1), (uint64_t)(v8 + 1), &v34);
    if (*(_QWORD *)v9)
    {
      v10 = v9 + 24;
      v11 = *(_QWORD *)(v9 + 24);
      LODWORD(v34) = 3;
      v35 = "'";
      v36 = 1;
      v12 = *(unsigned int *)(v9 + 32);
      v13 = &v34;
      if (v12 >= *(_DWORD *)(v9 + 36))
      {
        v27 = v12 + 1;
        v28 = v11 + 24 * v12 > (unint64_t)&v34;
        if (v11 <= (unint64_t)&v34 && v28)
        {
          v30 = (char *)&v34 - v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = (const char **)&v30[v11];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = &v34;
        }
      }
      v14 = v11 + 24 * *(unsigned int *)(v9 + 32);
      v15 = *(_OWORD *)v13;
      *(_QWORD *)(v14 + 16) = v13[2];
      *(_OWORD *)v14 = v15;
      ++*(_DWORD *)(v9 + 32);
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v9);
  if (v38[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  if (v47)
  {
    v17 = __p;
    if (__p)
    {
      v18 = v46;
      v19 = __p;
      if (v46 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v46 = v17;
      operator delete(v19);
    }
    v20 = v43;
    if (v43)
    {
      v21 = v44;
      v22 = v43;
      if (v44 != v43)
      {
        do
        {
          v24 = *--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
            MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
        }
        while (v21 != v20);
        v22 = v43;
      }
      v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42)
      free(v39);
  }
  return v16;
}

uint64_t mlir::Op<mlir::scf::ReduceReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::HasParent<mlir::scf::ReduceOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::scf::WhileOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, mlir::OperationState *this)@<X8>)
{
  *a1 = mlir::scf::WhileOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                                  + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  mlir::OpAsmPrinter *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::WhileOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x28uLL, 0x800402FCC0CB6uLL);
  *v2 = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getEntrySuccessorOperands;
  v2[1] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getEntrySuccessorRegions;
  v2[2] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSuccessorRegions;
  v2[3] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getRegionInvocationBounds;
  v2[4] = mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::areTypesCompatible;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[385], v2);
}

uint64_t mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72);
  else
    return 0;
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getEntrySuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = a2;
  mlir::scf::WhileOp::getSuccessorRegions(&v5, 0, a5);
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v4;

  v4 = a2;
  mlir::scf::WhileOp::getSuccessorRegions(&v4, a3, a4);
}

void mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getRegionInvocationBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_DWORD *)(a2 + 44) & 0x7FFFFF;
  v7 = *(unsigned int *)(a5 + 8);
  if (v7 + v6 > (unint64_t)*(unsigned int *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v7 + v6, 12);
    LODWORD(v7) = *(_DWORD *)(a5 + 8);
    if (!(_DWORD)v6)
      goto LABEL_6;
  }
  else if (!(_DWORD)v6)
  {
    goto LABEL_6;
  }
  v8 = *(_QWORD *)a5 + 12 * v7;
  v9 = v6;
  do
  {
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    v8 += 12;
    --v9;
  }
  while (v9);
  LODWORD(v7) = *(_DWORD *)(a5 + 8);
LABEL_6:
  *(_DWORD *)(a5 + 8) = v7 + v6;
}

BOOL mlir::detail::RegionBranchOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x68uLL, 0x80040FDC59921uLL);
  *v2 = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::isDefinedOutsideOfLoop;
  v2[1] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getLoopRegions;
  v2[2] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::moveOutOfLoop;
  v2[3] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::promoteIfSingleIteration;
  v2[4] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleInductionVar;
  v2[5] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleLowerBound;
  v2[6] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleStep;
  v2[7] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleUpperBound;
  v2[8] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getInitsMutable;
  v2[9] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getRegionIterArgs;
  v2[10] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getYieldedValuesMutable;
  v2[11] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getLoopResults;
  v2[12] = mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::replaceWithAdditionalYields;
  v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[116], v2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::isDefinedOutsideOfLoop(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  Operation *v4;
  uint64_t v6;

  v6 = a3;
  v4 = (Operation *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v6) + 2);
  if (v4 == a2)
    return 0;
  else
    return mlir::Operation::isProperAncestor(a2, v4) ^ 1;
}

double mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getLoopRegions@<D0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *(unsigned int *)(a1 + 44);
  if ((v2 & 0x7FFFFF) != 0)
    v3 = ((a1 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a1 + 40);
  else
    v3 = 0;
  a2[2] = v3;
  *a2 = a2 + 2;
  a2[3] = v3 + 24;
  *(_QWORD *)&result = 0x600000002;
  a2[1] = 0x600000002;
  return result;
}

mlir::Operation *mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::moveOutOfLoop(int a1, mlir::Operation *a2, mlir::Operation *this)
{
  return mlir::Operation::moveBefore(this, a2);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::promoteIfSingleIteration()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleInductionVar()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleLowerBound()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleStep()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getSingleUpperBound()
{
  return 0;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getInitsMutable(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  unsigned int v5[4];
  void *v6;
  _QWORD v7[4];

  v7[3] = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a2 + 68);
  else
    v2 = 0;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v5, a2, 0, v2, 0, 0);
  v3 = mlir::MutableOperandRange::operator mlir::OperandRange(v5);
  if (v6 != v7)
    free(v6);
  return v3;
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getRegionIterArgs(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  return *(_QWORD *)(v3 + 48);
}

uint64_t mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getYieldedValuesMutable(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  ZinIrHalH13g **v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v8[4];
  void *v9;
  _QWORD v10[4];

  v10[3] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 32);
  if (v2)
    v3 = (ZinIrHalH13g **)(v2 - 8);
  else
    v3 = 0;
  mlir::Block::getTerminator(v3);
  if ((*(_BYTE *)(v4 + 46) & 0x80) != 0)
    v5 = *(_DWORD *)(v4 + 68);
  else
    v5 = 0;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v8, v4, 0, v5, 0, 0);
  v6 = mlir::MutableOperandRange::operator mlir::OperandRange(v8);
  if (v9 != v10)
    free(v9);
  return v6;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::getLoopResults(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void mlir::detail::LoopLikeOpInterfaceInterfaceTraits::Model<mlir::scf::WhileOp>::replaceWithAdditionalYields(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  unint64_t v163;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NRegions<2>::Impl<Empty>]";
      v163 = 89;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NRegions<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NRegions<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v153;
    }
  }
  v3 = v2[439];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v163 = 87;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v163 = 88;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[73];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SingleBlock<Empty>]";
      v163 = 83;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SingleBlock<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SingleBlock>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[433];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451B000;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = (_QWORD *)&unk_25451B000;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface::Trait<Empty>]";
      v163 = 93;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = (_QWORD *)&unk_25451B000;
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[217];
  v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::LoopLikeOpInterface::Trait<Empty>]";
      v163 = 89;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::LoopLikeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::LoopLikeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[122];
  v26 = &unk_25451B000;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = (_QWORD *)&unk_25451B000;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v163 = 97;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = (_QWORD *)&unk_25451B000;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v26[219] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v8;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v8 = a2;
  return mlir::scf::WhileOp::print(&v8, a3);
}

BOOL mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyInvariants(mlir::OpTrait::impl *a1)
{
  mlir::Operation *v2;
  mlir::OpTrait::impl *v4;

  if (!mlir::OpTrait::impl::verifyNRegions(a1, (mlir::Operation *)2))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v2))
    return 0;
  if (!mlir::OpTrait::SingleBlock<mlir::memref::GenericAtomicRMWOp>::verifyTrait((uint64_t)a1))
    return 0;
  v4 = a1;
  if (!mlir::scf::WhileOp::verifyInvariantsImpl((mlir::scf::WhileOp *)&v4))
    return 0;
  v4 = a1;
  return mlir::scf::WhileOp::verify((mlir::scf::WhileOp *)&v4);
}

BOOL mlir::Op<mlir::scf::WhileOp,mlir::OpTrait::NRegions<2u>::Impl,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::SingleBlock,mlir::OpTrait::OpInvariants,mlir::RegionBranchOpInterface::Trait,mlir::LoopLikeOpInterface::Trait,mlir::OpTrait::HasRecursiveMemoryEffects>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;

  return mlir::detail::verifyTypesAlongControlFlowEdges(a1, a2)
      && mlir::detail::verifyLoopLikeOpInterface(a1, v3) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::YieldOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"scf.yield", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24BFF3DC8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::scf::YieldOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::scf::YieldOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::YieldOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::YieldOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::scf::YieldOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>::getMutableSuccessorOperands;
  v2[1] = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>::getSuccessorRegions;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      v15 = 89;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[393], v2);
}

double mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>::getMutableSuccessorOperands@<D0>(mlir::Operation *a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1);
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::scf::YieldOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Block *v6;
  uint64_t ParentOp;
  uint64_t v9;
  mlir::Block *v10;
  unint64_t Parent;
  uint64_t v13;
  uint64_t v14;

  v6 = *(mlir::Block **)(a2 + 16);
  if (v6)
  {
    ParentOp = mlir::Block::getParentOp(v6);
    v9 = ParentOp;
    if (ParentOp)
      ParentOp = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor(ParentOp);
    v10 = *(mlir::Block **)(a2 + 16);
    v13 = v9;
    v14 = ParentOp;
    if (v10)
      Parent = mlir::Block::getParent(v10);
    else
      Parent = 0;
  }
  else
  {
    Parent = 0;
    v13 = 0;
    v14 = 0;
  }
  return mlir::BranchOpInterface::getSuccessorForOperands(&v13, Parent, a5);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v222;
    }
  }
  v3 = v2[13];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v235 = 83;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v235 = 88;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[73];
  v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp, mlir:"
             ":scf::ForOp, mlir::scf::IfOp, mlir::scf::IndexSwitchOp, mlir::scf::ParallelOp, mlir::scf::WhileOp>::Impl<Empty>]";
      v235 = 219;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[156];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[21];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface::Trait<Empty>]";
      v235 = 103;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[69];
  v32 = &unk_254519000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_254519000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ReturnLike<Empty>]";
      v235 = 82;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_254519000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[401];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v235 = 84;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[223] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::ReturnOp::print((mlir::func::ReturnOp *)&v7, a3);
}

BOOL mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;

  return mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
      && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
      && mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl<mlir::scf::YieldOp>::verifyTrait((uint64_t *)a1)
      && mlir::OpTrait::impl::verifyIsTerminator(a1, v5) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl<mlir::scf::YieldOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  void *v4;
  uint64_t v8;
  __int128 *v9;
  char *v10;
  char *v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const char **v18;
  uint64_t v19;
  __int128 v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v30;
  unint64_t v31;
  BOOL v32;
  int64_t v33;
  char *v34;
  const char *v35;
  const void **v36;
  __int16 v37;
  const char *v38[3];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  _QWORD v46[3];
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD *v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      v4 = *(void **)(*(_QWORD *)(ParentOp + 48) + 16);
      if (v4 == &mlir::detail::TypeIDResolver<mlir::scf::ExecuteRegionOp,void>::id
        || v4 == &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id)
      {
        return 1;
      }
      if (v4 == &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id
        || v4 == &mlir::detail::TypeIDResolver<mlir::scf::IndexSwitchOp,void>::id)
      {
        return 1;
      }
      if (v4 == &mlir::detail::TypeIDResolver<mlir::scf::ParallelOp,void>::id
        || v4 == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
      {
        return 1;
      }
    }
  }
  v37 = 257;
  mlir::Operation::emitOpError(a1, &v36, (uint64_t)v46);
  if (v46[0])
  {
    LODWORD(v39) = 3;
    *((_QWORD *)&v39 + 1) = "expects parent op ";
    *(_QWORD *)&v40 = 18;
    v9 = &v39;
    v10 = (char *)v47;
    if (v48 >= v49)
    {
      v30 = v48 + 1;
      if (v47 <= &v39 && (char *)v47 + 24 * v48 > (char *)&v39)
      {
        v33 = (char *)&v39 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v30, 24);
        v10 = (char *)v47;
        v9 = (__int128 *)((char *)v47 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v30, 24);
        v9 = &v39;
        v10 = (char *)v47;
      }
    }
    v11 = &v10[24 * v48];
    v12 = *v9;
    *((_QWORD *)v11 + 2) = *((_QWORD *)v9 + 2);
    *(_OWORD *)v11 = v12;
    ++v48;
  }
  v35 = "to be one of '";
  v13 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v46, &v35);
  v14 = (uint64_t)v13;
  v41 = xmmword_24C061088;
  v42 = *(_OWORD *)&off_24C061098;
  v43 = xmmword_24C0610A8;
  v44 = *(_OWORD *)&off_24C0610B8;
  v39 = xmmword_24C061068;
  v40 = *(_OWORD *)&off_24C061078;
  if (*v13)
  {
    v38[0] = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)&v39, (uint64_t)&v45, (uint64_t)(v13 + 1), (uint64_t)(v13 + 1), v38);
    if (*(_QWORD *)v14)
    {
      v15 = v14 + 24;
      v16 = *(_QWORD *)(v14 + 24);
      LODWORD(v38[0]) = 3;
      v38[1] = "'";
      v38[2] = (const char *)1;
      v17 = *(unsigned int *)(v14 + 32);
      v18 = v38;
      if (v17 >= *(_DWORD *)(v14 + 36))
      {
        v31 = v17 + 1;
        v32 = v16 + 24 * v17 > (unint64_t)v38;
        if (v16 <= (unint64_t)v38 && v32)
        {
          v34 = (char *)v38 - v16;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 40), v31, 24);
          v16 = *(_QWORD *)(v14 + 24);
          v18 = (const char **)&v34[v16];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v15, (void *)(v14 + 40), v31, 24);
          v16 = *(_QWORD *)(v14 + 24);
          v18 = v38;
        }
      }
      v19 = v16 + 24 * *(unsigned int *)(v14 + 32);
      v20 = *(_OWORD *)v18;
      *(_QWORD *)(v19 + 16) = v18[2];
      *(_OWORD *)v19 = v20;
      ++*(_DWORD *)(v14 + 32);
    }
  }
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v14);
  if (v46[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v46);
  if (v55)
  {
    v21 = __p;
    if (__p)
    {
      v22 = v54;
      v23 = __p;
      if (v54 != __p)
      {
        do
          v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        v23 = __p;
      }
      v54 = v21;
      operator delete(v23);
    }
    v24 = v51;
    if (v51)
    {
      v25 = v52;
      v26 = v51;
      if (v52 != v51)
      {
        do
        {
          v28 = *--v25;
          v27 = v28;
          *v25 = 0;
          if (v28)
            MEMORY[0x20BD002D4](v27, 0x1000C8077774924);
        }
        while (v25 != v24);
        v26 = v51;
      }
      v52 = v24;
      operator delete(v26);
    }
    if (v47 != v50)
      free(v47);
  }
  return v8;
}

uint64_t mlir::Op<mlir::scf::YieldOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp,mlir::scf::ForOp,mlir::scf::IfOp,mlir::scf::IndexSwitchOp,mlir::scf::ParallelOp,mlir::scf::WhileOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

void `anonymous namespace'::SCFInlinerInterface::~SCFInlinerInterface(_anonymous_namespace_::SCFInlinerInterface *this)
{
  ZinIrHalH13g::~ZinIrHalH13g(this);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::SCFInlinerInterface::isLegalToInline()
{
  return 1;
}

{
  return 1;
}

void `anonymous namespace'::SCFInlinerInterface::handleTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (a2 && *(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id)
  {
    if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    {
      v6 = *(_QWORD *)(a2 + 72);
      v7 = *(unsigned int *)(a2 + 68);
      v18 = a3;
      v19 = 0;
      v20 = v6;
      v21 = 0;
      if (!a4)
        return;
    }
    else
    {
      v6 = 0;
      v7 = 0;
      v18 = a3;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      if (!a4)
        return;
    }
    v8 = 0;
    v9 = 0;
    do
    {
      if (v20 == v6 && v9 == v7)
        break;
      v12 = (uint64_t **)mlir::ValueRange::dereference_iterator(&v18, v8);
      v13 = v21;
      v14 = *v12;
      if (*v12)
      {
        v15 = *(uint64_t **)(v20 + 32 * v21 + 24);
        do
        {
          v16 = (uint64_t *)v14[1];
          if (v16)
          {
            *v16 = *v14;
            if (*v14)
              *(_QWORD *)(*v14 + 8) = v14[1];
          }
          v14[3] = (uint64_t)v15;
          v14[1] = (uint64_t)v15;
          v17 = *v15;
          *v14 = *v15;
          if (v17)
            *(_QWORD *)(v17 + 8) = v14;
          *v15 = (uint64_t)v14;
          v14 = *v12;
        }
        while (*v12);
      }
      v8 = v19 + 1;
      v9 = v13 + 1;
      ++v19;
      v21 = v9;
    }
    while (v18 != a3 || v8 != a4);
  }
}

void mlir::RewritePatternSet::addImpl<SingleBlockExecuteInliner,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"scf.execute_region", 18, (__int16)v24, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24BFF24D8;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = SingleBlockExecuteInliner]";
    v25 = 75;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<MultiBlockExecuteInliner,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  const char *v18;
  unint64_t v19;
  uint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v24, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"scf.execute_region", 18, (__int16)v24, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24BFF2480;
  v23 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v24 = "StringRef llvm::getTypeName() [DesiredTypeName = MultiBlockExecuteInliner]";
    v25 = 74;
    v16 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
    if (v25 >= v16)
      v17 = v16;
    else
      v17 = v25;
    v18 = &v24[v17];
    v19 = v25 - v17;
    if (v25 - v17 >= 0x12)
      v20 = 18;
    else
      v20 = v25 - v17;
    v21 = &v18[v20];
    v22 = v19 - v20;
    if (v22 >= v22 - 1)
      --v22;
    *(_QWORD *)(v8 + 64) = v21;
    *(_QWORD *)(v8 + 72) = v22;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v23);
    v15 = v23;
    a1[2] = v14;
    v23 = 0;
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void SingleBlockExecuteInliner::~SingleBlockExecuteInliner(SingleBlockExecuteInliner *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ExecuteRegionOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ExecuteRegionOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ExecuteRegionOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t SingleBlockExecuteInliner::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  ZinIrHalH13g **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18[2];
  unint64_t v19[3];

  v19[2] = *MEMORY[0x24BDAC8D0];
  v5 = *(unsigned int *)(a2 + 44);
  if ((v5 & 0x7FFFFF) != 0)
  {
    v6 = ((a2 + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
    v7 = *(_QWORD *)(v6 + 8);
    if (v7 == v6)
      return 0;
  }
  else
  {
    v6 = 0;
    v7 = MEMORY[8];
    if (!MEMORY[8])
      return 0;
  }
  if (*(_QWORD *)(v7 + 8) != v6)
    return 0;
  if ((v5 & 0x7FFFFF) != 0)
    v9 = ((a2 + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  else
    v9 = 0;
  mlir::ValueRange::ValueRange(v18, 0, 0);
  v10 = v18[0];
  v11 = v18[1];
  v12 = *(_QWORD *)(v9 + 8);
  if (v12)
    v13 = (ZinIrHalH13g **)(v12 - 8);
  else
    v13 = 0;
  mlir::Block::getTerminator(v13);
  v15 = v14;
  if ((*(_BYTE *)(v14 + 46) & 0x80) != 0)
  {
    v16 = *(_QWORD *)(v14 + 72);
    v17 = *(unsigned int *)(v14 + 68);
  }
  else
  {
    v16 = 0;
    v17 = 0;
  }
  mlir::ValueRange::ValueRange(v19, v16, v17);
  mlir::RewriterBase::inlineBlockBefore(a3, (uint64_t)v13, a2, v10, v11);
  (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v19[0], v19[1]);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v15);
  return 1;
}

void MultiBlockExecuteInliner::~MultiBlockExecuteInliner(MultiBlockExecuteInliner *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t MultiBlockExecuteInliner::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD, uint64_t, unint64_t, char *))
{
  mlir::Block *v5;
  uint64_t ParentOp;
  uint64_t (**v8)(_QWORD, uint64_t, unint64_t, char *);
  mlir::Block *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  ZinIrHalH13g **v20;
  ZinIrHalH13g *v21;
  BOOL v22;
  ZinIrHalH13g *v23;
  uint64_t (**v24)(_QWORD, uint64_t, unint64_t, char *);
  uint64_t (**v25)(_QWORD, uint64_t, unint64_t, char *);
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  mlir::Block *v29;
  unint64_t v30;
  uint64_t Loc;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  uint64_t NextResultAtOffset;
  mlir::Block *v37;
  unint64_t v38[2];
  void *v39;
  uint64_t v40;
  _QWORD v41[7];

  v41[6] = *MEMORY[0x24BDAC8D0];
  v5 = *(mlir::Block **)(a2 + 16);
  if (v5)
  {
    ParentOp = mlir::Block::getParentOp(v5);
    if (mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(ParentOp))
      goto LABEL_7;
  }
  else
  {
    ParentOp = 0;
    if (mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(0))
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::scf::ExecuteRegionOp,void>::id)
    return 0;
LABEL_7:
  v8 = *(uint64_t (***)(_QWORD, uint64_t, unint64_t, char *))(a2 + 16);
  v9 = (mlir::Block *)((uint64_t (*)(uint64_t (***)(_QWORD, uint64_t, unint64_t, char *), uint64_t (**)(_QWORD, uint64_t, unint64_t, char *), uint64_t))(*a3)[8])(a3, v8, a2);
  v37 = v9;
  a3[3] = v8;
  a3[4] = v8 + 4;
  v10 = a2 + 64;
  v11 = *(_QWORD *)(a2 + 24);
  v12 = *(_QWORD *)(((a2
                    + 64
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 8);
  if (v12)
    v13 = (void *)(v12 - 8);
  else
    v13 = 0;
  v39 = v13;
  mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *>((mlir::OpBuilder *)(a3 + 1), v11, (uint64_t *)&v39);
  v14 = *(unsigned int *)(a2 + 44);
  if ((v14 & 0x7FFFFF) != 0)
  {
    v15 = ((v10 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a2 + 40);
    v16 = *(_QWORD *)(v15 + 8);
    if (v16 == v15)
      goto LABEL_29;
    do
    {
LABEL_18:
      if (v16)
        v20 = (ZinIrHalH13g **)(v16 - 8);
      else
        v20 = 0;
      mlir::Block::getTerminator(v20);
      if (v21)
        v22 = *(_QWORD *)(*((_QWORD *)v21 + 6) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::YieldOp,void>::id;
      else
        v22 = 0;
      if (v22)
      {
        v23 = v21;
        v24 = (uint64_t (**)(_QWORD, uint64_t, unint64_t, char *))*((_QWORD *)v21 + 2);
        ZinIrHalH13g::~ZinIrHalH13g(v21);
        a3[3] = v24;
        a3[4] = v25;
        if ((*((_BYTE *)v23 + 46) & 0x80) != 0)
        {
          v17 = *((unsigned int *)v23 + 17);
          v18 = (void *)*((_QWORD *)v23 + 9);
        }
        else
        {
          v18 = 0;
          v17 = 0;
        }
        v19 = *((_QWORD *)v23 + 3);
        v39 = v18;
        v40 = v17;
        mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 1), v19, (uint64_t *)&v37, (uint64_t)&v39);
        ((void (*)(uint64_t (***)(_QWORD, uint64_t, unint64_t, char *), ZinIrHalH13g *))(*a3)[5])(a3, v23);
      }
      v16 = *(_QWORD *)(v16 + 8);
    }
    while (v16 != v15);
    LODWORD(v14) = *(_DWORD *)(a2 + 44);
    v9 = v37;
    goto LABEL_29;
  }
  v15 = 0;
  v16 = MEMORY[8];
  if (MEMORY[8])
    goto LABEL_18;
LABEL_29:
  mlir::RewriterBase::inlineRegionBefore(a3, ((v10 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a2 + 40), v9);
  v39 = v41;
  v40 = 0x600000000;
  v26 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v26)
    v27 = a2 - 16;
  else
    v27 = 0;
  if ((_DWORD)v26)
  {
    for (i = 0; i != v26; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v27, i);
      v29 = v37;
      v30 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
      Loc = mlir::Value::getLoc((mlir::Value *)&NextResultAtOffset);
      v32 = mlir::Block::addArgument(v29, v30, Loc);
      v33 = v40;
      if (v40 >= (unint64_t)HIDWORD(v40))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v41, v40 + 1, 8);
        v33 = v40;
      }
      *((_QWORD *)v39 + v33) = v32;
      v34 = (v40 + 1);
      LODWORD(v40) = v40 + 1;
    }
    v35 = v39;
  }
  else
  {
    v34 = 0;
    v35 = v41;
  }
  mlir::ValueRange::ValueRange(v38, (uint64_t)v35, v34);
  (*a3)[3](a3, a2, v38[0], (char *)v38[1]);
  if (v39 != v41)
    free(v39);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  uint64_t v9;
  ZinIrHalH13g *v10;
  ZinIrHalH13g *v11;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint64_t v16[4];
  __int16 v17;
  unint64_t v18[2];
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v13);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v8)
  {
    v17 = 1283;
    v16[2] = (uint64_t)"cf.br";
    v16[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v15 = 259;
    llvm::operator+(v16, (uint64_t *)&v14, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v7);
  v9 = *a3;
  mlir::ValueRange::ValueRange(v18, 0, 0);
  mlir::cf::BranchOp::build((uint64_t)a1, (uint64_t)v19, v9, v18[0], v18[1]);
  v10 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v10 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
    v11 = v10;
  else
    v11 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v11;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  ZinIrHalH13g *v12;
  ZinIrHalH13g *v13;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  unint64_t v20[2];
  _QWORD v21[39];

  v21[38] = *MEMORY[0x24BDAC8D0];
  v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    v19 = 1283;
    v18[2] = (uint64_t)"cf.br";
    v18[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  mlir::cf::BranchOp::build((uint64_t)a1, (uint64_t)v21, v11, v20[0], v20[1]);
  v12 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
    v13 = v12;
  else
    v13 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v13;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ForOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  const mlir::OperationState *v2;
  uint64_t v3;
  _QWORD v5[39];

  v5[38] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v5, a2, (uint64_t)"scf.yield", 9);
  v3 = mlir::Operation::create((mlir::Operation *)v5, v2);
  mlir::OperationState::~OperationState((mlir::OperationState *)v5);
  return v3;
}

char *llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t *k;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int128 *v45;
  uint64_t v46;
  const double *v47;
  const double *v48;
  unsigned __int128 v49;
  unsigned __int128 v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  __int128 *v57;
  _OWORD *v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  uint64_t *j;
  uint64_t v63;
  unsigned __int128 *v65;
  const double *v66;
  const double *v67;
  unsigned __int128 v68;
  unsigned __int128 v69;
  char *v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t *i;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned __int128 *v80;
  uint64_t v81;
  const double *v82;
  const double *v83;
  unsigned __int128 v84;
  unsigned __int128 v85;
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned __int128 *v92;
  uint64_t v93;
  const double *v94;
  const double *v95;
  unsigned __int128 v96;
  unsigned __int128 v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v103;

  v8 = a4;
  v11 = *(_QWORD *)a1;
  v12 = a2 - *(_QWORD *)a1;
  v13 = v12 >> 3;
  v15 = *(unsigned int *)(a1 + 8);
  v14 = *(unsigned int *)(a1 + 12);
  v16 = *(_DWORD *)(a1 + 8);
  v17 = a6 - a4;
  v18 = a6 - a4 + v15;
  if (*(_QWORD *)a1 + 8 * v15 != a2)
  {
    v103 = a3;
    if (v18 > v14)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v18, 8);
      v11 = *(_QWORD *)a1;
      v15 = *(unsigned int *)(a1 + 8);
      v16 = *(_DWORD *)(a1 + 8);
    }
    v19 = (char *)(v11 + 8 * v13);
    v20 = (char *)(v11 + 8 * v15);
    v21 = v20 - v19;
    v22 = (v20 - v19) >> 3;
    if (v22 < v17)
    {
      v23 = v16 + v17;
      *(_DWORD *)(a1 + 8) = v23;
      if (v12 >> 3 == v15)
      {
        v24 = a6;
        v25 = v103;
      }
      else
      {
        memcpy((void *)(v11 + 8 * v23 - 8 * v22), v19, v20 - v19);
        if (v21 > 0x87)
        {
          v25 = v103;
          if ((unint64_t)v19 >= v103 + 32 * v8 + 4 * v21
            || v103 + 32 * v8 + 24 >= v11 + (v12 & 0xFFFFFFFFFFFFFFF8) + v21)
          {
            v39 = (v21 >> 3) & 3;
            if (!v39)
              v39 = 4;
            v38 = &v19[8 * (v22 - v39)];
            v40 = v8 + v22 - v39;
            v65 = (unsigned __int128 *)(v11 + 8 * (v12 >> 3) + 16);
            v66 = (const double *)(v103 + 32 * v8 + 88);
            do
            {
              v67 = v66 - 8;
              v68 = (unsigned __int128)vld4q_f64(v67);
              v69 = (unsigned __int128)vld4q_f64(v66);
              *(v65 - 1) = v68;
              *v65 = v69;
              v65 += 2;
              v22 -= 4;
              v66 += 16;
            }
            while (v39 != v22);
          }
          else
          {
            v38 = v19;
            v39 = (v20 - v19) >> 3;
            v40 = v8;
          }
        }
        else
        {
          v38 = v19;
          v39 = (v20 - v19) >> 3;
          v40 = v8;
          v25 = v103;
        }
        v24 = a6;
        v71 = (uint64_t *)(v25 + 32 * v40 + 24);
        v8 = v40 + v39;
        do
        {
          v72 = *v71;
          v71 += 4;
          *(_QWORD *)v38 = v72;
          v38 += 8;
          --v39;
        }
        while (v39);
      }
      if (v25 != a5 || v24 != v8)
      {
        if (v25 != a5)
        {
          for (i = (uint64_t *)(v25 + 32 * v8 + 24); ; i += 4)
          {
            v74 = *i;
            *(_QWORD *)v20 = v74;
            v20 += 8;
          }
        }
        v75 = v24 - v8;
        if ((unint64_t)(v24 - v8) > 0x12)
        {
          v76 = v25 + 32 * v8;
          if ((unint64_t)v20 >= v25 + 32 * v24 || v76 + 24 >= (unint64_t)(v11 + 8 * (v24 + v15 - v8)))
          {
            v77 = 4;
            if ((v75 & 3) != 0)
              v77 = v75 & 3;
            v78 = v75 - v77;
            v20 += 8 * v78;
            v79 = v8 + v78;
            v80 = (unsigned __int128 *)(v11 + 8 * v15 + 16);
            v81 = v77 + v8 - v24;
            v82 = (const double *)(v76 + 88);
            do
            {
              v83 = v82 - 8;
              v84 = (unsigned __int128)vld4q_f64(v83);
              v85 = (unsigned __int128)vld4q_f64(v82);
              *(v80 - 1) = v84;
              *v80 = v85;
              v80 += 2;
              v82 += 16;
              v81 += 4;
            }
            while (v81);
            v8 = v79;
          }
        }
        v86 = v24 - v8;
        v87 = (uint64_t *)(v25 + 32 * v8 + 24);
        do
        {
          v88 = *v87;
          v87 += 4;
          *(_QWORD *)v20 = v88;
          v20 += 8;
          --v86;
        }
        while (v86);
      }
      return v19;
    }
    v29 = v12 >> 3;
    v30 = 8 * v17;
    v31 = v15 + ((uint64_t)(8 * v17) >> 3);
    v32 = v15;
    if (v31 > *(unsigned int *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v31, 8);
      v32 = *(unsigned int *)(a1 + 8);
      v16 = *(_DWORD *)(a1 + 8);
    }
    v33 = &v20[-v30];
    if (a6 == v8)
      goto LABEL_38;
    v34 = (_QWORD *)(*(_QWORD *)a1 + 8 * v32);
    v35 = 8 * a6;
    v36 = 8 * a6 - 8 * v8 - 8;
    if (v36 >= 0x98)
    {
      v54 = 8 * v32 + *(_QWORD *)a1;
      v37 = &v20[-v30];
      if ((unint64_t)(v35 - (v11 + 8 * (v8 + v15)) + v54) >= 0x20)
      {
        v55 = (v36 >> 3) + 1;
        v56 = 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
        v34 = (_QWORD *)((char *)v34 + v56);
        v37 = &v33[v56];
        v57 = (__int128 *)(8 * v8 + 8 * v15 - v35 + v11 + 16);
        v58 = (_OWORD *)(v54 + 16);
        v59 = v55 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v60 = *v57;
          *(v58 - 1) = *(v57 - 1);
          *v58 = v60;
          v57 += 2;
          v58 += 2;
          v59 -= 4;
        }
        while (v59);
        if (v55 == (v55 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_38;
      }
    }
    else
    {
      v37 = &v20[-v30];
    }
    do
    {
      v61 = *(_QWORD *)v37;
      v37 += 8;
      *v34++ = v61;
    }
    while (v37 != v20);
LABEL_38:
    *(_DWORD *)(a1 + 8) = v16 + v17;
    if (v33 != v19)
      memmove(&v19[v30], v19, &v20[-v30] - v19);
    if (v103 != a5 || a6 != v8)
    {
      if (v103 != a5)
      {
        for (j = (uint64_t *)(v103 + 32 * v8 + 24); ; j += 4)
        {
          v63 = *j;
          *(_QWORD *)v19 = v63;
          v19 += 8;
        }
      }
      if (v17 > 0x12)
      {
        v89 = v103 + 32 * v8;
        if ((unint64_t)v19 >= v103 + 32 * a6
          || (v70 = v19, v89 + 24 >= (unint64_t)(v11 + 8 * (a6 + v29 - v8))))
        {
          if ((v17 & 3) != 0)
            v90 = v17 & 3;
          else
            v90 = 4;
          v70 = &v19[8 * (v17 - v90)];
          v91 = v8 + v17 - v90;
          v92 = (unsigned __int128 *)(v11 + 8 * v29 + 16);
          v93 = v8 + v90 - a6;
          v94 = (const double *)(v89 + 88);
          do
          {
            v95 = v94 - 8;
            v96 = (unsigned __int128)vld4q_f64(v95);
            v97 = (unsigned __int128)vld4q_f64(v94);
            *(v92 - 1) = v96;
            *v92 = v97;
            v92 += 2;
            v94 += 16;
            v93 += 4;
          }
          while (v93);
          v8 = v91;
        }
      }
      else
      {
        v70 = v19;
      }
      v98 = a6 - v8;
      v99 = (uint64_t *)(v103 + 32 * v8 + 24);
      do
      {
        v100 = *v99;
        v99 += 4;
        *(_QWORD *)v70 = v100;
        v70 += 8;
        --v98;
      }
      while (v98);
    }
    return v19;
  }
  if (v18 > v14)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v18, 8);
    v16 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  if (a6 != v8 || a3 != a5)
  {
    v26 = (_QWORD *)(v11 + 8 * v16);
    if (a3 != a5)
    {
      for (k = (uint64_t *)(a3 + 32 * v8 + 24); ; k += 4)
      {
        v28 = *k;
        *v26++ = v28;
      }
    }
    if (v17 > 0x12)
    {
      v41 = v16;
      v42 = a3 + 32 * v8;
      if ((unint64_t)v26 >= a3 + 32 * a6 || v42 + 24 >= v11 + 8 * (a6 + (unint64_t)v16 - v8))
      {
        v43 = 4;
        if ((v17 & 3) != 0)
          v43 = v17 & 3;
        v26 += v17 - v43;
        v44 = v8 + v17 - v43;
        v45 = (unsigned __int128 *)(v11 + 8 * v41 + 16);
        v46 = v8 + v43 - a6;
        v47 = (const double *)(v42 + 88);
        do
        {
          v48 = v47 - 8;
          v49 = (unsigned __int128)vld4q_f64(v48);
          v50 = (unsigned __int128)vld4q_f64(v47);
          *(v45 - 1) = v49;
          *v45 = v50;
          v45 += 2;
          v47 += 16;
          v46 += 4;
        }
        while (v46);
        v8 = v44;
      }
    }
    v51 = a6 - v8;
    v52 = (uint64_t *)(a3 + 32 * v8 + 24);
    do
    {
      v53 = *v52;
      v52 += 4;
      *v26++ = v53;
      --v51;
    }
    while (v51);
    v16 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  *(_DWORD *)(a1 + 8) = v16 + v17;
  return (char *)(v11 + 8 * v13);
}

mlir::Block *llvm::function_ref<BOOL ()(mlir::OpOperand &)>::callback_fn<mlir::scf::ForOp::replaceWithAdditionalYields(mlir::RewriterBase &,mlir::ValueRange,BOOL,std::function<llvm::SmallVector<mlir::Value,6u> ()(mlir::OpBuilder &,mlir::Location,llvm::ArrayRef<mlir::BlockArgument>)> const&)::$_2>(mlir::Operation ***a1, uint64_t a2)
{
  return mlir::Operation::isProperAncestor(**a1, *(Operation **)(a2 + 16));
}

void `anonymous namespace'::ForOpIterArgsFolder::~ForOpIterArgsFolder(_anonymous_namespace_::ForOpIterArgsFolder *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ForOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ForOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ForOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::ForOpIterArgsFolder::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v4;
  int v5;
  unint64_t v6;
  mlir::Operation *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  mlir::detail::OpResultImpl *v18;
  mlir::detail::OpResultImpl *v19;
  unint64_t YieldedValues;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _QWORD *v27;
  uint64_t v30;
  _QWORD *NextResultAtOffset;
  uint64_t v32;
  uint64_t v33;
  _BOOL4 v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  void *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  ZinIrHalH13g *v49;
  void **p_AttrDictionary;
  mlir::MLIRContext *Value;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unsigned int v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  ZinIrHalH13g *v67;
  ZinIrHalH13g *v68;
  _OWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  mlir::Operation *v82;
  mlir::Operation *v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  __int128 v91;
  uint64_t v92;
  mlir::Operation *v93;
  unint64_t v94[2];
  unint64_t v95[2];
  unint64_t v96[2];
  unint64_t v97[2];
  void *AttrDictionary;
  uint64_t v99;
  uint64_t v100;
  mlir::detail::OpResultImpl *v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  void *v105;
  uint64_t v106;
  _BYTE v107[32];
  _QWORD *v108;
  uint64_t v109;
  _BYTE v110[32];
  _QWORD *v111;
  uint64_t v112;
  _BYTE v113[32];
  _QWORD *v114;
  uint64_t v115;
  _QWORD v116[6];

  v116[4] = *MEMORY[0x24BDAC8D0];
  v93 = (mlir::Operation *)a2;
  v4 = a2[9];
  v90 = &v92;
  v91 = xmmword_207A80460;
  if (v4 >= 5)
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v90, &v92, v4, 1);
  v114 = v116;
  v115 = 0x400000000;
  v111 = v113;
  v112 = 0x400000000;
  v108 = v110;
  v109 = 0x400000000;
  v105 = v107;
  v106 = 0x400000000;
  if (v4 < 4)
  {
    v5 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v116, v4 + 1, 8);
    v5 = v115;
    if (v115 >= HIDWORD(v115))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v116, v115 + 1, 8);
      v5 = v115;
    }
  }
  v114[v5] = 0;
  LODWORD(v115) = v115 + 1;
  if ((*((_BYTE *)v93 + 46) & 0x80) == 0)
  {
    v6 = -3;
LABEL_9:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v111, v113, v6, 8);
    if (HIDWORD(v109) >= v4)
      goto LABEL_10;
    goto LABEL_14;
  }
  v6 = *((unsigned int *)v93 + 17) - 3;
  if (v6 > HIDWORD(v112))
    goto LABEL_9;
  if (HIDWORD(v109) >= v4)
  {
LABEL_10:
    if (HIDWORD(v106) < v4)
      goto LABEL_11;
LABEL_15:
    v7 = v93;
    v8 = *((unsigned int *)v93 + 11);
    v84 = a3;
    if ((v8 & 0x800000) == 0)
      goto LABEL_12;
    goto LABEL_16;
  }
LABEL_14:
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v110, v4, 8);
  if (HIDWORD(v106) >= v4)
    goto LABEL_15;
LABEL_11:
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v105, v107, v4, 8);
  v7 = v93;
  v8 = *((unsigned int *)v93 + 11);
  v84 = a3;
  if ((v8 & 0x800000) == 0)
  {
LABEL_12:
    v9 = 0;
    v10 = -3;
    goto LABEL_17;
  }
LABEL_16:
  v9 = *((_QWORD *)v7 + 9);
  v10 = *((unsigned int *)v7 + 17) - 3;
LABEL_17:
  v11 = (void *)(v9 + 96);
  v12 = *((unsigned int *)v7 + 9);
  v13 = *(_QWORD *)((((unint64_t)v7 + 16 * ((v8 >> 23) & 1) + ((v8 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v7 + 10)
                  + 8);
  if (v13)
    v14 = v13 - 8;
  else
    v14 = 0;
  v15 = *(_QWORD *)(v14 + 48);
  v16 = *(_QWORD **)(v14 + 56);
  v17 = (_QWORD *)(v15 + 8);
  v18 = (mlir::Operation *)((char *)v7 - 16);
  if ((_DWORD)v12)
    v19 = v18;
  else
    v19 = 0;
  YieldedValues = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues((uint64_t)&v93);
  v85 = v21;
  v86 = v11;
  AttrDictionary = v11;
  v99 = 0;
  v100 = v15 + 8;
  v101 = v19;
  v102 = 0;
  v103 = YieldedValues;
  v104 = 0;
  if (!v10 || (_QWORD *)((char *)v16 - v15) == (_QWORD *)8)
  {
    v43 = 0;
    v44 = v105;
    if (v105 == v107)
      goto LABEL_63;
    goto LABEL_62;
  }
  v22 = YieldedValues;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = v11;
  do
  {
    if (v101 == v19 && v25 == v12)
      break;
    if (v103 == v22 && v24 == v85)
      break;
    v30 = v27[4 * v23 + 3];
    NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v101, v25);
    v32 = mlir::ValueRange::dereference_iterator(&v103, v104);
    v33 = v32;
    if (*v17 == v32)
      goto LABEL_41;
    if (!*(_QWORD *)*v17)
    {
      if (v30 == v32)
      {
LABEL_41:
        v34 = 1;
        v35 = v91;
        v36 = v91 + 1;
        if ((unint64_t)(v91 + 1) <= *((_QWORD *)&v91 + 1))
          goto LABEL_42;
      }
      else
      {
        v34 = *NextResultAtOffset == 0;
        v35 = v91;
        v36 = v91 + 1;
        if ((unint64_t)(v91 + 1) <= *((_QWORD *)&v91 + 1))
          goto LABEL_42;
      }
LABEL_37:
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v90, &v92, v36, 1);
      v35 = v91;
      goto LABEL_42;
    }
    v34 = 0;
    v35 = v91;
    v36 = v91 + 1;
    if ((unint64_t)(v91 + 1) > *((_QWORD *)&v91 + 1))
      goto LABEL_37;
LABEL_42:
    *((_BYTE *)v90 + v35) = !v34;
    *(_QWORD *)&v91 = v91 + 1;
    if (v34)
    {
      v37 = v115;
      if (v115 >= (unint64_t)HIDWORD(v115))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v116, v115 + 1, 8);
        v37 = v115;
      }
      v114[v37] = v30;
    }
    else
    {
      v38 = v112;
      if (v112 >= (unint64_t)HIDWORD(v112))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v111, v113, v112 + 1, 8);
        v38 = v112;
      }
      v111[v38] = v30;
      LODWORD(v112) = v112 + 1;
      v39 = v109;
      if (v109 >= (unint64_t)HIDWORD(v109))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v110, v109 + 1, 8);
        v39 = v109;
      }
      v108[v39] = v33;
      LODWORD(v109) = v109 + 1;
      v40 = v115;
      if (v115 >= (unint64_t)HIDWORD(v115))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v116, v115 + 1, 8);
        v40 = v115;
      }
      v30 = 0;
      v114[v40] = 0;
    }
    LODWORD(v115) = v115 + 1;
    v41 = v106;
    if (v106 >= (unint64_t)HIDWORD(v106))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v105, v107, v106 + 1, 8);
      v41 = v106;
    }
    v26 |= v34;
    *((_QWORD *)v105 + v41) = v30;
    LODWORD(v106) = v106 + 1;
    v27 = AttrDictionary;
    v23 = v99 + 1;
    v17 = (_QWORD *)(v100 + 8);
    v99 = v23;
    v100 += 8;
    v25 = v102 + 1;
    v24 = v104 + 1;
    ++v102;
    ++v104;
    v42 = v23 == v10 && AttrDictionary == v86;
  }
  while (!v42 && v17 != v16);
  if ((v26 & 1) == 0)
  {
    v43 = 0;
    v44 = v105;
    if (v105 == v107)
      goto LABEL_63;
LABEL_62:
    free(v44);
    goto LABEL_63;
  }
  v46 = *((_QWORD *)v93 + 3);
  v47 = *((_QWORD *)v93 + 9);
  AttrDictionary = *(void **)(v47 + 24);
  v48 = *(_QWORD *)(v47 + 56);
  v88 = *(_QWORD *)(v47 + 88);
  v89 = v48;
  v49 = mlir::OpBuilder::create<mlir::scf::ForOp,mlir::Value,mlir::Value,mlir::Value,llvm::SmallVector<mlir::Value,4u> &>((mlir::OpBuilder *)(v84 + 8), v46, (uint64_t *)&AttrDictionary, &v89, &v88, (uint64_t)&v111);
  if (*((_BYTE *)v93 + 47))
  {
    AttrDictionary = (void *)mlir::Operation::getAttrDictionary(v93);
    p_AttrDictionary = &AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (void **)((char *)v93 + 56);
  }
  Value = (mlir::MLIRContext *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)p_AttrDictionary);
  mlir::Operation::setAttrs((uint64_t)v49, Value, v52);
  v53 = *((unsigned int *)v49 + 10);
  v54 = *(_QWORD *)((((unint64_t)v49
                    + 16 * (((unint64_t)*((unsigned int *)v49 + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)v49 + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * v53
                  + 8);
  if (v54)
    v55 = v54 - 8;
  else
    v55 = 0;
  *v114 = **(_QWORD **)(v55 + 48);
  if ((_DWORD)v106)
  {
    v56 = 0;
    v57 = 0;
    v58 = 8 * v106;
    do
    {
      if (!v114[v56 / 8 + 1])
      {
        v59 = (char *)v105;
        v60 = *(_QWORD *)((((unint64_t)v49
                          + 16 * (((unint64_t)*((unsigned int *)v49 + 11) >> 23) & 1)
                          + (((unint64_t)*((unsigned int *)v49 + 11) >> 21) & 0x7F8)
                          + 71) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * v53
                        + 8);
        if (v60)
          v61 = v60 - 8;
        else
          v61 = 0;
        v114[v56 / 8 + 1] = *(_QWORD *)(*(_QWORD *)(v61 + 48) + 8 * v57 + 8);
        v62 = v57 - 5;
        v63 = v57++ >= 6;
        v64 = (uint64_t)v49 - 24 * v62 - 96;
        if (!v63)
          v64 = (uint64_t)v49 - 16 * v57;
        *(_QWORD *)&v59[v56] = v64;
      }
      v56 += 8;
    }
    while (v58 != v56);
  }
  v65 = *(_QWORD *)((((unint64_t)v93
                    + 16 * (((unint64_t)*((unsigned int *)v93 + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)v93 + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v93 + 10)
                  + 8);
  if (v65)
    v66 = v65 - 8;
  else
    v66 = 0;
  if ((_DWORD)v112)
  {
    mlir::ValueRange::ValueRange(v95, (uint64_t)v114, v115);
    mlir::RewriterBase::mergeBlocks(v84, v66, v55, v95[0], v95[1]);
    mlir::Block::getTerminator((ZinIrHalH13g **)v55);
    v68 = v67;
    v69 = (_OWORD *)(v84 + 24);
    v87 = *(_OWORD *)(v84 + 24);
    v70 = *((_QWORD *)v67 + 2);
    ZinIrHalH13g::~ZinIrHalH13g(v67);
    *(_QWORD *)(v84 + 24) = v70;
    *(_QWORD *)(v84 + 32) = v71;
    AttrDictionary = &v100;
    v99 = 0x400000000;
    if (v106 >= 5)
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AttrDictionary, &v100, v106, 8);
    v72 = v91;
    if ((_DWORD)v91)
    {
      v73 = 0;
      v74 = 24;
      do
      {
        if (*((_BYTE *)v90 + v73))
        {
          v75 = *(_QWORD *)(*((_QWORD *)v68 + 9) + v74);
          v76 = v99;
          if (v99 >= (unint64_t)HIDWORD(v99))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AttrDictionary, &v100, v99 + 1, 8);
            v76 = v99;
          }
          *((_QWORD *)AttrDictionary + v76) = v75;
          LODWORD(v99) = v99 + 1;
        }
        ++v73;
        v74 += 32;
      }
      while (v72 != v73);
    }
    mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(v84 + 8), *((_QWORD *)v68 + 3), (uint64_t)&AttrDictionary);
    if (AttrDictionary != &v100)
      free(AttrDictionary);
    if ((_QWORD)v87)
    {
      *v69 = v87;
    }
    else
    {
      *(_QWORD *)v69 = 0;
      *(_QWORD *)(v84 + 32) = 0;
    }
    (*(void (**)(uint64_t, ZinIrHalH13g *))(*(_QWORD *)v84 + 40))(v84, v68);
    v82 = v93;
    mlir::ValueRange::ValueRange(v94, (uint64_t)v105, v106);
    (*(void (**)(uint64_t, mlir::Operation *, unint64_t, unint64_t))(*(_QWORD *)v84 + 24))(v84, v82, v94[0], v94[1]);
  }
  else
  {
    mlir::Block::getTerminator((ZinIrHalH13g **)v55);
    v78 = v77;
    mlir::ValueRange::ValueRange(v97, (uint64_t)v114, v115);
    mlir::RewriterBase::inlineBlockBefore(v84, v66, v78, v97[0], v97[1]);
    mlir::Block::getTerminator((ZinIrHalH13g **)v55);
    if (*(_QWORD *)(*(_QWORD *)(v79 + 16) + 40) == v79)
    {
      v81 = 0;
    }
    else
    {
      ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)v79);
      v81 = v80;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v84 + 40))(v84, v81);
    v83 = v93;
    mlir::ValueRange::ValueRange(v96, (uint64_t)v105, v106);
    (*(void (**)(uint64_t, mlir::Operation *, unint64_t, unint64_t))(*(_QWORD *)v84 + 24))(v84, v83, v96[0], v96[1]);
  }
  v43 = 1;
  v44 = v105;
  if (v105 != v107)
    goto LABEL_62;
LABEL_63:
  if (v108 != (_QWORD *)v110)
    free(v108);
  if (v111 != (_QWORD *)v113)
    free(v111);
  if (v114 != v116)
    free(v114);
  if (v90 != &v92)
    free(v90);
  return v43;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::ForOp,mlir::Value,mlir::Value,mlir::Value,llvm::SmallVector<mlir::Value,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  ZinIrHalH13g *v19;
  ZinIrHalH13g *v20;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v26[4];
  __int16 v27;
  unint64_t v28[2];
  _QWORD v29[39];

  v29[38] = *MEMORY[0x24BDAC8D0];
  v23 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v23);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.for", (const unsigned __int8 *)7, Context);
  if (!v14)
  {
    v27 = 1283;
    v26[2] = (uint64_t)"scf.for";
    v26[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v25 = 259;
    llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v13);
  v15 = *a3;
  v16 = *a4;
  v17 = *a5;
  mlir::ValueRange::ValueRange(v28, *(_QWORD *)a6, *(unsigned int *)(a6 + 8));
  mlir::scf::ForOp::build((uint64_t)a1, (uint64_t)v29, v15, v16, v17, v28[0], v28[1], v18, 0, v22);
  v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v20;
}

void `anonymous namespace'::SimplifyTrivialLoops::~SimplifyTrivialLoops(_anonymous_namespace_::SimplifyTrivialLoops *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::SimplifyTrivialLoops::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  void **v6;
  void **v7;
  uint64_t DefiningOp;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  void **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  void **v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  void **v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t YieldedValues;
  uint64_t v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  ZinIrHalH13g **v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unsigned int v53;
  mlir::Operation *v54;
  unint64_t v55;
  uint64_t v56;
  void **v57;
  void **v58;
  char v59;
  mlir::Operation *v60;
  void **v61;
  void **v62;
  unint64_t v63;
  unint64_t v64;
  void **v65;
  unint64_t v66[2];
  void *v67;
  uint64_t v68;
  _BYTE v69[32];
  unint64_t v70[2];
  unint64_t v71[2];
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  v60 = (mlir::Operation *)a2;
  v5 = *(_QWORD *)(a2 + 72);
  v6 = *(void ***)(v5 + 24);
  v7 = *(void ***)(v5 + 56);
  if (v6 == v7)
  {
    mlir::ValueRange::ValueRange(v71, v5 + 96, *(unsigned int *)(a2 + 68) - 3);
    v23 = v71[0];
    v24 = v71[1];
LABEL_52:
    (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v23, v24);
    return 1;
  }
  v63 = 0;
  v64 = 0;
  v57 = v6;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v57);
  if (DefiningOp)
  {
    v9 = DefiningOp;
    if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    {
      v67 = v69;
      v68 = 0x100000000;
      mlir::Operation::fold(v9, 0, 0, (uint64_t)&v67);
      v10 = *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)v67 & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
         || (*(_QWORD *)v67 & 0xFFFFFFFFFFFFFFF8) == 0;
      if (!v10)
        v64 = *(_QWORD *)v67 & 0xFFFFFFFFFFFFFFF8;
      if (v67 != v69)
        free(v67);
      if (!v10)
      {
        v57 = v7;
        v11 = mlir::Value::getDefiningOp((mlir::Value *)&v57);
        if (v11)
        {
          v12 = v11;
          if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(v11 + 48)))
          {
            v67 = v69;
            v68 = 0x100000000;
            mlir::Operation::fold(v12, 0, 0, (uint64_t)&v67);
            v13 = *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)v67 & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
               || (*(_QWORD *)v67 & 0xFFFFFFFFFFFFFFF8) == 0;
            if (!v13)
              v63 = *(_QWORD *)v67 & 0xFFFFFFFFFFFFFFF8;
            if (v67 != v69)
              free(v67);
            if (!v13)
            {
              mlir::IntegerAttr::getValue(&v64, (llvm::APInt *)&v67);
              mlir::IntegerAttr::getValue(&v63, (llvm::APInt *)&v57);
              LODWORD(v73) = (_DWORD)v58;
              if (v58 > 0x40)
                llvm::APInt::initSlowCase((llvm::APInt *)&v72, (const void **)&v57);
              else
                v72 = (uint64_t *)v57;
              llvm::APInt::operator-=((uint64_t)&v72, (_QWORD **)&v67);
              v53 = v73;
              LODWORD(v73) = 0;
              if (v53 > 0x40)
              {
                v25 = *v72;
                if (v72)
                {
                  MEMORY[0x20BD002D4](v72, 0x1000C8000313F17);
                  if (v73 >= 0x41)
                  {
                    if (v72)
                      MEMORY[0x20BD002D4](v72, 0x1000C8000313F17);
                  }
                }
              }
              else
              {
                v25 = (uint64_t)((_QWORD)v72 << -(char)v53) >> -(char)v53;
              }
              if (v58 >= 0x41 && v57)
                MEMORY[0x20BD002D4](v57, 0x1000C8000313F17);
              if (v68 >= 0x41 && v67)
                MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
              goto LABEL_44;
            }
          }
        }
      }
    }
  }
  LODWORD(v68) = 1;
  v67 = 0;
  v57 = v6;
  v58 = &v67;
  v61 = v7;
  v14 = mlir::Value::getDefiningOp((mlir::Value *)&v61);
  if (v14)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::AddIOp,void>::id
      && (*(_BYTE *)(v14 + 46) & 0x80) != 0
      && *(_DWORD *)(v14 + 68) == 2)
    {
      v15 = *(void ***)(*(_QWORD *)(v14 + 72) + 24);
      if (mlir::detail::matchOperandOrValueAtIndex<mlir::detail::constant_int_value_binder>(v14, 1u, (uint64_t *)&v58))
      {
        if (v15 == v6)
          goto LABEL_34;
      }
    }
  }
  v61 = &v67;
  v62 = v6;
  v65 = v7;
  v16 = mlir::Value::getDefiningOp((mlir::Value *)&v65);
  if (v16
    && (v17 = v16,
        *(_UNKNOWN **)(*(_QWORD *)(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::AddIOp,void>::id)
    && (*(_BYTE *)(v16 + 46) & 0x80) != 0
    && *(_DWORD *)(v16 + 68) == 2)
  {
    LOBYTE(v18) = 0;
    v19 = 1;
    if (mlir::detail::matchOperandOrValueAtIndex<mlir::detail::constant_int_value_binder>(v16, 0, (uint64_t *)&v61))
    {
      v20 = *(void ***)(*(_QWORD *)(v17 + 72) + 56);
      v21 = 0;
      if (v62 == v20)
      {
LABEL_34:
        if (v68 > 0x40)
          v18 = *(_QWORD *)v67;
        else
          v18 = (uint64_t)((_QWORD)v67 << -(uint64_t)v68) >> -(uint64_t)v68;
        v19 = 0;
        v21 = v18 & 0xFFFFFFFFFFFFFF00;
      }
    }
    else
    {
      v21 = 0;
    }
  }
  else
  {
    LOBYTE(v18) = 0;
    v21 = 0;
    v19 = 1;
  }
  if (v68 >= 0x41 && v67)
    MEMORY[0x20BD002D4](v67, 0x1000C8000313F17);
  if ((v19 & 1) != 0)
    return 0;
  v25 = v21 | v18;
LABEL_44:
  if (v25 <= 0)
  {
    if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    {
      v26 = *(_QWORD *)(a2 + 72);
      v27 = *(unsigned int *)(a2 + 68) - 3;
    }
    else
    {
      v26 = 0;
      v27 = -3;
    }
    mlir::ValueRange::ValueRange(v70, v26 + 96, v27);
    v23 = v70[0];
    v24 = v70[1];
    goto LABEL_52;
  }
  mlir::scf::ForOp::getConstantStep((mlir::scf::ForOp *)&v60, (uint64_t)&v57);
  if (!v59)
    return 0;
  LODWORD(v62) = (_DWORD)v58;
  if (v58 > 0x40)
  {
    llvm::APInt::initSlowCase((llvm::APInt *)&v61, (const void **)&v57);
    if (v62 > 0x40)
    {
      v29 = v61;
      v30 = (_DWORD)v62 + 1;
      if ((((unint64_t)v61[((_DWORD)v62 - 1) >> 6] >> (v62 - 1)) & 1) != 0)
      {
        if (v30 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&v61) > 0x40)
          goto LABEL_67;
      }
      else if (v30 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v61) > 0x40)
      {
        goto LABEL_74;
      }
      if ((uint64_t)*v29 >= v25)
        goto LABEL_74;
    }
    else if ((uint64_t)((_QWORD)v61 << -(char)v62) >> -(char)v62 >= v25)
    {
      goto LABEL_74;
    }
  }
  else
  {
    v61 = v57;
    if ((uint64_t)((_QWORD)v57 << -(char)v58) >> -(char)v58 >= v25)
    {
LABEL_74:
      v67 = v69;
      v68 = 0x400000000;
      if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
      {
        v37 = *(unsigned int *)(a2 + 68) - 2;
        if (v37 <= 4)
        {
          v38 = 0;
          v39 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
          goto LABEL_79;
        }
      }
      else
      {
        v37 = -2;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v67, v69, v37, 8);
      v38 = v68;
      v39 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
      if (v68 >= HIDWORD(v68))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v67, v69, v68 + 1, 8);
        v38 = v68;
      }
LABEL_79:
      *((_QWORD *)v67 + v38) = v39;
      v40 = v68 + 1;
      LODWORD(v68) = v68 + 1;
      if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
      {
        v41 = *(_QWORD *)(a2 + 72);
        v42 = *(unsigned int *)(a2 + 68) - 3;
      }
      else
      {
        v41 = 0;
        v42 = -3;
      }
      llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>((uint64_t)&v67, (uint64_t)v67 + 8 * v40, v41 + 96, 0, v41 + 96, v42);
      v43 = *(unsigned int *)(a2 + 44);
      if ((v43 & 0x7FFFFF) != 0)
        v44 = ((a2 + 16 * ((v43 >> 23) & 1) + ((v43 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
            + 32 * *(unsigned int *)(a2 + 40);
      else
        v44 = 0;
      mlir::ValueRange::ValueRange(v66, (uint64_t)v67, v68);
      v45 = v66[0];
      v46 = v66[1];
      v47 = *(_QWORD *)(v44 + 8);
      if (v47)
        v48 = (ZinIrHalH13g **)(v47 - 8);
      else
        v48 = 0;
      mlir::Block::getTerminator(v48);
      v50 = v49;
      if ((*(_BYTE *)(v49 + 46) & 0x80) != 0)
      {
        v51 = *(_QWORD *)(v49 + 72);
        v52 = *(unsigned int *)(v49 + 68);
      }
      else
      {
        v51 = 0;
        v52 = 0;
      }
      mlir::ValueRange::ValueRange((unint64_t *)&v72, v51, v52);
      mlir::RewriterBase::inlineBlockBefore(a3, (uint64_t)v48, a2, v45, v46);
      (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v72, v73);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v50);
      if (v67 != v69)
        free(v67);
      v22 = 1;
      if (v62 < 0x41)
        goto LABEL_94;
      goto LABEL_92;
    }
  }
LABEL_67:
  v31 = *(_QWORD *)(((a2
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 8);
  v32 = v31 - 8;
  if (!v31)
    v32 = 0;
  v33 = v32 + 32;
  v34 = *(_QWORD *)(v32 + 40);
  if (v34 != v33 && *(_QWORD *)(v34 + 8) == v33)
  {
    YieldedValues = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues((uint64_t)&v60);
    {
      v54 = v60;
      v55 = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getYieldedValues((uint64_t)&v60);
      (*(void (**)(uint64_t, mlir::Operation *, unint64_t, uint64_t))(*(_QWORD *)a3 + 24))(a3, v54, v55, v56);
      v22 = 1;
      if (v62 < 0x41)
        goto LABEL_94;
LABEL_92:
      if (v61)
        MEMORY[0x20BD002D4](v61, 0x1000C8000313F17);
      goto LABEL_94;
    }
  }
  v22 = 0;
  if (v62 >= 0x41)
    goto LABEL_92;
LABEL_94:
  if (v59 && v58 >= 0x41 && v57)
    MEMORY[0x20BD002D4](v57, 0x1000C8000313F17);
  return v22;
}

mlir::Block *llvm::any_of<mlir::ValueRange,`anonymous namespace'::SimplifyTrivialLoops::matchAndRewrite(mlir::scf::ForOp,mlir::PatternRewriter &)::{lambda(mlir::Value)#1}>(uint64_t a1, uint64_t a2, mlir::Operation **a3)
{
  uint64_t v6;
  uint64_t v7;
  mlir::Operation *v8;
  Operation *v9;
  mlir::Block *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = 0;
  if (!a2)
    return 0;
  v6 = 0;
  while (1)
  {
    v7 = mlir::ValueRange::dereference_iterator(&v12, v6);
    v8 = *a3;
    v11 = v7;
    v9 = (Operation *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v11) + 2);
    if (v9 == v8)
      break;
    result = mlir::Operation::isProperAncestor(v8, v9);
    if ((result & 1) == 0)
    {
      v6 = ++v13;
      if (v12 != a1 || v6 != a2)
        continue;
    }
    return result;
  }
  return (mlir::Block *)1;
}

void `anonymous namespace'::LastTensorLoadCanonicalization::~LastTensorLoadCanonicalization(_anonymous_namespace_::LastTensorLoadCanonicalization *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

void `anonymous namespace'::LastTensorLoadCanonicalization::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnitAttr **a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v12;
  mlir::UnitAttr **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  ZinIrHalH13g **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t DefiningOp;
  uint64_t v22;
  void *v23;
  _BOOL4 v25;
  _QWORD *v26;
  uint64_t Input;
  ZinIrHalH13g *v28;
  uint64_t v29;
  mlir::UnitAttr *v30;
  mlir::UnitAttr *v31;
  _QWORD *v32;
  ZinIrHalH13g *v33;
  mlir::UnitAttr *v34;
  uint64_t v35;
  mlir::UnitAttr *v36;
  ZinIrHalH13g *v37;
  uint64_t v38;
  unsigned int v39;
  void *v40;
  void *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  llvm *v51;
  uint64_t *p_NextResultAtOffset;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  void ***v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t NextResultAtOffset;
  llvm *v68;
  uint64_t v69;
  unsigned int v70;
  unint64_t v71[2];
  void *v72;
  uint64_t v73;
  _BYTE v74[48];
  void **v75;
  uint64_t *v76;
  unint64_t v77;
  uint64_t v78;

  v78 = *MEMORY[0x24BDAC8D0];
  v3 = a2 + 64;
  v4 = *(unsigned int *)(a2 + 40);
  v5 = a2
     + 64
     + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
     + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8);
  v64 = *(_QWORD *)(a2 + 24);
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v6 = *(_QWORD *)(((v5 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v4 + 8);
  v7 = v6 - 8;
  if (!v6)
    v7 = 0;
  v8 = *(_QWORD *)(v7 + 48);
  v9 = *(_QWORD *)(v7 + 56) - v8;
  if (v9 == 8)
LABEL_88:
    llvm::deallocate_buffer(v68, (void *)(16 * v70));
  v12 = (uint64_t *)(v8 + 8);
  v13 = a3 + 1;
  v63 = a2 - 96;
  v14 = 8 * (v9 >> 3) - 8;
  while (1)
  {
    v15 = *v12;
    v16 = (*(_DWORD *)(*v12 + 24) - 1);
    v17 = *(_QWORD *)(((v3
                      + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                      + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(a2 + 40)
                    + 8);
    if (v17)
      v18 = (ZinIrHalH13g **)(v17 - 8);
    else
      v18 = 0;
    mlir::Block::getTerminator(v18);
    v20 = v19;
    NextResultAtOffset = *(_QWORD *)(*(_QWORD *)(v19 + 72) + 32 * v16 + 24);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&NextResultAtOffset);
    if (DefiningOp)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::bufferization::ToTensorOp,void>::id)
        v22 = DefiningOp;
      else
        v22 = 0;
    }
    else
    {
      v22 = 0;
    }
    v66 = v22;
    v23 = *(void **)(*(_QWORD *)(*(_QWORD *)(v15 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
    v25 = v23 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
       || v23 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    v65 = 0;
    v26 = *(_QWORD **)v15;
    if (*(_QWORD *)v15)
    {
      if (!*v26)
      {
        v26 = (_QWORD *)v26[2];
        if (*(_UNKNOWN **)(v26[6] + 16) != &mlir::detail::TypeIDResolver<mlir::bufferization::ToMemrefOp,void>::id)
          v26 = 0;
        v65 = v26;
        if (!v22)
          v25 = 0;
        if (!v25)
          goto LABEL_6;
        goto LABEL_27;
      }
      v26 = 0;
    }
    if (!v22)
      v25 = 0;
    if (!v25)
      goto LABEL_6;
LABEL_27:
    if (*(_QWORD *)v15)
    {
      if (!v26)
        goto LABEL_6;
    }
    else if (!v26)
    {
      goto LABEL_39;
    }
    Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v66);
    if (v65 - 2 != (_QWORD *)Input)
      goto LABEL_6;
    v22 = v66;
LABEL_39:
    v28 = *(ZinIrHalH13g **)(v22 + 8);
    if (v28 == (ZinIrHalH13g *)(*(_QWORD *)(v22 + 16) + 32))
    {
      if (!v20)
      {
LABEL_43:
        if (v65)
        {
          v30 = *(mlir::UnitAttr **)(a2 + 16);
          ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)a2);
          a3[3] = v30;
          a3[4] = v31;
          v32 = v65;
          v72 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v65) + 8) & 0xFFFFFFFFFFFFFFF8);
          v75 = (void **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v65);
          v33 = mlir::OpBuilder::create<mlir::bufferization::ToMemrefOp,mlir::BaseMemRefType,mlir::detail::TypedValue<mlir::TensorType>>(v13, v32[3], (uint64_t *)&v72, (uint64_t *)&v75);
          (*((void (**)(mlir::UnitAttr **, _QWORD *, ZinIrHalH13g *))*a3 + 4))(a3, v32, v33);
        }
        v34 = *(mlir::UnitAttr **)(a2 + 16);
        ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)a2);
        v36 = *(mlir::UnitAttr **)(v35 + 8);
        a3[3] = v34;
        a3[4] = v36;
        v72 = (void *)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v66);
        v37 = mlir::OpBuilder::create<mlir::bufferization::ToTensorOp,mlir::detail::TypedValue<mlir::BaseMemRefType>>(v13, v64, (uint64_t *)&v72);
        v38 = *(_QWORD *)(v15 + 24);
        v39 = v38 - 1;
        v40 = (void *)(a2 - 16 * v38);
        v41 = (void *)(v63 - 24 * (v38 - 6));
        if (v39 < 6)
          v41 = v40;
        v72 = v41;
        v73 = (uint64_t)v37 - 16;
        v75 = 0;
        if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v68, (unint64_t *)&v72, &v75) & 1) == 0)
        {
          v42 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)&v68, (uint64_t)&v72, (unint64_t *)&v72, v75);
          *v42 = v72;
          v42[1] = v73;
        }
        (*((void (**)(mlir::UnitAttr **, uint64_t))*a3 + 9))(a3, v20);
        v43 = (_QWORD *)(*(_QWORD *)(v20 + 72) + 32 * v16);
        v44 = (_QWORD *)v43[1];
        if (v44)
        {
          *v44 = *v43;
          if (*v43)
            *(_QWORD *)(*v43 + 8) = v43[1];
        }
        v43[3] = v15;
        v43[1] = v15;
        v45 = *(_QWORD **)v15;
        *v43 = *(_QWORD *)v15;
        if (v45)
          v45[1] = v43;
        *(_QWORD *)v15 = v43;
        (*((void (**)(mlir::UnitAttr **, uint64_t))*a3 + 10))(a3, v20);
      }
    }
    else
    {
      ZinIrHalH13g::~ZinIrHalH13g(v28);
      if (v29 == v20)
        goto LABEL_43;
    }
LABEL_6:
    ++v12;
    v14 -= 8;
    if (!v14)
    {
      if ((_DWORD)v69)
      {
        v72 = v74;
        v73 = 0x600000000;
        v46 = *(unsigned int *)(a2 + 36);
        if (v46 >= 7)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v74, v46, 8);
          LODWORD(v46) = *(_DWORD *)(a2 + 36);
        }
        if ((_DWORD)v46)
          v47 = a2 - 16;
        else
          v47 = 0;
        if ((_DWORD)v46)
        {
          v48 = 0;
          v49 = v46;
          do
          {
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v47, v48);
            v75 = 0;
            v50 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v68, (unint64_t *)&NextResultAtOffset, &v75);
            v51 = (llvm *)v75;
            if (!v50)
              v51 = (llvm *)((char *)v68 + 16 * v70);
            if (v51 == (llvm *)((char *)v68 + 16 * v70))
              p_NextResultAtOffset = &NextResultAtOffset;
            else
              p_NextResultAtOffset = (uint64_t *)((char *)v51 + 8);
            v53 = *p_NextResultAtOffset;
            v54 = v73;
            if (v73 >= (unint64_t)HIDWORD(v73))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v74, v73 + 1, 8);
              v54 = v73;
            }
            *((_QWORD *)v72 + v54) = v53;
            v55 = v73 + 1;
            LODWORD(v73) = v73 + 1;
            ++v48;
          }
          while (v49 != v48);
        }
        else
        {
          v55 = v73;
        }
        LODWORD(NextResultAtOffset) = 0;
        mlir::ValueRange::ValueRange(v71, (uint64_t)v72, v55);
            + 2;
            + 2 > 7;
           + 2 >= 8)
        {
          v56 = 0;
          v75 = &v72;
          v76 = &NextResultAtOffset;
        }
        (*((void (**)(mlir::UnitAttr **, uint64_t, unint64_t, unint64_t, _QWORD, void ***))*a3
         + 2))(a3, a2, v71[0], v71[1], 0, &v75);
        v61 = v77;
        if (v77 >= 8)
        {
          if ((v77 & 4) != 0)
          {
            if ((v77 & 2) != 0)
              v62 = &v75;
            else
              v62 = (void ***)v75;
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v77 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v62, v57, v58, v59, v60);
          }
          if ((v61 & 2) == 0)
            llvm::deallocate_buffer((llvm *)v75, v76);
        }
        if (v56
           + 2 >= 8)
        {
          llvm::deallocate_buffer((llvm *)&v72, &NextResultAtOffset);
        }
        if (v72 != v74)
          free(v72);
      }
      goto LABEL_88;
    }
  }
}

uint64_t sub_2074D3074()
{
  uint64_t v0;

  return v0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::bufferization::ToTensorOp,mlir::detail::TypedValue<mlir::BaseMemRefType>>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  ZinIrHalH13g *v9;
  ZinIrHalH13g *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x24BDAC8D0];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"bufferization.to_tensor", (const unsigned __int8 *)0x17, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"bufferization.to_tensor";
    v15[3] = 23;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::bufferization::ToTensorOp::build(a1, (uint64_t)v17, *a3, 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::bufferization::ToTensorOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::bufferization::ToMemrefOp,mlir::BaseMemRefType,mlir::detail::TypedValue<mlir::TensorType>>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"bufferization.to_memref", (const unsigned __int8 *)0x17, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"bufferization.to_memref";
    v17[3] = 23;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::bufferization::ToMemrefOp::build(a1, (uint64_t)v19, *a3, *a4, 0);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::bufferization::ToMemrefOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::OpOperand &>::CallImpl<`anonymous namespace'::LastTensorLoadCanonicalization::matchAndRewrite(mlir::scf::ForOp,mlir::PatternRewriter &)::{lambda(mlir::OpOperand &)#1} const>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a1[1];
  v3 = *(_QWORD *)(a2 + 24);
  v4 = **a1;
  v5 = *(unsigned int *)v2;
  *(_DWORD *)v2 = v5 + 1;
  return *(_QWORD *)(v4 + 8 * v5) != v3;
}

void `anonymous namespace'::ForOpTensorCastFolder::~ForOpTensorCastFolder(_anonymous_namespace_::ForOpTensorCastFolder *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ForOpTensorCastFolder::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  void *v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *NextResultAtOffset;
  uint64_t DefiningOp;
  void *v25;
  BOOL v26;
  uint64_t v27;
  uint64_t Input;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int OperandNumber;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v45;
  uint64_t v46;
  ZinIrHalH13g *v47;
  uint64_t v48;
  void **p_AttrDictionary;
  mlir::MLIRContext *Value;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  char *v60;
  uint64_t *v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  __int128 *v65;
  _OWORD *v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  unsigned int v72;
  ZinIrHalH13g *v73;
  uint64_t v74;
  uint64_t v75;
  ZinIrHalH13g *v76;
  ZinIrHalH13g *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  char *v86;
  char *v87;
  unint64_t v88;
  uint64_t v89;
  const double *v90;
  unsigned __int128 *v91;
  unint64_t v92;
  const double *v93;
  unsigned __int128 v94;
  unsigned __int128 v95;
  unint64_t v96;
  uint64_t *v97;
  uint64_t v98;
  int v99;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  ZinIrHalH13g *v105;
  unint64_t v106;
  char *v107;
  uint64_t v108;
  _BYTE *v109;
  uint64_t v110;
  _BYTE *v111;
  int v112;
  _BYTE *v113;
  ZinIrHalH13g *v114;
  __int128 v115;
  mlir::OpBuilder *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t TiedLoopRegionIterArg;
  ZinIrHalH13g *v121;
  unint64_t v122;
  unint64_t v123;
  void *v124;
  uint64_t v125;
  _BYTE v126[48];
  unint64_t v127[2];
  __int128 v128;
  void *v129[2];
  _BYTE v130[24];
  uint64_t v131;
  uint64_t v132;
  void *AttrDictionary;
  uint64_t v134;
  void *v135[2];
  uint64_t v136;
  unint64_t v137[2];
  char *v138;
  uint64_t v139;
  _BYTE v140[32];
  __int128 v141;
  _QWORD *v142;
  int v143;
  _QWORD v144[6];

  v144[4] = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    v5 = *(_DWORD *)(a2 + 68) - 3;
  else
    v5 = -3;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)&v141, a2, 3, v5, 0, 0);
  v6 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v6)
    v7 = a2 - 16;
  else
    v7 = 0;
  v128 = v141;
  v129[0] = v130;
  v129[1] = (void *)0x100000000;
  if (v143)
    llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=((uint64_t)v129, (uint64_t *)&v142);
  v131 = v7;
  v132 = v6;
  if (v142 != v144)
    free(v142);
  v8 = mlir::MutableOperandRange::begin((mlir::MutableOperandRange *)&v128);
  v9 = v131;
  v10 = mlir::MutableOperandRange::end((mlir::MutableOperandRange *)&v128);
  if (v8 == v10)
    goto LABEL_50;
  v11 = v10;
  if (v9 == v131)
  {
    v117 = a3;
    v21 = 0;
    v22 = v132;
    while (v22 != v21)
    {
      NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v9, v21);
      *(_QWORD *)&v141 = *(_QWORD *)(v8 + 24);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v141);
      if (DefiningOp)
      {
        v25 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
        v26 = v25 == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id;
        v27 = v25 == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id ? DefiningOp : 0;
        v119 = v27;
        if (v26)
        {
          Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119);
          if ((*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8) != (*(_QWORD *)(v119 - 8) & 0xFFFFFFFFFFFFFFF8))
          {
            v29 = *(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8;
            v30 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119);
            if (mlir::tensor::preservesStaticInformation(v29, *(_QWORD *)(v30 + 8) & 0xFFFFFFFFFFFFFFF8))
            {
              if (*NextResultAtOffset && !*(_QWORD *)*NextResultAtOffset)
              {
                a3 = v117;
                goto LABEL_39;
              }
            }
          }
        }
      }
      v8 += 32;
      ++v21;
      if (v8 == v11)
        break;
    }
LABEL_50:
    v42 = 0;
    v43 = v129[0];
    if (v129[0] == v130)
      return v42;
LABEL_51:
    free(v43);
    return v42;
  }
  v12 = 0;
  while (1)
  {
    v13 = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v9, v12);
    *(_QWORD *)&v141 = *(_QWORD *)(v8 + 24);
    v14 = mlir::Value::getDefiningOp((mlir::Value *)&v141);
    if (v14)
    {
      v15 = *(void **)(*(_QWORD *)(v14 + 48) + 16);
      v16 = v15 == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id;
      v17 = v15 == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id ? v14 : 0;
      v119 = v17;
      if (v16)
      {
        v18 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119);
        if ((*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8) != (*(_QWORD *)(v119 - 8) & 0xFFFFFFFFFFFFFFF8))
        {
          v19 = *(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8;
          v20 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119);
          if (mlir::tensor::preservesStaticInformation(v19, *(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8))
          {
            if (*v13 && !*(_QWORD *)*v13)
              break;
          }
        }
      }
    }
    v8 += 32;
    ++v12;
    if (v8 == v11)
      goto LABEL_50;
  }
LABEL_39:
  v31 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119);
  v32 = *(_QWORD *)(v8 + 16);
  v33 = *(_QWORD *)(*(_QWORD *)(v8 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v122 = *(_QWORD *)(v31 + 8) & 0xFFFFFFFFFFFFFFF8;
  v123 = v33;
  *(_QWORD *)&v141 = &v142;
  *((_QWORD *)&v141 + 1) = 0x600000000;
  if ((*(_BYTE *)(v32 + 46) & 0x80) != 0)
    v34 = *(_DWORD *)(v32 + 68) - 3;
  else
    v34 = -3;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)&AttrDictionary, v32, 3, v34, 0, 0);
  v35 = mlir::MutableOperandRange::begin((mlir::MutableOperandRange *)&AttrDictionary);
  v36 = mlir::MutableOperandRange::end((mlir::MutableOperandRange *)&AttrDictionary);
  if (v35 != v36)
  {
    v37 = v36;
    do
    {
      OperandNumber = mlir::OpOperand::getOperandNumber(v35);
      if (OperandNumber == mlir::OpOperand::getOperandNumber(v8))
      {
        v39 = DWORD2(v141);
        v40 = HIDWORD(v141);
        v41 = v31;
      }
      else
      {
        v41 = *(_QWORD *)(v35 + 24);
        v39 = DWORD2(v141);
        v40 = HIDWORD(v141);
      }
      if (v39 >= v40)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, &v142, v39 + 1, 8);
        v39 = DWORD2(v141);
      }
      *(_QWORD *)(v141 + 8 * v39) = v41;
      ++DWORD2(v141);
      v35 += 32;
    }
    while (v35 != v37);
  }
  if (v135[0] != &v136)
    free(v135[0]);
  v45 = *(_QWORD *)(v32 + 24);
  v46 = *(_QWORD *)(v32 + 72);
  AttrDictionary = *(void **)(v46 + 24);
  v124 = *(void **)(v46 + 56);
  v138 = *(char **)(v46 + 88);
  v116 = (mlir::OpBuilder *)(a3 + 8);
  v47 = mlir::OpBuilder::create<mlir::scf::ForOp,mlir::Value,mlir::Value,mlir::Value,llvm::SmallVector<mlir::Value,4u> &>((mlir::OpBuilder *)(a3 + 8), v45, (uint64_t *)&AttrDictionary, (uint64_t *)&v124, (uint64_t *)&v138, (uint64_t)&v141);
  v121 = v47;
  v48 = a3;
  if (*(_BYTE *)(v32 + 47))
  {
    AttrDictionary = (void *)mlir::Operation::getAttrDictionary((mlir::Operation *)v32);
    p_AttrDictionary = &AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (void **)(v32 + 56);
  }
  Value = (mlir::MLIRContext *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)p_AttrDictionary);
  mlir::Operation::setAttrs((uint64_t)v47, Value, v51);
  v52 = *(_QWORD *)((((unint64_t)v47
                    + 16 * (((unint64_t)*((unsigned int *)v47 + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)v47 + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v47 + 10)
                  + 8);
  if (v52)
    v53 = v52 - 8;
  else
    v53 = 0;
  v54 = *(_QWORD *)(v53 + 48);
  v55 = *(_QWORD *)(v53 + 56);
  v56 = v55 - v54;
  v138 = v140;
  v139 = 0x400000000;
  if ((unint64_t)(v55 - v54) < 0x21)
  {
    v57 = 0;
    v58 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v138, v140, v56 >> 3, 8);
    v57 = v139;
    v58 = v139;
  }
  v16 = v55 == v54;
  v59 = v48;
  if (!v16)
  {
    v60 = &v138[8 * v57];
    if ((unint64_t)(v56 - 8) >= 0x38)
    {
      v62 = &v138[8 * v57];
      v61 = (uint64_t *)v54;
      if ((unint64_t)&v62[-v54] >= 0x20)
      {
        v63 = ((unint64_t)(v56 - 8) >> 3) + 1;
        v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
        v60 += v64;
        v61 = (uint64_t *)(v54 + v64);
        v65 = (__int128 *)(v54 + 16);
        v66 = v62 + 16;
        v67 = v63 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v68 = *v65;
          *(v66 - 1) = *(v65 - 1);
          *v66 = v68;
          v65 += 2;
          v66 += 2;
          v67 -= 4;
        }
        while (v67);
        if (v63 == (v63 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_72;
      }
    }
    else
    {
      v61 = (uint64_t *)v54;
    }
    do
    {
      v69 = *v61++;
      *(_QWORD *)v60 = v69;
      v60 += 8;
    }
    while (v61 != (uint64_t *)(v54 + (v56 & 0xFFFFFFFFFFFFFFF8)));
  }
LABEL_72:
  LODWORD(v139) = v58 + ((unint64_t)v56 >> 3);
  v70 = (_QWORD *)(v48 + 24);
  v115 = *(_OWORD *)(v48 + 24);
  v71 = *(_QWORD *)(v53 + 40);
  *(_QWORD *)(v48 + 24) = v53;
  *(_QWORD *)(v48 + 32) = v71;
  v72 = mlir::OpOperand::getOperandNumber(v8);
  TiedLoopRegionIterArg = mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getTiedLoopRegionIterArg((uint64_t *)&v121, *((_QWORD *)v47 + 9) + 32 * v72);
  v73 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::BlockArgument &>(v116, *((_QWORD *)v121 + 3), (uint64_t *)&v123, &TiedLoopRegionIterArg);
  *(_QWORD *)&v138[8 * *(unsigned int *)(TiedLoopRegionIterArg + 24)] = (char *)v73 - 16;
  v74 = *(_QWORD *)(((v32
                    + 16 * (((unint64_t)*(unsigned int *)(v32 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(v32 + 44) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v32 + 40)
                  + 8);
  if (v74)
    v75 = v74 - 8;
  else
    v75 = 0;
  mlir::ValueRange::ValueRange(v137, (uint64_t)v138, v139);
  mlir::RewriterBase::mergeBlocks(v48, v75, v53, v137[0], v137[1]);
  mlir::Block::getTerminator((ZinIrHalH13g **)v53);
  v77 = v76;
  v78 = *((_QWORD *)v76 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v76);
  *v70 = v78;
  v118 = v59;
  *(_QWORD *)(v59 + 32) = v79;
  v80 = (*(_DWORD *)(TiedLoopRegionIterArg + 24) - 1);
  v81 = *((_QWORD *)v121 + 3);
  AttrDictionary = *(void **)(*((_QWORD *)v77 + 9) + 32 * v80 + 24);
  v82 = (char *)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::BlockArgument &>(v116, v81, (uint64_t *)&v122, (uint64_t *)&AttrDictionary)- 16;
  if ((*((_BYTE *)v77 + 46) & 0x80) != 0)
  {
    v83 = *((_QWORD *)v77 + 9);
    v84 = *((unsigned int *)v77 + 17);
    AttrDictionary = v135;
    v134 = 0x600000000;
    if (v84 < 7)
    {
      if (!(_DWORD)v84)
      {
        v99 = 0;
        v100 = v135;
        goto LABEL_91;
      }
      v85 = 0;
      v86 = (char *)v135;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AttrDictionary, v135, v84, 8);
      v85 = v134;
      v86 = (char *)AttrDictionary;
    }
    v87 = &v86[8 * v85];
    if (v84 >= 0xD
      && ((unint64_t)v87 >= v83 + 32 * v84 || v83 + 24 >= (unint64_t)&v86[8 * v85 + 8 * v84]))
    {
      v89 = v84 & 3;
      if ((v84 & 3) == 0)
        v89 = 4;
      v88 = v84 - v89;
      v87 += 8 * v88;
      v90 = (const double *)(v83 + 88);
      v91 = (unsigned __int128 *)&v86[8 * v85 + 16];
      v92 = v88;
      do
      {
        v93 = v90 - 8;
        v94 = (unsigned __int128)vld4q_f64(v93);
        v95 = (unsigned __int128)vld4q_f64(v90);
        *(v91 - 1) = v94;
        *v91 = v95;
        v90 += 16;
        v91 += 2;
        v92 -= 4;
      }
      while (v92);
    }
    else
    {
      v88 = 0;
    }
    v96 = v84 - v88;
    v97 = (uint64_t *)(v83 + 32 * v88 + 24);
    do
    {
      v98 = *v97;
      v97 += 4;
      *(_QWORD *)v87 = v98;
      v87 += 8;
      --v96;
    }
    while (v96);
    v99 = v134;
    v100 = AttrDictionary;
  }
  else
  {
    LODWORD(v84) = 0;
    v99 = 0;
    v100 = v135;
    AttrDictionary = v135;
    HIDWORD(v134) = 6;
  }
LABEL_91:
  v101 = v118;
  LODWORD(v134) = v99 + v84;
  v100[v80] = v82;
  mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(v116, *((_QWORD *)v121 + 3), (uint64_t)&AttrDictionary);
  (*(void (**)(uint64_t, ZinIrHalH13g *))(*(_QWORD *)v101 + 40))(v101, v77);
  v102 = *((_QWORD *)v121 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v121);
  v104 = *(_QWORD *)(v103 + 8);
  *(_QWORD *)(v118 + 24) = v102;
  *(_QWORD *)(v118 + 32) = v104;
  v105 = v121;
  v106 = *((unsigned int *)v121 + 9);
  if ((_DWORD)v106)
    v107 = (char *)v121 - 16;
  else
    v107 = 0;
  v124 = v126;
  v125 = 0x600000000;
  if (v106 < 7)
  {
    if (!(_DWORD)v106)
    {
      v112 = 0;
      v113 = v126;
      goto LABEL_101;
    }
    v108 = 0;
    v109 = v126;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v124, v126, v106, 8);
    v108 = v125;
    v109 = v124;
  }
  v110 = 0;
  v111 = &v109[8 * v108];
  do
  {
    *(_QWORD *)&v111[8 * v110] = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v107, v110);
    ++v110;
  }
  while (v106 != v110);
  v112 = v125;
  v105 = v121;
  v113 = v124;
  v101 = v118;
LABEL_101:
  LODWORD(v125) = v112 + v106;
  v114 = mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::BlockArgument &>(v116, *((_QWORD *)v105 + 3), (uint64_t *)&v123, (uint64_t *)&v113[8 * v80]);
  *((_QWORD *)v124 + v80) = (char *)v114 - 16;
  if (AttrDictionary != v135)
    free(AttrDictionary);
  if ((_QWORD)v115)
  {
    *(_OWORD *)v70 = v115;
  }
  else
  {
    *v70 = 0;
    v70[1] = 0;
  }
  if (v138 != v140)
    free(v138);
  if ((_QWORD **)v141 != &v142)
    free((void *)v141);
  mlir::ValueRange::ValueRange(v127, (uint64_t)v124, v125);
  (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)v101 + 24))(v101, a2, v127[0], v127[1]);
  if (v124 != v126)
    free(v124);
  v42 = 1;
  v43 = v129[0];
  if (v129[0] != v130)
    goto LABEL_51;
  return v42;
}

uint64_t mlir::detail::LoopLikeOpInterfaceTrait<mlir::scf::ForOp>::getTiedLoopRegionIterArg(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17[4];
  void *v18;
  _QWORD v19[4];

  v19[3] = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  if ((*(_BYTE *)(*a1 + 46) & 0x80) != 0)
    v5 = *(_DWORD *)(v4 + 68) - 3;
  else
    v5 = -3;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v17, v4, 3, v5, 0, 0);
  v6 = mlir::MutableOperandRange::operator mlir::OperandRange(v17);
  v8 = v7;
  if (v18 != v19)
    free(v18);
  v9 = -32;
  v10 = 32 * v8;
  do
  {
    v9 += 32;
    if (!v10)
      break;
    v10 -= 32;
    v11 = v6 == a2;
    v6 += 32;
  }
  while (!v11);
  v12 = v9 >> 5;
  if (v12 == v8)
    return 0;
  v14 = 32 * v12;
  v15 = *(_QWORD *)(((*a1
                    + 16 * (((unint64_t)*(unsigned int *)(*a1 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(*a1 + 44) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(*a1 + 40)
                  + 8);
  if (v15)
    v16 = v15 - 8;
  else
    v16 = 0;
  return *(_QWORD *)(*(_QWORD *)(v16 + 48) + (v14 >> 2) + 8);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::BlockArgument &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.cast", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"tensor.cast";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::DeviceMappingAttrInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DeviceMappingAttrInterface]";
      v23 = 82;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::DeviceMappingAttrInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[158];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

uint64_t mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::ValueRange,llvm::PointerUnion<mlir::Value const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Value,mlir::Value,mlir::Value>::iterator>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  llvm::raw_ostream *v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v11 = (llvm::raw_ostream *)result;
  v18 = a2;
  v19 = a3;
  if (a2 != a4 || a3 != a5)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v18, a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 160))(a1, v12);
    v13 = ++v19;
    if (v18 != a4 || v13 != a5)
    {
      do
      {
        v15 = (_WORD *)*((_QWORD *)v11 + 4);
        if (*((_QWORD *)v11 + 3) - (_QWORD)v15 > 1uLL)
        {
          *v15 = 8236;
          *((_QWORD *)v11 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v11, ", ", 2uLL);
        }
        v16 = mlir::ValueRange::dereference_iterator(&v18, v19);
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 160))(a1, v16);
        v17 = ++v19;
      }
      while (v18 != a4 || v17 != a5);
    }
  }
  return result;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::InParallelOp>::Impl<mlir::scf::ForallOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  uint64_t v4;
  const mlir::OperationState *v5;
  uint64_t v6;
  __int128 v8;
  _QWORD v9[38];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v9, a2, (uint64_t)"scf.forall.in_parallel", 22);
  v3 = (_OWORD *)(a1 + 16);
  v8 = *(_OWORD *)(a1 + 16);
  v4 = mlir::OperationState::addRegion((mlir::OperationState *)v9);
  mlir::ValueRange::ValueRange(v10, 0, 0);
  mlir::OpBuilder::createBlock((_QWORD *)a1, v4, 0, v10[0], v10[1], 0, 0);
  if ((_QWORD)v8)
  {
    *v3 = v8;
  }
  else
  {
    *(_QWORD *)v3 = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
  v6 = mlir::Operation::create((mlir::Operation *)v9, v5);
  mlir::OperationState::~OperationState((mlir::OperationState *)v9);
  return v6;
}

void `anonymous namespace'::DimOfForallOp::~DimOfForallOp(_anonymous_namespace_::DimOfForallOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::DimOfForallOp::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *SourceMutable;
  uint64_t *v15;
  uint64_t v16;
  uint64_t Input;
  uint64_t v18;

  v18 = a2;
  Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v18);
  result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (result)
  {
    v5 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id)
    {
      v6 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v18);
      if (HIBYTE(*(_DWORD *)(v5 + 44)))
        v7 = (_DWORD *)(v5 + 16 * (((unint64_t)*(unsigned int *)(v5 + 44) >> 23) & 1) + 64);
      else
        v7 = 0;
      v8 = v7[8];
      v9 = v7[9];
      v10 = v7[10];
      if (v6 && (*(_QWORD *)(v6 + 8) & 7) == 6)
        v11 = *(_DWORD *)(v6 + 16) + 6;
      else
        v11 = *(_QWORD *)(v6 + 8) & 7;
      v12 = *(uint64_t **)(*(_QWORD *)(v5 + 72) + 32 * (v9 + v8 + v10 + v11) + 24);
      v13 = v18;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, v18);
      SourceMutable = (uint64_t *)mlir::tensor::DimOp::getSourceMutable((mlir::tensor::DimOp *)&v18);
      v15 = (uint64_t *)SourceMutable[1];
      if (v15)
      {
        *v15 = *SourceMutable;
        if (*SourceMutable)
          *(_QWORD *)(*SourceMutable + 8) = SourceMutable[1];
      }
      SourceMutable[3] = (uint64_t)v12;
      SourceMutable[1] = (uint64_t)v12;
      v16 = *v12;
      *SourceMutable = *v12;
      if (v16)
        *(_QWORD *)(v16 + 8) = SourceMutable;
      *v12 = (uint64_t)SourceMutable;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 80))(a3, v13);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void `anonymous namespace'::FoldTensorCastOfOutputIntoForallOp::~FoldTensorCastOfOutputIntoForallOp(_anonymous_namespace_::FoldTensorCastOfOutputIntoForallOp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ForallOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ForallOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ForallOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::FoldTensorCastOfOutputIntoForallOp::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  _DWORD *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  mlir::Value *v14;
  char *v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  unint64_t v19;
  const double *v20;
  unsigned __int128 *v21;
  uint64_t v22;
  const double *v23;
  unsigned __int128 v24;
  unsigned __int128 v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  mlir::Value *v29;
  unsigned int v30;
  uint64_t v31;
  mlir::Value *v32;
  int v33;
  _DWORD *v34;
  int v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  unsigned int v39;
  char *v40;
  uint64_t v41;
  uint64_t DefiningOp;
  void *v43;
  BOOL v44;
  void *v45;
  unint64_t v46;
  uint64_t Input;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  _DWORD *inserted;
  char *v52;
  void **v53;
  char *v54;
  __int128 v55;
  _DWORD *v56;
  int v57;
  BOOL v58;
  int v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *Context;
  uint64_t v64;
  char v65;
  uint64_t *v66;
  unint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  ZinIrHalH13g *v72;
  void *v73;
  ZinIrHalH13g *v74;
  uint64_t v75;
  ZinIrHalH13g **v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  ZinIrHalH13g *v80;
  ZinIrHalH13g *v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t v97;
  mlir::Value *v98;
  uint64_t **v99;
  uint64_t v100;
  BOOL v101;
  void *v102;
  uint64_t *DestMutable;
  uint64_t *v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  unsigned int v109;
  unsigned int v110;
  char *v111;
  char *v112;
  uint64_t *v113;
  unsigned int v114;
  uint64_t *v115;
  uint64_t v116;
  int64_t v118;
  _QWORD v120[3];
  uint64_t v121;
  uint64_t v122;
  const char *v123;
  __int16 v124;
  unint64_t v125[2];
  void *v126;
  unsigned int v127;
  uint64_t v128;
  void *v129;
  unsigned int v130;
  uint64_t v131;
  void *v132;
  unsigned int v133;
  uint64_t v134;
  mlir::Value *v135;
  uint64_t v136;
  _BYTE v137[48];
  uint64_t v138;
  llvm *v139;
  unsigned int v140;
  void *v141;
  uint64_t v142;
  _BYTE v143[48];
  void *v144;
  uint64_t v145;
  _QWORD v146[36];
  uint64_t v147[4];
  __int16 v148;
  uint64_t v149;

  v149 = *MEMORY[0x24BDAC8D0];
  v121 = a2;
  v138 = 1;
  LODWORD(v139) = -1;
  v140 = -1;
  v141 = v143;
  v142 = 0x200000000;
  v3 = *(unsigned int *)(a2 + 44);
  v4 = (_DWORD *)(a2 + 16 * ((v3 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = 0;
  v5 = v4[8];
  v6 = v4[9];
  v8 = v4[10];
  v7 = v4[11];
  if ((v3 & 0x800000) != 0)
    v9 = *(_QWORD *)(a2 + 72);
  else
    v9 = 0;
  v10 = (v6 + v5 + v8);
  v11 = (v7 + v10);
  v12 = v11 - v10;
  v135 = (mlir::Value *)v137;
  v136 = 0x600000000;
  if ((unint64_t)(v11 - v10) >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v137, v11 - v10, 8);
    v13 = v136;
    v14 = v135;
    v15 = (char *)v135 + 8 * v136;
    if (v12 < 0x13)
      goto LABEL_20;
LABEL_10:
    v16 = v9 + 32 * v10;
    v17 = (unint64_t)v15 >= v9 + 32 * v11 || v16 + 24 >= (unint64_t)v14 + 8 * (v13 + v11 - v10);
    if (v17)
    {
      v18 = 4;
      if ((v12 & 3) != 0)
        v18 = v12 & 3;
      v19 = v12 - v18;
      v15 += 8 * (v12 - v18);
      v20 = (const double *)(v16 + 88);
      v21 = (unsigned __int128 *)((char *)v14 + 8 * v13 + 16);
      v22 = v18 + v10 - v11;
      do
      {
        v23 = v20 - 8;
        v24 = (unsigned __int128)vld4q_f64(v23);
        v25 = (unsigned __int128)vld4q_f64(v20);
        *(v21 - 1) = v24;
        *v21 = v25;
        v20 += 16;
        v21 += 2;
        v22 += 4;
      }
      while (v22);
LABEL_21:
      v26 = v19 + v10 - v11;
      v27 = (uint64_t *)(32 * v19 + 32 * v10 + v9 + 24);
      do
      {
        v28 = *v27;
        v27 += 4;
        *(_QWORD *)v15 = v28;
        v15 += 8;
        v17 = __CFADD__(v26++, 1);
      }
      while (!v17);
      v29 = v135;
      v30 = v136 + v12;
      LODWORD(v136) = v136 + v12;
      if ((_DWORD)v136)
        goto LABEL_25;
      goto LABEL_62;
    }
LABEL_20:
    v19 = 0;
    goto LABEL_21;
  }
  if (v7)
  {
    v13 = 0;
    v14 = (mlir::Value *)v137;
    v15 = v137;
    if (v12 < 0x13)
      goto LABEL_20;
    goto LABEL_10;
  }
  v29 = (mlir::Value *)v137;
  v30 = v12;
  LODWORD(v136) = v12;
  if ((_DWORD)v12)
  {
LABEL_25:
    v31 = 0;
    v32 = (mlir::Value *)((char *)v29 + 8 * v30);
    do
    {
      DefiningOp = mlir::Value::getDefiningOp(v29);
      if (!DefiningOp)
        goto LABEL_30;
      v43 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
      v44 = v43 == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id;
      v45 = v43 == &mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id ? (void *)DefiningOp : 0;
      v129 = v45;
      if (!v44)
        goto LABEL_30;
      v46 = *(_QWORD *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v129) + 8) & 0xFFFFFFFFFFFFFFF8;
      Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v129);
      if (!mlir::tensor::preservesStaticInformation(v46, *(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_30;
      v48 = *(_QWORD *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v129) + 8);
      v49 = *((_QWORD *)v129 - 1);
      v132 = (void *)v31;
      if ((v138 & 1) != 0)
      {
        v33 = 2;
        v34 = &v139;
      }
      else
      {
        v33 = v140;
        if (!v140)
        {
          v50 = 0;
LABEL_42:
          inserted = llvm::DenseMapBase<llvm::SmallDenseMap<unsigned int,unsigned int,2u,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>,unsigned int,unsigned int,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>::InsertIntoBucket<unsigned int const&,unsigned int const&>((uint64_t)&v138, v50, &v132, (_DWORD *)&v132 + 1);
          v145 = 0;
          v146[0] = 0;
          LODWORD(v144) = v31;
          v52 = (char *)v141;
          if (v142 >= HIDWORD(v142))
          {
            v60 = v142 + 1;
            if (v141 <= &v144 && (char *)v141 + 24 * v142 > (char *)&v144)
            {
              v118 = (char *)&v144 - (_BYTE *)v141;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v143, v60, 24);
              v52 = (char *)v141;
              v53 = (void **)((char *)v141 + v118);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v143, v60, 24);
              v53 = &v144;
              v52 = (char *)v141;
            }
          }
          else
          {
            v53 = &v144;
          }
          v54 = &v52[24 * v142];
          v55 = *(_OWORD *)v53;
          *((_QWORD *)v54 + 2) = v53[2];
          *(_OWORD *)v54 = v55;
          v39 = v142;
          LODWORD(v142) = v142 + 1;
          inserted[1] = v39;
          goto LABEL_29;
        }
        v34 = v139;
      }
      v35 = v33 - 1;
      v36 = (v33 - 1) & (37 * v31);
      v37 = &v34[2 * v36];
      v38 = *v37;
      if (*v37 != (_DWORD)v31)
      {
        v56 = 0;
        v57 = 1;
        while (v38 != -1)
        {
          if (v56)
            v58 = 0;
          else
            v58 = v38 == -2;
          if (v58)
            v56 = v37;
          v59 = v36 + v57++;
          v36 = v59 & v35;
          v37 = &v34[2 * v36];
          v38 = *v37;
          if (*v37 == (_DWORD)v31)
            goto LABEL_28;
        }
        if (v56)
          v50 = v56;
        else
          v50 = v37;
        goto LABEL_42;
      }
LABEL_28:
      v39 = v34[2 * v36 + 1];
LABEL_29:
      v40 = (char *)v141 + 24 * v39;
      *((_QWORD *)v40 + 1) = v48 & 0xFFFFFFFFFFFFFFF8;
      *((_QWORD *)v40 + 2) = v49 & 0xFFFFFFFFFFFFFFF8;
      v41 = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v129);
      *((_QWORD *)v135 + v31) = v41;
LABEL_30:
      ++v31;
      v29 = (mlir::Value *)((char *)v29 + 8);
    }
    while (v29 != v32);
  }
LABEL_62:
  if ((_DWORD)v142)
  {
    v61 = *(_QWORD *)(v121 + 24);
    mlir::scf::ForallOp::getMixedLowerBound((mlir::scf::ForallOp *)&v121, (uint64_t)&v132);
    mlir::scf::ForallOp::getMixedUpperBound((mlir::scf::ForallOp *)&v121, (uint64_t)&v129);
    mlir::scf::ForallOp::getMixedStep((mlir::scf::ForallOp *)&v121, (uint64_t)&v126);
    v62 = *(_QWORD *)(v121 + 16 * (((unint64_t)*(unsigned int *)(v121 + 44) >> 23) & 1) + 64);
    v120[0] = &v121;
    v120[1] = &v138;
    v120[2] = a3;
    v122 = v61;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v122);
    v64 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.forall", (const unsigned __int8 *)0xA, Context);
    if (!v65)
    {
      v148 = 1283;
      v147[2] = (uint64_t)"scf.forall";
      v147[3] = 10;
             " by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-w"
             "ith-dialects-management";
      v124 = 259;
      llvm::operator+(v147, (uint64_t *)&v123, (uint64_t)&v144);
      llvm::report_fatal_error((llvm::Twine *)&v144, 1);
    }
    mlir::OperationState::OperationState(&v144, v61, v64);
    v66 = (uint64_t *)v132;
    v67 = v133;
    v68 = (uint64_t *)v129;
    v69 = v130;
    v70 = (uint64_t *)v126;
    v71 = v127;
    mlir::ValueRange::ValueRange((unint64_t *)v147, (uint64_t)v135, v136);
    v72 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 1), (const mlir::OperationState *)&v144);
    v73 = *(void **)(*((_QWORD *)v72 + 6) + 16);
    mlir::OperationState::~OperationState((mlir::OperationState *)&v144);
    if (v73 == &mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id)
      v74 = v72;
    else
      v74 = 0;
    if (v126 != &v128)
      free(v126);
    if (v129 != &v131)
      free(v129);
    if (v132 != &v134)
      free(v132);
    v75 = *(_QWORD *)((((unint64_t)v74
                      + 16 * (((unint64_t)*((unsigned int *)v74 + 11) >> 23) & 1)
                      + (((unint64_t)*((unsigned int *)v74 + 11) >> 21) & 0x7F8)
                      + 71) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *((unsigned int *)v74 + 10)
                    + 8);
    if (v75)
      v76 = (ZinIrHalH13g **)(v75 - 8);
    else
      v76 = 0;
    mlir::Block::getTerminator(v76);
    v78 = *(_QWORD *)(((v77
                      + 16 * (((unint64_t)*(unsigned int *)(v77 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(v77 + 44) >> 21) & 0x7F8)
                      + 71) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(v77 + 40)
                    + 8);
    if (v78)
      v79 = v78 - 8;
    else
      v79 = 0;
    v80 = (ZinIrHalH13g *)(v79 + 32);
    v81 = *(ZinIrHalH13g **)(v79 + 40);
    v82 = *((unsigned int *)v74 + 11);
    v83 = *(_QWORD *)((((unint64_t)v74 + 16 * ((v82 >> 23) & 1) + ((v82 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *((unsigned int *)v74 + 10)
                    + 8);
    if (v83)
      v84 = v83 - 8;
    else
      v84 = 0;
    v85 = *(_QWORD *)(v84 + 48);
    v86 = (*(_QWORD *)(v84 + 56) - v85) >> 3;
    if (HIBYTE(*((_DWORD *)v74 + 11)))
      v87 = (uint64_t)v74 + 16 * ((v82 >> 23) & 1) + 64;
    else
      v87 = 0;
    v144 = *(void **)(v87 + 8);
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)&v144);
    if (v81 != v80 && v88 != v86)
    {
      v99 = (uint64_t **)(v85 + 8 * v88);
      v100 = 8 * v86 - 8 * v88 - 8;
      do
      {
        ZinIrHalH13g::~ZinIrHalH13g(v81);
        v144 = v102;
        DestMutable = (uint64_t *)mlir::tensor::InsertSliceOp::getDestMutable((mlir::tensor::InsertSliceOp *)&v144);
        v104 = *v99;
        v105 = (uint64_t *)DestMutable[1];
        if (v105)
        {
          *v105 = *DestMutable;
          if (*DestMutable)
            *(_QWORD *)(*DestMutable + 8) = DestMutable[1];
        }
        DestMutable[3] = (uint64_t)v104;
        DestMutable[1] = (uint64_t)v104;
        v106 = *v104;
        *DestMutable = *v104;
        if (v106)
          *(_QWORD *)(v106 + 8) = DestMutable;
        *v104 = (uint64_t)DestMutable;
        v81 = (ZinIrHalH13g *)*((_QWORD *)v81 + 1);
        ++v99;
        v101 = v81 == v80 || v100 == 0;
        v100 -= 8;
      }
      while (!v101);
    }
    v90 = *((_QWORD *)v74 + 2);
    ZinIrHalH13g::~ZinIrHalH13g(v74);
    v92 = *(_QWORD *)(v91 + 8);
    a3[3] = v90;
    a3[4] = v92;
    v93 = *((unsigned int *)v74 + 9);
    if ((_DWORD)v93)
      v94 = (uint64_t)v74 - 16;
    else
      v94 = 0;
    v144 = v146;
    v145 = 0x600000000;
    if (v93 < 7)
    {
      if (!(_DWORD)v93)
      {
        v109 = 0;
        LODWORD(v145) = 0;
        v110 = v142;
        if (!(_DWORD)v142)
          goto LABEL_114;
        goto LABEL_111;
      }
      v95 = 0;
      v96 = v146;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v144, v146, v93, 8);
      v95 = v145;
      v96 = v144;
    }
    v107 = 0;
    v108 = &v96[v95];
    do
    {
      v108[v107] = mlir::detail::OpResultImpl::getNextResultAtOffset(v94, v107);
      ++v107;
    }
    while (v93 != v107);
    v109 = v145 + v93;
    LODWORD(v145) = v145 + v93;
    v110 = v142;
    if (!(_DWORD)v142)
    {
LABEL_114:
      v116 = v121;
      mlir::ValueRange::ValueRange(v125, (uint64_t)v144, v109);
      (*(void (**)(_QWORD *, uint64_t, unint64_t, unint64_t))(*a3 + 24))(a3, v116, v125[0], v125[1]);
      if (v144 != v146)
        free(v144);
      v97 = 1;
      v98 = v135;
      if (v135 != (mlir::Value *)v137)
        goto LABEL_117;
      goto LABEL_118;
    }
LABEL_111:
    v111 = (char *)v141;
    v112 = (char *)v141 + 24 * v110;
    do
    {
      v113 = (uint64_t *)(v111 + 16);
      v114 = *(_DWORD *)v111;
      v111 += 24;
      v115 = (uint64_t *)((char *)v144 + 8 * v114);
      *v115 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::BlockArgument &>((mlir::OpBuilder *)(a3 + 1), v61, v113, v115)- 16;
    }
    while (v111 != v112);
    v109 = v145;
    goto LABEL_114;
  }
  v97 = 0;
  v98 = v135;
  if (v135 != (mlir::Value *)v137)
LABEL_117:
    free(v98);
LABEL_118:
  if (v141 != v143)
    free(v141);
  if ((v138 & 1) == 0)
    llvm::deallocate_buffer(v139, (void *)(8 * v140));
  return v97;
}

_DWORD *llvm::DenseMapBase<llvm::SmallDenseMap<unsigned int,unsigned int,2u,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>,unsigned int,unsigned int,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>::InsertIntoBucket<unsigned int const&,unsigned int const&>(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  _DWORD *v18;
  int v19;
  BOOL v20;
  unsigned int v21;

  v8 = *(_DWORD *)a1;
  v9 = *(_DWORD *)a1 >> 1;
  if ((*(_DWORD *)a1 & 1) != 0)
    v10 = 2;
  else
    v10 = *(_DWORD *)(a1 + 16);
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
  }
  else if (v10 + ~v9 - *(_DWORD *)(a1 + 4) > v10 >> 3)
  {
    v11 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<unsigned int,unsigned int,2u,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>::grow(a1, v10);
  v13 = a1 + 8;
  v8 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) != 0)
  {
    v14 = 2;
  }
  else
  {
    v14 = *(_DWORD *)(a1 + 16);
    if (!v14)
    {
      v11 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    v13 = *(_QWORD *)(a1 + 8);
  }
  v11 = *(_DWORD *)a1 & 1;
  v15 = v14 - 1;
  v16 = (37 * *a3) & (v14 - 1);
  a2 = (_DWORD *)(v13 + 8 * v16);
  v17 = *a2;
  if (*a3 != *a2)
  {
    v18 = 0;
    v19 = 1;
    while (v17 != -1)
    {
      if (v18)
        v20 = 0;
      else
        v20 = v17 == -2;
      if (v20)
        v18 = a2;
      v21 = v16 + v19++;
      v16 = v21 & v15;
      a2 = (_DWORD *)(v13 + 8 * (v21 & v15));
      v17 = *a2;
      if (*a3 == *a2)
        goto LABEL_7;
    }
    if (v18)
      a2 = v18;
  }
LABEL_7:
  *(_DWORD *)a1 = (v8 & 0xFFFFFFFE | v11) + 2;
  if (*a2 != -1)
    --*(_DWORD *)(a1 + 4);
  *a2 = *a3;
  a2[1] = *a4;
  return a2;
}

uint64_t llvm::SmallDenseMap<unsigned int,unsigned int,2u,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,unsigned int>>::grow(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  int v7;
  llvm *v8;
  uint64_t v9;
  llvm *v10;
  _QWORD *v11;
  unsigned int *v12;
  unsigned int v13;
  _DWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  uint64_t v20;
  _DWORD *buffer;
  int v22;
  _DWORD *v23;
  unint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  _DWORD *v27;
  uint64_t v28;
  llvm *v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  _DWORD *v34;
  int v35;
  int v36;
  _DWORD *v37;
  int v38;
  BOOL v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  int v43;
  unsigned int *v44;
  uint64_t v45;
  int v46;
  int v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int *v52;
  BOOL v53;
  int v54;
  _DWORD v55[2];
  _QWORD v56[2];

  v2 = a2;
  v3 = result;
  v56[1] = *MEMORY[0x24BDAC8D0];
  if (a2 >= 3)
  {
    v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40)
      v2 = v6 + 1;
    else
      v2 = 64;
  }
  v7 = *(_DWORD *)result;
  if ((*(_DWORD *)result & 1) == 0)
  {
    v8 = *(llvm **)(result + 8);
    v9 = *(unsigned int *)(result + 16);
    if (v2 > 2)
    {
      buffer = llvm::allocate_buffer(8 * v2, (std::align_val_t)4uLL);
      *(_QWORD *)(v3 + 8) = buffer;
      *(_QWORD *)(v3 + 16) = v2;
      v22 = *(_DWORD *)v3;
      v10 = (llvm *)((char *)v8 + 8 * v9);
      *(_QWORD *)v3 = *(_DWORD *)v3 & 1;
      if ((v22 & 1) == 0)
      {
        v23 = &buffer[2 * v2];
        v24 = 8 * v2 - 8;
        if (v24 < 8)
        {
          v26 = buffer;
          goto LABEL_26;
        }
LABEL_20:
        v25 = (v24 >> 3) + 1;
        v26 = &buffer[2 * (v25 & 0x3FFFFFFFFFFFFFFELL)];
        v27 = buffer + 2;
        v28 = v25 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          *(v27 - 2) = -1;
          *v27 = -1;
          v27 += 4;
          v28 -= 2;
        }
        while (v28);
        if (v25 == (v25 & 0x3FFFFFFFFFFFFFFELL))
        {
LABEL_27:
          if ((_DWORD)v9)
          {
            v29 = v8;
            do
            {
              v36 = *(_DWORD *)v29;
              if (*(_DWORD *)v29 <= 0xFFFFFFFD)
              {
                if ((*(_BYTE *)v3 & 1) != 0)
                {
                  v31 = 2;
                  v30 = v3 + 8;
                }
                else
                {
                  v30 = *(_QWORD *)(v3 + 8);
                  v31 = *(_DWORD *)(v3 + 16);
                }
                v32 = v31 - 1;
                v33 = (v31 - 1) & (37 * v36);
                v34 = (_DWORD *)(v30 + 8 * v33);
                v35 = *v34;
                if (v36 != *v34)
                {
                  v37 = 0;
                  v38 = 1;
                  while (v35 != -1)
                  {
                    if (v37)
                      v39 = 0;
                    else
                      v39 = v35 == -2;
                    if (v39)
                      v37 = v34;
                    v40 = v33 + v38++;
                    v33 = v40 & v32;
                    v34 = (_DWORD *)(v30 + 8 * (v40 & v32));
                    v35 = *v34;
                    if (v36 == *v34)
                      goto LABEL_31;
                  }
                  if (v37)
                    v34 = v37;
                }
LABEL_31:
                *v34 = v36;
                v34[1] = *((_DWORD *)v29 + 1);
                *(_DWORD *)v3 += 2;
              }
              v29 = (llvm *)((char *)v29 + 8);
            }
            while (v29 != v10);
          }
          llvm::deallocate_buffer(v8, (void *)(8 * v9));
        }
        do
        {
LABEL_26:
          *v26 = -1;
          v26 += 2;
        }
        while (v26 != v23);
        goto LABEL_27;
      }
    }
    else
    {
      v10 = (llvm *)((char *)v8 + 8 * v9);
      *(_QWORD *)result = 1;
    }
    v23 = (_DWORD *)(v3 + 24);
    buffer = (_DWORD *)(v3 + 8);
    v24 = 8;
    goto LABEL_20;
  }
  v11 = (_QWORD *)(result + 8);
  v12 = v55;
  if (*(_DWORD *)(result + 8) <= 0xFFFFFFFD)
  {
    v41 = *(_DWORD *)(result + 12);
    v55[0] = *(_DWORD *)(result + 8);
    v55[1] = v41;
    v12 = (unsigned int *)v56;
    v13 = *(_DWORD *)(result + 16);
    if (v13 > 0xFFFFFFFD)
    {
LABEL_10:
      if (v2 < 3)
        goto LABEL_11;
      goto LABEL_51;
    }
  }
  else
  {
    v13 = *(_DWORD *)(result + 16);
    if (v13 > 0xFFFFFFFD)
      goto LABEL_10;
  }
  v42 = *(_DWORD *)(result + 20);
  *v12 = v13;
  v12[1] = v42;
  v12 += 2;
  if (v2 < 3)
  {
LABEL_11:
    *(_QWORD *)result = v7 & 1;
    if ((v7 & 1) == 0)
      goto LABEL_12;
LABEL_52:
    v15 = v3 + 24;
    v14 = (_DWORD *)(v3 + 8);
    v16 = 8;
    goto LABEL_14;
  }
LABEL_51:
  *(_DWORD *)result = v7 & 0xFFFFFFFE;
  result = (uint64_t)llvm::allocate_buffer(8 * v2, (std::align_val_t)4uLL);
  *(_QWORD *)(v3 + 8) = result;
  *(_QWORD *)(v3 + 16) = v2;
  v43 = *(_DWORD *)v3;
  v13 = v2;
  *(_QWORD *)v3 = *(_DWORD *)v3 & 1;
  if ((v43 & 1) != 0)
    goto LABEL_52;
LABEL_12:
  if (!v13)
    goto LABEL_55;
  v14 = (_DWORD *)*v11;
  v15 = *v11 + 8 * v13;
  v16 = 8 * v13 - 8;
  if (v16 < 8)
  {
    v18 = (_DWORD *)*v11;
    do
    {
LABEL_54:
      *v18 = -1;
      v18 += 2;
    }
    while (v18 != (_DWORD *)v15);
    goto LABEL_55;
  }
LABEL_14:
  v17 = (v16 >> 3) + 1;
  v18 = &v14[2 * (v17 & 0x3FFFFFFFFFFFFFFELL)];
  v19 = v14 + 2;
  v20 = v17 & 0x3FFFFFFFFFFFFFFELL;
  do
  {
    *(v19 - 2) = -1;
    *v19 = -1;
    v19 += 4;
    v20 -= 2;
  }
  while (v20);
  if (v17 != (v17 & 0x3FFFFFFFFFFFFFFELL))
    goto LABEL_54;
LABEL_55:
  if (v55 != v12)
  {
    v44 = v55;
    do
    {
      v51 = *v44;
      if (*v44 <= 0xFFFFFFFD)
      {
        if ((*(_BYTE *)v3 & 1) != 0)
        {
          v46 = 2;
          v45 = v3 + 8;
        }
        else
        {
          v45 = *(_QWORD *)(v3 + 8);
          v46 = *(_DWORD *)(v3 + 16);
        }
        v47 = v46 - 1;
        v48 = (v46 - 1) & (37 * v51);
        v49 = (unsigned int *)(v45 + 8 * v48);
        v50 = *v49;
        if (v51 != *v49)
        {
          v52 = 0;
          result = 1;
          while (v50 != -1)
          {
            if (v52)
              v53 = 0;
            else
              v53 = v50 == -2;
            if (v53)
              v52 = v49;
            v54 = v48 + result;
            result = (result + 1);
            v48 = v54 & v47;
            v49 = (unsigned int *)(v45 + 8 * (v54 & v47));
            v50 = *v49;
            if (v51 == *v49)
              goto LABEL_59;
          }
          if (v52)
            v49 = v52;
        }
LABEL_59:
        *v49 = v51;
        v49[1] = v44[1];
        *(_DWORD *)v3 += 2;
      }
      v44 += 2;
    }
    while (v44 != v12);
  }
  return result;
}

void llvm::function_ref<void ()(mlir::OpBuilder &,mlir::Location,mlir::ValueRange)>::callback_fn<`anonymous namespace'::FoldTensorCastOfOutputIntoForallOp::matchAndRewrite(mlir::scf::ForallOp,mlir::PatternRewriter &)::{lambda(mlir::OpBuilder,mlir::Location,mlir::ValueRange)#1}>(uint64_t **a1, _OWORD *a2, uint64_t a3, void *a4, unint64_t a5)
{
  __int128 v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  _BYTE *v11;
  void *v12;
  uint64_t *v13;
  uint64_t *v15;
  uint64_t v16;
  __int128 *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  int v33;
  unint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t ParentBlock;
  _OWORD v44[2];
  uint64_t v45;
  void *v46[2];
  uint64_t v47[7];
  void *__src;
  uint64_t v49;
  _BYTE v50[48];
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v7 = a2[1];
  v44[0] = *a2;
  v44[1] = v7;
  v51 = (uint64_t)a4;
  v52 = a5;
  v8 = *(unsigned int *)(**a1 + 36);
  if (a5 <= v8)
  {
    v9 = a4;
    v8 = a5;
  }
  else
  {
    v9 = (void *)mlir::ValueRange::offset_base(&v51, a5 - v8);
  }
  __src = v50;
  v49 = 0x600000000;
  if (v8 < 7)
  {
    v10 = 0;
    v46[0] = v9;
    v46[1] = 0;
    v11 = v50;
    if (!v8)
    {
      LODWORD(v49) = 0;
      v15 = a1[1];
      v16 = *((unsigned int *)v15 + 8);
      if (!(_DWORD)v16)
        goto LABEL_16;
      goto LABEL_14;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v50, v8, 8);
    v10 = v49;
    v11 = __src;
    v46[0] = v9;
    v46[1] = 0;
  }
  v12 = 0;
  v13 = (uint64_t *)&v11[8 * v10];
  do
  {
    *v13++ = mlir::ValueRange::dereference_iterator(v46, (uint64_t)v12);
    v12 = ++v46[1];
  }
  while (v46[0] != v9 || v12 != (void *)v8);
  LODWORD(v49) = v49 + v8;
  v15 = a1[1];
  v16 = *((unsigned int *)v15 + 8);
  if ((_DWORD)v16)
  {
LABEL_14:
    v17 = (__int128 *)v15[3];
    v18 = 24 * v16;
    do
    {
      v19 = *((_QWORD *)v17 + 2);
      v20 = *v17;
      v17 = (__int128 *)((char *)v17 + 24);
      *(_OWORD *)v46 = v20;
      v47[0] = v19;
      v21 = (uint64_t *)((char *)__src + 8 * v20);
      *v21 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::CastOp,mlir::Type &,mlir::BlockArgument &>((mlir::OpBuilder *)v44, a3, v47, v21)- 16;
      v18 -= 24;
    }
    while (v18);
  }
LABEL_16:
  v22 = **a1;
  v23 = *(unsigned int *)(v22 + 44);
  v24 = v22 + 16 * ((v23 >> 23) & 1) + 64;
  if (!BYTE3(v23))
    v24 = 0;
  v46[0] = *(void **)(v24 + 8);
  mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)v46);
  v26 = v51;
  if (v52 >= v25)
    v27 = v25;
  else
    v27 = v52;
  v46[0] = v47;
  v46[1] = (void *)0x600000000;
  if (v27 < 7)
  {
    v28 = 0;
    v53 = v51;
    v54 = 0;
    v29 = v47;
    if (!v27)
    {
      v33 = 0;
      v34 = 6;
      goto LABEL_31;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, v47, v27, 8);
    v28 = LODWORD(v46[1]);
    v29 = (uint64_t *)v46[0];
    v53 = v26;
    v54 = 0;
  }
  v30 = 0;
  v31 = &v29[v28];
  do
  {
    *v31++ = mlir::ValueRange::dereference_iterator(&v53, v30);
    v30 = ++v54;
  }
  while (v53 != v26 || v30 != v27);
  v33 = (int)v46[1];
  v34 = HIDWORD(v46[1]);
LABEL_31:
  v35 = (v33 + v27);
  LODWORD(v46[1]) = v35;
  v36 = __src;
  v37 = v49;
  v38 = v49 + v35;
  if (v38 > v34)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, v47, v38, 8);
    LODWORD(v35) = v46[1];
  }
  if ((_DWORD)v37)
  {
    memcpy((char *)v46[0] + 8 * v35, v36, 8 * v37);
    LODWORD(v35) = v46[1];
  }
  LODWORD(v46[1]) = v35 + v37;
  v39 = **a1;
  v40 = (uint64_t)a1[2];
  v41 = *(_QWORD *)(((v39
                    + 16 * (((unint64_t)*(unsigned int *)(v39 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(v39 + 44) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v39 + 40)
                  + 8);
  if (v41)
    v42 = v41 - 8;
  else
    v42 = 0;
  v45 = mlir::ValueRange::dereference_iterator(&v51, 0);
  ParentBlock = mlir::Value::getParentBlock((mlir::Value *)&v45);
  mlir::ValueRange::ValueRange((unint64_t *)&v53, (uint64_t)v46[0], LODWORD(v46[1]));
  mlir::RewriterBase::mergeBlocks(v40, v42, ParentBlock, v53, v54);
  if (v46[0] != v47)
    free(v46[0]);
  if (__src != v50)
    free(__src);
}

void `anonymous namespace'::ForallOpControlOperandsFolder::~ForallOpControlOperandsFolder(_anonymous_namespace_::ForallOpControlOperandsFolder *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ForallOpControlOperandsFolder::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  mlir::MLIRContext *Context;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t DenseI64ArrayAttr;
  uint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  mlir::MLIRContext *v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  int v32;
  uint64_t v33;
  mlir::MLIRContext *v34;
  unint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t DenseI32ArrayAttr;
  mlir::StringAttr *v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  unsigned int v52;
  _BYTE v53[48];
  void *v54;
  unsigned int v55;
  uint64_t v56;
  void *v57;
  unsigned int v58;
  uint64_t v59;
  unint64_t v60[2];
  unint64_t v61[2];
  mlir::MLIRContext *v62[2];
  void *v63;
  _WORD v64[12];
  void *v65;
  uint64_t v66;
  _BYTE v67[48];
  void *v68;
  uint64_t v69;
  _BYTE v70[48];
  void *v71;
  uint64_t v72;
  _BYTE v73[48];
  void *v74;
  uint64_t v75;
  _BYTE v76[48];
  void *v77;
  uint64_t v78;
  _BYTE v79[48];
  _BYTE *v80;
  uint64_t v81;
  _BYTE v82[48];
  __int128 v83;
  uint64_t v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v50 = a2;
  mlir::scf::ForallOp::getMixedLowerBound((mlir::scf::ForallOp *)&v50, (uint64_t)&v57);
  mlir::scf::ForallOp::getMixedUpperBound((mlir::scf::ForallOp *)&v50, (uint64_t)&v54);
  mlir::scf::ForallOp::getMixedStep((mlir::scf::ForallOp *)&v50, (uint64_t)&v51);
  if (mlir::foldDynamicIndexList((uint64_t)&v57, 0)
    || mlir::foldDynamicIndexList((uint64_t)&v54, 0)
    || mlir::foldDynamicIndexList((uint64_t)&v51, 0))
  {
    v49 = v50;
    (*((void (**)(mlir::MLIRContext **))*a3 + 9))(a3);
    v80 = v82;
    v81 = 0x600000000;
    v77 = v79;
    v78 = 0x600000000;
    v74 = v76;
    v75 = 0x600000000;
    v71 = v73;
    v72 = 0x600000000;
    v68 = v70;
    v69 = 0x600000000;
    v65 = v67;
    v66 = 0x600000000;
    mlir::dispatchIndexOpFoldResults((uint64_t *)v57, v58, (uint64_t)&v80, (uint64_t)&v71);
    v4 = v50;
    if (HIBYTE(*(_DWORD *)(v50 + 44)))
      v5 = v50 + 16 * (((unint64_t)*(unsigned int *)(v50 + 44) >> 23) & 1) + 64;
    else
      v5 = 0;
    v6 = *(_DWORD *)(v5 + 32);
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(v50 + 48) + 104) - 8);
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v50 + 24));
    v9 = v50 + 16 * (((unint64_t)*(unsigned int *)(v50 + 44) >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(v50 + 44)))
      v9 = 0;
    v10 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v9 + 32, 4);
    ZinMirCacheTensors::ZinMirCacheTensors(&v83, v7, v10);
    LODWORD(v84) = 0;
    v85 = v83;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v62, v4, 0, v6, &v84, 1);
    mlir::ValueRange::ValueRange(v61, (uint64_t)v80, v81);
    mlir::MutableOperandRange::assign((uint64_t)v62, v61[0], v61[1]);
    if (v63 != v64)
      free(v63);
    v11 = v71;
    v12 = v72;
    v13 = v50;
    v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 + 48) + 96) + 8);
    v62[0] = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v50 + 24));
    DenseI64ArrayAttr = mlir::Builder::getDenseI64ArrayAttr(v62, (uint64_t)v11, v12);
    mlir::Operation::setAttr(v13, v14, DenseI64ArrayAttr);
    mlir::dispatchIndexOpFoldResults((uint64_t *)v54, v55, (uint64_t)&v77, (uint64_t)&v68);
    v16 = v50;
    if (HIBYTE(*(_DWORD *)(v50 + 44)))
      v17 = v50 + 16 * (((unint64_t)*(unsigned int *)(v50 + 44) >> 23) & 1) + 64;
    else
      v17 = 0;
    v18 = *(_DWORD *)(v17 + 32);
    v19 = *(_DWORD *)(v17 + 36);
    v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(v50 + 48) + 104) - 8);
    v21 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v50 + 24));
    v22 = v50 + 16 * (((unint64_t)*(unsigned int *)(v50 + 44) >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(v50 + 44)))
      v22 = 0;
    v23 = mlir::detail::DenseArrayAttrImpl<int>::get(v21, v22 + 32, 4);
    ZinMirCacheTensors::ZinMirCacheTensors(&v83, v20, v23);
    LODWORD(v84) = 1;
    v85 = v83;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v62, v16, v18, v19, &v84, 1);
    mlir::ValueRange::ValueRange(v60, (uint64_t)v77, v78);
    mlir::MutableOperandRange::assign((uint64_t)v62, v60[0], v60[1]);
    if (v63 != v64)
      free(v63);
    v24 = v68;
    v25 = v69;
    v26 = v50;
    v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 + 48) + 96) + 24);
    v62[0] = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v50 + 24));
    v28 = mlir::Builder::getDenseI64ArrayAttr(v62, (uint64_t)v24, v25);
    mlir::Operation::setAttr(v26, v27, v28);
    mlir::dispatchIndexOpFoldResults((uint64_t *)v51, v52, (uint64_t)&v74, (uint64_t)&v65);
    v29 = v50;
    if (HIBYTE(*(_DWORD *)(v50 + 44)))
      v30 = (_DWORD *)(v50 + 16 * (((unint64_t)*(unsigned int *)(v50 + 44) >> 23) & 1) + 64);
    else
      v30 = 0;
    v31 = v30[9] + v30[8];
    v32 = v30[10];
    v33 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(v50 + 48) + 104) - 8);
    v34 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v50 + 24));
    v35 = v50 + 16 * (((unint64_t)*(unsigned int *)(v50 + 44) >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(v50 + 44)))
      v35 = 0;
    v36 = mlir::detail::DenseArrayAttrImpl<int>::get(v34, v35 + 32, 4);
    ZinMirCacheTensors::ZinMirCacheTensors(&v83, v33, v36);
    LODWORD(v84) = 2;
    v85 = v83;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v62, v29, v31, v32, &v84, 1);
    mlir::ValueRange::ValueRange((unint64_t *)&v84, (uint64_t)v74, v75);
    mlir::MutableOperandRange::assign((uint64_t)v62, v84, v85);
    if (v63 != v64)
      free(v63);
    v37 = v65;
    v38 = v66;
    v39 = v50;
    v40 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v50 + 48) + 96) + 16);
    v62[0] = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v50 + 24));
    v41 = mlir::Builder::getDenseI64ArrayAttr(v62, (uint64_t)v37, v38);
    mlir::Operation::setAttr(v39, v40, v41);
    v42 = v50;
    *(_QWORD *)&v83 = __PAIR64__(v78, v81);
    *((_QWORD *)&v83 + 1) = __PAIR64__(*(_DWORD *)(v50 + 36), v75);
    DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(a3 + 1, (uint64_t)&v83, 4);
    v44 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v42 + 24));
    v64[0] = 261;
    v62[0] = (mlir::MLIRContext *)"operandSegmentSizes";
    v62[1] = (mlir::MLIRContext *)19;
    v45 = mlir::StringAttr::get(v44, (mlir::MLIRContext *)v62);
    mlir::Operation::setAttr(v42, v45, DenseI32ArrayAttr);
    if (v65 != v67)
      free(v65);
    if (v68 != v70)
      free(v68);
    if (v71 != v73)
      free(v71);
    if (v74 != v76)
      free(v74);
    if (v77 != v79)
      free(v77);
    if (v80 != v82)
      free(v80);
    (*((void (**)(mlir::MLIRContext **, uint64_t))*a3 + 10))(a3, v49);
    v46 = 1;
    v47 = v51;
    if (v51 != v53)
      goto LABEL_38;
  }
  else
  {
    v46 = 0;
    v47 = v51;
    if (v51 != v53)
LABEL_38:
      free(v47);
  }
  if (v54 != &v56)
    free(v54);
  if (v57 != &v59)
    free(v57);
  return v46;
}

void `anonymous namespace'::ForallOpSingleOrZeroIterationDimsFolder::~ForallOpSingleOrZeroIterationDimsFolder(_anonymous_namespace_::ForallOpSingleOrZeroIterationDimsFolder *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ForallOpSingleOrZeroIterationDimsFolder::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __int128 v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  _BYTE *v17;
  uint64_t v18;
  char v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  void *v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *ConstantIndexOp;
  char v40;
  _QWORD *v41;
  void *v42;
  int v44;
  void **v45;
  int v46;
  mlir::Operation *v47;
  uint64_t v48;
  unint64_t v49;
  _DWORD *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  ZinIrHalH13g *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  mlir::Block *v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  int8x16_t *v67;
  uint64_t v68;
  uint64_t v69;
  int8x16_t v70;
  void **p_src;
  uint64_t Value;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  uint64_t NumNeededNEs;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  unint64_t v80;
  mlir::Operation *v81;
  unint64_t v82;
  uint64_t v83;
  mlir::Operation *v84;
  unint64_t v85;
  _DWORD *v86;
  int v87;
  int v88;
  int v89;
  int v90;
  uint64_t v91;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  uint64_t v96;
  llvm *v97[2];
  int v98;
  llvm *v99;
  uint64_t v100;
  int v101;
  llvm *v102;
  uint64_t v103;
  unsigned int v104;
  mlir::Operation *v105;
  unint64_t v106[2];
  unint64_t v107[2];
  void *v108;
  uint64_t v109;
  _BYTE v110[48];
  void *v111;
  uint64_t v112;
  _BYTE v113[48];
  void *__src;
  uint64_t *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  void *__dst[2];
  _QWORD v120[2];
  int8x16_t v121;
  void *v122;
  uint64_t v123;
  _BYTE v124[48];
  void *v125;
  uint64_t v126;
  _BYTE v127[48];
  __int128 v128;
  void *v129;
  uint64_t v130;
  _BYTE v131[48];
  _BYTE *v132;
  uint64_t v133;
  _BYTE v134[48];
  _QWORD *v135;
  uint64_t v136;
  _QWORD v137[8];

  v137[6] = *MEMORY[0x24BDAC8D0];
  v105 = (mlir::Operation *)a2;
  if (!*(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64))
  {
    v96 = *(_QWORD *)(a2 + 24);
    v97[0] = 0;
    v135 = v137;
    v136 = 0x600000000;
    v132 = v134;
    v133 = 0x600000000;
    v129 = v131;
    v130 = 0x600000000;
    v97[1] = 0;
    v98 = 0;
    v99 = 0;
    v100 = 0;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    v104 = 0;
    mlir::scf::ForallOp::getMixedLowerBound((mlir::scf::ForallOp *)&v105, (uint64_t)&__src);
    mlir::scf::ForallOp::getMixedUpperBound((mlir::scf::ForallOp *)&v105, (uint64_t)&v111);
    mlir::scf::ForallOp::getMixedStep((mlir::scf::ForallOp *)&v105, (uint64_t)&v108);
    v3 = *((unsigned int *)v105 + 11);
    v4 = (void **)((char *)v105 + 16 * ((v3 >> 23) & 1) + 64);
    v5 = *(_QWORD *)((((unint64_t)v4 + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *((unsigned int *)v105 + 10)
                   + 8);
    if (v5)
      v6 = v5 - 8;
    else
      v6 = 0;
    v7 = *(_QWORD *)(v6 + 48);
    v8 = (*(_QWORD *)(v6 + 56) - v7) >> 3;
    if (!HIBYTE(*((_DWORD *)v105 + 11)))
      v4 = 0;
    __dst[0] = v4[1];
    mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)__dst);
    if (v8 >= v9)
      v10 = v9;
    else
      v10 = v8;
    mlir::ValueRange::ValueRange((unint64_t *)__dst, v7, v10);
    v11 = *(_OWORD *)__dst;
    __dst[0] = v120;
    __dst[1] = (void *)0x600000000;
    v12 = (int)v115;
    if ((_DWORD)v115)
    {
      if (__src == &v116)
      {
        v93 = v11;
        v13 = v115;
        if (v115 < 7
          || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)__dst, v120, v115, 8),
              (v13 = v115) != 0))
        {
          memcpy(__dst[0], __src, 8 * v13);
        }
        LODWORD(__dst[1]) = v12;
        v11 = v93;
      }
      else
      {
        __dst[0] = __src;
        __dst[1] = v115;
        __src = &v116;
        HIDWORD(v115) = 0;
      }
      LODWORD(v115) = 0;
    }
    v122 = v124;
    v123 = 0x600000000;
    v14 = v112;
    if (!(_DWORD)v112)
    {
LABEL_29:
      v125 = v127;
      v126 = 0x600000000;
      v16 = v109;
      v17 = v108;
      if (!(_DWORD)v109)
      {
LABEL_39:
        v128 = v11;
        if (v17 != v110)
          free(v17);
        if (v111 != v113)
          free(v111);
        if (__src != &v116)
          free(__src);
        v19 = 0;
        v20 = (uint64_t *)__dst[0];
        v21 = (uint64_t *)v122;
        v22 = (uint64_t *)v125;
        v23 = v128;
        __src = __dst[0];
        v115 = (uint64_t *)v122;
        v116 = (char *)v125;
        v117 = v128;
        v118 = 0;
        if (!LODWORD(__dst[1]) || !(_DWORD)v123 || !(_DWORD)v126)
        {
LABEL_71:
          v42 = v125;
          if (v125 == v127)
            goto LABEL_73;
          goto LABEL_72;
        }
        v24 = 0;
        v25 = (uint64_t *)((char *)__dst[0] + 8 * LODWORD(__dst[1]));
        v26 = (uint64_t *)((char *)v122 + 8 * v123);
        v27 = *((_QWORD *)&v128 + 1);
        v28 = (uint64_t *)((char *)v125 + 8 * v126);
        while (1)
        {
          if (v117 == v23 && v24 == v27)
          {
            v19 = 0;
            goto LABEL_71;
          }
          v30 = (void *)mlir::ValueRange::dereference_iterator(&v117, v24);
          v31 = mlir::constantTripCount(*v20, *v21, *v22);
          if (v32)
          {
            if (v31 == 1)
            {
              ConstantIndexOp = mlir::getValueOrCreateConstantIndexOp((mlir::IndexType **)(a3 + 8), v96, *v20);
              v108 = v30;
              v111 = 0;
              v40 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v97, (unint64_t *)&v108, &v111);
              v41 = v111;
              if ((v40 & 1) == 0)
              {
                v41 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v97, (uint64_t)&v108, (unint64_t *)&v108, v111);
                *v41 = v108;
                v41[1] = 0;
              }
              v41[1] = ConstantIndexOp;
              goto LABEL_66;
            }
            if (!v31)
            {
              v84 = v105;
              v85 = *((unsigned int *)v105 + 11);
              if (HIBYTE(*((_DWORD *)v105 + 11)))
                v86 = (_DWORD *)((char *)v105 + 16 * ((v85 >> 23) & 1) + 64);
              else
                v86 = 0;
              v87 = v86[8];
              v88 = v86[9];
              v90 = v86[10];
              v89 = v86[11];
              if ((v85 & 0x800000) != 0)
                v91 = *((_QWORD *)v105 + 9);
              else
                v91 = 0;
              mlir::ValueRange::ValueRange(v107, v91 + 32 * (v88 + v87 + v90), (v89 + v88 + v87 + v90) - (unint64_t)(v88 + v87 + v90));
              (*(void (**)(uint64_t, mlir::Operation *, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, v84, v107[0], v107[1]);
              v19 = 1;
              v42 = v125;
              if (v125 == v127)
              {
LABEL_73:
                if (v122 != v124)
                  free(v122);
                if (__dst[0] != v120)
                  free(__dst[0]);
                if ((v19 & 1) != 0)
                  goto LABEL_78;
                v44 = v136;
                v45 = (void **)((char *)v105 + 16 * (((unint64_t)*((unsigned int *)v105 + 11) >> 23) & 1) + 64);
                if (!HIBYTE(*((_DWORD *)v105 + 11)))
                  v45 = 0;
                __dst[0] = v45[1];
                mlir::detail::DenseArrayAttrImpl<long long>::operator llvm::ArrayRef<long long>((uint64_t)__dst);
                if (v44 == v46)
                {
                  __dst[0] = "no dimensions have 0 or 1 iterations";
                  v121.i16[0] = 259;
                  v47 = v105;
                  __src = __dst;
                  v48 = *(_QWORD *)(a3 + 16);
                  if (v48 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a3 + 16)))
                    (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v48 + 64))(v48, *((_QWORD *)v47 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::scf::ForallOp &>(mlir::scf::ForallOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &__src);
                  goto LABEL_78;
                }
                if (!(_DWORD)v136)
                {
                  mlir::scf::promote(a3, (uint64_t)v105);
                  goto LABEL_78;
                }
                v49 = *((unsigned int *)v105 + 11);
                if (HIBYTE(*((_DWORD *)v105 + 11)))
                  v50 = (_DWORD *)((char *)v105 + 16 * ((v49 >> 23) & 1) + 64);
                else
                  v50 = 0;
                v51 = v50[8];
                v52 = v50[9];
                v54 = v50[10];
                v53 = v50[11];
                if ((v49 & 0x800000) != 0)
                  v55 = *((_QWORD *)v105 + 9);
                else
                  v55 = 0;
                v56 = (v52 + v51 + v54);
                __dst[0] = (void *)(v55 + 32 * v56);
                __dst[1] = (void *)((v53 + v56) - v56);
                __src = 0;
                v57 = mlir::OpBuilder::create<mlir::scf::ForallOp,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,mlir::OperandRange,std::nullopt_t const&,decltype(nullptr)>((mlir::OpBuilder *)(a3 + 8), v96, (uint64_t)&v135, (uint64_t)&v132, (uint64_t)&v129, (uint64_t)__dst);
                v58 = (uint64_t)v57;
                v59 = *((unsigned int *)v57 + 11);
                if ((v59 & 0x7FFFFF) != 0)
                {
                  v60 = (((unint64_t)v57 + 16 * ((v59 >> 23) & 1) + ((v59 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                      + 32 * *((unsigned int *)v57 + 10);
                  v61 = *(_QWORD *)(v60 + 8);
                  if (v61 != v60)
                  {
                    do
                    {
LABEL_93:
                      v62 = *(_QWORD *)(v61 + 8);
                      if (v61)
                        v63 = (mlir::Block *)(v61 - 8);
                      else
                        v63 = 0;
                      llvm::ilist_traits<mlir::Block>::removeNodeFromList(v60, (uint64_t)v63);
                      v64 = *((_QWORD *)v63 + 1);
                      v65 = (_QWORD *)*((_QWORD *)v63 + 2);
                      *v65 = v64;
                      *(_QWORD *)(v64 + 8) = v65;
                      *((_QWORD *)v63 + 1) = 0;
                      *((_QWORD *)v63 + 2) = 0;
                      mlir::Block::~Block(v63);
                      MEMORY[0x20BD002F8]();
                      v61 = v62;
                    }
                    while (v62 != v60);
                  }
                }
                else
                {
                  v60 = 0;
                  v61 = MEMORY[8];
                  if (MEMORY[8])
                    goto LABEL_93;
                }
                v66 = *(_QWORD *)(v58 + 48);
                v67 = *(int8x16_t **)(v66 + 96);
                v68 = v67->i64[*(_QWORD *)(v66 + 104) - 1];
                v69 = v67->i64[1];
                __dst[0] = v120;
                v70 = v67[1];
                v120[0] = v68;
                v120[1] = v69;
                v121 = vextq_s8(v70, v70, 8uLL);
                __dst[1] = (void *)0x600000004;
                if (*((_BYTE *)v105 + 47))
                {
                  __src = (void *)mlir::Operation::getAttrDictionary(v105);
                  p_src = &__src;
                }
                else
                {
                  p_src = (void **)((char *)v105 + 56);
                }
                Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)p_src);
                v74 = (uint64_t *)Value;
                if (v73)
                {
                  v75 = (uint64_t *)(Value + 16 * v73);
                  do
                  {
                    NumNeededNEs = MirInfoChannelAssignment::GetNumNeededNEs((MirInfoChannelAssignment *)v74);
                    if (!LODWORD(__dst[1]))
                      goto LABEL_111;
                    v77 = 8 * LODWORD(__dst[1]);
                    v78 = (char *)__dst[0];
                    do
                    {
                      if (*(_QWORD *)v78 == NumNeededNEs)
                        goto LABEL_110;
                      v78 += 8;
                      v77 -= 8;
                    }
                    while (v77);
                    v78 = (char *)__dst[0] + 8 * LODWORD(__dst[1]);
LABEL_110:
                    if (LODWORD(__dst[1]) == (v78 - (char *)__dst[0]) >> 3)
                    {
LABEL_111:
                      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, v58);
                      v79 = MirInfoChannelAssignment::GetNumNeededNEs((MirInfoChannelAssignment *)v74);
                      mlir::Operation::setAttr(v58, v79, v74[1]);
                      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 80))(a3, v58);
                    }
                    v74 += 2;
                  }
                  while (v74 != v75);
                }
                v80 = ((v58
                      + 16 * (((unint64_t)*(unsigned int *)(v58 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(v58 + 44) >> 21) & 0x7F8)
                      + 71) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(v58 + 40);
                (*(void (**)(uint64_t, unint64_t, unint64_t, _QWORD, llvm **))(*(_QWORD *)a3 + 8))(a3, (((unint64_t)v105+ 16 * (((unint64_t)*((unsigned int *)v105 + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)v105 + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)v105 + 10), v80, *(_QWORD *)(v80 + 8), v97);
                v81 = v105;
                v82 = *(unsigned int *)(v58 + 36);
                if ((_DWORD)v82)
                  v83 = v58 - 16;
                else
                  v83 = 0;
                mlir::ValueRange::ValueRange(v106, v83, v82);
                (*(void (**)(uint64_t, mlir::Operation *, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, v81, v106[0], v106[1]);
                if (__dst[0] != v120)
                  free(__dst[0]);
LABEL_78:
                llvm::deallocate_buffer(v102, (void *)(16 * v104));
              }
LABEL_72:
              free(v42);
              goto LABEL_73;
            }
          }
          v33 = *v20;
          v34 = v136;
          if (v136 >= (unint64_t)HIDWORD(v136))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v137, v136 + 1, 8);
            v34 = v136;
          }
          v135[v34] = v33;
          LODWORD(v136) = v136 + 1;
          v35 = *v21;
          v36 = v133;
          if (v133 >= (unint64_t)HIDWORD(v133))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v134, v133 + 1, 8);
            v36 = v133;
          }
          *(_QWORD *)&v132[8 * v36] = v35;
          LODWORD(v133) = v133 + 1;
          v37 = *v22;
          v38 = v130;
          if (v130 >= (unint64_t)HIDWORD(v130))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v129, v131, v130 + 1, 8);
            v38 = v130;
          }
          *((_QWORD *)v129 + v38) = v37;
          LODWORD(v130) = v130 + 1;
LABEL_66:
          v19 = 0;
          v20 = (uint64_t *)((char *)__src + 8);
          v21 = v115 + 1;
          __src = v20;
          ++v115;
          v22 = (uint64_t *)(v116 + 8);
          v24 = v118 + 1;
          v116 += 8;
          ++v118;
          if (v20 == v25 || v21 == v26 || v22 == v28)
            goto LABEL_71;
        }
      }
      if (v108 != v110)
      {
        v125 = v108;
        v126 = v109;
        v108 = v110;
        HIDWORD(v109) = 0;
        v17 = v110;
LABEL_38:
        LODWORD(v109) = 0;
        goto LABEL_39;
      }
      v95 = v11;
      if (v109 < 7)
      {
        v18 = v109;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v125, v127, v109, 8);
        v18 = v109;
        v17 = v108;
        if (!(_DWORD)v109)
          goto LABEL_37;
      }
      memcpy(v125, v17, 8 * v18);
      v17 = v108;
LABEL_37:
      LODWORD(v126) = v16;
      v11 = v95;
      goto LABEL_38;
    }
    if (v111 != v113)
    {
      v122 = v111;
      v123 = v112;
      v111 = v113;
      HIDWORD(v112) = 0;
LABEL_28:
      LODWORD(v112) = 0;
      goto LABEL_29;
    }
    v94 = v11;
    if (v112 < 7)
    {
      v15 = v112;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v124, v112, 8);
      v15 = v112;
      if (!(_DWORD)v112)
        goto LABEL_27;
    }
    memcpy(v122, v111, 8 * v15);
LABEL_27:
    LODWORD(v123) = v14;
    v11 = v94;
    goto LABEL_28;
  }
  return 0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::ForallOp,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,llvm::SmallVector<mlir::OpFoldResult,6u> &,mlir::OperandRange,std::nullopt_t const&,decltype(nullptr)>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  uint64_t *v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  ZinIrHalH13g *v21;
  ZinIrHalH13g *v22;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  unint64_t v30[2];
  _QWORD v31[39];

  v31[38] = *MEMORY[0x24BDAC8D0];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.forall", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"scf.forall";
    v28[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v13);
  v15 = *(uint64_t **)a3;
  v16 = *(unsigned int *)(a3 + 8);
  v17 = *(uint64_t **)a4;
  v18 = *(unsigned int *)(a4 + 8);
  v19 = *(uint64_t **)a5;
  v20 = *(unsigned int *)(a5 + 8);
  mlir::ValueRange::ValueRange(v30, *(_QWORD *)a6, *(_QWORD *)(a6 + 8));
  mlir::scf::ForallOp::build((uint64_t)a1, (uint64_t)v31, v15, v16, v17, v18, v19, v20, v30[0], v30[1], 0, 0, 0, v24);
  v21 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ForallOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v22;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::scf::ForallOp &>(mlir::scf::ForallOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IfOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  const mlir::OperationState *v2;
  uint64_t v3;
  _QWORD v5[39];

  v5[38] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v5, a2, (uint64_t)"scf.yield", 9);
  v3 = mlir::Operation::create((mlir::Operation *)v5, v2);
  mlir::OperationState::~OperationState((mlir::OperationState *)v5);
  return v3;
}

void `anonymous namespace'::CombineIfs::~CombineIfs(_anonymous_namespace_::CombineIfs *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::IfOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::IfOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::IfOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::CombineIfs::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t DefiningOp;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  void *v18;
  BOOL v19;
  char *v20;
  uint64_t v21;
  void *v22;
  BOOL v23;
  char *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  unint64_t v40;
  mlir::Operation *v41;
  _QWORD *v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  char *v48;
  mlir::Operation *v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  const double *v53;
  unsigned __int128 *v54;
  unint64_t v55;
  const double *v56;
  unsigned __int128 v57;
  unsigned __int128 v58;
  unint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::detail::OpResultImpl *v68;
  uint64_t v69;
  uint64_t **v70;
  char *v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t *v74;
  mlir::Region *Parent;
  mlir::Block *v76;
  mlir::Region *v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t *v80;
  mlir::Region *v81;
  mlir::Block *v82;
  mlir::Region *v83;
  uint64_t *v84;
  unsigned int *v85;
  uint64_t v86;
  char *v87;
  mlir::detail::OpResultImpl *v88;
  uint64_t v89;
  uint64_t v90;
  mlir::detail::OpResultImpl *v91;
  int v92;
  int v93;
  BOOL v94;
  unint64_t *v95;
  uint64_t v96;
  void *v97;
  mlir::OpBuilder *v98;
  uint64_t v99;
  unsigned int *v100;
  unsigned int *v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  mlir::detail::OpResultImpl **v117;
  uint64_t v119;
  unint64_t v120;
  const double *v121;
  unsigned __int128 *v122;
  unint64_t v123;
  const double *v124;
  unsigned __int128 v125;
  unsigned __int128 v126;
  unint64_t v127;
  mlir::detail::OpResultImpl **v128;
  mlir::detail::OpResultImpl *v129;
  int v130;
  unsigned int v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  BOOL v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  BOOL v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  BOOL v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  mlir::detail::OpResultImpl **v169;
  mlir::detail::OpResultImpl **v170;
  unint64_t v171;
  uint64_t v172;
  const double *v173;
  unsigned __int128 *v174;
  unint64_t v175;
  const double *v176;
  unsigned __int128 v177;
  unsigned __int128 v178;
  unint64_t v179;
  mlir::detail::OpResultImpl **v180;
  mlir::detail::OpResultImpl *v181;
  int v182;
  unsigned int v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t i;
  uint64_t v189;
  void **v190;
  uint64_t NextResultAtOffset;
  mlir::detail::OpResultImpl **v192;
  unint64_t v193;
  mlir::detail::OpResultImpl *v194;
  uint64_t v195;
  char *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  mlir::detail::OpResultImpl *v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203[2];
  unint64_t v204[2];
  void *v205;
  uint64_t v206;
  _BYTE v207[48];
  unint64_t v208[2];
  void *v209;
  uint64_t v210;
  mlir::detail::OpResultImpl *v211;
  uint64_t v212;
  unint64_t v213[2];
  char *v214;
  uint64_t v215;
  _BYTE v216[48];
  char *Filter;
  unint64_t v218;
  _QWORD v219[8];

  v219[6] = *MEMORY[0x24BDAC8D0];
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(*(_QWORD *)(a2 + 16) + 40));
  if (v5 == a2 || *(_QWORD *)(*(_QWORD *)(a2 + 16) + 40) == a2)
    return 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)a2);
  v7 = v6 && *(_QWORD *)(*(_QWORD *)(v6 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id;
  if (!v7)
    return 0;
  v8 = v6;
  if (*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) != *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24))
  {
    v9 = 0;
    v10 = 0;
    Filter = *(char **)(*(_QWORD *)(a2 + 72) + 24);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
    if (!DefiningOp)
      goto LABEL_26;
    goto LABEL_20;
  }
  v12 = (_QWORD *)(((a2 + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8) + 87) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40));
  v13 = *v12 - 8;
  v7 = *v12 == 0;
  v16 = (_QWORD *)v12[3];
  v15 = v12 + 3;
  v14 = v16;
  if (v7)
    v10 = 0;
  else
    v10 = v13;
  v17 = (uint64_t)(v14 - 1);
  if (!v14)
    v17 = 0;
  if (v14 == v15)
    v9 = 0;
  else
    v9 = v17;
  Filter = *(char **)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp)
  {
LABEL_20:
    v18 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v19 = v18 == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id;
    if (v18 == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id)
      v20 = (char *)DefiningOp;
    else
      v20 = 0;
    v214 = v20;
    if (v19
      && *(_QWORD *)(*(_QWORD *)(v8 + 72) + 24) == mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v214))
    {
      v209 = mlir::m_One(void)::{lambda(llvm::APInt const&)#1}::__invoke;
      Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v214);
      v41 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Filter);
      if (v41)
      {
        if (mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(uint64_t *))&v209, v41))
        {
          v42 = (_QWORD *)(((a2
                           + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                           + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                           + 71) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(a2 + 40));
          v43 = *v42 - 8;
          v7 = *v42 == 0;
          v46 = (_QWORD *)v42[3];
          v45 = v42 + 3;
          v44 = v46;
          if (v7)
            v9 = 0;
          else
            v9 = v43;
          v47 = (uint64_t)(v44 - 1);
          if (!v44)
            v47 = 0;
          if (v44 != v45)
            v10 = v47;
        }
      }
    }
  }
LABEL_26:
  Filter = *(char **)(*(_QWORD *)(v8 + 72) + 24);
  v21 = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (v21)
  {
    v22 = *(void **)(*(_QWORD *)(v21 + 48) + 16);
    v23 = v22 == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id;
    v24 = v22 == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id ? (char *)v21 : 0;
    v214 = v24;
    if (v23
      && *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) == mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v214))
    {
      v48 = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v214);
      v209 = mlir::m_One(void)::{lambda(llvm::APInt const&)#1}::__invoke;
      Filter = v48;
      v49 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Filter);
      if (v49)
      {
        if (mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(uint64_t *))&v209, v49))
        {
          v50 = (_QWORD *)(((a2
                           + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                           + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                           + 71) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(a2 + 40));
          v9 = *v50 ? *v50 - 8 : 0;
          v51 = (_QWORD *)v50[3];
          if (v51 != v50 + 3)
          {
            if (v51)
              v10 = (uint64_t)(v51 - 1);
            else
              v10 = 0;
          }
        }
      }
    }
  }
  if (!(v10 | v9))
    return 0;
  Filter = (char *)v219;
  v218 = 0x600000000;
  v25 = *(unsigned int *)(v8 + 44);
  if ((v25 & 0x7FFFFF) != 0)
  {
    v26 = (v8 + 16 * ((v25 >> 23) & 1) + ((v25 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8;
    v27 = v26 + 32 * *(unsigned int *)(v8 + 40);
    if (*(_QWORD *)(v27 + 24) == v27 + 24)
      goto LABEL_100;
    v28 = v26 + 32 * *(unsigned int *)(v8 + 40);
  }
  else
  {
    if (MEMORY[0x18] == 24)
      goto LABEL_100;
    v28 = 0;
  }
  v32 = *(_QWORD *)(v28 + 24);
  v30 = v28 + 24;
  v31 = v32;
  v33 = v32 - 8;
  if (v32)
    v34 = v31 == v30;
  else
    v34 = 1;
  if (v34)
    v35 = 0;
  else
    v35 = v33;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v35 + 32));
  if ((*(_BYTE *)(v36 + 46) & 0x80) != 0)
  {
    v37 = *(_QWORD *)(v36 + 72);
    v38 = *(unsigned int *)(v36 + 68);
    v214 = v216;
    v215 = 0x600000000;
    if (v38 >= 7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v214, v216, v38, 8);
      v39 = &v214[8 * v215];
      if (v38 >= 0xD
        && ((unint64_t)v39 >= v37 + 32 * v38
         || v37 + 24 >= (unint64_t)&v214[8 * v215 + 8 * v38]))
      {
        v52 = v38 & 3;
        if ((v38 & 3) == 0)
          v52 = 4;
        v40 = v38 - v52;
        v39 += 8 * v40;
        v53 = (const double *)(v37 + 88);
        v54 = (unsigned __int128 *)&v214[8 * v215 + 16];
        v55 = v40;
        do
        {
          v56 = v53 - 8;
          v57 = (unsigned __int128)vld4q_f64(v56);
          v58 = (unsigned __int128)vld4q_f64(v53);
          *(v54 - 1) = v57;
          *v54 = v58;
          v53 += 16;
          v54 += 2;
          v55 -= 4;
        }
        while (v55);
LABEL_78:
        v59 = v38 - v40;
        v60 = (uint64_t *)(v37 + 32 * v40 + 24);
        do
        {
          v61 = *v60;
          v60 += 4;
          *(_QWORD *)v39 = v61;
          v39 += 8;
          --v59;
        }
        while (v59);
        v62 = v214;
        v63 = (v215 + v38);
        LODWORD(v215) = v63;
        if (v214 != v216)
        {
          if (Filter != (char *)v219)
          {
            free(Filter);
            v62 = v214;
            LODWORD(v63) = v215;
          }
          Filter = v62;
          v218 = __PAIR64__(HIDWORD(v215), v63);
          v214 = v216;
          HIDWORD(v215) = 0;
          goto LABEL_97;
        }
        v64 = v218;
        if (v218 >= v63)
        {
          if ((_DWORD)v63)
            memmove(Filter, v214, 8 * v63);
          goto LABEL_96;
        }
        if (HIDWORD(v218) >= v63)
        {
          if ((_DWORD)v218)
          {
            memmove(Filter, v214, 8 * v218);
            goto LABEL_92;
          }
        }
        else
        {
          LODWORD(v218) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Filter, v219, v63, 8);
        }
        v64 = 0;
LABEL_92:
        if (v64 != v215)
          memcpy(&Filter[8 * v64], &v214[8 * v64], 8 * v215 - 8 * v64);
        goto LABEL_96;
      }
LABEL_54:
      v40 = 0;
      goto LABEL_78;
    }
    if ((_DWORD)v38)
    {
      v39 = v216;
      goto LABEL_54;
    }
  }
  else
  {
    v214 = v216;
    HIDWORD(v215) = 6;
  }
  LODWORD(v63) = 0;
  LODWORD(v215) = 0;
LABEL_96:
  LODWORD(v218) = v63;
LABEL_97:
  LODWORD(v215) = 0;
  if (v214 != v216)
    free(v214);
  LODWORD(v25) = *(_DWORD *)(v8 + 44);
LABEL_100:
  v195 = v8 + 64;
  v202 = *(unsigned int *)(v8 + 36);
  v65 = *(_QWORD *)(((v8 + 64 + 16 * ((v25 >> 23) & 1) + ((v25 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(v8 + 40));
  if (v65)
    v66 = v65 - 8;
  else
    v66 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v66 + 32));
  v197 = a2;
  v198 = v8;
  if ((*(_BYTE *)(v67 + 46) & 0x80) != 0)
  {
    v201 = *(unsigned int *)(v67 + 68);
    v196 = (char *)(v8 - 16);
    if ((_DWORD)v202)
      v68 = (mlir::detail::OpResultImpl *)(v8 - 16);
    else
      v68 = 0;
    v199 = *(_QWORD *)(v67 + 72);
    v200 = v68;
    if (!(_DWORD)v202)
      goto LABEL_141;
  }
  else
  {
    v201 = 0;
    v196 = (char *)(v8 - 16);
    if ((_DWORD)v202)
      v194 = (mlir::detail::OpResultImpl *)(v8 - 16);
    else
      v194 = 0;
    v199 = 0;
    v200 = v194;
    if (!(_DWORD)v202)
      goto LABEL_141;
  }
  if (v201 && (_DWORD)v218)
  {
    v69 = 0;
    v70 = (uint64_t **)Filter;
    v71 = &Filter[8 * v218];
    while (1)
    {
      v72 = *(uint64_t **)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v200, v69);
      if (v72)
        break;
LABEL_138:
      if (++v69 != v202 && v69 != v201 && ++v70 != (uint64_t **)v71)
        continue;
      goto LABEL_141;
    }
    v73 = *(uint64_t **)(v199 + 32 * v69 + 24);
    while (1)
    {
      v74 = v72;
      v72 = (uint64_t *)*v72;
      if (v10)
      {
        Parent = (mlir::Region *)mlir::Block::getParent((mlir::Block *)v10);
        v76 = *(mlir::Block **)(v74[2] + 16);
        if (v76)
        {
          v77 = (mlir::Region *)mlir::Block::getParent(v76);
          if (Parent == v77)
            goto LABEL_122;
        }
        else
        {
          v77 = 0;
          if (!Parent)
            goto LABEL_122;
        }
        if (mlir::Region::isProperAncestor(Parent, v77))
        {
LABEL_122:
          (*(void (**)(_QWORD *, uint64_t))(*a3 + 72))(a3, v74[2]);
          v78 = (uint64_t *)v74[1];
          if (v78)
          {
            *v78 = *v74;
            if (*v74)
              *(_QWORD *)(*v74 + 8) = v74[1];
          }
          v74[3] = (uint64_t)v73;
          v74[1] = (uint64_t)v73;
          v79 = *v73;
          *v74 = *v73;
          v80 = v73;
          if (!v79)
            goto LABEL_114;
          goto LABEL_113;
        }
      }
      if (!v9)
        goto LABEL_115;
      v81 = (mlir::Region *)mlir::Block::getParent((mlir::Block *)v9);
      v82 = *(mlir::Block **)(v74[2] + 16);
      if (v82)
      {
        v83 = (mlir::Region *)mlir::Block::getParent(v82);
        if (v81 == v83)
          goto LABEL_133;
      }
      else
      {
        v83 = 0;
        if (!v81)
          goto LABEL_133;
      }
      if (!mlir::Region::isProperAncestor(v81, v83))
        goto LABEL_115;
LABEL_133:
      (*(void (**)(_QWORD *, uint64_t))(*a3 + 72))(a3, v74[2]);
      v80 = *v70;
      v84 = (uint64_t *)v74[1];
      if (v84)
      {
        *v84 = *v74;
        if (*v74)
          *(_QWORD *)(*v74 + 8) = v74[1];
      }
      v74[3] = (uint64_t)v80;
      v74[1] = (uint64_t)v80;
      v79 = *v80;
      *v74 = *v80;
      if (!v79)
        goto LABEL_114;
LABEL_113:
      *(_QWORD *)(v79 + 8) = v74;
LABEL_114:
      *v80 = (uint64_t)v74;
      (*(void (**)(_QWORD *, uint64_t))(*a3 + 80))(a3, v74[2]);
LABEL_115:
      if (!v72)
        goto LABEL_138;
    }
  }
LABEL_141:
  v85 = (unsigned int *)v198;
  v86 = *(unsigned int *)(v198 + 36);
  v87 = v196;
  if (!(_DWORD)v86)
    v87 = 0;
  v214 = v87;
  v215 = v86;
  mlir::OperandRange::getTypes((uint64_t *)&v214, (uint64_t *)&v209);
  v214 = v216;
  v215 = 0x600000000;
  v88 = (mlir::detail::OpResultImpl *)v209;
  v89 = v210;
  v91 = v211;
  v90 = v212;
  v92 = v212 - v210;
  if ((unint64_t)(v212 - v210) >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v214, v216, v212 - v210, 8);
    v93 = v215;
    v94 = v88 != v91;
    if (v90 != v89)
      goto LABEL_148;
LABEL_147:
    if (!v94)
      goto LABEL_152;
    goto LABEL_148;
  }
  v93 = 0;
  v94 = v209 != v211;
  if (v212 == v210)
    goto LABEL_147;
LABEL_148:
  v95 = (unint64_t *)&v214[8 * v93];
  if (v94)
  {
    while (1)
      *v95++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v88, v89++) + 8) & 0xFFFFFFFFFFFFFFF8;
  }
  do
    *v95++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v88, v89++) + 8) & 0xFFFFFFFFFFFFFFF8;
  while (v90 != v89);
  v93 = v215;
LABEL_152:
  LODWORD(v215) = v93 + v92;
  v96 = *(unsigned int *)(v197 + 36);
  v97 = (void *)(v197 - 16);
  if (!(_DWORD)v96)
    v97 = 0;
  v205 = v97;
  v206 = v96;
  mlir::OperandRange::getTypes((uint64_t *)&v205, (uint64_t *)&v209);
  llvm::SmallVectorImpl<mlir::Type>::insert<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void>((uint64_t)&v214, (uint64_t)&v214[8 * v215], (mlir::detail::OpResultImpl *)v209, v210, v211, v212);
  v98 = (mlir::OpBuilder *)(a3 + 1);
  v99 = *(_QWORD *)(v197 + 24);
  v209 = *(void **)(*(_QWORD *)(v198 + 72) + 24);
  LOBYTE(v205) = 0;
  v100 = (unsigned int *)mlir::OpBuilder::create<mlir::scf::IfOp,llvm::SmallVector<mlir::Type,6u> &,mlir::detail::TypedValue<mlir::IntegerType>,BOOL>((mlir::OpBuilder *)(a3 + 1), v99, (uint64_t)&v214, (uint64_t *)&v209, (unsigned __int8 *)&v205);
  v101 = v100 + 16;
  v102 = *(_QWORD *)((((unint64_t)&v100[4 * (((unint64_t)v100[11] >> 23) & 1) + 17]
                     + (((unint64_t)v100[11] >> 21) & 0x7F8)
                     + 3) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * v100[10]);
  if (v102)
    v103 = v102 - 8;
  else
    v103 = 0;
  (*(void (**)(_QWORD *, uint64_t))(*a3 + 48))(a3, v103);
  v104 = (((unint64_t)&v101[4 * (((unint64_t)v100[11] >> 23) & 1) + 1]
         + (((unint64_t)v100[11] >> 21) & 0x7F8)
         + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * v100[10];
  (*(void (**)(_QWORD *, unint64_t, unint64_t, _QWORD))*a3)(a3, ((v195+ 16 * (((unint64_t)*(unsigned int *)(v198 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(v198 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(v198 + 40), v104, *(_QWORD *)(v104 + 8));
  if (v10)
  {
    v105 = *(_QWORD *)((((unint64_t)&v101[4 * (((unint64_t)v100[11] >> 23) & 1) + 1]
                       + (((unint64_t)v100[11] >> 21) & 0x7F8)
                       + 3) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * v100[10]);
    if (v105)
      v106 = v105 - 8;
    else
      v106 = 0;
    ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v106 + 32));
    v108 = v107;
    mlir::Block::getTerminator((ZinIrHalH13g **)v10);
    v110 = v109;
    v111 = *(_QWORD *)((((unint64_t)&v101[4 * (((unint64_t)v100[11] >> 23) & 1) + 1]
                       + (((unint64_t)v100[11] >> 21) & 0x7F8)
                       + 3) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * v100[10]);
    if (v111)
      v112 = v111 - 8;
    else
      v112 = 0;
    mlir::ValueRange::ValueRange(v213, 0, 0);
    mlir::RewriterBase::mergeBlocks((uint64_t)a3, v10, v112, v213[0], v213[1]);
    v113 = *(_QWORD *)((((unint64_t)&v101[4 * (((unint64_t)v100[11] >> 23) & 1) + 1]
                       + (((unint64_t)v100[11] >> 21) & 0x7F8)
                       + 3) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * v100[10]);
    if (v113)
      v114 = v113 - 8;
    else
      v114 = 0;
    a3[3] = v114;
    a3[4] = v114 + 32;
    if ((*(_BYTE *)(v108 + 46) & 0x80) == 0)
    {
      LODWORD(v116) = 0;
      v130 = 0;
      v209 = &v211;
      HIDWORD(v210) = 6;
      goto LABEL_187;
    }
    v115 = *(_QWORD *)(v108 + 72);
    v116 = *(unsigned int *)(v108 + 68);
    v209 = &v211;
    v210 = 0x600000000;
    if (v116 < 7)
    {
      if (!(_DWORD)v116)
      {
        v130 = 0;
        goto LABEL_187;
      }
      v117 = &v211;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, &v211, v116, 8);
      v117 = (mlir::detail::OpResultImpl **)((char *)v209 + 8 * v210);
      if (v116 >= 0xD
        && ((unint64_t)v117 >= v115 + 32 * v116
         || v115 + 24 >= (unint64_t)v209 + 8 * v210 + 8 * v116))
      {
        v119 = v116 & 3;
        if ((v116 & 3) == 0)
          v119 = 4;
        v120 = v116 - v119;
        v117 += v120;
        v121 = (const double *)(v115 + 88);
        v122 = (unsigned __int128 *)((char *)v209 + 8 * v210 + 16);
        v123 = v120;
        do
        {
          v124 = v121 - 8;
          v125 = (unsigned __int128)vld4q_f64(v124);
          v126 = (unsigned __int128)vld4q_f64(v121);
          *(v122 - 1) = v125;
          *v122 = v126;
          v121 += 16;
          v122 += 2;
          v123 -= 4;
        }
        while (v123);
        goto LABEL_184;
      }
    }
    v120 = 0;
LABEL_184:
    v127 = v116 - v120;
    v128 = (mlir::detail::OpResultImpl **)(v115 + 32 * v120 + 24);
    do
    {
      v129 = *v128;
      v128 += 4;
      *v117++ = v129;
      --v127;
    }
    while (v127);
    v130 = v210;
LABEL_187:
    v131 = v130 + v116;
    LODWORD(v210) = v131;
    if ((*(_BYTE *)(v110 + 46) & 0x80) != 0)
    {
      v132 = *(_QWORD *)(v110 + 72);
      v133 = *(unsigned int *)(v110 + 68);
    }
    else
    {
      v132 = 0;
      v133 = 0;
    }
    v98 = (mlir::OpBuilder *)(a3 + 1);
    llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>((uint64_t)&v209, (uint64_t)v209 + 8 * v131, v132, 0, v132, v133);
    mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(v110 + 24), (uint64_t)&v209);
    (*(void (**)(_QWORD *, uint64_t))(*a3 + 40))(a3, v108);
    (*(void (**)(_QWORD *, uint64_t))(*a3 + 40))(a3, v110);
    if (v209 != &v211)
      free(v209);
    v85 = (unsigned int *)v198;
  }
  v134 = v85[11];
  if ((v134 & 0x7FFFFF) != 0)
    v135 = ((v195 + 16 * ((v134 >> 23) & 1) + ((v134 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
         + 32 * v85[10];
  else
    v135 = 0;
  v136 = v135 + 24;
  v137 = (((unint64_t)&v101[4 * (((unint64_t)v100[11] >> 23) & 1) + 1]
         + (((unint64_t)v100[11] >> 21) & 0x7F8)
         + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * v100[10];
  (*(void (**)(_QWORD *, unint64_t, unint64_t, _QWORD))*a3)(a3, v136, v137 + 24, *(_QWORD *)(v137 + 32));
  if (!v9)
    goto LABEL_248;
  v138 = v100[11];
  if ((v138 & 0x7FFFFF) != 0)
  {
    v139 = (((unint64_t)&v101[4 * ((v138 >> 23) & 1) + 1] + ((v138 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
         + 32 * v100[10];
    v140 = *(_QWORD *)(v139 + 24);
    if (v140 == v139 + 24)
      goto LABEL_209;
LABEL_201:
    v141 = v139 + 24;
    if (v140)
      v142 = v140 == v141;
    else
      v142 = 1;
    if (v142)
      v143 = 0;
    else
      v143 = v140 - 8;
    ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v143 + 32));
    v145 = v144;
    mlir::Block::getTerminator((ZinIrHalH13g **)v9);
    v147 = v146;
    v148 = v100[11];
    if ((v148 & 0x7FFFFF) != 0)
      v149 = (((unint64_t)&v101[4 * ((v148 >> 23) & 1) + 1] + ((v148 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
           + 32 * v100[10];
    else
      v149 = 0;
    v154 = *(_QWORD *)(v149 + 24);
    v152 = v149 + 24;
    v153 = v154;
    v155 = v154 - 8;
    if (v154)
      v156 = v153 == v152;
    else
      v156 = 1;
    if (v156)
      v157 = 0;
    else
      v157 = v155;
    mlir::ValueRange::ValueRange(v208, 0, 0);
    mlir::RewriterBase::mergeBlocks((uint64_t)a3, v9, v157, v208[0], v208[1]);
    v158 = v100[11];
    if ((v158 & 0x7FFFFF) != 0)
      v159 = (((unint64_t)&v101[4 * ((v158 >> 23) & 1) + 1] + ((v158 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
           + 32 * v100[10];
    else
      v159 = 0;
    v162 = *(_QWORD *)(v159 + 24);
    v160 = v159 + 24;
    v161 = v162;
    v163 = v162 - 8;
    if (v162)
      v164 = v161 == v160;
    else
      v164 = 1;
    if (v164)
      v165 = 0;
    else
      v165 = v163;
    a3[3] = v165;
    a3[4] = v165 + 32;
    if ((*(_BYTE *)(v145 + 46) & 0x80) != 0)
    {
      v166 = *(_QWORD *)(v145 + 72);
      v167 = *(unsigned int *)(v145 + 68);
      v209 = &v211;
      v210 = 0x600000000;
      if (v167 >= 7)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, &v211, v167, 8);
        v168 = v210;
        v169 = (mlir::detail::OpResultImpl **)v209;
        goto LABEL_231;
      }
      if ((_DWORD)v167)
      {
        v168 = 0;
        v169 = &v211;
LABEL_231:
        v170 = &v169[v168];
        if (v167 >= 0xD
          && ((unint64_t)v170 >= v166 + 32 * v167 || v166 + 24 >= (unint64_t)(&v169[v168] + v167)))
        {
          v172 = v167 & 3;
          if ((v167 & 3) == 0)
            v172 = 4;
          v171 = v167 - v172;
          v170 += v171;
          v173 = (const double *)(v166 + 88);
          v174 = (unsigned __int128 *)&v169[v168 + 2];
          v175 = v171;
          do
          {
            v176 = v173 - 8;
            v177 = (unsigned __int128)vld4q_f64(v176);
            v178 = (unsigned __int128)vld4q_f64(v173);
            *(v174 - 1) = v177;
            *v174 = v178;
            v173 += 16;
            v174 += 2;
            v175 -= 4;
          }
          while (v175);
        }
        else
        {
          v171 = 0;
        }
        v179 = v167 - v171;
        v180 = (mlir::detail::OpResultImpl **)(v166 + 32 * v171 + 24);
        do
        {
          v181 = *v180;
          v180 += 4;
          *v170++ = v181;
          --v179;
        }
        while (v179);
        v182 = v210;
        goto LABEL_243;
      }
      v182 = 0;
    }
    else
    {
      LODWORD(v167) = 0;
      v182 = 0;
      v209 = &v211;
      HIDWORD(v210) = 6;
    }
LABEL_243:
    v183 = v182 + v167;
    LODWORD(v210) = v183;
    if ((*(_BYTE *)(v147 + 46) & 0x80) != 0)
    {
      v184 = *(_QWORD *)(v147 + 72);
      v185 = *(unsigned int *)(v147 + 68);
    }
    else
    {
      v184 = 0;
      v185 = 0;
    }
    llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>((uint64_t)&v209, (uint64_t)v209 + 8 * v183, v184, 0, v184, v185);
    mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(v98, *(_QWORD *)(v147 + 24), (uint64_t)&v209);
    (*(void (**)(_QWORD *, uint64_t))(*a3 + 40))(a3, v145);
    (*(void (**)(_QWORD *, uint64_t))(*a3 + 40))(a3, v147);
    if (v209 != &v211)
      free(v209);
    v85 = (unsigned int *)v198;
    goto LABEL_248;
  }
  v140 = MEMORY[0x18];
  if (MEMORY[0x18] != 24)
  {
    v139 = 0;
    goto LABEL_201;
  }
LABEL_209:
  v150 = mlir::Block::getParent((mlir::Block *)v9);
  v151 = (((unint64_t)&v101[4 * (((unint64_t)v100[11] >> 23) & 1) + 1]
         + (((unint64_t)v100[11] >> 21) & 0x7F8)
         + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * v100[10];
  (*(void (**)(_QWORD *, unint64_t, unint64_t, _QWORD))*a3)(a3, v150, v151 + 24, *(_QWORD *)(v151 + 32));
LABEL_248:
  v209 = &v211;
  v210 = 0x600000000;
  v205 = v207;
  v206 = 0x600000000;
  v186 = v100[9];
  if ((_DWORD)v186)
    v187 = (uint64_t)(v100 - 4);
  else
    v187 = 0;
  if ((_DWORD)v186)
  {
    for (i = 0; i != v186; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v187, i);
      if (i < v85[9])
      {
        v189 = v210;
        v190 = &v209;
        if (v210 >= (unint64_t)HIDWORD(v210))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, &v211, v210 + 1, 8);
          v189 = v210;
        }
      }
      else
      {
        v189 = v206;
        v190 = &v205;
        if (v206 >= (unint64_t)HIDWORD(v206))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v205, v207, v206 + 1, 8);
          v189 = v206;
        }
      }
      *((_QWORD *)*v190 + v189) = NextResultAtOffset;
      ++*((_DWORD *)v190 + 2);
    }
    v192 = (mlir::detail::OpResultImpl **)v209;
    v193 = v210;
  }
  else
  {
    v193 = 0;
    v192 = &v211;
  }
  mlir::ValueRange::ValueRange(v204, (uint64_t)v192, v193);
  (*(void (**)(_QWORD *, unsigned int *, unint64_t, unint64_t))(*a3 + 24))(a3, v85, v204[0], v204[1]);
  mlir::ValueRange::ValueRange(v203, (uint64_t)v205, v206);
  (*(void (**)(_QWORD *, uint64_t, unint64_t, unint64_t))(*a3 + 24))(a3, v197, v203[0], v203[1]);
  if (v205 != v207)
    free(v205);
  if (v209 != &v211)
    free(v209);
  if (v214 != v216)
    free(v214);
  if (Filter != (char *)v219)
    free(Filter);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::IfOp,llvm::SmallVector<mlir::Type,6u> &,mlir::detail::TypedValue<mlir::IntegerType>,BOOL>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.if", (const unsigned __int8 *)6, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"scf.if";
    v19[3] = 6;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v11);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::scf::IfOp::build((uint64_t)a1, (unsigned int *)v22, v21[0], v21[1], *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

unint64_t *llvm::SmallVectorImpl<mlir::Type>::insert<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void>(uint64_t a1, uint64_t a2, mlir::detail::OpResultImpl *this, uint64_t a4, mlir::detail::OpResultImpl *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t *v23;
  BOOL v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 *v37;
  _OWORD *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  unint64_t *v42;

  v8 = a4;
  v11 = *(_QWORD *)a1;
  v12 = (a2 - *(_QWORD *)a1) >> 3;
  v14 = *(unsigned int *)(a1 + 8);
  v13 = *(unsigned int *)(a1 + 12);
  v15 = *(_DWORD *)(a1 + 8);
  v16 = a6 - a4;
  v17 = a6 - a4 + v14;
  if (*(_QWORD *)a1 + 8 * v14 != a2)
  {
    if (v17 > v13)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v17, 8);
      v11 = *(_QWORD *)a1;
      v14 = *(unsigned int *)(a1 + 8);
      v15 = *(_DWORD *)(a1 + 8);
    }
    v18 = (unint64_t *)(v11 + 8 * v12);
    v19 = v12;
    v20 = (unint64_t *)(v11 + 8 * v14);
    v21 = v20 - v18;
    if (v21 < v16)
    {
      v22 = v15 + v16;
      *(_DWORD *)(a1 + 8) = v22;
      if (v19 != v14)
      {
        memcpy((void *)(v11 + 8 * v22 - 8 * v21), v18, (char *)v20 - (char *)v18);
        v23 = v18;
        do
        {
          *v23++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
          --v21;
        }
        while (v21);
      }
      if (this != a5 || v8 != a6)
      {
        if (this != a5)
        {
          while (1)
            *v20++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
        }
        do
          *v20++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
        while (a6 != v8);
      }
      return v18;
    }
    v26 = 8 * v16;
    v27 = v14 + ((uint64_t)(8 * v16) >> 3);
    v28 = v14;
    if (v27 > *(unsigned int *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v27, 8);
      v28 = *(unsigned int *)(a1 + 8);
      v15 = *(_DWORD *)(a1 + 8);
    }
    v29 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
    if (a6 == v8)
      goto LABEL_33;
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    v31 = 8 * a6;
    v32 = 8 * a6 - 8 * v8 - 8;
    if (v32 >= 0x98)
    {
      v34 = 8 * v28 + *(_QWORD *)a1;
      v33 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
      if ((unint64_t)(v31 - (v11 + 8 * (v8 + v14)) + v34) >= 0x20)
      {
        v35 = (v32 >> 3) + 1;
        v36 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        v30 = (_QWORD *)((char *)v30 + v36 * 8);
        v33 = &v29[v36];
        v37 = (__int128 *)(8 * v8 + 8 * v14 - v31 + v11 + 16);
        v38 = (_OWORD *)(v34 + 16);
        v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v40 = *v37;
          *(v38 - 1) = *(v37 - 1);
          *v38 = v40;
          v37 += 2;
          v38 += 2;
          v39 -= 4;
        }
        while (v39);
        if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_33;
      }
    }
    else
    {
      v33 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      v41 = *v33++;
      *v30++ = v41;
    }
    while (v33 != v20);
LABEL_33:
    *(_DWORD *)(a1 + 8) = v15 + v16;
    if (v29 != v18)
      memmove(&v18[(unint64_t)v26 / 8], v18, (char *)&v20[v26 / 0xFFFFFFFFFFFFFFF8] - (char *)v18);
    if (this != a5 || a6 != v8)
    {
      if (this != a5)
      {
        while (1)
          *v18++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
      }
      v42 = v18;
      do
        *v42++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
      while (a6 != v8);
    }
    return v18;
  }
  if (v17 > v13)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v17, 8);
    v15 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  v24 = this != a5;
  if (a6 != v8 || this != a5)
  {
    v25 = (unint64_t *)(v11 + 8 * v15);
    if (v24)
    {
      while (1)
        *v25++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
    }
    do
      *v25++ = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++) + 8) & 0xFFFFFFFFFFFFFFF8;
    while (a6 != v8);
    v15 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  *(_DWORD *)(a1 + 8) = v15 + v16;
  return (unint64_t *)(v11 + 8 * v12);
}

void `anonymous namespace'::CombineNestedIfs::~CombineNestedIfs(_anonymous_namespace_::CombineNestedIfs *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::CombineNestedIfs::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  ZinIrHalH13g *v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  _QWORD *v12;
  uint64_t v14;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  BOOL v36;
  uint64_t v37;
  unint64_t v38;
  const double *v39;
  unsigned __int128 *v40;
  unint64_t v41;
  const double *v42;
  unsigned __int128 v43;
  unsigned __int128 v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  int v48;
  unsigned int v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  BOOL v53;
  BOOL v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  mlir::Value *v61;
  uint64_t v62;
  uint64_t v63;
  mlir::Block *ParentRegion;
  unint64_t v65;
  uint64_t v66;
  BOOL v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  BOOL v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  ZinIrHalH13g *v82;
  uint64_t v83;
  uint64_t v84;
  ZinIrHalH13g *v85;
  ZinIrHalH13g *v86;
  unint64_t v87;
  uint64_t v88;
  void *v89;
  uint64_t Block;
  uint64_t v91;
  mlir::detail::OpResultImpl *v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int *v95;
  uint64_t v96;
  unsigned int v97;
  uint64_t v98;
  uint64_t v99;
  ZinIrHalH13g *v100;
  uint64_t v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  ZinIrHalH13g *v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  BOOL v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124[2];
  unint64_t v125[2];
  unint64_t v126[2];
  unint64_t v127[2];
  void *v128;
  uint64_t v129;
  _BYTE v130[48];
  unint64_t v131[2];
  void *v132;
  uint64_t v133;
  _BYTE v134[48];
  char *v135;
  uint64_t v136;
  _BYTE v137[48];
  _QWORD *v138;
  uint64_t v139;
  _QWORD v140[8];

  v140[6] = *MEMORY[0x24BDAC8D0];
  v3 = a2 + 64;
  v4 = (_QWORD *)(((a2
                  + 64
                  + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                  + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                  + 7) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  v5 = *v4 - 8;
  if (!*v4)
    v5 = 0;
  v6 = *(ZinIrHalH13g **)(v5 + 40);
  if (v6 == (ZinIrHalH13g *)(v5 + 32))
    return 0;
  v7 = *(ZinIrHalH13g **)(v5 + 32);
  if (v6 == v7 || *((ZinIrHalH13g **)v6 + 1) != v7)
    return 0;
  v12 = (_QWORD *)v4[3];
  if (v12 != v4 + 3 && v12 != 0)
  {
    v21 = v12[4];
    v22 = v12 + 3;
    if ((_QWORD *)v21 == v22 || *(_QWORD **)(v21 + 8) != v22)
      return 0;
  }
  ZinIrHalH13g::~ZinIrHalH13g(v6);
  if (!v14
    || *(_QWORD *)(*(_QWORD *)(v14 + 48) + 16) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id)
  {
    return 0;
  }
  v16 = v14;
  v17 = *(unsigned int *)(v14 + 44);
  if ((v17 & 0x7FFFFF) != 0)
  {
    v18 = ((v14 + 16 * ((v17 >> 23) & 1) + ((v17 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(v14 + 40);
    v19 = *(_QWORD *)(v18 + 24);
    if (v19)
      v20 = v19 == v18 + 24;
    else
      v20 = 1;
    if (v20)
      goto LABEL_39;
  }
  else
  {
    v19 = MEMORY[0x18];
    if (!MEMORY[0x18] || MEMORY[0x18] == 24)
      goto LABEL_39;
    v18 = 0;
  }
  v23 = v18 + 24;
  if (v19)
    v24 = v19 == v23;
  else
    v24 = 1;
  if (v24)
    v25 = 0;
  else
    v25 = v19 - 8;
  v26 = v25 + 32;
  v27 = *(_QWORD *)(v25 + 40);
  if (v27 == v26 || *(_QWORD *)(v27 + 8) != v26)
    return 0;
LABEL_39:
  v28 = *(_QWORD *)(((v3
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40));
  if (v28)
    v29 = v28 - 8;
  else
    v29 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v29 + 32));
  if ((*(_BYTE *)(v30 + 46) & 0x80) != 0)
  {
    v31 = *(_QWORD *)(v30 + 72);
    v32 = *(unsigned int *)(v30 + 68);
    v138 = v140;
    v139 = 0x600000000;
    if (v32 < 7)
    {
      if (!(_DWORD)v32)
      {
        v48 = 0;
        goto LABEL_62;
      }
      v33 = 0;
      v34 = v140;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v138, v140, v32, 8);
      v33 = v139;
      v34 = v138;
    }
    v35 = &v34[v33];
    if (v32 >= 0xD
      && ((unint64_t)v35 < v31 + 32 * v32 ? (v36 = v31 + 24 >= (unint64_t)&v34[v33 + v32]) : (v36 = 1), v36))
    {
      v37 = v32 & 3;
      if ((v32 & 3) == 0)
        v37 = 4;
      v38 = v32 - v37;
      v35 += v38;
      v39 = (const double *)(v31 + 88);
      v40 = (unsigned __int128 *)&v34[v33 + 2];
      v41 = v38;
      do
      {
        v42 = v39 - 8;
        v43 = (unsigned __int128)vld4q_f64(v42);
        v44 = (unsigned __int128)vld4q_f64(v39);
        *(v40 - 1) = v43;
        *v40 = v44;
        v39 += 16;
        v40 += 2;
        v41 -= 4;
      }
      while (v41);
    }
    else
    {
      v38 = 0;
    }
    v45 = v32 - v38;
    v46 = (uint64_t *)(v31 + 32 * v38 + 24);
    do
    {
      v47 = *v46;
      v46 += 4;
      *v35++ = v47;
      --v45;
    }
    while (v45);
    v48 = v139;
  }
  else
  {
    LODWORD(v32) = 0;
    v48 = 0;
    v138 = v140;
    HIDWORD(v139) = 6;
  }
LABEL_62:
  v49 = v48 + v32;
  LODWORD(v139) = v49;
  v135 = v137;
  v136 = 0x600000000;
  v50 = *(unsigned int *)(a2 + 44);
  if ((v50 & 0x7FFFFF) != 0)
  {
    v51 = ((v3 + 16 * ((v50 >> 23) & 1) + ((v50 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a2 + 40);
    v52 = *(_QWORD *)(v51 + 24);
    if (v52)
      v53 = v52 == v51 + 24;
    else
      v53 = 1;
    if (!v53)
      goto LABEL_74;
  }
  else
  {
    v52 = MEMORY[0x18];
    if (MEMORY[0x18])
      v54 = MEMORY[0x18] == 24;
    else
      v54 = 1;
    if (!v54)
    {
      v51 = 0;
LABEL_74:
      if (v52)
        v55 = v52 == v51 + 24;
      else
        v55 = 1;
      if (v55)
        v56 = 0;
      else
        v56 = v52 - 8;
      ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v56 + 32));
      if ((*(_BYTE *)(v57 + 46) & 0x80) != 0)
      {
        v58 = *(_QWORD *)(v57 + 72);
        v59 = *(unsigned int *)(v57 + 68);
      }
      else
      {
        v58 = 0;
        v59 = 0;
      }
      llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void>((uint64_t)&v135, (uint64_t)&v135[8 * v136], v58, 0, v58, v59);
      v49 = v139;
    }
  }
  v132 = v134;
  v133 = 0xC00000000;
  if (v49)
  {
    v60 = 0;
    v61 = (mlir::Value *)v138;
    v62 = v16 + 64;
    v63 = 8 * v49;
    while (1)
    {
      while (mlir::Value::getDefiningOp(v61) != v16)
      {
        ParentRegion = mlir::Value::getParentRegion(v61);
        v65 = *(unsigned int *)(a2 + 44);
        if ((v65 & 0x7FFFFF) != 0)
        {
          if (ParentRegion == (mlir::Block *)(((v3 + 16 * ((v65 >> 23) & 1) + ((v65 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                             + 32 * *(unsigned int *)(a2 + 40)))
            goto LABEL_118;
        }
        else if (!ParentRegion)
        {
          goto LABEL_118;
        }
        v70 = v133;
        if (v133 >= (unint64_t)HIDWORD(v133))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v134, v133 + 1, 4);
          v70 = v133;
        }
        *((_DWORD *)v132 + v70) = v60;
        LODWORD(v133) = v133 + 1;
        ++v60;
        v61 = (mlir::Value *)((char *)v61 + 8);
        v63 -= 8;
        if (!v63)
          goto LABEL_114;
      }
      v66 = *(_QWORD *)(*(_QWORD *)v61 + 8) & 7;
      if (*(_QWORD *)v61)
        v67 = v66 == 6;
      else
        v67 = 0;
      if (v67)
        v66 = *(_QWORD *)(*(_QWORD *)v61 + 16) + 6;
      v68 = *(unsigned int *)(v16 + 44);
      v69 = (v68 & 0x7FFFFF) != 0
          ? ((v62 + 16 * ((v68 >> 23) & 1) + ((v68 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *(unsigned int *)(v16 + 40)
          : 0;
      v73 = *(_QWORD *)(v69 + 24);
      v71 = v69 + 24;
      v72 = v73;
      v74 = v73 - 8;
      v75 = !v73 || v72 == v71;
      v76 = v75 ? 0 : v74;
      ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v76 + 32));
      if (*(_QWORD *)(*(_QWORD *)(v77 + 72) + 32 * v66 + 24) != *(_QWORD *)&v135[8 * v60])
        break;
      v78 = *(_QWORD *)(((v62
                        + 16 * (((unint64_t)*(unsigned int *)(v16 + 44) >> 23) & 1)
                        + (((unint64_t)*(unsigned int *)(v16 + 44) >> 21) & 0x7F8)
                        + 7) & 0xFFFFFFFFFFFFFFF8)
                      + 32 * *(unsigned int *)(v16 + 40));
      if (v78)
        v79 = v78 - 8;
      else
        v79 = 0;
      ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v79 + 32));
      v138[v60++] = *(_QWORD *)(*(_QWORD *)(v80 + 72) + 32 * v66 + 24);
      v61 = (mlir::Value *)((char *)v61 + 8);
      v63 -= 8;
      if (!v63)
        goto LABEL_114;
    }
LABEL_118:
    v8 = 0;
    v89 = v132;
    if (v132 == v134)
      goto LABEL_155;
  }
  else
  {
LABEL_114:
    v81 = *(_QWORD *)(a2 + 24);
    v128 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
    v124[0] = *(_QWORD *)(*(_QWORD *)(v16 + 72) + 24);
    v82 = mlir::OpBuilder::create<mlir::arith::AndIOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::detail::TypedValue<mlir::IntegerType>>((mlir::OpBuilder *)(a3 + 1), v81, (uint64_t *)&v128, v124);
    v83 = *(unsigned int *)(a2 + 36);
    v84 = a2 - 16;
    if (!(_DWORD)v83)
      v84 = 0;
    v123 = (uint64_t)v82 - 16;
    v124[0] = v84;
    v124[1] = v83;
    mlir::OperandRange::getTypes(v124, (uint64_t *)&v128);
    v85 = mlir::OpBuilder::create<mlir::scf::IfOp,mlir::ValueTypeRange<mlir::ResultRange>,mlir::Value &>((mlir::OpBuilder *)(a3 + 1), v81, (uint64_t *)&v128, &v123);
    v86 = v85;
    v87 = *((unsigned int *)v85 + 11);
    v122 = v81;
    if ((v87 & 0x7FFFFF) != 0)
      v88 = (((unint64_t)v85 + 16 * ((v87 >> 23) & 1) + ((v87 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *((unsigned int *)v85 + 10);
    else
      v88 = 0;
    mlir::ValueRange::ValueRange(v131, 0, 0);
    Block = mlir::OpBuilder::createBlock(a3 + 1, v88, 0, v131[0], v131[1], 0, 0);
    v128 = v130;
    v129 = 0x600000000;
    v91 = *((unsigned int *)v86 + 9);
    if ((_DWORD)v91)
      v92 = (ZinIrHalH13g *)((char *)v86 - 16);
    else
      v92 = 0;
    llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator,void>((uint64_t)&v128, (uint64_t)v130, v92, 0, v92, v91);
    v93 = *((_QWORD *)v86 + 2);
    ZinIrHalH13g::~ZinIrHalH13g(v86);
    a3[3] = v93;
    a3[4] = v94;
    if ((_DWORD)v133)
    {
      v95 = (unsigned int *)v132;
      v96 = 4 * v133;
      do
      {
        v97 = *v95++;
        v98 = *(_QWORD *)(a2 + 24);
        v124[0] = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
        v99 = 8 * v97;
        v100 = mlir::OpBuilder::create<mlir::arith::SelectOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 1), v98, v124, &v138[(unint64_t)v99 / 8], (uint64_t *)&v135[v99]);
        *(_QWORD *)((char *)v128 + v99) = (char *)v100 - 16;
        v96 -= 4;
      }
      while (v96);
    }
    v101 = *(_QWORD *)(((v16
                       + 16 * (((unint64_t)*(unsigned int *)(v16 + 44) >> 23) & 1)
                       + (((unint64_t)*(unsigned int *)(v16 + 44) >> 21) & 0x7F8)
                       + 71) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * *(unsigned int *)(v16 + 40));
    if (v101)
      v102 = v101 - 8;
    else
      v102 = 0;
    mlir::ValueRange::ValueRange(v127, 0, 0);
    mlir::RewriterBase::mergeBlocks((uint64_t)a3, v102, Block, v127[0], v127[1]);
    v103 = (char *)v86 + 64;
    v104 = *(_QWORD *)((((unint64_t)v86
                       + 16 * (((unint64_t)*((unsigned int *)v86 + 11) >> 23) & 1)
                       + (((unint64_t)*((unsigned int *)v86 + 11) >> 21) & 0x7F8)
                       + 71) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * *((unsigned int *)v86 + 10));
    if (v104)
      v105 = v104 - 8;
    else
      v105 = 0;
    a3[3] = v105;
    a3[4] = v105 + 32;
    v106 = *(_QWORD *)(((unint64_t)&v103[16 * (((unint64_t)*((unsigned int *)v86 + 11) >> 23) & 1)
                                              + 7
                                              + (((unint64_t)*((unsigned int *)v86 + 11) >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
                     + 32 * *((unsigned int *)v86 + 10));
    if (v106)
      v107 = v106 - 8;
    else
      v107 = 0;
    ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v107 + 32));
    v109 = v108;
    v110 = mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(v108 + 24), (uint64_t)&v138);
    (*(void (**)(_QWORD *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v109, v110);
    if ((_DWORD)v136)
    {
      v111 = *((unsigned int *)v86 + 11);
      if ((v111 & 0x7FFFFF) != 0)
        v112 = ((unint64_t)&v103[16 * ((v111 >> 23) & 1) + 7 + ((v111 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
             + 32 * *((unsigned int *)v86 + 10);
      else
        v112 = 0;
      v113 = v112 + 24;
      mlir::ValueRange::ValueRange(v126, 0, 0);
      mlir::OpBuilder::createBlock(a3 + 1, v113, 0, v126[0], v126[1], 0, 0);
      v114 = *((unsigned int *)v86 + 11);
      if ((v114 & 0x7FFFFF) != 0)
        v115 = ((unint64_t)&v103[16 * ((v114 >> 23) & 1) + 7 + ((v114 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
             + 32 * *((unsigned int *)v86 + 10);
      else
        v115 = 0;
      v118 = *(_QWORD *)(v115 + 24);
      v116 = v115 + 24;
      v117 = v118;
      v119 = v118 - 8;
      if (v118)
        v120 = v117 == v116;
      else
        v120 = 1;
      if (v120)
        v121 = 0;
      else
        v121 = v119;
      a3[3] = v121;
      a3[4] = v121 + 32;
      mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(a3 + 1), v122, (uint64_t)&v135);
    }
    mlir::ValueRange::ValueRange(v125, (uint64_t)v128, v129);
    (*(void (**)(_QWORD *, uint64_t, unint64_t, unint64_t))(*a3 + 24))(a3, a2, v125[0], v125[1]);
    if (v128 != v130)
      free(v128);
    v8 = 1;
    v89 = v132;
    if (v132 == v134)
      goto LABEL_155;
  }
  free(v89);
LABEL_155:
  if (v135 != v137)
    free(v135);
  if (v138 != v140)
    free(v138);
  return v8;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::AndIOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::detail::TypedValue<mlir::IntegerType>>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.andi", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"arith.andi";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::arith::AndIOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::AndIOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::IfOp,mlir::ValueTypeRange<mlir::ResultRange>,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t NextResultAtOffset;
  uint64_t v12;
  uint64_t v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  unint64_t v20[2];
  unsigned int v21[76];
  uint64_t v22[4];
  __int16 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.if", (const unsigned __int8 *)6, Context);
  if (!v10)
  {
    v23 = 1283;
    v22[2] = (uint64_t)"scf.if";
    v22[3] = 6;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v22, (uint64_t *)&v18, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  NextResultAtOffset = *a3;
  v12 = a3[1];
  v13 = a3[3];
  if (v12)
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v12);
  mlir::ValueRange::ValueRange((unint64_t *)v22, NextResultAtOffset, v13 - v12);
  mlir::TypeRange::TypeRange(v20, v22[0], v22[1]);
  mlir::scf::IfOp::build(a1, v21, v20[0], v20[1], *a4, 0, 0);
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v15;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::SelectOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.select", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"arith.select";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::arith::SelectOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::SelectOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t *llvm::SmallVectorImpl<mlir::Value>::insert<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator,void>(uint64_t a1, uint64_t a2, mlir::detail::OpResultImpl *this, uint64_t a4, mlir::detail::OpResultImpl *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t *v23;
  BOOL v24;
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 *v37;
  _OWORD *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t *v42;

  v8 = a4;
  v11 = *(_QWORD *)a1;
  v12 = (a2 - *(_QWORD *)a1) >> 3;
  v14 = *(unsigned int *)(a1 + 8);
  v13 = *(unsigned int *)(a1 + 12);
  v15 = *(_DWORD *)(a1 + 8);
  v16 = a6 - a4;
  v17 = a6 - a4 + v14;
  if (*(_QWORD *)a1 + 8 * v14 != a2)
  {
    if (v17 > v13)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v17, 8);
      v11 = *(_QWORD *)a1;
      v14 = *(unsigned int *)(a1 + 8);
      v15 = *(_DWORD *)(a1 + 8);
    }
    v18 = (uint64_t *)(v11 + 8 * v12);
    v19 = v12;
    v20 = (uint64_t *)(v11 + 8 * v14);
    v21 = v20 - v18;
    if (v21 < v16)
    {
      v22 = v15 + v16;
      *(_DWORD *)(a1 + 8) = v22;
      if (v19 != v14)
      {
        memcpy((void *)(v11 + 8 * v22 - 8 * v21), v18, (char *)v20 - (char *)v18);
        v23 = v18;
        do
        {
          *v23++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
          --v21;
        }
        while (v21);
      }
      if (this != a5 || v8 != a6)
      {
        if (this != a5)
        {
          while (1)
            *v20++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
        }
        do
          *v20++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
        while (a6 != v8);
      }
      return v18;
    }
    v26 = 8 * v16;
    v27 = v14 + ((uint64_t)(8 * v16) >> 3);
    v28 = v14;
    if (v27 > *(unsigned int *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v27, 8);
      v28 = *(unsigned int *)(a1 + 8);
      v15 = *(_DWORD *)(a1 + 8);
    }
    v29 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
    if (a6 == v8)
      goto LABEL_33;
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    v31 = 8 * a6;
    v32 = 8 * a6 - 8 * v8 - 8;
    if (v32 >= 0x98)
    {
      v34 = 8 * v28 + *(_QWORD *)a1;
      v33 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
      if ((unint64_t)(v31 - (v11 + 8 * (v8 + v14)) + v34) >= 0x20)
      {
        v35 = (v32 >> 3) + 1;
        v36 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        v30 = (_QWORD *)((char *)v30 + v36 * 8);
        v33 = &v29[v36];
        v37 = (__int128 *)(8 * v8 + 8 * v14 - v31 + v11 + 16);
        v38 = (_OWORD *)(v34 + 16);
        v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v40 = *v37;
          *(v38 - 1) = *(v37 - 1);
          *v38 = v40;
          v37 += 2;
          v38 += 2;
          v39 -= 4;
        }
        while (v39);
        if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_33;
      }
    }
    else
    {
      v33 = &v20[v26 / 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      v41 = *v33++;
      *v30++ = v41;
    }
    while (v33 != v20);
LABEL_33:
    *(_DWORD *)(a1 + 8) = v15 + v16;
    if (v29 != v18)
      memmove(&v18[(unint64_t)v26 / 8], v18, (char *)&v20[v26 / 0xFFFFFFFFFFFFFFF8] - (char *)v18);
    if (this != a5 || a6 != v8)
    {
      if (this != a5)
      {
        while (1)
          *v18++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
      }
      v42 = v18;
      do
        *v42++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
      while (a6 != v8);
    }
    return v18;
  }
  if (v17 > v13)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v17, 8);
    v15 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  v24 = this != a5;
  if (a6 != v8 || this != a5)
  {
    v25 = (uint64_t *)(v11 + 8 * v15);
    if (v24)
    {
      while (1)
        *v25++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
    }
    do
      *v25++ = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v8++);
    while (a6 != v8);
    v15 = *(_DWORD *)(a1 + 8);
    v11 = *(_QWORD *)a1;
  }
  *(_DWORD *)(a1 + 8) = v15 + v16;
  return (uint64_t *)(v11 + 8 * v12);
}

void `anonymous namespace'::ConditionPropagation::~ConditionPropagation(_anonymous_namespace_::ConditionPropagation *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ConditionPropagation::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  _QWORD *v7;
  char v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  mlir::Region *v13;
  _QWORD *v14;
  mlir::Block *v15;
  mlir::Region *Parent;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  mlir::Block *v24;
  mlir::Region *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *IntegerAttr;
  uint64_t I1Type;

  I1Type = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&I1Type);
  if (DefiningOp && (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)) & 1) != 0)
    return 0;
  I1Type = mlir::Builder::getI1Type((mlir::Builder *)(a3 + 8));
  v7 = **(_QWORD ***)(*(_QWORD *)(a2 + 72) + 24);
  if (v7)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = a2 + 64;
    while (1)
    {
      v12 = *(unsigned int *)(a2 + 44);
      if ((v12 & 0x7FFFFF) != 0)
      {
        v13 = (mlir::Region *)(((v11 + 16 * ((v12 >> 23) & 1) + ((v12 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                             + 32 * *(unsigned int *)(a2 + 40));
        v14 = (_QWORD *)*v7;
        v15 = *(mlir::Block **)(v7[2] + 16);
        if (v15)
          goto LABEL_11;
      }
      else
      {
        v13 = 0;
        v14 = (_QWORD *)*v7;
        v15 = *(mlir::Block **)(v7[2] + 16);
        if (v15)
        {
LABEL_11:
          Parent = (mlir::Region *)mlir::Block::getParent(v15);
          if (v13 == Parent)
            goto LABEL_16;
          goto LABEL_15;
        }
      }
      Parent = 0;
      if (!v13)
        goto LABEL_16;
LABEL_15:
      if (mlir::Region::isProperAncestor(v13, Parent))
      {
LABEL_16:
        if (!v9)
        {
          v17 = *(_QWORD *)(a2 + 24);
          IntegerAttr = (_QWORD *)mlir::Builder::getIntegerAttr(a3 + 8, I1Type, 1);
          v9 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::IntegerAttr>((mlir::OpBuilder *)(a3 + 8), v17, &I1Type, &IntegerAttr)- 16);
        }
        v18 = v9;
        v19 = v7[2];
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, v19);
        v20 = (_QWORD *)v7[1];
        if (v20)
        {
          *v20 = *v7;
          if (*v7)
            *(_QWORD *)(*v7 + 8) = v7[1];
        }
        v7[3] = v9;
        v7[1] = v9;
        v21 = *v9;
        *v7 = *v9;
        if (!v21)
          goto LABEL_7;
        goto LABEL_6;
      }
      v22 = *(unsigned int *)(a2 + 44);
      if ((v22 & 0x7FFFFF) != 0)
      {
        v23 = ((v11 + 16 * ((v22 >> 23) & 1) + ((v22 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
            + 32 * *(unsigned int *)(a2 + 40)
            + 24;
        v24 = *(mlir::Block **)(v7[2] + 16);
        if (v24)
          goto LABEL_25;
      }
      else
      {
        v23 = 24;
        v24 = *(mlir::Block **)(v7[2] + 16);
        if (v24)
        {
LABEL_25:
          v25 = (mlir::Region *)mlir::Block::getParent(v24);
          if ((mlir::Region *)v23 != v25 && !mlir::Region::isProperAncestor((mlir::Region *)v23, v25))
            goto LABEL_8;
          goto LABEL_30;
        }
      }
      if (!mlir::Region::isProperAncestor((mlir::Region *)v23, 0))
        goto LABEL_8;
LABEL_30:
      if (!v10)
      {
        v26 = *(_QWORD *)(a2 + 24);
        IntegerAttr = (_QWORD *)mlir::Builder::getIntegerAttr(a3 + 8, I1Type, 0);
        v10 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::IntegerAttr>((mlir::OpBuilder *)(a3 + 8), v26, &I1Type, &IntegerAttr)- 16);
      }
      v18 = v10;
      v19 = v7[2];
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, v19);
      v27 = (_QWORD *)v7[1];
      if (v27)
      {
        *v27 = *v7;
        if (*v7)
          *(_QWORD *)(*v7 + 8) = v7[1];
      }
      v7[3] = v10;
      v7[1] = v10;
      v21 = *v10;
      *v7 = *v10;
      if (!v21)
        goto LABEL_7;
LABEL_6:
      *(_QWORD *)(v21 + 8) = v7;
LABEL_7:
      *v18 = v7;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 80))(a3, v19);
      v8 = 1;
LABEL_8:
      v7 = v14;
      if (!v14)
        return v8 & 1;
    }
  }
  v8 = 0;
  return v8 & 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::IntegerAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD **a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20[4];
  __int16 v21;
  _QWORD v22[39];

  v22[38] = *MEMORY[0x24BDAC8D0];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v21 = 1283;
    v20[2] = (uint64_t)"arith.constant";
    v20[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  v12 = *a4;
  if (v12)
    v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v12 + 8);
  else
    v13 = 0;
  mlir::arith::ConstantOp::build((uint64_t)a1, (uint64_t)v22, v11, (uint64_t)v12, v13);
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

void `anonymous namespace'::ConvertTrivialIfToSelect::~ConvertTrivialIfToSelect(_anonymous_namespace_::ConvertTrivialIfToSelect *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ConvertTrivialIfToSelect::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  mlir::Block *v32;
  unint64_t v33;
  mlir::Block *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  ZinIrHalH13g *v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  mlir::Block *v63;
  unint64_t v64;
  mlir::Block *v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  ZinIrHalH13g *v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  BOOL v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  ZinIrHalH13g *v97;
  uint64_t v99;
  uint64_t v100;
  mlir::OpBuilder *v101;
  char *v102;
  char *v103;
  uint64_t v104;
  unint64_t v105[2];
  void *v106;
  uint64_t v107;
  _BYTE v108[48];
  void *v109;
  uint64_t v110;
  _BYTE v111[48];
  void *v112;
  uint64_t v113;
  _BYTE v114[48];
  _QWORD *v115;
  uint64_t v116;
  _QWORD v117[8];

  v117[6] = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(a2 + 36))
    return 0;
  v5 = a2 + 64;
  v104 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v6 = *(_QWORD *)(((a2 + 64 + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8) + 23) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40));
  if (v6)
    v7 = v6 - 8;
  else
    v7 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v7 + 32));
  if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
  {
    v9 = *(_QWORD *)(v8 + 72);
    v10 = *(unsigned int *)(v8 + 68);
    v11 = *(unsigned int *)(a2 + 44);
    if ((v11 & 0x7FFFFF) != 0)
    {
LABEL_7:
      v12 = ((v5 + 16 * ((v11 >> 23) & 1) + ((v11 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *(unsigned int *)(a2 + 40);
      goto LABEL_11;
    }
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = *(unsigned int *)(a2 + 44);
    if ((v11 & 0x7FFFFF) != 0)
      goto LABEL_7;
  }
  v12 = 0;
LABEL_11:
  v16 = *(_QWORD *)(v12 + 24);
  v14 = v12 + 24;
  v15 = v16;
  v17 = v16 - 8;
  if (v16)
    v18 = v15 == v14;
  else
    v18 = 1;
  if (v18)
    v19 = 0;
  else
    v19 = v17;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v19 + 32));
  v21 = "owGraphRK15ZinIrParametersE3$_5";
  v100 = v9;
  v22 = 0;
  if ((*(_BYTE *)(v20 + 46) & 0x80) == 0)
  {
    v99 = 0;
    v23 = 0;
    v115 = v117;
    v116 = 0x600000000;
    if (*(_DWORD *)(a2 + 36))
      goto LABEL_39;
LABEL_36:
    v13 = 0;
    v37 = v115;
    if (v115 != v117)
      goto LABEL_104;
    return v13;
  }
  v23 = *(_QWORD *)(v20 + 72);
  v24 = *(unsigned int *)(v20 + 68);
  v115 = v117;
  v116 = 0x600000000;
  v99 = v24;
  if (!v10 || !(_DWORD)v24)
  {
    if (*(_DWORD *)(a2 + 36))
      goto LABEL_39;
    goto LABEL_36;
  }
  v25 = 0;
  v26 = v9 + 24;
  v27 = v10;
  v28 = 32 * v10 - 32;
  v29 = 32 * v24 - 32;
  do
  {
    v30 = *(_QWORD *)(v23 + v25 + 24);
    v112 = *(void **)(v26 + v25);
    v113 = v30;
    v31 = *(unsigned int *)(a2 + 44);
    if ((v31 & 0x7FFFFF) != 0)
    {
      v32 = (mlir::Block *)(((v5 + 16 * ((v31 >> 23) & 1) + ((v31 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                          + 32 * *(unsigned int *)(a2 + 40));
      if (v32 == mlir::Value::getParentRegion((mlir::Value *)&v112))
        goto LABEL_29;
    }
    else if (!mlir::Value::getParentRegion((mlir::Value *)&v112))
    {
      goto LABEL_29;
    }
    v33 = *(unsigned int *)(a2 + 44);
    if ((v33 & 0x7FFFFF) != 0)
    {
      v34 = (mlir::Block *)(((v5 + 16 * ((v33 >> 23) & 1) + ((v33 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                          + 32 * *(unsigned int *)(a2 + 40)
                          + 24);
      if (v34 != mlir::Value::getParentRegion((mlir::Value *)&v113))
        goto LABEL_32;
    }
    else if (mlir::Value::getParentRegion((mlir::Value *)&v113) != (mlir::Block *)24)
    {
      goto LABEL_32;
    }
LABEL_29:
    v35 = *((_QWORD *)v112 + 1);
    v36 = v116;
    if (v116 >= (unint64_t)HIDWORD(v116))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v115, v117, v116 + 1, 8);
      v36 = v116;
    }
    v115[v36] = v35 & 0xFFFFFFFFFFFFFFF8;
    LODWORD(v116) = v116 + 1;
LABEL_32:
    if (v28 == v25)
      break;
    v18 = v29 == v25;
    v25 += 32;
  }
  while (!v18);
  v22 = 1;
  v10 = v27;
  v21 = "ZN8ZinIrOpt28VarianceCalculationDetectionEP21ZinIrControlFlowGraphRK15ZinIrParametersE3$_5" + 59;
  if ((_DWORD)v116 == *(_DWORD *)(a2 + 36))
    goto LABEL_36;
LABEL_39:
  v38 = *(_QWORD *)(a2 + 24);
  LOBYTE(v112) = 0;
  v101 = (mlir::OpBuilder *)(a3 + 1);
  v39 = mlir::OpBuilder::create<mlir::scf::IfOp,llvm::SmallVector<mlir::Type,6u> &,mlir::detail::TypedValue<mlir::IntegerType>,BOOL>((mlir::OpBuilder *)(a3 + 1), v38, (uint64_t)&v115, &v104, (unsigned __int8 *)&v112);
  v40 = (char *)v39 + 64;
  v41 = *((unsigned int *)v39 + 10);
  v42 = *((unsigned int *)v39 + 11);
  v43 = (v42 >> 23) & 1;
  v44 = (v42 >> 21) & 0x7F8;
  v45 = *(_QWORD *)((((unint64_t)v39 + 16 * v43 + v44 + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v41);
  if (v45)
  {
    (*(void (**)(_QWORD *, uint64_t))(*a3 + 48))(a3, v45 - 8);
    v41 = *((unsigned int *)v39 + 10);
    v46 = *((unsigned int *)v39 + 11);
    v43 = (v46 >> 23) & 1;
    v44 = (v46 >> 21) & 0x7F8;
  }
  mlir::Region::takeBody((mlir::Region *)(((unint64_t)&v40[16 * v43 + 7 + v44] & 0xFFFFFFFFFFFFFFF8) + 32 * v41), (mlir::Region *)(((v5+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a2 + 40)));
  v47 = *((unsigned int *)v39 + 11);
  if ((v47 & 0x7FFFFF) != 0)
  {
    v48 = ((unint64_t)&v40[16 * ((v47 >> 23) & 1) + 7 + ((v47 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v39 + 10)
        + 24;
    v49 = *(unsigned int *)(a2 + 44);
    if ((v49 & 0x7FFFFF) != 0)
      goto LABEL_43;
LABEL_45:
    v50 = 0;
  }
  else
  {
    v48 = 24;
    v49 = *(unsigned int *)(a2 + 44);
    if ((v49 & 0x7FFFFF) == 0)
      goto LABEL_45;
LABEL_43:
    v50 = ((v5 + 16 * ((v49 >> 23) & 1) + ((v49 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a2 + 40);
  }
  mlir::Region::takeBody((mlir::Region *)v48, (mlir::Region *)(v50 + 24));
  v51 = *(unsigned int *)(a2 + 36);
  v112 = v114;
  v52 = *((_QWORD *)v21 + 100);
  v113 = v52;
  if ((_DWORD)v51)
  {
    if (v51 < 7)
    {
      v53 = 0;
      v54 = v51;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v114, v51, 8);
      v53 = v113;
      v54 = v51 - v113;
      if (v51 == v113)
      {
LABEL_52:
        LODWORD(v113) = v51;
        goto LABEL_53;
      }
    }
    bzero((char *)v112 + 8 * v53, 8 * v54);
    goto LABEL_52;
  }
LABEL_53:
  v109 = v111;
  v110 = v52;
  v106 = v108;
  v107 = v52;
  v55 = *((_QWORD *)v39 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v39);
  a3[3] = v55;
  a3[4] = v56;
  if (v22)
  {
    v57 = 0;
    v58 = (uint64_t *)(v100 + 24);
    v59 = (uint64_t *)(v23 + 24);
    v60 = v10 - 1;
    do
    {
      v61 = *v58;
      v102 = (char *)*v59;
      v103 = (char *)v61;
      v62 = *((unsigned int *)v39 + 11);
      if ((v62 & 0x7FFFFF) != 0)
      {
        v63 = (mlir::Block *)(((unint64_t)&v40[16 * ((v62 >> 23) & 1) + 7 + ((v62 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
                            + 32 * *((unsigned int *)v39 + 10));
        if (v63 == mlir::Value::getParentRegion((mlir::Value *)&v103))
          goto LABEL_66;
      }
      else if (!mlir::Value::getParentRegion((mlir::Value *)&v103))
      {
        goto LABEL_66;
      }
      v64 = *((unsigned int *)v39 + 11);
      if ((v64 & 0x7FFFFF) != 0)
      {
        v65 = (mlir::Block *)(((unint64_t)&v40[16 * ((v64 >> 23) & 1) + 7 + ((v64 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
                            + 32 * *((unsigned int *)v39 + 10)
                            + 24);
        if (v65 == mlir::Value::getParentRegion((mlir::Value *)&v102))
          goto LABEL_66;
      }
      else if (mlir::Value::getParentRegion((mlir::Value *)&v102) == (mlir::Block *)24)
      {
LABEL_66:
        v67 = v110;
        v68 = (uint64_t)v39 - 24 * (v110 - 5) - 96;
        if (v110 <= 5)
          v68 = (uint64_t)v39 - 16 * v110 - 16;
        *((_QWORD *)v112 + v57) = v68;
        v69 = (uint64_t)v103;
        if (v67 >= HIDWORD(v110))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v111, v67 + 1, 8);
          v67 = v110;
        }
        *((_QWORD *)v109 + v67) = v69;
        LODWORD(v110) = v110 + 1;
        v70 = (uint64_t)v102;
        v71 = v107;
        if (v107 >= (unint64_t)HIDWORD(v107))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, v107 + 1, 8);
          v71 = v107;
        }
        *((_QWORD *)v106 + v71) = v70;
        LODWORD(v107) = v107 + 1;
        if (v60 == v57)
          break;
        goto LABEL_56;
      }
      v66 = v103;
      if (v103 != v102)
        v66 = (char *)mlir::OpBuilder::create<mlir::arith::SelectOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Value &,mlir::Value &>(v101, *(_QWORD *)(a2 + 24), &v104, (uint64_t *)&v103, (uint64_t *)&v102)- 16;
      *((_QWORD *)v112 + v57) = v66;
      if (v60 == v57)
        break;
LABEL_56:
      v58 += 4;
      v59 += 4;
      v18 = v99 - 1 == v57++;
    }
    while (!v18);
  }
  v72 = *(_QWORD *)(((unint64_t)&v40[16 * (((unint64_t)*((unsigned int *)v39 + 11) >> 23) & 1)
                                          + 7
                                          + (((unint64_t)*((unsigned int *)v39 + 11) >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v39 + 10));
  if (v72)
    v73 = v72 - 8;
  else
    v73 = 0;
  a3[3] = v73;
  a3[4] = v73 + 32;
  v74 = *(_QWORD *)(((unint64_t)&v40[16 * (((unint64_t)*((unsigned int *)v39 + 11) >> 23) & 1)
                                          + 7
                                          + (((unint64_t)*((unsigned int *)v39 + 11) >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v39 + 10));
  if (v74)
    v75 = v74 - 8;
  else
    v75 = 0;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v75 + 32));
  v77 = v76;
  v78 = mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(v101, *(_QWORD *)(v76 + 24), (uint64_t)&v109);
  (*(void (**)(_QWORD *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v77, v78);
  v79 = *((unsigned int *)v39 + 11);
  if ((v79 & 0x7FFFFF) != 0)
    v80 = ((unint64_t)&v40[16 * ((v79 >> 23) & 1) + 7 + ((v79 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v39 + 10);
  else
    v80 = 0;
  v83 = *(_QWORD *)(v80 + 24);
  v81 = v80 + 24;
  v82 = v83;
  v84 = v83 - 8;
  if (v83)
    v85 = v82 == v81;
  else
    v85 = 1;
  if (v85)
    v86 = 0;
  else
    v86 = v84;
  a3[3] = v86;
  a3[4] = v86 + 32;
  v87 = *((unsigned int *)v39 + 11);
  if ((v87 & 0x7FFFFF) != 0)
    v88 = ((unint64_t)&v40[16 * ((v87 >> 23) & 1) + 7 + ((v87 >> 21) & 0x7F8)] & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v39 + 10);
  else
    v88 = 0;
  v91 = *(_QWORD *)(v88 + 24);
  v89 = v88 + 24;
  v90 = v91;
  v92 = v91 - 8;
  if (v91)
    v93 = v90 == v89;
  else
    v93 = 1;
  if (v93)
    v94 = 0;
  else
    v94 = v92;
  ZinIrHalH13g::~ZinIrHalH13g(*(ZinIrHalH13g **)(v94 + 32));
  v96 = v95;
  v97 = mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>(v101, *(_QWORD *)(v95 + 24), (uint64_t)&v106);
  (*(void (**)(_QWORD *, uint64_t, ZinIrHalH13g *))(*a3 + 32))(a3, v96, v97);
  mlir::ValueRange::ValueRange(v105, (uint64_t)v112, v113);
  (*(void (**)(_QWORD *, uint64_t, unint64_t, unint64_t))(*a3 + 24))(a3, a2, v105[0], v105[1]);
  if (v106 != v108)
    free(v106);
  if (v109 != v111)
    free(v109);
  if (v112 != v114)
    free(v112);
  v13 = 1;
  v37 = v115;
  if (v115 != v117)
LABEL_104:
    free(v37);
  return v13;
}

void `anonymous namespace'::RemoveEmptyElseBranch::~RemoveEmptyElseBranch(_anonymous_namespace_::RemoveEmptyElseBranch *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::RemoveEmptyElseBranch::matchAndRewrite(uint64_t a1, mlir::Operation *a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;

  if (*((_DWORD *)a2 + 9))
    return 0;
  v3 = *((unsigned int *)a2 + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (((unint64_t)a2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)a2 + 10);
    v5 = *(_QWORD *)(v4 + 24);
    if (v5 != v4 + 24 && v5 != 0)
    {
LABEL_14:
      v8 = *(_QWORD *)(v5 + 32);
      v9 = v5 + 24;
      if (v8 != v9 && *(_QWORD *)(v8 + 8) == v9)
        mlir::Operation::cloneWithoutRegions(a2);
    }
  }
  else
  {
    v5 = MEMORY[0x18];
    if (MEMORY[0x18] != 24 && MEMORY[0x18] != 0)
      goto LABEL_14;
  }
  return 0;
}

uint64_t sub_2074DA57C(mlir::Operation *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  uint64_t v15;
  mlir::OpBuilder *v16;
  mlir::Operation *v17;
  unint64_t v18;

  v17 = mlir::OpBuilder::insert(v16, a1);
  v18 = (((unint64_t)v17
        + 16 * (((unint64_t)*((unsigned int *)v17 + 11) >> 23) & 1)
        + (((unint64_t)*((unsigned int *)v17 + 11) >> 21) & 0x7F8)
        + 71) & 0xFFFFFFFFFFFFFFF8)
      + 32 * *((unsigned int *)v17 + 10);
  (**(void (***)(uint64_t, unint64_t, unint64_t, _QWORD))v15)(v15, ((v14+ 16 * (((unint64_t)*(unsigned int *)(v14 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(v14 + 44) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(v14 + 40), v18, *(_QWORD *)(v18 + 8));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v15 + 40))(v15, v14);
  return 1;
}

void `anonymous namespace'::RemoveStaticCondition::~RemoveStaticCondition(_anonymous_namespace_::RemoveStaticCondition *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::RemoveStaticCondition::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v9;
  unint64_t v10;
  _BOOL4 v11;
  _BOOL4 Value;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  ZinIrHalH13g **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28[2];
  unint64_t v29[2];
  void *v30;
  uint64_t v31;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v26 = 0;
  v27 = v5;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v27);
  if (DefiningOp)
  {
    v7 = DefiningOp;
    if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    {
      v30 = v32;
      v31 = 0x100000000;
      mlir::Operation::fold(v7, 0, 0, (uint64_t)&v30);
      v8 = *(_QWORD *)v30;
      v9 = mlir::BoolAttr::classof((_QWORD *)(*(_QWORD *)v30 & 0xFFFFFFFFFFFFFFF8));
      v10 = v8 & 0xFFFFFFFFFFFFFFF8;
      v11 = (v8 & 0xFFFFFFFFFFFFFFF8) != 0 && v9;
      if (v11)
        v26 = v10;
      if (v30 != v32)
        free(v30);
      if (v11)
      {
        Value = mlir::BoolAttr::getValue((mlir::BoolAttr *)&v26);
        v13 = *(unsigned int *)(a2 + 44);
        v14 = v13 & 0x7FFFFF;
        if (Value)
        {
          if (v14)
            v15 = ((a2 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40);
          else
            v15 = 0;
          mlir::ValueRange::ValueRange(v29, 0, 0);
          v18 = v29[0];
          v19 = v29[1];
          v20 = *(_QWORD *)(v15 + 8);
          goto LABEL_24;
        }
        if (v14)
        {
          v17 = ((a2 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
              + 32 * *(unsigned int *)(a2 + 40);
          if (*(_QWORD *)(v17 + 24) == v17 + 24)
            goto LABEL_31;
        }
        else
        {
          if (MEMORY[0x18] == 24)
          {
LABEL_31:
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, a2);
            return 1;
          }
          v17 = 0;
        }
        mlir::ValueRange::ValueRange(v28, 0, 0);
        v18 = v28[0];
        v19 = v28[1];
        v20 = *(_QWORD *)(v17 + 32);
LABEL_24:
        if (v20)
          v21 = (ZinIrHalH13g **)(v20 - 8);
        else
          v21 = 0;
        mlir::Block::getTerminator(v21);
        v23 = v22;
        if ((*(_BYTE *)(v22 + 46) & 0x80) != 0)
        {
          v24 = *(_QWORD *)(v22 + 72);
          v25 = *(unsigned int *)(v22 + 68);
        }
        else
        {
          v24 = 0;
          v25 = 0;
        }
        mlir::ValueRange::ValueRange((unint64_t *)&v30, v24, v25);
        mlir::RewriterBase::inlineBlockBefore(a3, (uint64_t)v21, a2, v18, v19);
        (*(void (**)(uint64_t, uint64_t, void *, uint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v30, v31);
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 40))(a3, v23);
        return 1;
      }
    }
  }
  return 0;
}

void `anonymous namespace'::RemoveUnusedResults::~RemoveUnusedResults(_anonymous_namespace_::RemoveUnusedResults *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::RemoveUnusedResults::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t NextResultAtOffset;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  ZinIrHalH13g *v16;
  ZinIrHalH13g *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  ZinIrHalH13g **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  ZinIrHalH13g **v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  unint64_t v55[2];
  void *v56;
  uint64_t v57;
  _BYTE v58[32];
  unint64_t v59[2];
  unint64_t v60[2];
  void *v61;
  uint64_t v62;
  _BYTE v63[32];
  char *v64;
  uint64_t v65;
  _QWORD v66[5];

  v66[4] = *MEMORY[0x24BDAC8D0];
  v64 = (char *)v66;
  v65 = 0x400000000;
  v3 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v3)
    v4 = a2 - 16;
  else
    v4 = 0;
  if (!(_DWORD)v3)
    return 0;
  for (i = 0; i != v3; ++i)
  {
    if (*(_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v4, i))
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, i);
      v9 = v65;
      if (v65 >= (unint64_t)HIDWORD(v65))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v65 + 1, 8);
        v9 = v65;
      }
      *(_QWORD *)&v64[8 * v9] = NextResultAtOffset;
      LODWORD(v65) = v65 + 1;
    }
  }
  v10 = v64;
  if ((_DWORD)v65 == *(_DWORD *)(a2 + 36))
  {
    v11 = 0;
    if (v64 == (char *)v66)
      return v11;
    goto LABEL_75;
  }
  v61 = v63;
  v62 = 0x400000000;
  if ((_DWORD)v65)
  {
    v12 = 0;
    v13 = 8 * v65;
    do
    {
      v14 = *(_QWORD *)(*(_QWORD *)v10 + 8);
      if (v12 >= HIDWORD(v62))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v12 + 1, 8);
        v12 = v62;
      }
      *((_QWORD *)v61 + v12) = v14 & 0xFFFFFFFFFFFFFFF8;
      v12 = v62 + 1;
      LODWORD(v62) = v62 + 1;
      v10 += 8;
      v13 -= 8;
    }
    while (v13);
  }
  v15 = *(_QWORD *)(a2 + 24);
  v56 = *(void **)(*(_QWORD *)(a2 + 72) + 24);
  v16 = mlir::OpBuilder::create<mlir::scf::IfOp,llvm::SmallVector<mlir::Type,4u> &,mlir::detail::TypedValue<mlir::IntegerType>>((mlir::OpBuilder *)(a3 + 8), v15, (uint64_t)&v61, (uint64_t *)&v56);
  v17 = v16;
  v18 = *((unsigned int *)v16 + 11);
  if ((v18 & 0x7FFFFF) != 0)
    v19 = (((unint64_t)v16 + 16 * ((v18 >> 23) & 1) + ((v18 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v16 + 10);
  else
    v19 = 0;
  mlir::ValueRange::ValueRange(v60, 0, 0);
  mlir::OpBuilder::createBlock((_QWORD *)(a3 + 8), v19, 0, v60[0], v60[1], 0, 0);
  v20 = *((unsigned int *)v17 + 11);
  if ((v20 & 0x7FFFFF) != 0)
    v21 = (((unint64_t)v17 + 16 * ((v20 >> 23) & 1) + ((v20 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v17 + 10);
  else
    v21 = 0;
  v22 = v21 + 24;
  mlir::ValueRange::ValueRange(v59, 0, 0);
  mlir::OpBuilder::createBlock((_QWORD *)(a3 + 8), v22, 0, v59[0], v59[1], 0, 0);
  v23 = *(_QWORD *)(((a2
                    + 64
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 8);
  if (v23)
    v24 = v23 - 8;
  else
    v24 = 0;
  v25 = *(_QWORD *)((((unint64_t)v17
                    + 16 * (((unint64_t)*((unsigned int *)v17 + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)v17 + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v17 + 10)
                  + 8);
  if (v25)
    v26 = (ZinIrHalH13g **)(v25 - 8);
  else
    v26 = 0;
  v27 = *(_QWORD *)(((a2
                    + 64
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 32);
  v54 = v27 == 0;
  v28 = v27 - 8;
  if (v54)
    v29 = 0;
  else
    v29 = v28;
  v30 = *(_QWORD *)((((unint64_t)v17
                    + 16 * (((unint64_t)*((unsigned int *)v17 + 11) >> 23) & 1)
                    + (((unint64_t)*((unsigned int *)v17 + 11) >> 21) & 0x7F8)
                    + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v17 + 10)
                  + 32);
  if (v30)
    v31 = (ZinIrHalH13g **)(v30 - 8);
  else
    v31 = 0;
  v32 = *(unsigned int *)(a2 + 36);
  v56 = v58;
  v57 = 0x400000000;
  if ((_DWORD)v32)
  {
    if (v32 < 5)
    {
      v33 = 0;
      v34 = v32;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v58, v32, 8);
      v33 = v57;
      v34 = v32 - v57;
      if (v32 == v57)
        goto LABEL_44;
    }
    bzero((char *)v56 + 8 * v33, 8 * v34);
LABEL_44:
    LODWORD(v57) = v32;
  }
  v35 = v65;
  if ((_DWORD)v65)
  {
    v36 = v64;
    v37 = *(_QWORD *)(*(_QWORD *)v64 + 8) & 7;
    if (*(_QWORD *)v64 && v37 == 6)
      v37 = (*(_DWORD *)(*(_QWORD *)v64 + 16) + 6);
    *((_QWORD *)v56 + v37) = (char *)v17 - 16;
    if ((_DWORD)v35 != 1)
    {
      v38 = *((_QWORD *)v36 + 1);
      v39 = *(_QWORD *)(v38 + 8) & 7;
      if (v38 && v39 == 6)
        v39 = (*(_DWORD *)(v38 + 16) + 6);
      *((_QWORD *)v56 + v39) = (char *)v17 - 32;
      if ((_DWORD)v35 != 2)
      {
        v40 = *((_QWORD *)v36 + 2);
        v41 = *(_QWORD *)(v40 + 8) & 7;
        if (v40 && v41 == 6)
          v41 = (*(_DWORD *)(v40 + 16) + 6);
        *((_QWORD *)v56 + v41) = (char *)v17 - 48;
        if ((_DWORD)v35 != 3)
        {
          v42 = *((_QWORD *)v36 + 3);
          v43 = *(_QWORD *)(v42 + 8) & 7;
          if (v42 && v43 == 6)
            v43 = (*(_DWORD *)(v42 + 16) + 6);
          *((_QWORD *)v56 + v43) = (char *)v17 - 64;
          if ((_DWORD)v35 != 4)
          {
            v44 = *((_QWORD *)v36 + 4);
            v45 = *(_QWORD *)(v44 + 8) & 7;
            if (v44 && v45 == 6)
              v45 = (*(_DWORD *)(v44 + 16) + 6);
            *((_QWORD *)v56 + v45) = (char *)v17 - 80;
            if ((_DWORD)v35 != 5)
            {
              v46 = (char *)v17 - 96;
              v47 = *((_QWORD *)v36 + 5);
              v48 = *(_QWORD *)(v47 + 8) & 7;
              if (v47 && v48 == 6)
                v48 = (*(_DWORD *)(v47 + 16) + 6);
              *((_QWORD *)v56 + v48) = v46;
              if ((_DWORD)v35 != 6)
              {
                v50 = v36 + 48;
                v51 = 8 * v35 - 48;
                v52 = 0x100000001;
                do
                {
                  v53 = *(_QWORD *)(*v50 + 8) & 7;
                  if (*v50)
                    v54 = v53 == 6;
                  else
                    v54 = 0;
                  if (v54)
                    v53 = *(_QWORD *)(*v50 + 16) + 6;
                  *((_QWORD *)v56 + v53) = &v46[-24 * v52];
                  ++v50;
                  ++v52;
                  v51 -= 8;
                }
                while (v51);
              }
            }
          }
        }
      }
    }
  }
  mlir::ValueRange::ValueRange(v55, (uint64_t)v56, v32);
  (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v55[0], v55[1]);
  if (v56 != v58)
    free(v56);
  if (v61 != v63)
    free(v61);
  v11 = 1;
  v10 = v64;
  if (v64 != (char *)v66)
LABEL_75:
    free(v10);
  return v11;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::IfOp,llvm::SmallVector<mlir::Type,4u> &,mlir::detail::TypedValue<mlir::IntegerType>>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.if", (const unsigned __int8 *)6, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"scf.if";
    v17[3] = 6;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::scf::IfOp::build(a1, (unsigned int *)v20, v19[0], v19[1], *a4, 0, 0);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void `anonymous namespace'::RemoveUnusedResults::transferBody(uint64_t a1, ZinIrHalH13g **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v10;
  uint64_t *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[32];
  unint64_t v20[2];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  mlir::ValueRange::ValueRange(v20, 0, 0);
  mlir::RewriterBase::mergeBlocks(a5, a1, (uint64_t)a2, v20[0], v20[1]);
  mlir::Block::getTerminator(a2);
  v11 = v10;
  v17 = v19;
  v18 = 0x400000000;
  if (a4)
  {
    v12 = 0;
    v13 = 8 * a4;
    do
    {
      v14 = *(_QWORD *)(*(_QWORD *)a3 + 8) & 7;
      if (*(_QWORD *)a3)
        v15 = v14 == 6;
      else
        v15 = 0;
      if (v15)
        v14 = (*(_DWORD *)(*(_QWORD *)a3 + 16) + 6);
      v16 = *(_QWORD *)(v11[9] + 32 * v14 + 24);
      if (v12 >= HIDWORD(v18))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v12 + 1, 8);
        v12 = v18;
      }
      *((_QWORD *)v17 + v12) = v16;
      v12 = v18 + 1;
      LODWORD(v18) = v18 + 1;
      a3 += 8;
      v13 -= 8;
    }
    while (v13);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a5 + 72))(a5, v11);
  mlir::ValueRange::ValueRange((unint64_t *)&v21, (uint64_t)v17, v18);
  mlir::Operation::setOperands(v11, v21, v22);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a5 + 80))(a5, v11);
  if (v17 != v19)
    free(v17);
}

void `anonymous namespace'::ReplaceIfYieldWithConditionOrValue::~ReplaceIfYieldWithConditionOrValue(_anonymous_namespace_::ReplaceIfYieldWithConditionOrValue *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::ReplaceIfYieldWithConditionOrValue::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  ZinIrHalH13g **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  ZinIrHalH13g **v11;
  uint64_t v12;
  uint64_t v13;
  mlir::OpBuilder *v14;
  uint64_t I1Type;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD **NextResultAtOffset;
  uint64_t DefiningOp;
  uint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  _BOOL4 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BOOL4 v35;
  _BOOL4 v36;
  _BOOL4 Value;
  _BOOL4 v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t IntegerAttr;
  ZinIrHalH13g *v44;
  _QWORD **v45;
  _QWORD *v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD **v50;
  _QWORD *v51;
  uint64_t *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t Values;
  uint64_t v57;
  _BOOL4 v58;
  uint64_t v59;
  mlir::OpBuilder *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  void *v68;
  uint64_t v69;
  _QWORD v70[3];

  v70[1] = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(a2 + 36))
    return 0;
  v5 = a2 + 64;
  v6 = *(_QWORD *)(((a2
                   + 64
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40));
  if (v6)
    v7 = (ZinIrHalH13g **)(v6 - 8);
  else
    v7 = 0;
  mlir::Block::getTerminator(v7);
  v9 = v8;
  v10 = *(_QWORD *)(((v5
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 24);
  if (v10)
    v11 = (ZinIrHalH13g **)(v10 - 8);
  else
    v11 = 0;
  mlir::Block::getTerminator(v11);
  v13 = v12;
  v14 = (mlir::OpBuilder *)(a3 + 1);
  a3[3] = *(_QWORD *)(a2 + 16);
  a3[4] = a2;
  I1Type = mlir::Builder::getI1Type((mlir::Builder *)(a3 + 1));
  if ((*(_BYTE *)(v9 + 46) & 0x80) != 0)
  {
    v16 = *(unsigned int *)(v9 + 68);
    v17 = *(_QWORD *)(v9 + 72);
    if ((*(_BYTE *)(v13 + 46) & 0x80) != 0)
      goto LABEL_10;
  }
  else
  {
    v17 = 0;
    v16 = 0;
    if ((*(_BYTE *)(v13 + 46) & 0x80) != 0)
    {
LABEL_10:
      v18 = *(unsigned int *)(v13 + 68);
      v19 = *(_QWORD *)(v13 + 72);
      v20 = 0;
      v21 = *(unsigned int *)(a2 + 36);
      if ((_DWORD)v21)
        v22 = a2 - 16;
      else
        v22 = 0;
      if (v16)
        goto LABEL_14;
      return v20 & 1;
    }
  }
  v19 = 0;
  v18 = 0;
  v20 = 0;
  v21 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v21)
    v22 = a2 - 16;
  else
    v22 = 0;
  if (v16)
  {
LABEL_14:
    if (v18)
    {
      v59 = I1Type;
      v60 = v14;
      v61 = a2;
      if ((_DWORD)v21)
      {
        v20 = 0;
        v23 = 0;
        while (1)
        {
          v24 = *(_QWORD **)(v17 + 32 * v23 + 24);
          v25 = *(_QWORD **)(v19 + 32 * v23 + 24);
          NextResultAtOffset = (_QWORD **)mlir::detail::OpResultImpl::getNextResultAtOffset(v22, v23);
          v64 = v24;
          v65 = (uint64_t)v25;
          v66 = NextResultAtOffset;
          if (v24 == v25)
          {
            v40 = *NextResultAtOffset;
            if (*NextResultAtOffset)
            {
              do
              {
                v41 = (_QWORD *)v40[1];
                if (v41)
                {
                  *v41 = *v40;
                  if (*v40)
                    *(_QWORD *)(*v40 + 8) = v40[1];
                }
                v40[3] = v24;
                v40[1] = v24;
                v42 = *v24;
                *v40 = *v24;
                if (v42)
                  *(_QWORD *)(v42 + 8) = v40;
                *v24 = v40;
                v40 = *NextResultAtOffset;
              }
              while (*NextResultAtOffset);
              v20 = 1;
            }
            goto LABEL_52;
          }
          v62 = 0;
          v63 = 0;
          v67 = v24;
          DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v67);
          if (!DefiningOp)
            goto LABEL_52;
          v28 = DefiningOp;
          if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
            goto LABEL_52;
          v68 = v70;
          v69 = 0x100000000;
          mlir::Operation::fold(v28, 0, 0, (uint64_t)&v68);
          v29 = *(_QWORD *)v68;
          v30 = mlir::BoolAttr::classof((_QWORD *)(*(_QWORD *)v68 & 0xFFFFFFFFFFFFFFF8));
          v31 = (v29 & 0xFFFFFFFFFFFFFFF8) != 0 && v30;
          if (v31)
            v63 = v29 & 0xFFFFFFFFFFFFFFF8;
          if (v68 != v70)
            free(v68);
          if (!v31)
            goto LABEL_52;
          v67 = (_QWORD *)v65;
          v32 = mlir::Value::getDefiningOp((mlir::Value *)&v67);
          if (!v32)
            goto LABEL_52;
          v33 = v32;
          if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(v32 + 48)))
            goto LABEL_52;
          v68 = v70;
          v69 = 0x100000000;
          mlir::Operation::fold(v33, 0, 0, (uint64_t)&v68);
          v34 = *(_QWORD *)v68;
          v35 = mlir::BoolAttr::classof((_QWORD *)(*(_QWORD *)v68 & 0xFFFFFFFFFFFFFFF8));
          v36 = (v34 & 0xFFFFFFFFFFFFFFF8) != 0 && v35;
          if (v36)
            v62 = v34 & 0xFFFFFFFFFFFFFFF8;
          if (v68 != v70)
            free(v68);
          if (!v36)
            goto LABEL_52;
          Value = mlir::BoolAttr::getValue((mlir::BoolAttr *)&v63);
          v38 = mlir::BoolAttr::getValue((mlir::BoolAttr *)&v62);
          if (Value || !v38 || !*v66)
            goto LABEL_66;
          v58 = v38;
          v39 = *(_QWORD *)(mlir::Value::getDefiningOp((mlir::Value *)&v64) + 48);
          if (*(_UNKNOWN **)(v39 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v68 = *(void **)(v39 + 8);
            Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v68);
          }
          else
          {
            Values = *(_QWORD *)(v39 + 24);
          }
          v57 = *(_QWORD *)(v61 + 24);
          v68 = *(void **)(*(_QWORD *)(v61 + 72) + 24);
          v20 = 1;
          IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)v60, v59, 1);
          v67 = (_QWORD *)((*(uint64_t (**)(uint64_t, mlir::OpBuilder *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)Values + 24))(Values, v60, IntegerAttr, v59, *(_QWORD *)(v61 + 24))- 16);
          v44 = mlir::OpBuilder::create<mlir::arith::XOrIOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::OpResult>(v60, v57, (uint64_t *)&v68, (uint64_t *)&v67);
          v45 = (_QWORD **)v66;
          v46 = (_QWORD *)*v66;
          if (*v66)
            break;
          if (Value && !v58)
          {
LABEL_67:
            v50 = (_QWORD **)v66;
            v51 = (_QWORD *)*v66;
            if (*v66)
            {
              v52 = *(uint64_t **)(*(_QWORD *)(v61 + 72) + 24);
              do
              {
                v53 = (_QWORD *)v51[1];
                if (v53)
                {
                  *v53 = *v51;
                  if (*v51)
                    *(_QWORD *)(*v51 + 8) = v51[1];
                }
                v51[3] = v52;
                v51[1] = v52;
                v54 = *v52;
                *v51 = *v52;
                if (v54)
                  *(_QWORD *)(v54 + 8) = v51;
                *v52 = (uint64_t)v51;
                v51 = *v50;
                v20 = 1;
              }
              while (*v50);
            }
          }
LABEL_52:
          if (++v23 == v16 || v23 == v18 || v23 == v21)
            return v20 & 1;
        }
        v47 = (uint64_t *)((char *)v44 - 16);
        v38 = v58;
        do
        {
          v48 = (_QWORD *)v46[1];
          if (v48)
          {
            *v48 = *v46;
            if (*v46)
              *(_QWORD *)(*v46 + 8) = v46[1];
          }
          v46[3] = v47;
          v46[1] = v47;
          v49 = *v47;
          *v46 = *v47;
          if (v49)
            *(_QWORD *)(v49 + 8) = v46;
          *v47 = (uint64_t)v46;
          v46 = *v45;
        }
        while (*v45);
        v20 = 1;
LABEL_66:
        if (Value && !v38)
          goto LABEL_67;
        goto LABEL_52;
      }
    }
  }
  return v20 & 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::XOrIOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::OpResult>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.xori", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"arith.xori";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::arith::AndIOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::XOrIOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::ParallelOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  const mlir::OperationState *v2;
  uint64_t v3;
  _QWORD v5[39];

  v5[38] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v5, a2, (uint64_t)"scf.yield", 9);
  v3 = mlir::Operation::create((mlir::Operation *)v5, v2);
  mlir::OperationState::~OperationState((mlir::OperationState *)v5);
  return v3;
}

BOOL mlir::detail::op_filter_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::filter(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::scf::ReduceOp,void>::id;
}

void llvm::SmallVectorImpl<mlir::scf::ReduceOp>::append<mlir::detail::op_iterator<mlir::scf::ReduceOp,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>,void>(uint64_t a1, uint64_t a2, ZinIrHalH13g **a3)
{
  ZinIrHalH13g *v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t (*v10)(void);
  ZinIrHalH13g *v11;
  uint64_t v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v15;
  uint64_t (*v16)(void);
  uint64_t (*v17)(void);
  _QWORD *v18;
  ZinIrHalH13g *v19;

  v6 = *(ZinIrHalH13g **)a2;
  v7 = *a3;
  if (*(ZinIrHalH13g **)a2 == *a3)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = *(ZinIrHalH13g **)(a2 + 8);
    v10 = *(uint64_t (**)(void))(a2 + 16);
    do
    {
      v11 = (ZinIrHalH13g *)*((_QWORD *)v6 + 1);
      v6 = v9;
      if (v11 != v9)
      {
        v6 = v11;
        while (1)
        {
          ZinIrHalH13g::~ZinIrHalH13g(v6);
          if ((v10() & 1) != 0)
            break;
          v6 = (ZinIrHalH13g *)*((_QWORD *)v6 + 1);
          if (v6 == v9)
          {
            v6 = v9;
            break;
          }
        }
      }
      ++v8;
    }
    while (v6 != v7);
  }
  v12 = *(unsigned int *)(a1 + 8);
  if (v8 + v12 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8 + v12, 8);
    v12 = *(unsigned int *)(a1 + 8);
  }
  v13 = *(ZinIrHalH13g **)a2;
  v14 = *a3;
  if (*(ZinIrHalH13g **)a2 != v14)
  {
    v15 = *(ZinIrHalH13g **)(a2 + 8);
    v16 = *(uint64_t (**)(void))(a2 + 16);
    v17 = *(uint64_t (**)(void))(a2 + 24);
    v18 = (_QWORD *)(*(_QWORD *)a1 + 8 * v12);
    do
    {
      ZinIrHalH13g::~ZinIrHalH13g(v13);
      *v18 = v17();
      v19 = (ZinIrHalH13g *)*((_QWORD *)v13 + 1);
      v13 = v15;
      if (v19 != v15)
      {
        v13 = v19;
        while (1)
        {
          ZinIrHalH13g::~ZinIrHalH13g(v13);
          if ((v16() & 1) != 0)
            break;
          v13 = (ZinIrHalH13g *)*((_QWORD *)v13 + 1);
          if (v13 == v15)
          {
            v13 = v15;
            break;
          }
        }
      }
      ++v18;
    }
    while (v13 != v14);
    LODWORD(v12) = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v12 + v8;
}

void `anonymous namespace'::ParallelOpSingleOrZeroIterationDimsFolder::~ParallelOpSingleOrZeroIterationDimsFolder(_anonymous_namespace_::ParallelOpSingleOrZeroIterationDimsFolder *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ParallelOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ParallelOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::ParallelOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

void `anonymous namespace'::ParallelOpSingleOrZeroIterationDimsFolder::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unsigned int *v4;
  char *v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *ConstantIndexOp;
  char v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  int *v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  ZinIrHalH13g **v55;
  ZinIrHalH13g *v56;
  ZinIrHalH13g *v57;
  uint64_t **v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _DWORD *v63;
  uint64_t v64;
  char v65;
  _QWORD *v66;
  unint64_t v67;
  unint64_t v68;
  char v69;
  _QWORD *v70;
  ZinIrHalH13g **v71;
  ZinIrHalH13g *v72;
  ZinIrHalH13g *i;
  mlir::Operation *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  int *v79;
  int v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  unsigned int *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  llvm *v93[2];
  unsigned int v94;
  llvm *v95;
  uint64_t v96;
  int v97;
  llvm *v98;
  uint64_t v99;
  unsigned int v100;
  unint64_t v101;
  _QWORD *v102;
  unint64_t v103[2];
  unint64_t v104[2];
  unint64_t v105[2];
  void *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char *v110;
  uint64_t v111;
  void *v112;
  uint64_t v113;
  void *v114;
  uint64_t v115;
  _BYTE v116[48];
  _BYTE *v117;
  uint64_t v118;
  _BYTE v119[48];
  _QWORD *v120;
  uint64_t v121;
  _QWORD v122[8];

  v122[6] = *MEMORY[0x24BDAC8D0];
  v87 = *(_QWORD *)(a2 + 24);
  v120 = v122;
  v121 = 0x600000000;
  v117 = v119;
  v118 = 0x600000000;
  v114 = v116;
  v115 = 0x600000000;
  v93[0] = 0;
  v93[1] = 0;
  v94 = 0;
  v95 = 0;
  v96 = 0;
  v97 = 0;
  v98 = 0;
  v99 = 0;
  v100 = 0;
  v3 = *(unsigned int *)(a2 + 44);
  v4 = (unsigned int *)(a2 + 64 + 16 * ((v3 >> 23) & 1));
  v90 = *v4;
  v86 = a2 + 64;
  if ((v3 & 0x800000) != 0)
  {
    v5 = *(char **)(a2 + 72);
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v6 = (unsigned int *)(a2 + 64 + 16 * ((v3 >> 23) & 1));
    else
      v6 = 0;
    v7 = *v6;
    v8 = v6[1] + v7;
    v9 = (uint64_t)&v5[32 * v7];
  }
  else
  {
    v5 = 0;
    if (HIBYTE(*(_DWORD *)(a2 + 44)))
      v85 = (unsigned int *)(a2 + 64 + 16 * ((v3 >> 23) & 1));
    else
      v85 = 0;
    v7 = *v85;
    v8 = v85[1] + v7;
    v9 = 32 * v7;
  }
  v92 = v8 - v7;
  v10 = v4[2];
  v11 = &v5[32 * v8];
  v12 = *(_QWORD *)((((unint64_t)v4 + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 8);
  if (v12)
    v13 = v12 - 8;
  else
    v13 = 0;
  mlir::ValueRange::ValueRange((unint64_t *)&v106, *(_QWORD *)(v13 + 48), (uint64_t)(*(_QWORD *)(v13 + 56) - *(_QWORD *)(v13 + 48)) >> 3);
  v14 = v106;
  v91 = v107;
  v106 = v5;
  v107 = 0;
  v108 = v9;
  v109 = 0;
  v110 = &v5[32 * v8];
  v111 = 0;
  v112 = v14;
  v113 = 0;
  if (!(_DWORD)v90)
  {
LABEL_38:
    v36 = *(unsigned int *)(a2 + 44);
    v37 = (v36 >> 23) & 1;
    v38 = (int *)(v86 + 16 * v37);
    if ((_DWORD)v121 != *v38)
    {
      v39 = BYTE3(v36);
      if ((_DWORD)v121)
      {
        v40 = *(_QWORD *)(a2 + 24);
        if (!v39)
          v38 = 0;
        v41 = *v38;
        v42 = v38[1];
        v44 = v38[2];
        v43 = v38[3];
        if ((v36 & 0x800000) != 0)
          v45 = *(_QWORD *)(a2 + 72);
        else
          v45 = 0;
        v46 = (v42 + v41 + v44);
        v106 = (void *)(v45 + 32 * v46);
        v107 = (v43 + v46) - v46;
        v102 = 0;
        v47 = (unsigned int *)mlir::OpBuilder::create<mlir::scf::ParallelOp,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &,mlir::OperandRange,decltype(nullptr)>((mlir::OpBuilder *)(a3 + 8), v40, (uint64_t)&v120, (uint64_t)&v117, (uint64_t)&v114, (uint64_t)&v106);
        v48 = (((unint64_t)&v47[4 * (((unint64_t)v47[11] >> 23) & 1) + 17]
              + (((unint64_t)v47[11] >> 21) & 0x7F8)
              + 3) & 0xFFFFFFFFFFFFFFF8)
            + 32 * v47[10];
        (*(void (**)(uint64_t, unint64_t, unint64_t, _QWORD, llvm **))(*(_QWORD *)a3 + 8))(a3, ((v86+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a2 + 40), v48, *(_QWORD *)(v48 + 8), v93);
        v49 = v47[9];
        if ((_DWORD)v49)
          v50 = (uint64_t)(v47 - 4);
        else
          v50 = 0;
        mlir::ValueRange::ValueRange(v103, v50, v49);
        (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v103[0], v103[1]);
      }
      else
      {
        v106 = &v108;
        v107 = 0x600000000;
        if (!v39)
          v38 = 0;
        v51 = (v38[1] + *v38 + v38[2]);
        v52 = (v38[3] + v51) - v51;
        if (v52 >= 7)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, &v108, v52, 8);
          v36 = *(unsigned int *)(a2 + 44);
          v37 = (v36 >> 23) & 1;
        }
        v53 = *(_QWORD *)(((v86 + 16 * v37 + ((v36 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * *(unsigned int *)(a2 + 40)
                        + 8);
        v54 = v53 - 8;
        if (!v53)
          v54 = 0;
        v55 = (ZinIrHalH13g **)(v54 + 32);
        v56 = *(ZinIrHalH13g **)(v54 + 40);
        if (v56 != (ZinIrHalH13g *)(v54 + 32))
        {
          v57 = *v55;
          if (v56 != *v55)
          {
            v58 = (uint64_t **)(a3 + 8);
            do
            {
              while (1)
              {
                ZinIrHalH13g::~ZinIrHalH13g(v56);
                v60 = v59;
                if (v59)
                {
                  if (*(_UNKNOWN **)(*(_QWORD *)(v59 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ReduceOp,void>::id)
                    break;
                }
                mlir::OpBuilder::clone(v58, (mlir::Operation *)v59, (mlir::IRMapping *)v93);
                v56 = (ZinIrHalH13g *)*((_QWORD *)v56 + 1);
                if (v56 == v57)
                  goto LABEL_82;
              }
              v61 = *(_QWORD *)(((v59
                                + 16 * (((unint64_t)*(unsigned int *)(v59 + 44) >> 23) & 1)
                                + (((unint64_t)*(unsigned int *)(v59 + 44) >> 21) & 0x7F8)
                                + 71) & 0xFFFFFFFFFFFFFFF8)
                              + 32 * *(unsigned int *)(v59 + 40)
                              + 8);
              if (v61)
                v62 = v61 - 8;
              else
                v62 = 0;
              if (*(_BYTE *)(a2 + 47))
                v63 = (_DWORD *)(a2 + 80);
              else
                v63 = 0;
              v64 = *(_QWORD *)(*(_QWORD *)(a2 + 72)
                              + 32 * (v63[1] + *v63 + v63[2])
                              + 32 * v107
                              + 24);
              v101 = **(_QWORD **)(v62 + 48);
              v102 = 0;
              v65 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v93, &v101, &v102);
              v66 = v102;
              if ((v65 & 1) == 0)
              {
                v66 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v93, (uint64_t)&v101, &v101, v102);
                *v66 = v101;
                v66[1] = 0;
              }
              v66[1] = v64;
              v67 = *(_QWORD *)(*(_QWORD *)(v62 + 48) + 8);
              v68 = *(_QWORD *)(*(_QWORD *)(v60 + 72) + 24);
              v101 = v68;
              v102 = 0;
              if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v93, &v101, &v102)&& v102 != (_QWORD *)v93[0] + 2 * v94)
              {
                v68 = v102[1];
              }
              v101 = v67;
              v102 = 0;
              v69 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v93, &v101, &v102);
              v70 = v102;
              if ((v69 & 1) == 0)
              {
                v70 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v93, (uint64_t)&v101, &v101, v102);
                *v70 = v101;
                v70[1] = 0;
              }
              v70[1] = v68;
              v71 = (ZinIrHalH13g **)(v62 + 32);
              v72 = *(ZinIrHalH13g **)(v62 + 40);
              if (v72 != (ZinIrHalH13g *)(v62 + 32))
              {
                for (i = *v71; v72 != i; v72 = (ZinIrHalH13g *)*((_QWORD *)v72 + 1))
                {
                  ZinIrHalH13g::~ZinIrHalH13g(v72);
                  mlir::OpBuilder::clone(v58, v74, (mlir::IRMapping *)v93);
                }
              }
              mlir::Block::getTerminator((ZinIrHalH13g **)v62);
              v76 = *(_QWORD *)(*(_QWORD *)(v75 + 72) + 24);
              v101 = v76;
              v102 = 0;
              if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v93, &v101, &v102)&& v102 != (_QWORD *)v93[0] + 2 * v94)
              {
                v76 = v102[1];
              }
              v77 = v107;
              if (v107 >= (unint64_t)HIDWORD(v107))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, &v108, v107 + 1, 8);
                v77 = v107;
              }
              *((_QWORD *)v106 + v77) = v76;
              LODWORD(v107) = v107 + 1;
              v56 = (ZinIrHalH13g *)*((_QWORD *)v56 + 1);
            }
            while (v56 != v57);
          }
        }
LABEL_82:
        mlir::ValueRange::ValueRange(v104, (uint64_t)v106, v107);
        (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v104[0], v104[1]);
        if (v106 != &v108)
          free(v106);
      }
    }
LABEL_84:
    llvm::deallocate_buffer(v98, (void *)(16 * v100));
  }
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = v10 + v8 - v8;
  v20 = v5;
  while (1)
  {
    if (v108 == v9 && v18 == v92)
      goto LABEL_38;
    if (v110 == v11 && v17 == v19)
      goto LABEL_38;
    if (v112 == v14 && v16 == v91)
      goto LABEL_38;
    v24 = v20[4 * v15 + 3];
    v25 = *(_QWORD *)(v108 + 32 * v18 + 24);
    v26 = *(_QWORD *)&v110[32 * v17 + 24];
    v27 = mlir::ValueRange::dereference_iterator(&v112, v16);
    v28 = mlir::constantTripCount(v24 | 4, v25 | 4, v26 | 4);
    if (v29)
    {
      if (v28 == 1)
      {
        ConstantIndexOp = mlir::getValueOrCreateConstantIndexOp((mlir::IndexType **)(a3 + 8), v87, v24 | 4);
        v101 = v27;
        v102 = 0;
        v34 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v93, &v101, &v102);
        v35 = v102;
        if ((v34 & 1) == 0)
        {
          v35 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v93, (uint64_t)&v101, &v101, v102);
          *v35 = v101;
          v35[1] = 0;
        }
        v35[1] = ConstantIndexOp;
        goto LABEL_36;
      }
      if (!v28)
      {
        v78 = *(unsigned int *)(a2 + 44);
        if (HIBYTE(*(_DWORD *)(a2 + 44)))
          v79 = (int *)(v86 + 16 * ((v78 >> 23) & 1));
        else
          v79 = 0;
        v80 = *v79;
        v81 = v79[1];
        v83 = v79[2];
        v82 = v79[3];
        if ((v78 & 0x800000) != 0)
          v84 = *(_QWORD *)(a2 + 72);
        else
          v84 = 0;
        mlir::ValueRange::ValueRange(v105, v84 + 32 * (v81 + v80 + v83), (v82 + v81 + v80 + v83) - (unint64_t)(v81 + v80 + v83));
        (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a3 + 24))(a3, a2, v105[0], v105[1]);
        goto LABEL_84;
      }
    }
    v30 = v121;
    if (v121 >= (unint64_t)HIDWORD(v121))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v120, v122, v121 + 1, 8);
      v30 = v121;
    }
    v120[v30] = v24;
    LODWORD(v121) = v121 + 1;
    v31 = v118;
    if (v118 >= (unint64_t)HIDWORD(v118))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v119, v118 + 1, 8);
      v31 = v118;
    }
    *(_QWORD *)&v117[8 * v31] = v25;
    LODWORD(v118) = v118 + 1;
    v32 = v115;
    if (v115 >= (unint64_t)HIDWORD(v115))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v116, v115 + 1, 8);
      v32 = v115;
    }
    *((_QWORD *)v114 + v32) = v26;
    LODWORD(v115) = v115 + 1;
LABEL_36:
    v20 = v106;
    v15 = v107 + 1;
    v18 = v109 + 1;
    ++v107;
    ++v109;
    v17 = v111 + 1;
    v16 = v113 + 1;
    ++v111;
    ++v113;
    if (v106 == v5 && v15 == v90)
      goto LABEL_38;
  }
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::ParallelOp,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &,llvm::SmallVector<mlir::Value,6u> &,mlir::OperandRange,decltype(nullptr)>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  __n128 v15;
  ZinIrHalH13g *v16;
  ZinIrHalH13g *v17;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  uint64_t v22[4];
  __int16 v23;
  void (*v24[2])(uint64_t, uint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t);
  unint64_t v25[2];
  unint64_t v26[2];
  unint64_t v27[2];
  _QWORD v28[39];

  v28[38] = *MEMORY[0x24BDAC8D0];
  v19 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v19);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.parallel", (const unsigned __int8 *)0xC, Context);
  if (!v14)
  {
    v23 = 1283;
    v22[2] = (uint64_t)"scf.parallel";
    v22[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v21 = 259;
    llvm::operator+(v22, (uint64_t *)&v20, (uint64_t)v28);
    llvm::report_fatal_error((llvm::Twine *)v28, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::ValueRange::ValueRange(v27, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v26, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::ValueRange::ValueRange(v25, *(_QWORD *)a5, *(unsigned int *)(a5 + 8));
  mlir::ValueRange::ValueRange((unint64_t *)v24, *(_QWORD *)a6, *(_QWORD *)(a6 + 8));
  mlir::scf::ParallelOp::build((uint64_t)a1, (uint64_t)v28, v27[0], v27[1], v26[0], v26[1], v25[0], v25[1], v15, v24[0], (uint64_t)v24[1]);
  v16 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (*(_UNKNOWN **)(*((_QWORD *)v16 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ParallelOp,void>::id)
    v17 = v16;
  else
    v17 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v17;
}

void `anonymous namespace'::MergeNestedParallelLoops::~MergeNestedParallelLoops(_anonymous_namespace_::MergeNestedParallelLoops *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::MergeNestedParallelLoops::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  ZinIrHalH13g *v6;
  ZinIrHalH13g *v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  _QWORD *v36;
  unsigned int v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unsigned int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  unsigned int *v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  unint64_t v51;
  unsigned int *v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  unint64_t v56;
  int *v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  int *v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *Context;
  uint64_t v72;
  char v73;
  __n128 v74;
  ZinIrHalH13g *v75;
  void *v76;
  ZinIrHalH13g *v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  unsigned int v87;
  uint64_t v88;
  void (*v89[2])(uint64_t, uint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t);
  unint64_t v90[2];
  uint64_t v91;
  uint64_t v92;
  uint64_t v93[4];
  __int16 v94;
  const char *v95;
  uint64_t v96;
  const char *v97;
  uint64_t v98;
  __int16 v99;
  uint64_t v100;

  v100 = *MEMORY[0x24BDAC8D0];
  v3 = a2 + 64;
  v4 = *(_QWORD *)(((a2
                   + 64
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v4)
    v5 = (_QWORD *)(v4 - 8);
  else
    v5 = 0;
  v6 = (ZinIrHalH13g *)v5[5];
  if (v6 == (ZinIrHalH13g *)(v5 + 4))
    return 0;
  v7 = (ZinIrHalH13g *)v5[4];
  if (v6 == v7 || *((ZinIrHalH13g **)v6 + 1) != v7)
    return 0;
  ZinIrHalH13g::~ZinIrHalH13g(v6);
  v12 = *(_UNKNOWN **)(*(_QWORD *)(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ParallelOp,void>::id
      ? v11
      : 0;
  v78 = v12;
  if (!v12)
    return 0;
  v13 = (uint64_t *)v5[6];
  v14 = (uint64_t *)v5[7];
  if (v14 != v13)
  {
    v15 = *(unsigned int *)(v12 + 44);
    v16 = v12 + 16 * ((v15 >> 23) & 1);
    v19 = *(_DWORD *)(v16 + 64);
    v18 = (unsigned int *)(v16 + 64);
    v17 = v19;
    if (!HIBYTE(*(_DWORD *)(v12 + 44)))
      v18 = 0;
    do
    {
      if ((v15 & 0x800000) != 0)
      {
        v21 = *(_QWORD *)(v12 + 72);
        v22 = *v13;
        v23 = 0;
        if (!(_DWORD)v17)
          goto LABEL_26;
      }
      else
      {
        v21 = 0;
        v22 = *v13;
        v23 = 0;
        if (!(_DWORD)v17)
          goto LABEL_26;
      }
      v24 = (_QWORD *)(v21 + 24);
      while (*v24 != v22)
      {
        ++v23;
        v24 += 4;
        if (v17 == v23)
          goto LABEL_27;
      }
LABEL_26:
      if (v23 != v17)
        return 0;
LABEL_27:
      if ((v15 & 0x800000) != 0)
      {
        v25 = *(_QWORD *)(v12 + 72);
        v26 = *v18;
        v27 = v18[1];
        v28 = v27 + v26;
        v29 = v28 - v26;
        if (!v27)
          goto LABEL_34;
      }
      else
      {
        v25 = 0;
        v26 = *v18;
        v32 = v18[1];
        v28 = v32 + v26;
        v29 = v28 - v26;
        if (!v32)
        {
LABEL_34:
          v30 = 0;
          goto LABEL_35;
        }
      }
      v30 = 0;
      v31 = (_QWORD *)(v25 + 32 * v26 + 24);
      while (*v31 != v22)
      {
        ++v30;
        v31 += 4;
        if (v29 == v30)
          goto LABEL_36;
      }
LABEL_35:
      if (v30 != v29)
        return 0;
LABEL_36:
      if ((v15 & 0x800000) != 0)
      {
        v33 = *(_QWORD *)(v12 + 72);
        v34 = v18[2];
        v35 = v34 + v28 - v28;
        if (v34)
          goto LABEL_38;
      }
      else
      {
        v33 = 0;
        v37 = v18[2];
        v35 = v37 + v28 - v28;
        if (v37)
        {
LABEL_38:
          v20 = 0;
          v36 = (_QWORD *)(v33 + 32 * v28 + 24);
          while (*v36 != v22)
          {
            ++v20;
            v36 += 4;
            if (v35 == v20)
              goto LABEL_18;
          }
          goto LABEL_17;
        }
      }
      v20 = 0;
LABEL_17:
      if (v20 != v35)
        return 0;
LABEL_18:
      ++v13;
    }
    while (v13 != v14);
  }
  v38 = *(unsigned int *)(a2 + 44);
  v39 = HIBYTE(*(_DWORD *)(a2 + 44)) ? v3 + 16 * ((v38 >> 23) & 1) : 0;
  if (*(_DWORD *)(v39 + 12))
    return 0;
  v40 = *(unsigned int *)(v12 + 44);
  v41 = (unsigned int *)(v12 + 16 * ((v40 >> 23) & 1) + 64);
  v42 = HIBYTE(*(_DWORD *)(v12 + 44)) ? v12 + 16 * ((v40 >> 23) & 1) + 64 : 0;
  if (*(_DWORD *)(v42 + 12))
    return 0;
  v43 = *(unsigned int *)(v3 + 16 * ((v38 >> 23) & 1));
  if ((v38 & 0x800000) == 0)
  {
    v91 = 0;
    v92 = v43;
    v44 = *v41;
    if ((v40 & 0x800000) != 0)
      goto LABEL_54;
LABEL_87:
    v45 = 0;
    goto LABEL_55;
  }
  v91 = *(_QWORD *)(a2 + 72);
  v92 = v43;
  v44 = *v41;
  if ((v40 & 0x800000) == 0)
    goto LABEL_87;
LABEL_54:
  v45 = *(void **)(v12 + 72);
LABEL_55:
  v83 = v45;
  v84 = v44;
  _ZZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterEENKUlRKT_RKT0_E_clINS1_12OperandRangeESE_EEDaS8_SB_((uint64_t)&v86, &v91, (uint64_t *)&v83);
  v46 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v47 = (unsigned int *)(v3 + 16 * ((v46 >> 23) & 1));
  else
    v47 = 0;
  v48 = *v47;
  v49 = v47[1];
  if ((v46 & 0x800000) != 0)
    v50 = *(_QWORD *)(a2 + 72);
  else
    v50 = 0;
  v91 = v50 + 32 * v48;
  v92 = v49 + v48 - v48;
  v51 = *(unsigned int *)(v78 + 44);
  if (HIBYTE(*(_DWORD *)(v78 + 44)))
    v52 = (unsigned int *)(v78 + 16 * ((v51 >> 23) & 1) + 64);
  else
    v52 = 0;
  v53 = *v52;
  v54 = v52[1];
  if ((v51 & 0x800000) != 0)
    v55 = *(_QWORD *)(v78 + 72);
  else
    v55 = 0;
  v80 = (void *)(v55 + 32 * v53);
  v81 = v54 + v53 - v53;
  _ZZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterEENKUlRKT_RKT0_E_clINS1_12OperandRangeESE_EEDaS8_SB_((uint64_t)&v83, &v91, (uint64_t *)&v80);
  v56 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v57 = (int *)(v3 + 16 * ((v56 >> 23) & 1));
  else
    v57 = 0;
  v58 = *v57;
  v59 = v57[1];
  v60 = v57[2];
  if ((v56 & 0x800000) != 0)
    v61 = *(_QWORD *)(a2 + 72);
  else
    v61 = 0;
  v62 = (v59 + v58);
  v91 = v61 + 32 * v62;
  v92 = (v60 + v62) - v62;
  v63 = *(unsigned int *)(v78 + 44);
  if (HIBYTE(*(_DWORD *)(v78 + 44)))
    v64 = (int *)(v78 + 16 * ((v63 >> 23) & 1) + 64);
  else
    v64 = 0;
  v65 = *v64;
  v66 = v64[1];
  v67 = v64[2];
  if ((v63 & 0x800000) != 0)
    v68 = *(_QWORD *)(v78 + 72);
  else
    v68 = 0;
  v69 = (v66 + v65);
  v95 = (const char *)(v68 + 32 * v69);
  v96 = (v67 + v69) - v69;
  _ZZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterEENKUlRKT_RKT0_E_clINS1_12OperandRangeESE_EEDaS8_SB_((uint64_t)&v80, &v91, (uint64_t *)&v95);
  v70 = *(_QWORD *)(a2 + 24);
  v79 = v70;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v79);
  v72 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.parallel", (const unsigned __int8 *)0xC, Context);
  if (!v73)
  {
    v99 = 1283;
    v97 = "scf.parallel";
    v98 = 12;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    v94 = 259;
    llvm::operator+((uint64_t *)&v95, v93, (uint64_t)&v91);
    llvm::report_fatal_error((llvm::Twine *)&v91, 1);
  }
  mlir::OperationState::OperationState(&v91, v70, v72);
  mlir::ValueRange::ValueRange((unint64_t *)&v95, (uint64_t)v86, v87);
  mlir::ValueRange::ValueRange((unint64_t *)v93, (uint64_t)v83, v84);
  mlir::ValueRange::ValueRange(v90, (uint64_t)v80, v81);
  mlir::ValueRange::ValueRange((unint64_t *)v89, 0, 0);
  mlir::scf::ParallelOp::build(a3 + 8, (uint64_t)&v91, (uint64_t)v95, v96, v93[0], v93[1], v90[0], v90[1], v74, v89[0], (uint64_t)v89[1]);
  v75 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 8), (const mlir::OperationState *)&v91);
  v76 = *(void **)(*((_QWORD *)v75 + 6) + 16);
  mlir::OperationState::~OperationState((mlir::OperationState *)&v91);
  if (v76 == &mlir::detail::TypeIDResolver<mlir::scf::ParallelOp,void>::id)
    v77 = v75;
  else
    v77 = 0;
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v77);
  if (v80 != &v82)
    free(v80);
  if (v83 != &v85)
    free(v83);
  if (v86 != &v88)
    free(v86);
  return 1;
}

void _ZZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterEENKUlRKT_RKT0_E_clINS1_12OperandRangeESE_EEDaS8_SB_(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  const double *v16;
  unsigned __int128 *v17;
  unint64_t v18;
  const double *v19;
  unsigned __int128 v20;
  unsigned __int128 v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  const double *v34;
  unsigned __int128 *v35;
  unint64_t v36;
  const double *v37;
  unsigned __int128 v38;
  unsigned __int128 v39;
  unint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  int v44;
  unsigned int v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD v48[7];

  v48[6] = *MEMORY[0x24BDAC8D0];
  v6 = v48;
  v46 = v48;
  v47 = 0x600000000;
  v7 = a2[1];
  v8 = a3[1] + v7;
  if (v8 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v48, v8, 8);
    v10 = a2;
    v9 = *a2;
    v7 = v10[1];
    LODWORD(v47) = 0;
    if (v7 <= HIDWORD(v47))
      goto LABEL_3;
LABEL_7:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v48, v7, 8);
    v11 = v47;
    v12 = v46;
    v13 = &v46[v47];
    if (v7 < 0xD)
      goto LABEL_10;
    goto LABEL_8;
  }
  v9 = *a2;
  LODWORD(v47) = 0;
  if (v7 > 6)
    goto LABEL_7;
LABEL_3:
  if (!v7)
  {
    v25 = 0;
    goto LABEL_18;
  }
  v11 = 0;
  v12 = v46;
  v13 = v46;
  if (v7 < 0xD)
    goto LABEL_10;
LABEL_8:
  if ((unint64_t)v13 >= v9 + 32 * v7 || v9 + 24 >= (unint64_t)&v12[v7 + v11])
  {
    v15 = v7 & 3;
    if ((v7 & 3) == 0)
      v15 = 4;
    v14 = v7 - v15;
    v13 += v14;
    v16 = (const double *)(v9 + 88);
    v17 = (unsigned __int128 *)&v12[v11 + 2];
    v18 = v14;
    do
    {
      v19 = v16 - 8;
      v20 = (unsigned __int128)vld4q_f64(v19);
      v21 = (unsigned __int128)vld4q_f64(v16);
      *(v17 - 1) = v20;
      *v17 = v21;
      v16 += 16;
      v17 += 2;
      v18 -= 4;
    }
    while (v18);
    goto LABEL_15;
  }
LABEL_10:
  v14 = 0;
LABEL_15:
  v22 = v7 - v14;
  v23 = (uint64_t *)(v9 + 32 * v14 + 24);
  do
  {
    v24 = *v23;
    v23 += 4;
    *v13++ = v24;
    --v22;
  }
  while (v22);
  v25 = v47;
LABEL_18:
  v26 = (v25 + v7);
  LODWORD(v47) = v25 + v7;
  v28 = *a3;
  v27 = a3[1];
  if (v27 + v26 > HIDWORD(v47))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v48, v27 + v26, 8);
    LODWORD(v26) = v47;
  }
  v29 = v46;
  if (v27)
  {
    v30 = &v46[v26];
    if (v27 >= 0xD
      && ((v31 = v26, (unint64_t)v30 >= v28 + 32 * v27)
       || v28 + 24 >= (unint64_t)&v46[v27 + v26]))
    {
      v33 = v27 & 3;
      if ((v27 & 3) == 0)
        v33 = 4;
      v32 = v27 - v33;
      v30 += v32;
      v34 = (const double *)(v28 + 88);
      v35 = (unsigned __int128 *)&v46[v31 + 2];
      v36 = v32;
      do
      {
        v37 = v34 - 8;
        v38 = (unsigned __int128)vld4q_f64(v37);
        v39 = (unsigned __int128)vld4q_f64(v34);
        *(v35 - 1) = v38;
        *v35 = v39;
        v34 += 16;
        v35 += 2;
        v36 -= 4;
      }
      while (v36);
    }
    else
    {
      v32 = 0;
    }
    v40 = v27 - v32;
    v41 = (uint64_t *)(v28 + 32 * v32 + 24);
    do
    {
      v42 = *v41;
      v41 += 4;
      *v30++ = v42;
      --v40;
    }
    while (v40);
    LODWORD(v26) = v47;
    v29 = v46;
  }
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x600000000;
  v43 = (v26 + v27);
  LODWORD(v47) = v43;
  if ((_DWORD)v43 && &v46 != (_QWORD **)a1)
  {
    if (v29 == v48)
    {
      v45 = v43;
      if (v43 < 7
        || (llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v43, 8),
            v45 = v47,
            v6 = v46,
            (_DWORD)v47))
      {
        memcpy(*(void **)a1, v6, 8 * v45);
        v6 = v46;
      }
      *(_DWORD *)(a1 + 8) = v43;
    }
    else
    {
      *(_QWORD *)a1 = v29;
      v44 = HIDWORD(v47);
      *(_DWORD *)(a1 + 8) = v43;
      *(_DWORD *)(a1 + 12) = v44;
      v46 = v48;
      HIDWORD(v47) = 0;
    }
    LODWORD(v47) = 0;
    v29 = v6;
  }
  if (v29 != v48)
    free(v29);
}

void llvm::function_ref<void ()(mlir::OpBuilder &,mlir::Location,mlir::ValueRange,mlir::ValueRange)>::callback_fn<`anonymous namespace'::MergeNestedParallelLoops::matchAndRewrite(mlir::scf::ParallelOp,mlir::PatternRewriter &)::{lambda(mlir::OpBuilder &,mlir::Location,mlir::ValueRange,mlir::ValueRange)#1}>(uint64_t **a1, uint64_t **a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  char v20;
  _QWORD *v21;
  unint64_t *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  uint64_t v28;
  char v29;
  _QWORD *v30;
  ZinIrHalH13g **v31;
  ZinIrHalH13g *v32;
  ZinIrHalH13g *i;
  mlir::Operation *v34;
  uint64_t v35[2];
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  llvm *v40;
  uint64_t v41;
  unsigned int v42;
  unint64_t v43;
  _QWORD *v44;
  _QWORD v45[2];
  unint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;

  v5 = a5;
  v6 = a4;
  v49 = *MEMORY[0x24BDAC8D0];
  v8 = a1[1];
  v9 = **a1;
  v11 = *(unsigned int *)(v9 + 40);
  v10 = *(unsigned int *)(v9 + 44);
  v13 = (unint64_t *)v8[6];
  v12 = (unint64_t *)v8[7];
  v45[0] = a4;
  v45[1] = a5;
  v14 = *(_QWORD *)(((v9 + 16 * ((v10 >> 23) & 1) + ((v10 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 32 * v11 + 8);
  if (v14)
    v15 = (_QWORD *)(v14 - 8);
  else
    v15 = 0;
  if (a5 >= ((unint64_t)((char *)v12 - (char *)v13) >> 3))
    v16 = ((unint64_t)((char *)v12 - (char *)v13) >> 3);
  else
    v16 = a5;
  v35[0] = 0;
  v35[1] = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v46 = v13;
  v47 = a4;
  v48 = 0;
  if (v12 != v13)
  {
    v17 = 0;
    do
    {
      if (v47 == v6 && v17 == v16)
        break;
      v19 = mlir::ValueRange::dereference_iterator(&v47, v17);
      v43 = *v13;
      v44 = 0;
      v20 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v35, &v43, &v44);
      v21 = v44;
      if ((v20 & 1) == 0)
      {
        v21 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v35, (uint64_t)&v43, &v43, v44);
        *v21 = v43;
        v21[1] = 0;
      }
      v21[1] = v19;
      v13 = v46 + 1;
      v17 = v48 + 1;
      v46 = v13;
      ++v48;
    }
    while (v13 != v12);
  }
  v23 = (unint64_t *)v15[6];
  v22 = (unint64_t *)v15[7];
  v24 = ((unint64_t)((char *)v22 - (char *)v23) >> 3);
  if (v5 > v24)
  {
    v6 = mlir::ValueRange::offset_base(v45, v5 - v24);
    v5 = ((unint64_t)((char *)v22 - (char *)v23) >> 3);
  }
  v46 = v23;
  v47 = v6;
  v48 = 0;
  if (v22 != v23)
  {
    v25 = 0;
    v26 = &v23[v22 - v23];
    do
    {
      if (v47 == v6 && v25 == v5)
        break;
      v28 = mlir::ValueRange::dereference_iterator(&v47, v25);
      v43 = *v23;
      v44 = 0;
      v29 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v35, &v43, &v44);
      v30 = v44;
      if ((v29 & 1) == 0)
      {
        v30 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v35, (uint64_t)&v43, &v43, v44);
        *v30 = v43;
        v30[1] = 0;
      }
      v30[1] = v28;
      v23 = v46 + 1;
      v25 = v48 + 1;
      v46 = v23;
      ++v48;
    }
    while (v23 != v26);
  }
  v31 = (ZinIrHalH13g **)(v15 + 4);
  v32 = (ZinIrHalH13g *)v15[5];
  if (v32 != (ZinIrHalH13g *)(v15 + 4))
  {
    for (i = *v31; v32 != i; v32 = (ZinIrHalH13g *)*((_QWORD *)v32 + 1))
    {
      ZinIrHalH13g::~ZinIrHalH13g(v32);
      mlir::OpBuilder::clone(a2, v34, (mlir::IRMapping *)v35);
    }
  }
  llvm::deallocate_buffer(v40, (void *)(16 * v42));
}

void sub_2074DD2A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, llvm *a13, uint64_t a14, unsigned int a15)
{
  llvm::deallocate_buffer(a13, (void *)(16 * a15));
}

void sub_2074DD2BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, llvm *a10, uint64_t a11, unsigned int a12)
{
  llvm::deallocate_buffer(a10, (void *)(16 * a12));
}

void `anonymous namespace'::RemoveLoopInvariantArgsFromBeforeBlock::~RemoveLoopInvariantArgsFromBeforeBlock(_anonymous_namespace_::RemoveLoopInvariantArgsFromBeforeBlock *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::WhileOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::WhileOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::scf::WhileOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::RemoveLoopInvariantArgsFromBeforeBlock::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  ZinIrHalH13g **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v29;
  unint64_t v30;
  unint64_t v31;
  void *v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  int v44;
  unsigned int v45;
  char *v46;
  int v47;
  char *v48;
  int v49;
  BOOL v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  unsigned int v57;
  char *v58;
  int v59;
  char *v60;
  int v61;
  BOOL v62;
  unsigned int v63;
  char *v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  char *v68;
  int v69;
  BOOL v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  BOOL v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  mlir::OpBuilder *v80;
  _OWORD *v81;
  uint64_t v82;
  uint64_t v83;
  ZinIrHalH13g *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  ZinIrHalH13g *v88;
  unsigned int *v89;
  unint64_t v90;
  uint64_t v91;
  __n128 *v92;
  unint64_t v93;
  void *v94;
  uint64_t v95;
  uint64_t Block;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unsigned int v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  char *v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  unsigned int v114;
  unsigned int v115;
  char *v116;
  int v117;
  BOOL v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  uint64_t v122;
  char *v123;
  int v124;
  BOOL v125;
  unsigned int v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  __int128 v139;
  llvm *v140;
  uint64_t v141;
  unsigned int v142;
  unint64_t v143[2];
  unint64_t v144[2];
  void *v145[3];
  unint64_t v146;
  uint64_t v147;
  __n128 v148;
  uint64_t v149;
  unint64_t v150[2];
  void *v151;
  uint64_t v152;
  _BYTE v153[48];
  void *v154;
  uint64_t v155;
  _BYTE v156[48];
  uint64_t *v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164[4];

  v164[2] = *MEMORY[0x24BDAC8D0];
  v136 = a2 + 64;
  v5 = ((a2
       + 64
       + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
       + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
       + 7) & 0xFFFFFFFFFFFFFFF8)
     + 32 * *(unsigned int *)(a2 + 40);
  v6 = *(_QWORD *)(v5 + 32);
  if (v6)
    v7 = (ZinIrHalH13g **)(v6 - 8);
  else
    v7 = 0;
  v8 = *(_QWORD *)(v5 + 8);
  if (v8)
    v9 = v8 - 8;
  else
    v9 = 0;
  v138 = *(_QWORD *)(v9 + 48);
  mlir::Block::getTerminator((ZinIrHalH13g **)v9);
  if ((*(_BYTE *)(v10 + 46) & 0x80) != 0)
  {
    v11 = *(_QWORD *)(v10 + 72);
    mlir::Block::getTerminator(v7);
    v13 = v12;
    if ((*(_BYTE *)(v12 + 46) & 0x80) != 0)
      goto LABEL_9;
  }
  else
  {
    v11 = 0;
    mlir::Block::getTerminator(v7);
    v13 = v78;
    if ((*(_BYTE *)(v78 + 46) & 0x80) != 0)
    {
LABEL_9:
      mlir::ValueRange::ValueRange(&v162, *(_QWORD *)(v13 + 72), *(unsigned int *)(v13 + 68));
      v135 = a3;
      if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
        goto LABEL_10;
LABEL_125:
      v157 = 0;
      v158 = 0;
      v159 = 0;
      v160 = v162;
      v161 = 0;
      return 0;
    }
  }
  mlir::ValueRange::ValueRange(&v162, 0, 0);
  v135 = a3;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    goto LABEL_125;
LABEL_10:
  v14 = *(_QWORD *)(a2 + 72);
  v15 = *(unsigned int *)(a2 + 68);
  v16 = v162;
  v157 = 0;
  v158 = v14;
  v159 = 0;
  v160 = v162;
  v161 = 0;
  if (v15)
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v137 = v11 + 32;
    v20 = v163;
    v21 = v14;
    while (1)
    {
      if (v160 == v16 && v19 == v20)
        return 0;
      v23 = *(_QWORD *)(v21 + 32 * v17 + 24);
      v24 = mlir::ValueRange::dereference_iterator(&v160, v19);
      if (v23 == v24)
        break;
      v25 = (~*(_DWORD *)(v24 + 8) & 7) != 0 ? 0 : v24;
      if (v25 && *(ZinIrHalH13g ***)(v25 + 16) == v7)
      {
        v26 = *(_QWORD *)(v137 + 32 * *(unsigned int *)(v25 + 24) + 24);
        if (v26 == *(_QWORD *)(v138 + 8 * v18) || v26 == v23)
          break;
      }
      v21 = v158;
      v18 = (_DWORD)v157 + 1;
      v17 = v159 + 1;
      v157 = (uint64_t *)((char *)v157 + 1);
      ++v159;
      v19 = ++v161;
      if (v158 == v14 && v17 == v15)
        return 0;
    }
    v157 = &v159;
    v158 = 0x600000000;
    v154 = v156;
    v155 = 0x600000000;
    v140 = 0;
    v141 = 0;
    v142 = 0;
    v151 = v153;
    v152 = 0x600000000;
    if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    {
      v29 = *(void **)(a2 + 72);
      v30 = *(unsigned int *)(a2 + 68);
      v31 = v162;
      v145[0] = 0;
      v145[1] = v29;
      v145[2] = 0;
      v146 = v162;
      v147 = 0;
      if (v30)
      {
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v35 = v163;
        v36 = v29;
        do
        {
          if (v146 == v31 && v34 == v35)
            break;
          v38 = v36[4 * (_QWORD)v32 + 3];
          v39 = mlir::ValueRange::dereference_iterator(&v146, v34);
          if (v38 == v39)
          {
            v56 = v142;
            if (!v142)
              goto LABEL_91;
            v57 = (v142 - 1) & (37 * v33);
            v58 = (char *)v140 + 16 * v57;
            v59 = *(_DWORD *)v58;
            if (*(_DWORD *)v58 != v33)
            {
              v60 = 0;
              v61 = 1;
              while (v59 != -1)
              {
                if (v60)
                  v62 = 0;
                else
                  v62 = v59 == -2;
                if (v62)
                  v60 = v58;
                v63 = v57 + v61++;
                v57 = v63 & (v142 - 1);
                v58 = (char *)v140 + 16 * v57;
                v59 = *(_DWORD *)v58;
                if (*(_DWORD *)v58 == v33)
                  goto LABEL_80;
              }
              if (v60)
                v64 = v60;
              else
                v64 = v58;
              if (4 * (int)v141 + 4 < 3 * v142)
              {
                if (v142 + ~(_DWORD)v141 - HIDWORD(v141) <= v142 >> 3)
                  goto LABEL_92;
                goto LABEL_77;
              }
LABEL_91:
              v56 = 2 * v142;
LABEL_92:
              llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::grow((uint64_t)&v140, v56);
              if (v142)
              {
                v65 = v142 - 1;
                v66 = (v142 - 1) & (37 * v33);
                v64 = (char *)v140 + 16 * v66;
                v67 = *(_DWORD *)v64;
                if (*(_DWORD *)v64 != v33)
                {
                  v68 = 0;
                  v69 = 1;
                  while (v67 != -1)
                  {
                    if (v68)
                      v70 = 0;
                    else
                      v70 = v67 == -2;
                    if (v70)
                      v68 = v64;
                    v71 = v66 + v69++;
                    v66 = v71 & v65;
                    v64 = (char *)v140 + 16 * (v71 & v65);
                    v67 = *(_DWORD *)v64;
                    if (*(_DWORD *)v64 == v33)
                      goto LABEL_77;
                  }
LABEL_120:
                  if (v68)
                    v64 = v68;
                }
LABEL_77:
                LODWORD(v141) = v141 + 1;
                if (*(_DWORD *)v64 != -1)
                  --HIDWORD(v141);
                *(_DWORD *)v64 = v33;
                *((_QWORD *)v64 + 1) = v38;
                goto LABEL_80;
              }
LABEL_119:
              v64 = 0;
              goto LABEL_77;
            }
          }
          else
          {
            v40 = v39;
            if ((~*(_DWORD *)(v39 + 8) & 7) != 0)
              v41 = 0;
            else
              v41 = v39;
            if (!v41
              || *(ZinIrHalH13g ***)(v41 + 16) != v7
              || ((v42 = *(_QWORD *)(v137 + 32 * *(unsigned int *)(v41 + 24) + 24),
                   v42 != *(_QWORD *)(v138 + 8 * v33))
                ? (v43 = v42 == v38)
                : (v43 = 1),
                  !v43))
            {
              v52 = v158;
              if (v158 >= HIDWORD(v158))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v157, &v159, v158 + 1, 8);
                v157[v158] = v38;
                LODWORD(v158) = v158 + 1;
                v53 = v155;
                if (v155 >= HIDWORD(v155))
                  goto LABEL_86;
LABEL_60:
                *((_QWORD *)v154 + v53) = v40;
              }
              else
              {
                v157[v158] = v38;
                LODWORD(v158) = v52 + 1;
                v53 = v155;
                if (v155 < HIDWORD(v155))
                  goto LABEL_60;
LABEL_86:
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v154, v156, v53 + 1, 8);
                *((_QWORD *)v154 + v155) = v40;
                LODWORD(v53) = v155;
              }
              LODWORD(v155) = v53 + 1;
              v54 = *(_QWORD *)(*(_QWORD *)(v138 + 8 * v33) + 32);
              v55 = v152;
              if (v152 >= HIDWORD(v152))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v153, v152 + 1, 8);
                v55 = v152;
              }
              *((_QWORD *)v151 + v55) = v54;
              LODWORD(v152) = v152 + 1;
              goto LABEL_80;
            }
            v44 = v142;
            if (!v142)
              goto LABEL_107;
            v45 = (v142 - 1) & (37 * v33);
            v46 = (char *)v140 + 16 * v45;
            v47 = *(_DWORD *)v46;
            if (*(_DWORD *)v46 != v33)
            {
              v48 = 0;
              v49 = 1;
              while (v47 != -1)
              {
                if (v48)
                  v50 = 0;
                else
                  v50 = v47 == -2;
                if (v50)
                  v48 = v46;
                v51 = v45 + v49++;
                v45 = v51 & (v142 - 1);
                v46 = (char *)v140 + 16 * v45;
                v47 = *(_DWORD *)v46;
                if (*(_DWORD *)v46 == v33)
                  goto LABEL_80;
              }
              if (v48)
                v64 = v48;
              else
                v64 = v46;
              if (4 * (int)v141 + 4 < 3 * v142)
              {
                if (v142 + ~(_DWORD)v141 - HIDWORD(v141) > v142 >> 3)
                  goto LABEL_77;
              }
              else
              {
LABEL_107:
                v44 = 2 * v142;
              }
              llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::grow((uint64_t)&v140, v44);
              if (v142)
              {
                v72 = v142 - 1;
                v73 = (v142 - 1) & (37 * v33);
                v64 = (char *)v140 + 16 * v73;
                v74 = *(_DWORD *)v64;
                if (*(_DWORD *)v64 != v33)
                {
                  v68 = 0;
                  v75 = 1;
                  while (v74 != -1)
                  {
                    if (v68)
                      v76 = 0;
                    else
                      v76 = v74 == -2;
                    if (v76)
                      v68 = v64;
                    v77 = v73 + v75++;
                    v73 = v77 & v72;
                    v64 = (char *)v140 + 16 * (v77 & v72);
                    v74 = *(_DWORD *)v64;
                    if (*(_DWORD *)v64 == v33)
                      goto LABEL_77;
                  }
                  goto LABEL_120;
                }
                goto LABEL_77;
              }
              goto LABEL_119;
            }
          }
LABEL_80:
          v36 = v145[1];
          v33 = LODWORD(v145[0]) + 1;
          ++v145[0];
          v32 = ++v145[2];
          v34 = ++v147;
        }
        while (*(_OWORD *)&v145[1] != __PAIR128__(v30, (unint64_t)v29));
      }
    }
    else
    {
      memset(v145, 0, sizeof(v145));
      v146 = v162;
      v147 = 0;
    }
    v79 = v135;
    v80 = (mlir::OpBuilder *)(v135 + 8);
    v81 = (_OWORD *)(v135 + 24);
    v139 = *(_OWORD *)(v135 + 24);
    v82 = *(_QWORD *)(v13 + 16);
    ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v13);
    *(_QWORD *)(v135 + 24) = v82;
    *(_QWORD *)(v135 + 32) = v83;
    v84 = mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(v135 + 8), *(_QWORD *)(v13 + 24), (uint64_t)&v154);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)v79 + 32))(v79, v13, v84);
    if ((_QWORD)v139)
    {
      *v81 = v139;
    }
    else
    {
      *(_QWORD *)v81 = 0;
      *(_QWORD *)(v135 + 32) = 0;
    }
    v85 = *(_QWORD *)(a2 + 24);
    v86 = *(unsigned int *)(a2 + 36);
    v87 = a2 - 16;
    if (!(_DWORD)v86)
      v87 = 0;
    v164[0] = v87;
    v164[1] = v86;
    mlir::OperandRange::getTypes(v164, (uint64_t *)v145);
    v88 = mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,6u> &>(v80, v85, (uint64_t *)v145, (uint64_t)&v157);
    v89 = (unsigned int *)v88;
    v90 = *((unsigned int *)v88 + 11);
    if ((v90 & 0x7FFFFF) != 0)
      v91 = (((unint64_t)v88 + 16 * ((v90 >> 23) & 1) + ((v90 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
          + 32 * *((unsigned int *)v88 + 10);
    else
      v91 = 0;
    v92 = (__n128 *)mlir::ValueRange::ValueRange((unint64_t *)v164, (uint64_t)v154, v155);
    mlir::ValueRange::getTypes(v92, &v148);
    v94 = (void *)v148.n128_u64[1];
    v93 = v148.n128_u64[0];
    v95 = v149;
    *(__n128 *)v145 = v148;
    if (v148.n128_u64[1])
    {
      v93 = mlir::ValueRange::offset_base(v145, v148.n128_i64[1]);
      v94 = v145[1];
    }
    mlir::TypeRange::TypeRange(v150, v93, v95 - (_QWORD)v94);
    Block = mlir::OpBuilder::createBlock(v80, v91, 0, v150[0], v150[1], (uint64_t)v151, v152);
    v97 = *(_QWORD *)(((v136
                      + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                      + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(a2 + 40)
                    + 8);
    if (v97)
      v98 = v97 - 8;
    else
      v98 = 0;
    v99 = (*(_QWORD *)(v98 + 56) - *(_QWORD *)(v98 + 48)) >> 3;
    v145[0] = &v145[2];
    v145[1] = (void *)0x600000000;
    if (!(_DWORD)v99)
    {
      LODWORD(v99) = 0;
      goto LABEL_195;
    }
    if (v99 < 7uLL)
    {
      v100 = 0;
      v101 = v99;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v145, &v145[2], v99, 8);
      v100 = LODWORD(v145[1]);
      v101 = v99 - (unint64_t)LODWORD(v145[1]);
      if (v99 == (unint64_t)LODWORD(v145[1]))
      {
LABEL_147:
        LODWORD(v145[1]) = v99;
        v102 = (*(_QWORD *)(v98 + 56) - *(_QWORD *)(v98 + 48)) >> 3;
        if ((_DWORD)v102)
        {
          v103 = v142;
          v104 = v102;
          if (v142)
          {
            v105 = 0;
            v106 = 0;
LABEL_150:
            v107 = 37 * v105;
            v108 = v103 - 1;
            v109 = (v103 - 1) & (37 * v105);
            v110 = (char *)v140 + 16 * v109;
            v111 = *(unsigned int *)v110;
            if (v105 == v111)
              goto LABEL_151;
            v112 = 1;
            LODWORD(v113) = *(_DWORD *)v110;
            v114 = v108 & v107;
            do
            {
              if ((_DWORD)v113 == -1)
              {
                while (1)
                {
                  v127 = *(_QWORD *)(*(_QWORD *)(Block + 48) + 8 * v106++);
                  *((_QWORD *)v145[0] + v105++) = v127;
                  if (v105 == v104)
                    goto LABEL_192;
LABEL_190:
                  v103 = v142;
                  if (v142)
                    goto LABEL_150;
                }
              }
              v115 = v114 + v112++;
              v114 = v115 & v108;
              v113 = *((unsigned int *)v140 + 4 * v114);
            }
            while (v105 != v113);
            if (v105 != v111)
            {
              v116 = 0;
              v117 = 1;
              while ((_DWORD)v111 != -1)
              {
                if (v116)
                  v118 = 0;
                else
                  v118 = (_DWORD)v111 == -2;
                if (v118)
                  v116 = v110;
                v119 = v109 + v117++;
                v109 = v119 & v108;
                v110 = (char *)v140 + 16 * (v119 & v108);
                v111 = *(unsigned int *)v110;
                if (v105 == v111)
                  goto LABEL_151;
              }
              if (4 * (int)v141 + 4 >= 3 * v103)
              {
                v103 *= 2;
              }
              else
              {
                if (v116)
                  v110 = v116;
                if (v103 + ~(_DWORD)v141 - HIDWORD(v141) > v103 >> 3)
                  goto LABEL_170;
              }
              llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::grow((uint64_t)&v140, v103);
              if (v142)
              {
                v120 = v142 - 1;
                v121 = (v142 - 1) & v107;
                v110 = (char *)v140 + 16 * v121;
                v122 = *(unsigned int *)v110;
                if (v105 != v122)
                {
                  v123 = 0;
                  v124 = 1;
                  while ((_DWORD)v122 != -1)
                  {
                    if (v123)
                      v125 = 0;
                    else
                      v125 = (_DWORD)v122 == -2;
                    if (v125)
                      v123 = v110;
                    v126 = v121 + v124++;
                    v121 = v126 & v120;
                    v110 = (char *)v140 + 16 * (v126 & v120);
                    v122 = *(unsigned int *)v110;
                    if (v105 == v122)
                      goto LABEL_170;
                  }
                  if (v123)
                    v110 = v123;
                }
              }
              else
              {
                v110 = 0;
              }
LABEL_170:
              LODWORD(v141) = v141 + 1;
              if (*(_DWORD *)v110 != -1)
                --HIDWORD(v141);
              *(_DWORD *)v110 = v105;
              *((_QWORD *)v110 + 1) = 0;
            }
LABEL_151:
            *((_QWORD *)v145[0] + v105++) = *((_QWORD *)v110 + 1);
            if (v105 != v104)
              goto LABEL_190;
LABEL_192:
            LODWORD(v99) = v145[1];
            v79 = v135;
          }
          else
          {
            v128 = 0;
            do
            {
              *(_QWORD *)((char *)v145[0] + v128) = *(_QWORD *)(*(_QWORD *)(Block + 48) + v128);
              v128 += 8;
            }
            while (8 * v104 != v128);
          }
        }
LABEL_195:
        mlir::ValueRange::ValueRange(v144, (uint64_t)v145[0], v99);
        mlir::RewriterBase::mergeBlocks(v79, v98, Block, v144[0], v144[1]);
        v129 = *(unsigned int *)(a2 + 44);
        if ((v129 & 0x7FFFFF) != 0)
          v130 = ((v136 + 16 * ((v129 >> 23) & 1) + ((v129 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
               + 32 * *(unsigned int *)(a2 + 40);
        else
          v130 = 0;
        v131 = v130 + 24;
        v132 = (((unint64_t)&v89[4 * (((unint64_t)v89[11] >> 23) & 1) + 17]
               + (((unint64_t)v89[11] >> 21) & 0x7F8)
               + 3) & 0xFFFFFFFFFFFFFFF8)
             + 32 * v89[10];
        (**(void (***)(uint64_t, unint64_t, uint64_t, _QWORD))v79)(v79, v131, v132 + 24, *(_QWORD *)(v132 + 32));
        v133 = v89[9];
        if ((_DWORD)v133)
          v134 = (uint64_t)(v89 - 4);
        else
          v134 = 0;
        mlir::ValueRange::ValueRange(v143, v134, v133);
        (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)v79 + 24))(v79, a2, v143[0], v143[1]);
        if (v145[0] != &v145[2])
          free(v145[0]);
        if (v151 != v153)
          free(v151);
        llvm::deallocate_buffer(v140, (void *)(16 * v142));
      }
    }
    bzero((char *)v145[0] + 8 * v100, 8 * v101);
    goto LABEL_147;
  }
  return 0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t NextResultAtOffset;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[38];
  uint64_t v24[4];
  __int16 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.while", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"scf.while";
    v24[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v24, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  NextResultAtOffset = *a3;
  v12 = a3[1];
  v13 = a3[3];
  if (v12)
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v12);
  mlir::ValueRange::ValueRange((unint64_t *)v24, NextResultAtOffset, v13 - v12);
  mlir::TypeRange::TypeRange(v22, v24[0], v24[1]);
  v14 = mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::scf::WhileOp::build((uint64_t)v14, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], 0, 0);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_DWORD *llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _DWORD *result;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  _DWORD *v15;
  llvm *v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  unsigned int v30;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_10;
      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[4 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 4;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 4) = -1;
        *v13 = -1;
        v13 += 8;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_10:
        v15 = &result[4 * v11];
        do
        {
          *v10 = -1;
          v10 += 4;
        }
        while (v10 != v15);
      }
    }
    if ((_DWORD)v3)
    {
      v16 = v4;
      do
      {
        v23 = *(_DWORD *)v16;
        if (*(_DWORD *)v16 <= 0xFFFFFFFD)
        {
          v24 = *(_DWORD *)(a1 + 16) - 1;
          v25 = v24 & (37 * v23);
          v22 = *(_QWORD *)a1 + 16 * v25;
          v26 = *(_DWORD *)v22;
          if (v23 != *(_DWORD *)v22)
          {
            v27 = 0;
            v28 = 1;
            while (v26 != -1)
            {
              if (v27)
                v29 = 0;
              else
                v29 = v26 == -2;
              if (v29)
                v27 = v22;
              v30 = v25 + v28++;
              v25 = v30 & v24;
              v22 = *(_QWORD *)a1 + 16 * (v30 & v24);
              v26 = *(_DWORD *)v22;
              if (v23 == *(_DWORD *)v22)
                goto LABEL_24;
            }
            if (v27)
              v22 = v27;
          }
LABEL_24:
          *(_DWORD *)v22 = v23;
          *(_QWORD *)(v22 + 8) = *((_QWORD *)v16 + 1);
          ++*(_DWORD *)(a1 + 8);
        }
        v16 = (llvm *)((char *)v16 + 16);
      }
      while (v16 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v17 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v17)
  {
    if (((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_19;
    v18 = ((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[4 * (v18 & 0x1FFFFFFFFFFFFFFELL)];
    v19 = result + 4;
    v20 = v18 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v19 - 4) = -1;
      *v19 = -1;
      v19 += 8;
      v20 -= 2;
    }
    while (v20);
    if (v18 != (v18 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_19:
      v21 = &result[4 * v17];
      do
      {
        *v10 = -1;
        v10 += 4;
      }
      while (v10 != v21);
    }
  }
  return result;
}

void `anonymous namespace'::RemoveLoopInvariantValueYielded::~RemoveLoopInvariantValueYielded(_anonymous_namespace_::RemoveLoopInvariantValueYielded *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::RemoveLoopInvariantValueYielded::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  ZinIrHalH13g **v7;
  uint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  char *v21;
  int v22;
  void *v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  int v31;
  BOOL v32;
  unsigned int v33;
  char *v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  char *v38;
  int v39;
  BOOL v40;
  unsigned int v41;
  void *v42;
  mlir::OpBuilder *v43;
  _OWORD *v44;
  uint64_t v45;
  uint64_t v46;
  ZinIrHalH13g *v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  ZinIrHalH13g *v52;
  ZinIrHalH13g *v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t Block;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  char *v74;
  uint64_t v75;
  char *v76;
  char *v77;
  int v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  char *v82;
  int v83;
  BOOL v84;
  unsigned int v85;
  uint64_t v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  char *v90;
  int v91;
  BOOL v92;
  unsigned int v93;
  _QWORD *v94;
  _QWORD *v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  __int128 v101;
  uint64_t v102;
  uint64_t v103;
  llvm *v104;
  uint64_t v105;
  unsigned int v106;
  unint64_t v107[2];
  unint64_t v108[2];
  void *v109;
  uint64_t v110;
  _BYTE v111[48];
  void *v112;
  uint64_t v113;
  _BYTE v114[48];
  unint64_t v115[2];
  void *v116;
  uint64_t v117;
  _BYTE v118[48];
  _BYTE *v119;
  uint64_t v120;
  _BYTE v121[48];
  _QWORD *v122;
  uint64_t v123;
  _QWORD v124[8];

  v124[6] = *MEMORY[0x24BDAC8D0];
  v5 = a2 + 64;
  v6 = *(_QWORD *)(((a2
                   + 64
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v6)
    v7 = (ZinIrHalH13g **)(v6 - 8);
  else
    v7 = 0;
  mlir::Block::getTerminator(v7);
  v9 = (ZinIrHalH13g *)v8;
  if ((*(_BYTE *)(v8 + 46) & 0x80) == 0)
  {
    v103 = a3;
    v11 = -1;
    v12 = 32;
LABEL_7:
    v13 = (_QWORD *)(v12 + 24);
    v14 = v11;
    while (1)
    {
      v122 = (_QWORD *)*v13;
      if ((ZinIrHalH13g **)mlir::Value::getParentBlock((mlir::Value *)&v122) != v7)
        break;
      v13 += 4;
      if (!--v14)
        return 0;
    }
    v16 = 0;
    v102 = v5;
    v17 = *(_QWORD *)(((v5
                      + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                      + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(a2 + 40)
                    + 32);
    if (v17)
      v18 = v17 - 8;
    else
      v18 = 0;
    v19 = *(_QWORD *)(v18 + 48);
    v122 = v124;
    v123 = 0x600000000;
    v119 = v121;
    v120 = 0x600000000;
    v104 = 0;
    v105 = 0;
    v106 = 0;
    v116 = v118;
    v117 = 0x600000000;
    while (1)
    {
      v112 = *(void **)(v12 + 32 * v16 + 24);
      if ((ZinIrHalH13g **)mlir::Value::getParentBlock((mlir::Value *)&v112) == v7)
      {
        v25 = v123;
        if (v123 >= HIDWORD(v123))
        {
          v42 = v112;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v124, v123 + 1, 8);
          v122[v123] = v42;
          v25 = v123;
        }
        else
        {
          v122[v123] = v112;
        }
        LODWORD(v123) = v25 + 1;
        v26 = *((_QWORD *)v112 + 1) & 0xFFFFFFFFFFFFFFF8;
        v27 = v120;
        if (v120 >= HIDWORD(v120))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v121, v120 + 1, 8);
          *(_QWORD *)&v119[8 * v120] = v26;
          v27 = v120;
        }
        else
        {
          *(_QWORD *)&v119[8 * v120] = v26;
        }
        LODWORD(v120) = v27 + 1;
        v28 = *(_QWORD *)(*(_QWORD *)(v19 + 8 * v16) + 32);
        v29 = v117;
        if (v117 >= HIDWORD(v117))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v118, v117 + 1, 8);
          v29 = v117;
        }
        *((_QWORD *)v116 + v29) = v28;
        LODWORD(v117) = v117 + 1;
        goto LABEL_16;
      }
      v23 = v112;
      v24 = v106;
      if (!v106)
        goto LABEL_44;
      v20 = (v106 - 1) & (37 * v16);
      v21 = (char *)v104 + 16 * v20;
      v22 = *(_DWORD *)v21;
      if (*(_DWORD *)v21 != (_DWORD)v16)
        break;
LABEL_16:
      if (++v16 == v11)
      {
        v43 = (mlir::OpBuilder *)(v103 + 8);
        v44 = (_OWORD *)(v103 + 24);
        v101 = *(_OWORD *)(v103 + 24);
        v45 = *((_QWORD *)v9 + 2);
        ZinIrHalH13g::~ZinIrHalH13g(v9);
        *(_QWORD *)(v103 + 24) = v45;
        *(_QWORD *)(v103 + 32) = v46;
        v112 = *(void **)(*((_QWORD *)v9 + 9) + 24);
        v47 = mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(v103 + 8), *((_QWORD *)v9 + 3), (uint64_t *)&v112, (uint64_t)&v122);
        (*(void (**)(uint64_t, ZinIrHalH13g *, ZinIrHalH13g *))(*(_QWORD *)v103 + 32))(v103, v9, v47);
        if ((_QWORD)v101)
        {
          *v44 = v101;
          v48 = v102;
          v49 = *(_QWORD *)(a2 + 24);
          if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
            goto LABEL_64;
LABEL_68:
          v50 = 0;
          v51 = 0;
        }
        else
        {
          *(_QWORD *)v44 = 0;
          *(_QWORD *)(v103 + 32) = 0;
          v48 = v102;
          v49 = *(_QWORD *)(a2 + 24);
          if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
            goto LABEL_68;
LABEL_64:
          v50 = *(void **)(a2 + 72);
          v51 = *(unsigned int *)(a2 + 68);
        }
        v112 = v50;
        v113 = v51;
        v52 = mlir::OpBuilder::create<mlir::scf::WhileOp,llvm::SmallVector<mlir::Type,6u> &,mlir::OperandRange>(v43, v49, (uint64_t)&v119, (uint64_t)&v112);
        v53 = v52;
        v54 = *((unsigned int *)v52 + 11);
        if ((v54 & 0x7FFFFF) != 0)
          v55 = (((unint64_t)v52 + 16 * ((v54 >> 23) & 1) + ((v54 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
              + 32 * *((unsigned int *)v52 + 10);
        else
          v55 = 0;
        v56 = v55 + 24;
        mlir::ValueRange::ValueRange(v115, (uint64_t)v119, v120);
        Block = mlir::OpBuilder::createBlock(v43, v56, 0, v115[0], v115[1], (uint64_t)v116, v117);
        v58 = *(_QWORD *)(((v48
                          + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                          + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                          + 7) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * *(unsigned int *)(a2 + 40)
                        + 32);
        if (v58)
          v59 = v58 - 8;
        else
          v59 = 0;
        v60 = *(_QWORD *)(v59 + 56) - *(_QWORD *)(v59 + 48);
        v61 = v60 >> 3;
        v62 = (v60 >> 3);
        v112 = v114;
        v113 = 0x600000000;
        if (!(v60 >> 3))
        {
          v109 = v111;
          v110 = 0x600000000;
          goto LABEL_87;
        }
        if (v62 < 7)
        {
          v63 = 0;
          v64 = v62;
          if (!v62)
            goto LABEL_80;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v114, (v60 >> 3), 8);
          v63 = v113;
          v64 = v62 - v113;
          if (v62 == v113)
          {
LABEL_80:
            LODWORD(v113) = v61;
            v61 = (*(_QWORD *)(v59 + 56) - *(_QWORD *)(v59 + 48)) >> 3;
            v109 = v111;
            v110 = 0x600000000;
            if (!(_DWORD)v61)
              goto LABEL_87;
            if (v61 < 7uLL)
            {
              v65 = 0;
              v66 = v61;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v111, v61, 8);
              v65 = v110;
              v66 = v61 - (unint64_t)v110;
              if (v61 == (unint64_t)v110)
              {
LABEL_86:
                LODWORD(v110) = v61;
                v61 = (*(_QWORD *)(v59 + 56) - *(_QWORD *)(v59 + 48)) >> 3;
LABEL_87:
                if ((_DWORD)v61)
                {
                  v67 = (char *)v53 - 96;
                  v68 = v106;
                  if (v106)
                  {
                    v69 = 0;
                    v70 = 0;
LABEL_90:
                    v71 = 37 * v69;
                    v72 = v68 - 1;
                    v73 = (v68 - 1) & (37 * v69);
                    v74 = (char *)v104 + 16 * v73;
                    v75 = *(unsigned int *)v74;
                    if (v69 == v75)
                      goto LABEL_91;
                    v78 = 1;
                    LODWORD(v79) = *(_DWORD *)v74;
                    v80 = v72 & v71;
                    while ((_DWORD)v79 != -1)
                    {
                      v81 = v80 + v78++;
                      v80 = v81 & v72;
                      v79 = *((unsigned int *)v104 + 4 * v80);
                      if (v69 == v79)
                      {
                        if (v69 != v75)
                        {
                          v82 = 0;
                          v83 = 1;
                          while ((_DWORD)v75 != -1)
                          {
                            if (v82)
                              v84 = 0;
                            else
                              v84 = (_DWORD)v75 == -2;
                            if (v84)
                              v82 = v74;
                            v85 = v73 + v83++;
                            v73 = v85 & v72;
                            v74 = (char *)v104 + 16 * (v85 & v72);
                            v75 = *(unsigned int *)v74;
                            if (v69 == v75)
                              goto LABEL_91;
                          }
                          if (4 * (int)v105 + 4 >= 3 * v68)
                          {
                            v68 *= 2;
                          }
                          else
                          {
                            if (v82)
                              v74 = v82;
                            if (v68 + ~(_DWORD)v105 - HIDWORD(v105) > v68 >> 3)
                              goto LABEL_116;
                          }
                          llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::grow((uint64_t)&v104, v68);
                          if (v106)
                          {
                            v87 = v106 - 1;
                            v88 = (v106 - 1) & v71;
                            v74 = (char *)v104 + 16 * v88;
                            v89 = *(unsigned int *)v74;
                            if (v69 != v89)
                            {
                              v90 = 0;
                              v91 = 1;
                              while ((_DWORD)v89 != -1)
                              {
                                if (v90)
                                  v92 = 0;
                                else
                                  v92 = (_DWORD)v89 == -2;
                                if (v92)
                                  v90 = v74;
                                v93 = v88 + v91++;
                                v88 = v93 & v87;
                                v74 = (char *)v104 + 16 * (v93 & v87);
                                v89 = *(unsigned int *)v74;
                                if (v69 == v89)
                                  goto LABEL_116;
                              }
                              if (v90)
                                v74 = v90;
                            }
                          }
                          else
                          {
                            v74 = 0;
                          }
LABEL_116:
                          LODWORD(v105) = v105 + 1;
                          if (*(_DWORD *)v74 != -1)
                            --HIDWORD(v105);
                          *(_DWORD *)v74 = v69;
                          *((_QWORD *)v74 + 1) = 0;
                        }
LABEL_91:
                        v76 = (char *)*((_QWORD *)v74 + 1);
                        v77 = v76;
                        goto LABEL_109;
                      }
                    }
                    while (1)
                    {
                      v76 = *(char **)(*(_QWORD *)(Block + 48) + 8 * v70);
                      v77 = &v67[-24 * v70 + 120];
                      if (v70 <= 5)
                        v77 = (char *)v53 - 16 * v70 - 16;
                      ++v70;
LABEL_109:
                      v86 = 8 * v69;
                      *(_QWORD *)((char *)v112 + v86) = v76;
                      *(_QWORD *)((char *)v109 + v86) = v77;
                      if (++v69 == v61)
                        break;
                      v68 = v106;
                      if (v106)
                        goto LABEL_90;
                    }
                  }
                  else
                  {
                    *(_QWORD *)v112 = **(_QWORD **)(Block + 48);
                    *(_QWORD *)v109 = (char *)v53 - 16;
                    if ((_DWORD)v61 != 1)
                    {
                      v94 = v112;
                      *((_QWORD *)v112 + 1) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 8);
                      v95 = v109;
                      *((_QWORD *)v109 + 1) = (char *)v53 - 32;
                      if ((_DWORD)v61 != 2)
                      {
                        v94[2] = *(_QWORD *)(*(_QWORD *)(Block + 48) + 16);
                        v95[2] = (char *)v53 - 48;
                        if ((_DWORD)v61 != 3)
                        {
                          v94[3] = *(_QWORD *)(*(_QWORD *)(Block + 48) + 24);
                          v95[3] = (char *)v53 - 64;
                          if ((_DWORD)v61 != 4)
                          {
                            v94[4] = *(_QWORD *)(*(_QWORD *)(Block + 48) + 32);
                            v95[4] = (char *)v53 - 80;
                            if ((_DWORD)v61 != 5)
                            {
                              v94[5] = *(_QWORD *)(*(_QWORD *)(Block + 48) + 40);
                              v95[5] = v67;
                              if ((_DWORD)v61 != 6)
                              {
                                v96 = (char *)v53 - 120;
                                v97 = 6;
                                do
                                {
                                  v98 = 8 * v97;
                                  *(_QWORD *)((char *)v112 + v98) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 8 * v97++);
                                  *(_QWORD *)((char *)v109 + v98) = v96;
                                  v96 -= 24;
                                }
                                while (v61 != v97);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                mlir::ValueRange::ValueRange(v108, (uint64_t)v112, v113);
                v99 = v103;
                mlir::RewriterBase::mergeBlocks(v103, v59, Block, v108[0], v108[1]);
                v100 = (((unint64_t)v53
                       + 16 * (((unint64_t)*((unsigned int *)v53 + 11) >> 23) & 1)
                       + (((unint64_t)*((unsigned int *)v53 + 11) >> 21) & 0x7F8)
                       + 71) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * *((unsigned int *)v53 + 10);
                (**(void (***)(uint64_t, unint64_t, unint64_t, _QWORD))v99)(v99, ((v102+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *(unsigned int *)(a2 + 40), v100, *(_QWORD *)(v100 + 8));
                mlir::ValueRange::ValueRange(v107, (uint64_t)v109, v110);
                (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)v99 + 24))(v99, a2, v107[0], v107[1]);
                if (v109 != v111)
                  free(v109);
                if (v112 != v114)
                  free(v112);
                if (v116 != v118)
                  free(v116);
                llvm::deallocate_buffer(v104, (void *)(16 * v106));
              }
            }
            bzero((char *)v109 + 8 * v65, 8 * v66);
            goto LABEL_86;
          }
        }
        bzero((char *)v112 + 8 * v63, 8 * v64);
        goto LABEL_80;
      }
    }
    v30 = 0;
    v31 = 1;
    while (v22 != -1)
    {
      if (v30)
        v32 = 0;
      else
        v32 = v22 == -2;
      if (v32)
        v30 = v21;
      v33 = v20 + v31++;
      v20 = v33 & (v106 - 1);
      v21 = (char *)v104 + 16 * v20;
      v22 = *(_DWORD *)v21;
      if (*(_DWORD *)v21 == (_DWORD)v16)
        goto LABEL_16;
    }
    if (v30)
      v34 = v30;
    else
      v34 = v21;
    if (4 * (int)v105 + 4 < 3 * v106)
    {
      if (v106 + ~(_DWORD)v105 - HIDWORD(v105) > v106 >> 3)
      {
LABEL_21:
        LODWORD(v105) = v105 + 1;
        if (*(_DWORD *)v34 != -1)
          --HIDWORD(v105);
        *(_DWORD *)v34 = v16;
        *((_QWORD *)v34 + 1) = v23;
        goto LABEL_16;
      }
    }
    else
    {
LABEL_44:
      v24 = 2 * v106;
    }
    llvm::DenseMap<unsigned int,mlir::Value,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::Value>>::grow((uint64_t)&v104, v24);
    if (v106)
    {
      v35 = v106 - 1;
      v36 = (v106 - 1) & (37 * v16);
      v34 = (char *)v104 + 16 * v36;
      v37 = *(_DWORD *)v34;
      if (*(_DWORD *)v34 != (_DWORD)v16)
      {
        v38 = 0;
        v39 = 1;
        while (v37 != -1)
        {
          if (v38)
            v40 = 0;
          else
            v40 = v37 == -2;
          if (v40)
            v38 = v34;
          v41 = v36 + v39++;
          v36 = v41 & v35;
          v34 = (char *)v104 + 16 * (v41 & v35);
          v37 = *(_DWORD *)v34;
          if (*(_DWORD *)v34 == (_DWORD)v16)
            goto LABEL_21;
        }
        if (v38)
          v34 = v38;
      }
    }
    else
    {
      v34 = 0;
    }
    goto LABEL_21;
  }
  v10 = *(unsigned int *)(v8 + 68);
  v11 = v10 - 1;
  if (v10 != 1)
  {
    v103 = a3;
    v12 = *(_QWORD *)(v8 + 72) + 32;
    goto LABEL_7;
  }
  return 0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::WhileOp,llvm::SmallVector<mlir::Type,6u> &,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  unint64_t *v11;
  ZinIrHalH13g *v12;
  ZinIrHalH13g *v13;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  unint64_t v20[2];
  unint64_t v21[2];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x24BDAC8D0];
  v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.while", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v19 = 1283;
    v18[2] = (uint64_t)"scf.while";
    v18[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  v11 = mlir::ValueRange::ValueRange(v20, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  mlir::scf::WhileOp::build((uint64_t)v11, (uint64_t)v22, v21[0], v21[1], v20[0], v20[1], 0, 0);
  v12 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
    v13 = v12;
  else
    v13 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v13;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20[4];
  __int16 v21;
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x24BDAC8D0];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.condition", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v21 = 1283;
    v20[2] = (uint64_t)"scf.condition";
    v20[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  v12 = v22[0];
  v13 = v22[1];
  v20[0] = v11;
  mlir::OperationState::addOperands((uint64_t)v23, (uint64_t)v20, 1);
  mlir::OperationState::addOperands((uint64_t)v23, v12, v13);
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ConditionOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v15;
}

void `anonymous namespace'::WhileConditionTruth::~WhileConditionTruth(_anonymous_namespace_::WhileConditionTruth *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::WhileConditionTruth::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::BoolAttr **a3)
{
  uint64_t v4;
  uint64_t v5;
  ZinIrHalH13g **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t ***v14;
  uint64_t ***v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  mlir::BoolAttr **v27;
  uint64_t v29;
  _QWORD *BoolAttr;
  unint64_t v31;

  v4 = a2 + 64;
  v5 = *(_QWORD *)(((a2
                   + 64
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v5)
    v6 = (ZinIrHalH13g **)(v5 - 8);
  else
    v6 = 0;
  mlir::Block::getTerminator(v6);
  v8 = v7;
  if ((*(_BYTE *)(v7 + 46) & 0x80) != 0)
  {
    v9 = *(_QWORD *)(v7 + 72);
    v10 = *(unsigned int *)(v7 + 68) - 1;
  }
  else
  {
    v9 = 0;
    v10 = -1;
  }
  v11 = 0;
  v12 = *(_QWORD *)(((v4
                    + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                    + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a2 + 40)
                  + 32);
  if (v12)
    v13 = v12 - 8;
  else
    v13 = 0;
  if (v10)
  {
    v14 = *(uint64_t ****)(v13 + 48);
    v15 = *(uint64_t ****)(v13 + 56);
    if (v15 != v14)
    {
      v11 = 0;
      v16 = 0;
      v17 = 0;
      v18 = v9 + 32;
      v27 = a3 + 1;
      v29 = v10;
      do
      {
        v19 = *(_QWORD *)(v18 + 32 * v17 + 24);
        if (v19 == *(_QWORD *)(*(_QWORD *)(v8 + 72) + 24))
        {
          v20 = **v14;
          if (v20)
          {
            if (v16
              || (v21 = *(_QWORD *)(a2 + 24),
                  v31 = *(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8,
                  BoolAttr = (_QWORD *)mlir::Builder::getBoolAttr(v27, (mlir::MLIRContext *)1),
                  v16 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::IntegerAttr>((mlir::OpBuilder *)v27, v21, (uint64_t *)&v31, &BoolAttr)- 16), (v20 = **v14) != 0))
            {
              do
              {
                v22 = (uint64_t *)*v20;
                v23 = v20[2];
                (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 9))(a3, v23);
                v24 = (uint64_t *)v20[1];
                if (v24)
                {
                  *v24 = *v20;
                  if (*v20)
                    *(_QWORD *)(*v20 + 8) = v20[1];
                }
                v20[3] = (uint64_t)v16;
                v20[1] = (uint64_t)v16;
                v25 = *v16;
                *v20 = *v16;
                if (v25)
                  *(_QWORD *)(v25 + 8) = v20;
                *v16 = (uint64_t)v20;
                (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 10))(a3, v23);
                v20 = v22;
              }
              while (v22);
              v11 = 1;
              v10 = v29;
            }
            else
            {
              v11 = 1;
            }
          }
        }
        if (++v17 == v10)
          break;
        ++v14;
      }
      while (v14 != v15);
    }
  }
  return v11 & 1;
}

void `anonymous namespace'::WhileCmpCond::~WhileCmpCond(_anonymous_namespace_::WhileCmpCond *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::WhileCmpCond::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  ZinIrHalH13g **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD **v18;
  uint64_t v19;
  mlir::Builder *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t Predicate;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *Context;
  uint64_t v32;
  char v33;
  ZinIrHalH13g *v34;
  mlir::Operation *v35;
  _BOOL4 v36;
  ZinIrHalH13g *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  char v48;
  ZinIrHalH13g *v49;
  mlir::Operation *v50;
  _BOOL4 v51;
  ZinIrHalH13g *v52;
  uint64_t v53;
  _QWORD **v54;
  uint64_t v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  __int16 v61;
  uint64_t v62[4];
  __int16 v63;
  _BYTE v64[40];
  _QWORD v65[40];

  v65[38] = *MEMORY[0x24BDAC8D0];
  v4 = a2 + 64;
  v5 = *(_QWORD *)(((a2
                   + 64
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v5)
    v6 = (ZinIrHalH13g **)(v5 - 8);
  else
    v6 = 0;
  mlir::Block::getTerminator(v6);
  v8 = v7;
  v65[0] = *(_QWORD *)(*(_QWORD *)(v7 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v65);
  if (result)
  {
    v10 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v11 = v10 == &mlir::detail::TypeIDResolver<mlir::arith::CmpIOp,void>::id;
    if (v10 == &mlir::detail::TypeIDResolver<mlir::arith::CmpIOp,void>::id)
      v12 = result;
    else
      v12 = 0;
    v58 = v12;
    if (!v11)
      return 0;
    if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
    {
      v13 = *(_QWORD *)(v8 + 72);
      v14 = *(unsigned int *)(v8 + 68) - 1;
    }
    else
    {
      v13 = 0;
      v14 = -1;
    }
    v15 = 0;
    v16 = *(_QWORD *)(((v4
                      + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                      + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                      + 7) & 0xFFFFFFFFFFFFFFF8)
                    + 32 * *(unsigned int *)(a2 + 40)
                    + 32);
    if (v16)
      v17 = v16 - 8;
    else
      v17 = 0;
    if (!v14)
      return v15 & 1;
    v18 = *(_QWORD ***)(v17 + 48);
    v54 = *(_QWORD ***)(v17 + 56);
    if (v54 == v18)
      return v15 & 1;
    v15 = 0;
    v19 = 0;
    v55 = v13 + 32;
    v20 = (mlir::Builder *)(a3 + 8);
    v53 = v14;
LABEL_19:
    v21 = *(_QWORD *)(v55 + 32 * v19 + 24);
    v22 = *(_QWORD *)(v58 + 72);
    if (v21 != *(_QWORD *)(v22 + 24) || (v23 = (_QWORD *)**v18) == 0)
    {
      if (v21 == *(_QWORD *)(v22 + 56))
        goto LABEL_40;
      goto LABEL_22;
    }
    while (1)
    {
      v24 = v23[2];
      v23 = (_QWORD *)*v23;
      if (*(_UNKNOWN **)(*(_QWORD *)(v24 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::arith::CmpIOp,void>::id)
        v24 = 0;
      v57 = v24;
      if (v24 && *(_QWORD *)(*(_QWORD *)(v24 + 72) + 56) == *(_QWORD *)(*(_QWORD *)(v58 + 72) + 56))
      {
        Predicate = mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v57);
        if (Predicate == mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v58))
        {
          v26 = 1;
LABEL_34:
          v29 = v57;
          v30 = *(_QWORD *)(v57 + 24);
          v59 = v30;
          Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v59);
          v32 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, Context);
          if (!v33)
          {
LABEL_57:
            v63 = 1283;
            v62[2] = (uint64_t)"arith.constant";
            v62[3] = 14;
                  "added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-"
                  "whats-up-with-dialects-management";
            v61 = 259;
            llvm::operator+(v62, (uint64_t *)&v60, (uint64_t)v64);
            llvm::report_fatal_error((llvm::Twine *)v64, 1);
          }
          mlir::OperationState::OperationState(v65, v30, v32);
          v15 = 1;
          mlir::arith::ConstantIntOp::build(v20, (uint64_t)v65, v26, 1u);
          v34 = mlir::OpBuilder::create(v20, (const mlir::OperationState *)v65);
          v36 = mlir::arith::ConstantIntOp::classof((_BOOL8)v34, v35);
          mlir::OperationState::~OperationState((mlir::OperationState *)v65);
          if (v36)
            v37 = v34;
          else
            v37 = 0;
          (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v29, v37);
          goto LABEL_25;
        }
        v27 = mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v57);
        v28 = mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v58);
        if (v27 == mlir::arith::invertPredicate(v28))
        {
          v26 = 0;
          goto LABEL_34;
        }
      }
LABEL_25:
      if (!v23)
      {
        if (v21 == *(_QWORD *)(*(_QWORD *)(v58 + 72) + 56))
        {
LABEL_40:
          v38 = (_QWORD *)**v18;
          if (!v38)
            goto LABEL_22;
          while (2)
          {
            v39 = v38[2];
            v38 = (_QWORD *)*v38;
            if (*(_UNKNOWN **)(*(_QWORD *)(v39 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::arith::CmpIOp,void>::id)
              v39 = 0;
            v57 = v39;
            if (v39 && *(_QWORD *)(*(_QWORD *)(v39 + 72) + 24) == *(_QWORD *)(*(_QWORD *)(v58 + 72) + 24))
            {
              v40 = mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v57);
              if (v40 == mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v58))
              {
                v41 = 1;
                goto LABEL_51;
              }
              v42 = mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v57);
              v43 = mlir::arith::CmpIOp::getPredicate((mlir::arith::CmpIOp *)&v58);
              if (v42 == mlir::arith::invertPredicate(v43))
              {
                v41 = 0;
LABEL_51:
                v44 = v57;
                v45 = *(_QWORD *)(v57 + 24);
                v59 = v45;
                v46 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v59);
                v47 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, v46);
                if (!v48)
                  goto LABEL_57;
                mlir::OperationState::OperationState(v65, v45, v47);
                v15 = 1;
                mlir::arith::ConstantIntOp::build(v20, (uint64_t)v65, v41, 1u);
                v49 = mlir::OpBuilder::create(v20, (const mlir::OperationState *)v65);
                v51 = mlir::arith::ConstantIntOp::classof((_BOOL8)v49, v50);
                mlir::OperationState::~OperationState((mlir::OperationState *)v65);
                if (v51)
                  v52 = v49;
                else
                  v52 = 0;
                (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, v44, v52);
              }
            }
            if (!v38)
              break;
            continue;
          }
        }
LABEL_22:
        if (++v19 == v53)
          return v15 & 1;
        if (++v18 == v54)
          return v15 & 1;
        goto LABEL_19;
      }
    }
  }
  return result;
}

void `anonymous namespace'::WhileUnusedResult::~WhileUnusedResult(_anonymous_namespace_::WhileUnusedResult *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::WhileUnusedResult::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int *v5;
  uint64_t v6;
  ZinIrHalH13g **v7;
  uint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *NextResultAtOffset;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  int v31;
  uint64_t Loc;
  uint64_t v33;
  mlir::OpBuilder *v34;
  _OWORD *v35;
  uint64_t v36;
  uint64_t v37;
  ZinIrHalH13g *v38;
  unsigned int *v39;
  unsigned int *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  ZinIrHalH13g *v44;
  ZinIrHalH13g *v45;
  unint64_t v46;
  unint64_t v47;
  void *v48;
  uint64_t v50;
  uint64_t Block;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unsigned int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int *v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  __int128 v73;
  unsigned int *v74;
  uint64_t v75;
  unsigned int *v76;
  unint64_t v77[2];
  unint64_t v78[2];
  void *v79;
  uint64_t v80;
  _BYTE v81[48];
  void *v82;
  uint64_t v83;
  _BYTE v84[48];
  unint64_t v85[2];
  void *v86;
  uint64_t v87;
  _BYTE v88[48];
  void *v89;
  uint64_t v90;
  _BYTE v91[48];
  _QWORD *v92;
  uint64_t v93;
  _BYTE v94[48];
  unsigned int *v95;
  uint64_t v96;
  _QWORD v97[8];

  v97[6] = *MEMORY[0x24BDAC8D0];
  v5 = a2 + 16;
  v6 = *(_QWORD *)((((unint64_t)&a2[4 * (((unint64_t)a2[11] >> 23) & 1) + 17]
                   + (((unint64_t)a2[11] >> 21) & 0x7F8)
                   + 3) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * a2[10]
                 + 8);
  if (v6)
    v7 = (ZinIrHalH13g **)(v6 - 8);
  else
    v7 = 0;
  mlir::Block::getTerminator(v7);
  v9 = (ZinIrHalH13g *)v8;
  v10 = *(_QWORD *)((((unint64_t)&v5[4 * (((unint64_t)a2[11] >> 23) & 1) + 1]
                    + (((unint64_t)a2[11] >> 21) & 0x7F8)
                    + 3) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * a2[10]
                  + 32);
  if (v10)
    v11 = v10 - 8;
  else
    v11 = 0;
  v76 = v5;
  if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
  {
    v12 = *(_QWORD *)(v8 + 72);
    v13 = *(unsigned int *)(v8 + 68) - 1;
  }
  else
  {
    v12 = 0;
    v13 = -1;
  }
  v14 = 0;
  v16 = *(_QWORD *)(v11 + 48);
  v15 = *(_QWORD *)(v11 + 56);
  v95 = (unsigned int *)v97;
  v96 = 0xC00000000;
  v92 = v94;
  v93 = 0x600000000;
  v89 = v91;
  v90 = 0x600000000;
  v86 = v88;
  v17 = a2[9];
  if ((_DWORD)v17)
    v18 = (uint64_t)(a2 - 4);
  else
    v18 = 0;
  v87 = 0x600000000;
  if (!(_DWORD)v17 || (v15 != v16 ? (v19 = v13 == 0) : (v19 = 1), v19))
  {
LABEL_44:
    v48 = v86;
    if (v86 == v88)
      goto LABEL_46;
    goto LABEL_45;
  }
  v74 = a2;
  v75 = a3;
  v20 = 0;
  v21 = 0;
  v22 = (uint64_t *)(v12 + 56);
  v23 = v17 - 1;
  v24 = v13 - 1;
  v25 = 8 * ((v15 - v16) >> 3) - 8;
  while (1)
  {
    NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v18, v21);
    v27 = *v22;
    v82 = NextResultAtOffset;
    if (!*NextResultAtOffset && !**(_QWORD **)(v16 + 8 * v21))
    {
      v20 = 1;
      if (v23 == v21)
        break;
      goto LABEL_29;
    }
    v28 = v96;
    if (v96 >= HIDWORD(v96))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v95, v97, v96 + 1, 4);
      v28 = v96;
    }
    v95[v28] = v21;
    LODWORD(v96) = v96 + 1;
    v29 = v90;
    if (v90 >= HIDWORD(v90))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v90 + 1, 8);
      *((_QWORD *)v89 + v90) = v27;
      v29 = v90;
    }
    else
    {
      *((_QWORD *)v89 + v90) = v27;
    }
    LODWORD(v90) = v29 + 1;
    v30 = *((_QWORD *)v82 + 1) & 0xFFFFFFFFFFFFFFF8;
    v31 = v93;
    if (v93 >= HIDWORD(v93))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v94, v93 + 1, 8);
      v92[v93] = v30;
      v31 = v93;
    }
    else
    {
      v92[v93] = v30;
    }
    LODWORD(v93) = v31 + 1;
    Loc = mlir::Value::getLoc((mlir::Value *)&v82);
    v33 = v87;
    if (v87 >= HIDWORD(v87))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v86, v88, v87 + 1, 8);
      v33 = v87;
    }
    *((_QWORD *)v86 + v33) = Loc;
    LODWORD(v87) = v87 + 1;
    if (v23 == v21)
      break;
LABEL_29:
    if (v25)
    {
      v22 += 4;
      v25 -= 8;
      v19 = v24 == v21++;
      if (!v19)
        continue;
    }
    break;
  }
  if ((v20 & 1) == 0)
  {
    v14 = 0;
    goto LABEL_44;
  }
  v34 = (mlir::OpBuilder *)(v75 + 8);
  v35 = (_OWORD *)(v75 + 24);
  v73 = *(_OWORD *)(v75 + 24);
  v36 = *((_QWORD *)v9 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v9);
  *(_QWORD *)(v75 + 24) = v36;
  *(_QWORD *)(v75 + 32) = v37;
  v82 = *(void **)(*((_QWORD *)v9 + 9) + 24);
  v38 = mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(v75 + 8), *((_QWORD *)v9 + 3), (uint64_t *)&v82, (uint64_t)&v89);
  (*(void (**)(uint64_t, ZinIrHalH13g *, ZinIrHalH13g *))(*(_QWORD *)v75 + 32))(v75, v9, v38);
  if ((_QWORD)v73)
  {
    *v35 = v73;
    v39 = v74;
    v40 = v76;
    v41 = *((_QWORD *)v74 + 3);
    if ((*((_BYTE *)v74 + 46) & 0x80) != 0)
      goto LABEL_40;
LABEL_54:
    v43 = 0;
    v42 = 0;
  }
  else
  {
    *(_QWORD *)v35 = 0;
    *(_QWORD *)(v75 + 32) = 0;
    v39 = v74;
    v40 = v76;
    v41 = *((_QWORD *)v74 + 3);
    if ((*((_BYTE *)v74 + 46) & 0x80) == 0)
      goto LABEL_54;
LABEL_40:
    v42 = v39[17];
    v43 = (void *)*((_QWORD *)v39 + 9);
  }
  v82 = v43;
  v83 = v42;
  v44 = mlir::OpBuilder::create<mlir::scf::WhileOp,llvm::SmallVector<mlir::Type,6u> &,mlir::OperandRange>(v34, v41, (uint64_t)&v92, (uint64_t)&v82);
  v45 = v44;
  v46 = *((unsigned int *)v44 + 11);
  if ((v46 & 0x7FFFFF) != 0)
    v47 = (((unint64_t)v44 + 16 * ((v46 >> 23) & 1) + ((v46 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *((unsigned int *)v44 + 10);
  else
    v47 = 0;
  v50 = v47 + 24;
  mlir::ValueRange::ValueRange(v85, (uint64_t)v92, v93);
  Block = mlir::OpBuilder::createBlock(v34, v50, 0, v85[0], v85[1], (uint64_t)v86, v87);
  v52 = v39[9];
  v82 = v84;
  v83 = 0x600000000;
  if (!(_DWORD)v52)
  {
    v79 = v81;
    v80 = 0x600000000;
    goto LABEL_70;
  }
  if (v52 < 7)
  {
    v53 = 0;
    v54 = v52;
    goto LABEL_62;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v84, v52, 8);
  v53 = v83;
  v54 = v52 - v83;
  if (v52 != v83)
LABEL_62:
    bzero((char *)v82 + 8 * v53, 8 * v54);
  LODWORD(v83) = v52;
  v55 = v39[9];
  v79 = v81;
  v80 = 0x600000000;
  if ((_DWORD)v55)
  {
    if (v55 < 7)
    {
      v56 = 0;
      v57 = v55;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v55, 8);
      v56 = v80;
      v57 = v55 - v80;
      if (v55 == v80)
      {
LABEL_69:
        LODWORD(v80) = v55;
        goto LABEL_70;
      }
    }
    bzero((char *)v79 + 8 * v56, 8 * v57);
    goto LABEL_69;
  }
LABEL_70:
  v58 = v96;
  if ((_DWORD)v96)
  {
    v59 = v95;
    v60 = 8 * *v95;
    *(_QWORD *)((char *)v82 + v60) = (char *)v45 - 16;
    *(_QWORD *)((char *)v79 + v60) = **(_QWORD **)(Block + 48);
    if ((_DWORD)v58 != 1)
    {
      v61 = 8 * v59[1];
      *(_QWORD *)((char *)v82 + v61) = (char *)v45 - 32;
      *(_QWORD *)((char *)v79 + v61) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 8);
      if ((_DWORD)v58 != 2)
      {
        v62 = 8 * v59[2];
        *(_QWORD *)((char *)v82 + v62) = (char *)v45 - 48;
        *(_QWORD *)((char *)v79 + v62) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 16);
        if ((_DWORD)v58 != 3)
        {
          v63 = 8 * v59[3];
          *(_QWORD *)((char *)v82 + v63) = (char *)v45 - 64;
          *(_QWORD *)((char *)v79 + v63) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 24);
          if ((_DWORD)v58 != 4)
          {
            v64 = 8 * v59[4];
            *(_QWORD *)((char *)v82 + v64) = (char *)v45 - 80;
            *(_QWORD *)((char *)v79 + v64) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 32);
            if ((_DWORD)v58 != 5)
            {
              v65 = 8 * v59[5];
              *(_QWORD *)((char *)v82 + v65) = (char *)v45 - 96;
              *(_QWORD *)((char *)v79 + v65) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 40);
              if ((_DWORD)v58 != 6)
              {
                v66 = 0;
                v67 = v59 + 6;
                v68 = 4 * v58 - 24;
                do
                {
                  v69 = 8 * v67[v66];
                  *(_QWORD *)((char *)v82 + v69) = (char *)v45 - 24 * (v66 + 1) - 96;
                  *(_QWORD *)((char *)v79 + v69) = *(_QWORD *)(*(_QWORD *)(Block + 48) + 8 * v66++ + 48);
                  v68 -= 4;
                }
                while (v68);
              }
            }
          }
        }
      }
    }
  }
  v70 = (((unint64_t)v45
        + 16 * (((unint64_t)*((unsigned int *)v45 + 11) >> 23) & 1)
        + (((unint64_t)*((unsigned int *)v45 + 11) >> 21) & 0x7F8)
        + 71) & 0xFFFFFFFFFFFFFFF8)
      + 32 * *((unsigned int *)v45 + 10);
  (**(void (***)(uint64_t, unint64_t, unint64_t, _QWORD))v75)(v75, (((unint64_t)&v40[4 * (((unint64_t)v39[11] >> 23) & 1) + 1]+ (((unint64_t)v39[11] >> 21) & 0x7F8)+ 3) & 0xFFFFFFFFFFFFFFF8)+ 32 * v39[10], v70, *(_QWORD *)(v70 + 8));
  v71 = *(_QWORD *)((((unint64_t)&v40[4 * (((unint64_t)v39[11] >> 23) & 1) + 1]
                    + (((unint64_t)v39[11] >> 21) & 0x7F8)
                    + 3) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * v39[10]
                  + 32);
  if (v71)
    v72 = v71 - 8;
  else
    v72 = 0;
  mlir::ValueRange::ValueRange(v78, (uint64_t)v79, v80);
  mlir::RewriterBase::mergeBlocks(v75, v72, Block, v78[0], v78[1]);
  mlir::ValueRange::ValueRange(v77, (uint64_t)v82, v83);
  (*(void (**)(uint64_t, unsigned int *, unint64_t, unint64_t))(*(_QWORD *)v75 + 24))(v75, v39, v77[0], v77[1]);
  if (v79 != v81)
    free(v79);
  if (v82 != v84)
    free(v82);
  v14 = 1;
  v48 = v86;
  if (v86 != v88)
LABEL_45:
    free(v48);
LABEL_46:
  if (v89 != v91)
    free(v89);
  if (v92 != (_QWORD *)v94)
    free(v92);
  if (v95 != (unsigned int *)v97)
    free(v95);
  return v14;
}

void `anonymous namespace'::WhileRemoveDuplicatedResults::~WhileRemoveDuplicatedResults(_anonymous_namespace_::WhileRemoveDuplicatedResults *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::WhileRemoveDuplicatedResults::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  ZinIrHalH13g **v7;
  uint64_t v8;
  ZinIrHalH13g *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  const void *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  ZinIrHalH13g *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  ZinIrHalH13g *v45;
  uint64_t v46;
  char *v47;
  unint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned __int32 v51;
  uint64_t v52;
  int v53;
  _OWORD *v54;
  uint64_t v55;
  uint64_t v56;
  ZinIrHalH13g *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  uint64_t v65;
  mlir::OpBuilder *v66;
  ZinIrHalH13g *v67;
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  _BYTE *v73;
  _BYTE *v74;
  uint64_t v75;
  int v76;
  _BYTE v77[64];
  unint64_t *v78;
  unint64_t v79[2];
  unint64_t v80[2];
  unint64_t v81[2];
  _QWORD *v82;
  unint64_t v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  _BYTE v87[48];
  __n128 v88;
  _BYTE v89[48];
  __n128 v90;
  void *v91;
  uint64_t v92;
  _BYTE v93[48];
  unint64_t v94;
  uint64_t v95;
  unsigned int v96;
  uint64_t v97;
  __int16 v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x24BDAC8D0];
  v5 = a2 + 64;
  v6 = *(_QWORD *)(((a2
                   + 64
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 7) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *(unsigned int *)(a2 + 40)
                 + 8);
  if (v6)
    v7 = (ZinIrHalH13g **)(v6 - 8);
  else
    v7 = 0;
  mlir::Block::getTerminator(v7);
  v9 = (ZinIrHalH13g *)v8;
  if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
  {
    v10 = *(_QWORD *)(v8 + 72);
    v11 = *(unsigned int *)(v8 + 68) - 1;
  }
  else
  {
    v10 = 0;
    v11 = -1;
  }
  mlir::ValueRange::ValueRange(&v101, v10 + 32, v11);
  v73 = v77;
  v74 = v77;
  v75 = 8;
  v76 = 0;
  v12 = v101;
  v13 = (char *)v102;
  v94 = v101;
  v95 = 0;
  if (v102)
  {
    v14 = 0;
    while (1)
    {
      v16 = (const void *)mlir::ValueRange::dereference_iterator(&v94, (uint64_t)v14);
      if (v74 != v73)
        goto LABEL_8;
      v17 = HIDWORD(v75);
      if (HIDWORD(v75))
      {
        v18 = 0;
        v19 = 8 * HIDWORD(v75);
        v20 = v74;
        while ((const void *)*v20 != v16)
        {
          if (*v20 == -2)
            v18 = v20;
          ++v20;
          v19 -= 8;
          if (!v19)
          {
            if (!v18)
              goto LABEL_22;
            *v18 = v16;
            --v76;
            goto LABEL_9;
          }
        }
        goto LABEL_9;
      }
LABEL_22:
      if (HIDWORD(v75) < v75)
      {
        ++HIDWORD(v75);
        *(_QWORD *)&v74[8 * v17] = v16;
      }
      else
      {
LABEL_8:
        llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)&v73, v16);
      }
LABEL_9:
      v14 = (char *)++v95;
      if (v94 == v12 && v14 == v13)
      {
        v21 = v102;
        if (v102 == HIDWORD(v75) - v76)
          break;
        v94 = 1;
        v95 = -4096;
        v97 = -4096;
        v99 = -4096;
        v100 = -4096;
        v91 = v93;
        v92 = 0x600000000;
        if ((_DWORD)v102
          && (v25 = (4 * (int)v102 / 3u + 1) | ((unint64_t)(4 * (int)v102 / 3u + 1) >> 1),
              v26 = v25 | (v25 >> 2) | ((v25 | (v25 >> 2)) >> 4),
              v27 = ((v26 | (v26 >> 8)) >> 16) | v26 | (v26 >> 8),
              v27 >= 4))
        {
          llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::grow((uint64_t)&v94, v27 + 1);
          v21 = v102;
          if (v102 <= HIDWORD(v92))
          {
LABEL_38:
            v28 = v101;
            v88 = (__n128)v101;
            if (v21)
            {
              v29 = 0;
              do
              {
                v90.n128_u64[0] = mlir::ValueRange::dereference_iterator(&v88, v29);
                v85 = 0;
                if ((llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t)&v94, v90.n128_u64, &v85) & 1) == 0)
                {
                  v85 = (void *)v90.n128_u64[0];
                  LODWORD(v86) = v94 >> 1;
                  v82 = 0;
                  if ((llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t)&v94, (unint64_t *)&v85, &v82) & 1) == 0)
                  {
                    v32 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::InsertIntoBucketImpl<mlir::Value>(&v94, (uint64_t)&v85, (unint64_t *)&v85, v82);
                    *v32 = v85;
                    *((_DWORD *)v32 + 2) = v86;
                  }
                  v30 = v92;
                  if (v92 >= HIDWORD(v92))
                  {
                    v33 = v90.n128_u64[0];
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v91, v93, v92 + 1, 8);
                    *((_QWORD *)v91 + v92) = v33;
                    v30 = v92;
                  }
                  else
                  {
                    *((_QWORD *)v91 + v92) = v90.n128_u64[0];
                  }
                  LODWORD(v92) = v30 + 1;
                }
                v29 = ++v88.n128_u64[1];
              }
              while (v88.n128_u64[0] != v28 || v29 != v21);
            }
            mlir::ValueRange::ValueRange(v90.n128_u64, (uint64_t)v91, v92);
            v34 = *(_QWORD *)(a2 + 24);
            mlir::ValueRange::getTypes(&v90, &v88);
            v69 = a3;
            v70 = a2;
            v67 = v9;
            v68 = v5;
            if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
            {
              v35 = *(unsigned int *)(a2 + 68);
              v36 = *(void **)(a2 + 72);
            }
            else
            {
              v36 = 0;
              v35 = 0;
            }
            v85 = v36;
            v86 = v35;
            v82 = 0;
            v66 = (mlir::OpBuilder *)(a3 + 1);
            v37 = mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ValueRange>,mlir::OperandRange,decltype(nullptr),decltype(nullptr)>((mlir::OpBuilder *)(a3 + 1), v34, v88.n128_u64, (uint64_t)&v85);
            v38 = (((unint64_t)v37
                  + 16 * (((unint64_t)*((unsigned int *)v37 + 11) >> 23) & 1)
                  + (((unint64_t)*((unsigned int *)v37 + 11) >> 21) & 0x7F8)
                  + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *((unsigned int *)v37 + 10);
            v39 = *(_QWORD *)(v38 + 8);
            if (v39)
              v40 = v39 - 8;
            else
              v40 = 0;
            v65 = v40;
            v41 = *(_QWORD *)(v38 + 32);
            if (v41)
              v42 = v41 - 8;
            else
              v42 = 0;
            v88.n128_u64[0] = (unint64_t)v89;
            v88.n128_u64[1] = 0x600000000;
            v84 = 0;
            v85 = v87;
            v86 = 0x600000000;
            v43 = v101;
            v44 = v102;
            v82 = 0;
            v83 = v101;
            if (v102)
            {
              v45 = v37;
              v46 = 0;
              v47 = (char *)v37 - 96;
              do
              {
                v72 = mlir::ValueRange::dereference_iterator(&v83, v46);
                v78 = 0;
                if ((llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t)&v94, (unint64_t *)&v72, &v78) & 1) != 0)
                {
                  v48 = v78;
                }
                else
                {
                  v48 = (unint64_t *)(v95 + 16 * v96);
                  if ((v94 & 1) != 0)
                    v48 = &v101;
                }
                v49 = *((unsigned int *)v48 + 2);
                v50 = *(_QWORD *)(*(_QWORD *)(v42 + 48) + 8 * v49);
                v51 = v88.n128_u32[2];
                if (v88.n128_u32[2] >= v88.n128_u32[3])
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v89, v88.n128_u32[2] + 1, 8);
                  *(_QWORD *)(v88.n128_u64[0] + 8 * v88.n128_u32[2]) = v50;
                  v51 = v88.n128_u32[2];
                }
                else
                {
                  *(_QWORD *)(v88.n128_u64[0] + 8 * v88.n128_u32[2]) = v50;
                }
                v88.n128_u32[2] = v51 + 1;
                if (v49 <= 5)
                  v52 = (uint64_t)v45 - 16 * v49 - 16;
                else
                  v52 = (uint64_t)&v47[-24 * (v49 - 5)];
                v53 = v86;
                if (v86 >= HIDWORD(v86))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v87, v86 + 1, 8);
                  *((_QWORD *)v85 + v86) = v52;
                  v53 = v86;
                }
                else
                {
                  *((_QWORD *)v85 + v86) = v52;
                }
                LODWORD(v86) = v53 + 1;
                v46 = v84 + 1;
                v82 = (_QWORD *)((char *)v82 + 1);
                ++v84;
              }
              while (v83 != v43 || v46 != v44);
            }
            v54 = v69 + 3;
            v71 = *(_OWORD *)(v69 + 3);
            v55 = *((_QWORD *)v67 + 2);
            ZinIrHalH13g::~ZinIrHalH13g(v67);
            v69[3] = v55;
            v69[4] = v56;
            v82 = *(_QWORD **)(*((_QWORD *)v67 + 9) + 24);
            v57 = mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::ValueRange &>(v66, *((_QWORD *)v67 + 3), (uint64_t *)&v82, (uint64_t *)&v90);
            (*(void (**)(_QWORD *, ZinIrHalH13g *, ZinIrHalH13g *))(*v69 + 32))(v69, v67, v57);
            v58 = ((v68
                  + 16 * (((unint64_t)*(unsigned int *)(v70 + 44) >> 23) & 1)
                  + (((unint64_t)*(unsigned int *)(v70 + 44) >> 21) & 0x7F8)
                  + 7) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(v70 + 40);
            v59 = *(_QWORD *)(v58 + 8);
            if (v59)
              v60 = v59 - 8;
            else
              v60 = 0;
            v61 = *(_QWORD *)(v58 + 32);
            if (v61)
              v62 = v61 - 8;
            else
              v62 = 0;
            mlir::ValueRange::ValueRange(v81, *(_QWORD *)(v65 + 48), (uint64_t)(*(_QWORD *)(v65 + 56) - *(_QWORD *)(v65 + 48)) >> 3);
            mlir::RewriterBase::mergeBlocks((uint64_t)v69, v60, v65, v81[0], v81[1]);
            mlir::ValueRange::ValueRange(v80, v88.n128_i64[0], v88.n128_u32[2]);
            mlir::RewriterBase::mergeBlocks((uint64_t)v69, v62, v42, v80[0], v80[1]);
            mlir::ValueRange::ValueRange(v79, (uint64_t)v85, v86);
            (*(void (**)(_QWORD *, uint64_t, unint64_t, unint64_t))(*v69 + 24))(v69, v70, v79[0], v79[1]);
            if ((_QWORD)v71)
            {
              *v54 = v71;
              v63 = v85;
              if (v85 != v87)
                goto LABEL_85;
            }
            else
            {
              *(_QWORD *)v54 = 0;
              v69[4] = 0;
              v63 = v85;
              if (v85 != v87)
LABEL_85:
                free(v63);
            }
            if ((_BYTE *)v88.n128_u64[0] != v89)
              free((void *)v88.n128_u64[0]);
            if (v91 != v93)
              free(v91);
            if ((v94 & 1) == 0)
              llvm::deallocate_buffer((llvm *)v95, (void *)(16 * v96));
            v23 = 1;
            v24 = v74;
            if (v74 != v73)
LABEL_93:
              free(v24);
            return v23;
          }
        }
        else if (v102 <= 6)
        {
          goto LABEL_38;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v91, v93, v21, 8);
        v21 = v102;
        goto LABEL_38;
      }
    }
  }
  v94 = (unint64_t)"No results to remove";
  v98 = 259;
  v91 = &v94;
  v22 = a3[2];
  if (v22 && mlir::RewriterBase::Listener::classof(a3[2]))
  {
    v23 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::scf::WhileOp &>(mlir::scf::WhileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v91);
    v24 = v74;
    if (v74 != v73)
      goto LABEL_93;
  }
  else
  {
    v23 = 0;
    v24 = v74;
    if (v74 != v73)
      goto LABEL_93;
  }
  return v23;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ValueRange>,mlir::OperandRange,decltype(nullptr),decltype(nullptr)>(mlir::OpBuilder *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  unint64_t v22[2];
  unint64_t v23[2];
  _QWORD v24[38];
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v19 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v19);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.while", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v29 = 1283;
    v27 = "scf.while";
    v28 = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v21 = 259;
    llvm::operator+((uint64_t *)&v25, (uint64_t *)&v20, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  v11 = *a3;
  v12 = a3[1];
  v13 = a3[3];
  v25 = (const char *)v11;
  v26 = v12;
  if (v12)
  {
    v11 = mlir::ValueRange::offset_base(&v25, v12);
    v12 = v26;
  }
  mlir::TypeRange::TypeRange(v23, v11, v13 - v12);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  mlir::scf::WhileOp::build((uint64_t)a1, (uint64_t)v24, v23[0], v23[1], v22[0], v22[1], 0, v14, 0, v18);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::scf::WhileOp &>(mlir::scf::WhileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::grow(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  llvm *v6;
  _QWORD *v7;
  uint64_t v8;
  llvm *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *buffer;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unint64_t *v34;
  unint64_t *v35;
  llvm *v36;
  _QWORD *v37;
  unint64_t *v38;
  _QWORD *v39;
  int v40;
  _QWORD v41[7];

  v2 = result;
  v41[6] = *MEMORY[0x24BDAC8D0];
  if (a2 >= 5)
  {
    v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40)
      a2 = v5 + 1;
    else
      a2 = 64;
  }
  if ((*(_BYTE *)result & 1) == 0)
  {
    v7 = (_QWORD *)(result + 8);
    v6 = *(llvm **)(result + 8);
    v8 = *(unsigned int *)(result + 16);
    if (a2 > 4)
    {
      v25 = a2;
      buffer = llvm::allocate_buffer(16 * a2, (std::align_val_t)8uLL);
      *(_QWORD *)(v2 + 8) = buffer;
      *(_QWORD *)(v2 + 16) = v25;
      v27 = *(_DWORD *)v2;
      v9 = (llvm *)((char *)v6 + 16 * v8);
      *(_QWORD *)v2 = *(_DWORD *)v2 & 1;
      if ((v27 & 1) != 0)
      {
        v10 = (_QWORD *)(v2 + 72);
        v11 = 48;
      }
      else
      {
        v10 = &buffer[2 * v25];
        v7 = buffer;
        v11 = 16 * v25 - 16;
        if (v11 < 0x10)
        {
          v29 = buffer;
          goto LABEL_41;
        }
      }
    }
    else
    {
      v9 = (llvm *)((char *)v6 + 16 * v8);
      *(_QWORD *)result = 1;
      v10 = (_QWORD *)(result + 72);
      v11 = 48;
    }
    v28 = (v11 >> 4) + 1;
    v29 = &v7[2 * (v28 & 0x1FFFFFFFFFFFFFFELL)];
    v30 = v7 + 2;
    v31 = v28 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v30 - 2) = -4096;
      *v30 = -4096;
      v30 += 4;
      v31 -= 2;
    }
    while (v31);
    if (v28 == (v28 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_42:
      if ((_DWORD)v8)
      {
        v36 = v6;
        do
        {
          if ((*(_QWORD *)v36 | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            v39 = 0;
            llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v2, (unint64_t *)v36, &v39);
            v37 = v39;
            *v39 = *(_QWORD *)v36;
            *((_DWORD *)v37 + 2) = *((_DWORD *)v36 + 2);
            *(_DWORD *)v2 += 2;
          }
          v36 = (llvm *)((char *)v36 + 16);
        }
        while (v36 != v9);
      }
      llvm::deallocate_buffer(v6, (void *)(16 * v8));
    }
    do
    {
LABEL_41:
      *v29 = -4096;
      v29 += 2;
    }
    while (v29 != v10);
    goto LABEL_42;
  }
  v12 = result + 8;
  v13 = (unint64_t *)&v39;
  if ((*(_QWORD *)(result + 8) | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
    v14 = *(_QWORD *)(result + 24);
    if ((v14 | 0x1000) == 0xFFFFFFFFFFFFF000)
      goto LABEL_10;
  }
  else
  {
    v39 = *(_QWORD **)(result + 8);
    v40 = *(_DWORD *)(result + 16);
    v13 = v41;
    v14 = *(_QWORD *)(result + 24);
    if ((v14 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
LABEL_10:
      v15 = *(_QWORD *)(result + 40);
      if ((v15 | 0x1000) == 0xFFFFFFFFFFFFF000)
        goto LABEL_11;
      goto LABEL_28;
    }
  }
  *v13 = v14;
  *((_DWORD *)v13 + 2) = *(_DWORD *)(result + 32);
  v13 += 2;
  v15 = *(_QWORD *)(result + 40);
  if ((v15 | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
LABEL_11:
    v16 = *(_QWORD *)(result + 56);
    if ((v16 | 0x1000) == 0xFFFFFFFFFFFFF000)
      goto LABEL_12;
    goto LABEL_29;
  }
LABEL_28:
  *v13 = v15;
  *((_DWORD *)v13 + 2) = *(_DWORD *)(result + 48);
  v13 += 2;
  v16 = *(_QWORD *)(result + 56);
  if ((v16 | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
LABEL_12:
    v17 = *(_DWORD *)result;
    if (a2 < 5)
      goto LABEL_13;
    goto LABEL_30;
  }
LABEL_29:
  *v13 = v16;
  *((_DWORD *)v13 + 2) = *(_DWORD *)(result + 64);
  v13 += 2;
  v17 = *(_DWORD *)result;
  if (a2 < 5)
  {
LABEL_13:
    *(_QWORD *)result = v17 & 1;
    if ((v17 & 1) == 0)
      goto LABEL_14;
LABEL_31:
    v19 = (_QWORD *)(v2 + 72);
    v20 = 48;
    goto LABEL_16;
  }
LABEL_30:
  *(_DWORD *)result = v17 & 0xFFFFFFFE;
  v32 = a2;
  result = (uint64_t)llvm::allocate_buffer(16 * a2, (std::align_val_t)8uLL);
  *(_QWORD *)(v2 + 8) = result;
  *(_QWORD *)(v2 + 16) = v32;
  v33 = *(_DWORD *)v2;
  *(_QWORD *)v2 = *(_DWORD *)v2 & 1;
  if ((v33 & 1) != 0)
    goto LABEL_31;
LABEL_14:
  v18 = *(unsigned int *)(v2 + 16);
  if (!(_DWORD)v18)
    goto LABEL_34;
  v12 = *(_QWORD *)(v2 + 8);
  v19 = (_QWORD *)(v12 + 16 * v18);
  v20 = (unint64_t)v19 - v12 - 16;
  if (v20 < 0x10)
  {
    v22 = *(_QWORD **)(v2 + 8);
    do
    {
LABEL_33:
      *v22 = -4096;
      v22 += 2;
    }
    while (v22 != v19);
    goto LABEL_34;
  }
LABEL_16:
  v21 = (v20 >> 4) + 1;
  v22 = (_QWORD *)(v12 + 16 * (v21 & 0x1FFFFFFFFFFFFFFELL));
  v23 = (_QWORD *)(v12 + 16);
  v24 = v21 & 0x1FFFFFFFFFFFFFFELL;
  do
  {
    *(v23 - 2) = -4096;
    *v23 = -4096;
    v23 += 4;
    v24 -= 2;
  }
  while (v24);
  if (v21 != (v21 & 0x1FFFFFFFFFFFFFFELL))
    goto LABEL_33;
LABEL_34:
  if (&v39 != (_QWORD **)v13)
  {
    v34 = (unint64_t *)&v39;
    do
    {
      if ((*v34 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v38 = 0;
        result = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v2, v34, &v38);
        v35 = v38;
        *v38 = *v34;
        *((_DWORD *)v35 + 2) = *((_DWORD *)v34 + 2);
        *(_DWORD *)v2 += 2;
      }
      v34 += 2;
    }
    while (v34 != v13);
  }
  return result;
}

uint64_t llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  unsigned __int8 v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t result;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  int v20;
  unint64_t v21;
  unint64_t *v22;
  int v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      result = 0;
      *a3 = 0;
      return result;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = *a2;
  v7 = &unk_254519000;
  if ((v6 & 1) == 0)
  {
    v24 = a3;
    v22 = a2;
    v25 = v3;
    v23 = v4;
    v26 = *a2;
    v7 = &unk_254519000;
    v3 = v25;
    v5 = v26;
    v4 = v23;
    a2 = v22;
    a3 = v24;
    if (v20)
    {
      v21 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v21 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v21;
      v7 = (_QWORD *)&unk_254519000;
      v3 = v25;
      v5 = v26;
      v4 = v23;
      a2 = v22;
      a3 = v24;
    }
  }
  v8 = (v7[373] + 8 * v5) ^ HIDWORD(v5);
  v9 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ ((0x9DDFEA08EB382D69 * v8) >> 47) ^ (0x9DDFEA08EB382D69 * v8));
  v10 = -348639895 * ((v9 >> 47) ^ v9);
  v11 = v4 - 1;
  v12 = v10 & (v4 - 1);
  v13 = (_QWORD *)(v3 + 16 * v12);
  v14 = *v13;
  if (*a2 == *v13)
  {
    result = 1;
LABEL_8:
    *a3 = v13;
  }
  else
  {
    v16 = 0;
    v17 = 1;
    result = 1;
    while (v14 != -4096)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v14 == -8192;
      if (v18)
        v16 = v13;
      v19 = v12 + v17++;
      v12 = v19 & v11;
      v13 = (_QWORD *)(v3 + 16 * (v19 & v11));
      v14 = *v13;
      if (*a2 == *v13)
        goto LABEL_8;
    }
    result = 0;
    if (v16)
      v13 = v16;
    *a3 = v13;
  }
  return result;
}

_QWORD *llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::InsertIntoBucketImpl<mlir::Value>(_DWORD *a1, uint64_t a2, unint64_t *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v7 = 4;
  else
    v7 = a1[4];
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_10:
    llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::grow((uint64_t)a1, v7);
    v9 = 0;
    llvm::DenseMapBase<llvm::SmallDenseMap<mlir::Value,unsigned int,4u,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t)a1, a3, &v9);
    a4 = v9;
    *a1 += 2;
    if (*a4 == -4096)
      return a4;
    goto LABEL_7;
  }
  if (v7 + ~v6 - a1[1] <= v7 >> 3)
    goto LABEL_10;
  *a1 += 2;
  if (*a4 != -4096)
LABEL_7:
    --a1[1];
  return a4;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::ConditionOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::ValueRange &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20[4];
  __int16 v21;
  _QWORD v22[39];

  v22[38] = *MEMORY[0x24BDAC8D0];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.condition", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v21 = 1283;
    v20[2] = (uint64_t)"scf.condition";
    v20[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  v13 = *a4;
  v12 = a4[1];
  v20[0] = v11;
  mlir::OperationState::addOperands((uint64_t)v22, (uint64_t)v20, 1);
  mlir::OperationState::addOperands((uint64_t)v22, v13, v12);
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::ConditionOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

void `anonymous namespace'::WhileRemoveUnusedArgs::~WhileRemoveUnusedArgs(_anonymous_namespace_::WhileRemoveUnusedArgs *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t `anonymous namespace'::WhileRemoveUnusedArgs::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  ZinIrHalH13g **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD **v36;
  _QWORD **v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  ZinIrHalH13g *v81;
  unint64_t v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  int v88;
  __int128 v89;
  ZinIrHalH13g *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93[4];
  uint64_t v94[2];
  unint64_t v95[2];
  unint64_t v96[2];
  unint64_t v97[2];
  void *v98;
  uint64_t v99;
  _WORD v100[24];
  int v101;
  _QWORD *v102;
  uint64_t v103;
  _BYTE v104[48];
  void **v105;
  uint64_t v106;
  _QWORD v107[8];

  v3 = a3;
  v4 = a2;
  v107[6] = *MEMORY[0x24BDAC8D0];
  v5 = a2 + 64;
  v6 = *(unsigned int *)(a2 + 40);
  v7 = (a2
      + 64
      + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
      + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
      + 7) & 0xFFFFFFFFFFFFFFF8;
  v8 = *(_QWORD *)(v7 + 32 * v6 + 8);
  v9 = v8 - 8;
  if (!v8)
    v9 = 0;
  v10 = *(_QWORD ***)(v9 + 48);
  v11 = *(_QWORD *)(v9 + 56) - (_QWORD)v10;
  if (!v11)
  {
LABEL_7:
    v98 = "No args to remove";
    v100[8] = 259;
    v105 = &v98;
    v13 = a3[2];
    if (!v13)
      return 0;
    result = mlir::RewriterBase::Listener::classof(a3[2]);
    if ((_DWORD)result)
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v13 + 64))(v13, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::scf::WhileOp &>(mlir::scf::WhileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v105);
    return result;
  }
  v12 = 8 * (v11 >> 3);
  while (**v10)
  {
    ++v10;
    v12 -= 8;
    if (!v12)
      goto LABEL_7;
  }
  v15 = *(_QWORD *)(v7 + 32 * v6 + 32);
  if (v15)
    v16 = (ZinIrHalH13g **)(v15 - 8);
  else
    v16 = 0;
  mlir::Block::getTerminator(v16);
  v18 = v17;
  v105 = (void **)v107;
  v106 = 0x600000000;
  v102 = v104;
  v103 = 0x600000000;
  v101 = 0;
  v19 = *(unsigned int *)(v4 + 40);
  v20 = v5
      + 16 * (((unint64_t)*(unsigned int *)(v4 + 44) >> 23) & 1)
      + (((unint64_t)*(unsigned int *)(v4 + 44) >> 21) & 0x7F8);
  v98 = v100;
  v99 = 0x600000000;
  v21 = *(_QWORD *)(((v20 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v19 + 8);
  if (v21)
    v22 = v21 - 8;
  else
    v22 = 0;
  v24 = *(_QWORD *)(v22 + 48);
  v23 = *(_QWORD *)(v22 + 56);
  v25 = v23 - v24;
  v26 = (v23 - v24) >> 3;
  if ((unint64_t)(v23 - v24) < 0x31)
  {
    if (v26 <= 6)
      goto LABEL_22;
    goto LABEL_21;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v105, v107, (v23 - v24) >> 3, 8);
  if (v26 > HIDWORD(v103))
LABEL_21:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v104, v26, 8);
LABEL_22:
  v27 = ((v25 >> 3) + 63) >> 6;
  if (HIDWORD(v99) < v27)
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v100, v27, 8);
  v28 = *(unsigned int *)(v4 + 40);
  v29 = *(unsigned int *)(v4 + 44);
  v30 = (v29 >> 23) & 1;
  v31 = (v29 >> 21) & 0x7F8;
  v32 = *(_QWORD *)(((v5 + 16 * v30 + v31 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v28 + 8);
  if (v32)
    v33 = v32 - 8;
  else
    v33 = 0;
  if ((*(_BYTE *)(v18 + 46) & 0x80) != 0)
  {
    v34 = *(_QWORD *)(v18 + 72);
    v35 = *(unsigned int *)(v18 + 68);
    v90 = (ZinIrHalH13g *)v18;
    if ((v29 & 0x800000) == 0)
      goto LABEL_66;
  }
  else
  {
    v34 = 0;
    v35 = 0;
    v90 = (ZinIrHalH13g *)v18;
    if ((v29 & 0x800000) == 0)
      goto LABEL_66;
  }
  v37 = *(_QWORD ***)(v33 + 48);
  v36 = *(_QWORD ***)(v33 + 56);
  v38 = *(unsigned int *)(v4 + 68);
  v39 = v36 == v37 || v35 == 0;
  if (!v39 && (_DWORD)v38 != 0)
  {
    v85 = v5;
    v86 = v3;
    v41 = 0;
    v87 = v4;
    v42 = v34 + 24;
    v43 = *(_QWORD *)(v4 + 72) + 24;
    v44 = 32 * v35 - 32;
    v45 = 32 * v38 - 32;
    v46 = 8 * (v36 - v37) - 8;
    v91 = v45;
    while (1)
    {
      if (!**v37)
      {
        llvm::BitVector::push_back((llvm::BitVector *)&v98, 1);
        goto LABEL_56;
      }
      v47 = *(void **)(v42 + v41);
      v48 = *(_QWORD *)(v43 + v41);
      v49 = v101;
      v50 = v99;
      v51 = v101 + 1;
      if ((v101 + 1) <= (_DWORD)v99 << 6)
      {
        ++v101;
        goto LABEL_52;
      }
      v52 = v44;
      v53 = v43;
      v54 = v42;
      if ((v101 & 0x3F) != 0)
        *((_QWORD *)v98 + v99 - 1) &= ~(-1 << (v101 & 0x3F));
      v101 = v51;
      v55 = (v49 + 64) >> 6;
      if ((_DWORD)v50 != (_DWORD)v55)
        break;
LABEL_48:
      v59 = v51 & 0x3F;
      v42 = v54;
      v43 = v53;
      v44 = v52;
      v45 = v91;
      if (v59)
        *((_QWORD *)v98 + v50 - 1) &= ~(-1 << v59);
LABEL_52:
      v60 = v106;
      if (v106 >= HIDWORD(v106))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v105, v107, v106 + 1, 8);
        v105[v106] = v47;
        LODWORD(v106) = v106 + 1;
        v61 = v103;
        if (v103 >= HIDWORD(v103))
        {
LABEL_62:
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v104, v61 + 1, 8);
          v102[v103] = v48;
          v62 = v103 + 1;
          goto LABEL_55;
        }
      }
      else
      {
        v105[v106] = v47;
        LODWORD(v106) = v60 + 1;
        v61 = v103;
        if (v103 >= HIDWORD(v103))
          goto LABEL_62;
      }
      v102[v61] = v48;
      v62 = v61 + 1;
LABEL_55:
      LODWORD(v103) = v62;
LABEL_56:
      if (v46)
      {
        if (v44 != v41)
        {
          ++v37;
          v46 -= 8;
          v39 = v45 == v41;
          v41 += 32;
          if (!v39)
            continue;
        }
      }
      v3 = v86;
      v4 = v87;
      v28 = *(unsigned int *)(v87 + 40);
      v63 = *(unsigned int *)(v87 + 44);
      v30 = (v63 >> 23) & 1;
      v31 = (v63 >> 21) & 0x7F8;
      v5 = v85;
      goto LABEL_66;
    }
    if (v50 > v55)
    {
LABEL_47:
      LODWORD(v99) = v55;
      LODWORD(v50) = v55;
      goto LABEL_48;
    }
    v56 = v50;
    v57 = v50;
    if (HIDWORD(v99) < v55)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v100, v55, 8);
      v56 = v99;
      v57 = v99;
      v58 = v55 - v50;
      if (v55 == v50)
        goto LABEL_46;
    }
    else
    {
      v58 = v55 - v50;
      if (v55 == v50)
      {
LABEL_46:
        LODWORD(v55) = v55 - v50 + v57;
        LOBYTE(v51) = v101;
        goto LABEL_47;
      }
    }
    v88 = v57;
    bzero((char *)v98 + 8 * v56, 8 * v58);
    v57 = v88;
    goto LABEL_46;
  }
LABEL_66:
  v64 = ((v5 + 16 * v30 + v31 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v28;
  v65 = *(_QWORD *)(v64 + 8);
  if (v65)
    v66 = v65 - 8;
  else
    v66 = 0;
  v67 = *(_QWORD *)(v64 + 32);
  if (v67)
    v68 = v67 - 8;
  else
    v68 = 0;
  v92 = v68;
  mlir::Block::eraseArguments(v66, (uint64_t)&v98);
  v69 = *(_QWORD *)(v4 + 24);
  v70 = *(unsigned int *)(v4 + 36);
  v71 = v4 - 16;
  if (!(_DWORD)v70)
    v71 = 0;
  v94[0] = v71;
  v94[1] = v70;
  mlir::OperandRange::getTypes(v94, v93);
  v94[0] = 0;
  v72 = (unsigned int *)mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,6u> &,decltype(nullptr),decltype(nullptr)>((mlir::OpBuilder *)(v3 + 1), v69, v93, (uint64_t)&v102);
  v73 = (((unint64_t)&v72[4 * (((unint64_t)v72[11] >> 23) & 1) + 17]
        + (((unint64_t)v72[11] >> 21) & 0x7F8)
        + 3) & 0xFFFFFFFFFFFFFFF8)
      + 32 * v72[10];
  v74 = *(_QWORD *)(v73 + 8);
  if (v74)
    v75 = v74 - 8;
  else
    v75 = 0;
  v76 = *(_QWORD *)(v73 + 32);
  if (v76)
    v77 = v76 - 8;
  else
    v77 = 0;
  v78 = v3 + 3;
  v89 = *(_OWORD *)(v3 + 3);
  v79 = *((_QWORD *)v90 + 2);
  ZinIrHalH13g::~ZinIrHalH13g(v90);
  v3[3] = v79;
  v3[4] = v80;
  v81 = mlir::OpBuilder::create<mlir::scf::YieldOp,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)(v3 + 1), *((_QWORD *)v90 + 3), (uint64_t)&v105);
  (*(void (**)(_QWORD *, ZinIrHalH13g *, ZinIrHalH13g *))(*v3 + 32))(v3, v90, v81);
  mlir::ValueRange::ValueRange(v97, *(_QWORD *)(v75 + 48), (uint64_t)(*(_QWORD *)(v75 + 56) - *(_QWORD *)(v75 + 48)) >> 3);
  mlir::RewriterBase::mergeBlocks((uint64_t)v3, v66, v75, v97[0], v97[1]);
  mlir::ValueRange::ValueRange(v96, *(_QWORD *)(v77 + 48), (uint64_t)(*(_QWORD *)(v77 + 56) - *(_QWORD *)(v77 + 48)) >> 3);
  mlir::RewriterBase::mergeBlocks((uint64_t)v3, v92, v77, v96[0], v96[1]);
  v82 = v72[9];
  if ((_DWORD)v82)
    v83 = (uint64_t)(v72 - 4);
  else
    v83 = 0;
  mlir::ValueRange::ValueRange(v95, v83, v82);
  (*(void (**)(_QWORD *, uint64_t, unint64_t, unint64_t))(*v3 + 24))(v3, v4, v95[0], v95[1]);
  if (!(_QWORD)v89)
  {
    *v78 = 0;
    v3[4] = 0;
    v84 = v98;
    if (v98 == v100)
      goto LABEL_86;
    goto LABEL_85;
  }
  *(_OWORD *)v78 = v89;
  v84 = v98;
  if (v98 != v100)
LABEL_85:
    free(v84);
LABEL_86:
  if (v102 != (_QWORD *)v104)
    free(v102);
  if (v105 != v107)
    free(v105);
  return 1;
}

void llvm::BitVector::push_back(llvm::BitVector *this, int a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v4 = *((_DWORD *)this + 16);
  v5 = v4 + 1;
  v6 = *((unsigned int *)this + 2);
  if (v4 + 1 > (_DWORD)v6 << 6)
  {
    if ((v4 & 0x3F) != 0)
      *(_QWORD *)(*(_QWORD *)this + 8 * v6 - 8) &= ~(-1 << (v4 & 0x3F));
    *((_DWORD *)this + 16) = v5;
    v7 = (v4 + 64) >> 6;
    if ((_DWORD)v6 == (_DWORD)v7)
    {
LABEL_11:
      v11 = v5 & 0x3F;
      if (v11)
        *(_QWORD *)(*(_QWORD *)this + 8 * v6 - 8) &= ~(-1 << v11);
      if (a2)
        goto LABEL_14;
      return;
    }
    if (v6 > v7)
    {
LABEL_10:
      *((_DWORD *)this + 2) = v7;
      LODWORD(v6) = v7;
      goto LABEL_11;
    }
    v8 = v6;
    v9 = v6;
    if (*((_DWORD *)this + 3) < v7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this, (char *)this + 16, (v4 + 64) >> 6, 8);
      v8 = *((unsigned int *)this + 2);
      v9 = *((_DWORD *)this + 2);
      v10 = v7 - v6;
      if (v7 == v6)
        goto LABEL_9;
    }
    else
    {
      v10 = v7 - v6;
      if (v7 == v6)
      {
LABEL_9:
        LODWORD(v7) = v9 + v7 - v6;
        v5 = *((_DWORD *)this + 16);
        goto LABEL_10;
      }
    }
    bzero((void *)(*(_QWORD *)this + 8 * v8), 8 * v10);
    goto LABEL_9;
  }
  *((_DWORD *)this + 16) = v5;
  if (a2)
LABEL_14:
    *(_QWORD *)(*(_QWORD *)this + 8 * (v4 >> 6)) |= 1 << v4;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::scf::WhileOp,mlir::ValueTypeRange<mlir::ResultRange>,llvm::SmallVector<mlir::Value,6u> &,decltype(nullptr),decltype(nullptr)>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t NextResultAtOffset;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  ZinIrHalH13g *v15;
  ZinIrHalH13g *v16;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  unint64_t v22[2];
  unint64_t v23[2];
  _QWORD v24[38];
  uint64_t v25[4];
  __int16 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v19 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v19);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"scf.while", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"scf.while";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v21 = 259;
    llvm::operator+(v25, (uint64_t *)&v20, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  NextResultAtOffset = *a3;
  v12 = a3[1];
  v13 = a3[3];
  if (v12)
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v12);
  mlir::ValueRange::ValueRange((unint64_t *)v25, NextResultAtOffset, v13 - v12);
  mlir::TypeRange::TypeRange(v23, v25[0], v25[1]);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::scf::WhileOp::build((uint64_t)a1, (uint64_t)v24, v23[0], v23[1], v22[0], v22[1], 0, v14, 0, v18);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::scf::WhileOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v16;
}

double std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::RegionRange,llvm::PointerUnion<mlir::Region *,std::unique_ptr<mlir::Region> const*,mlir::Region **>,mlir::Region *,mlir::Region *,mlir::Region *>::iterator,llvm::detail::indexed_accessor_range_base<mlir::RegionRange,llvm::PointerUnion<mlir::Region *,std::unique_ptr<mlir::Region> const*,mlir::Region **>,mlir::Region *,mlir::Region *,mlir::Region *>::iterator,std::back_insert_iterator<llvm::SmallVectorImpl<mlir::RegionSuccessor>>>@<D0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  double result;
  uint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  __int128 v15;
  unint64_t v16;
  BOOL v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v21 = a1;
  *((_QWORD *)&v21 + 1) = a2;
  if (a1 != a3 || a2 != a4)
  {
    while (1)
    {
      v19 = mlir::RegionRange::dereference_iterator(&v21, a2);
      mlir::ValueRange::ValueRange(&v20, 0, 0);
      v11 = *(unsigned int *)(a5 + 8);
      v12 = *(_QWORD *)a5;
      if (v11 < *(_DWORD *)(a5 + 12))
        goto LABEL_5;
      v16 = v11 + 1;
      v17 = v12 + 24 * v11 > (unint64_t)&v19;
      if (v12 > (unint64_t)&v19 || !v17)
        break;
      v18 = (char *)&v19 - v12;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v16, 24);
      v12 = *(_QWORD *)a5;
      v13 = (unint64_t *)&v18[*(_QWORD *)a5];
LABEL_6:
      v14 = v12 + 24 * *(unsigned int *)(a5 + 8);
      v15 = *(_OWORD *)v13;
      *(_QWORD *)(v14 + 16) = v13[2];
      *(_OWORD *)v14 = v15;
      ++*(_DWORD *)(a5 + 8);
      a2 = ++*((_QWORD *)&v21 + 1);
      if ((_QWORD)v21 == a3 && a2 == a4)
        goto LABEL_3;
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v16, 24);
    v12 = *(_QWORD *)a5;
LABEL_5:
    v13 = &v19;
    goto LABEL_6;
  }
LABEL_3:
  result = *(double *)&v21;
  *(_OWORD *)a6 = v21;
  *(_QWORD *)(a6 + 16) = a5;
  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ForallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::IndexSwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::scf::IndexSwitchOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

uint64_t mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<mlir::scf::IndexSwitchOp>::buildTerminator(uint64_t a1, uint64_t a2)
{
  const mlir::OperationState *v2;
  uint64_t v3;
  _QWORD v5[39];

  v5[38] = *MEMORY[0x24BDAC8D0];
  mlir::OperationState::OperationState(v5, a2, (uint64_t)"scf.yield", 9);
  v3 = mlir::Operation::create((mlir::Operation *)v5, v2);
  mlir::OperationState::~OperationState((mlir::OperationState *)v5);
  return v3;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::scf::detail::ParallelOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t mlir::isOpTriviallyDead(void ***this, mlir::Operation *a2)
{
  uint64_t v3;
  void ***v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *NextResultAtOffset;

  v3 = *((unsigned int *)this + 9);
  v4 = this - 2;
  if ((_DWORD)v3)
    v5 = (uint64_t)v4;
  else
    v5 = 0;
  if ((_DWORD)v3)
  {
    if (*(_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v4, 0))
      return 0;
    v6 = 1;
    while (v3 != v6)
    {
      NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v5, v6++);
      if (*NextResultAtOffset)
        return 0;
    }
  }
  return mlir::wouldOpBeTriviallyDead(this, a2);
}

uint64_t mlir::wouldOpBeTriviallyDead(void ***this, mlir::Operation *a2)
{
  uint64_t v3;
  uint64_t InherentAttr;
  char v5;
  unsigned int v6;
  unsigned __int8 *v7;
  _QWORD *v8;
  unsigned __int8 *v9;
  _QWORD *v10;
  uint64_t v11;
  int HasRecursiveMemory;
  char v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t i;
  uint64_t v18;
  ZinIrHalH13g *v19;
  ZinIrHalH13g *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (**InterfaceFor)(_QWORD, uint64_t, void **);
  char *v25;
  char *v26;
  uint64_t v27;
  unsigned __int8 v28;
  unint64_t v29;
  unint64_t v31;
  const void *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  unint64_t v38;
  const char *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  _BYTE *v46;
  unint64_t v47;
  const void *v48;
  const void **BucketFor;
  int v50;
  int v51;
  uint64_t v52;
  unsigned __int8 v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  char v62;
  void *v63;
  void *v64;
  _BYTE *v66;
  _BYTE *v67;
  uint64_t v68;
  int v69;
  _BYTE v70[32];
  const char *v71;
  unint64_t v72;
  void *v73;
  uint64_t v74;
  _BYTE v75[40];
  _QWORD *v76;
  unsigned int v77;
  unsigned int v78;
  _QWORD v79[3];

  v79[1] = *MEMORY[0x24BDAC8D0];
  if ((mlir::OperationName::mightHaveTrait<mlir::OpTrait::IsTerminator>(this + 6) & 1) != 0)
    return 0;
  if (!mlir::OpInterface<mlir::SymbolOpInterface,mlir::detail::SymbolOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
    goto LABEL_9;
  if (*((_BYTE *)this + 47))
  {
    InherentAttr = mlir::Operation::getInherentAttr((uint64_t)this, (uint64_t)"sym_name", 8);
    if (v5)
    {
      if (!InherentAttr)
        goto LABEL_9;
      return 0;
    }
  }
  if ((mlir::DictionaryAttr::contains((uint64_t)(this + 7), "sym_name", 8uLL) & 1) != 0)
    return 0;
LABEL_9:
  v76 = v79;
  v6 = 1;
  v78 = 1;
  v79[0] = this;
  v8 = &unk_25451A000;
  do
  {
    v9 = v7;
    v10 = v8;
    v11 = v76[v6 - 1];
    v77 = v6 - 1;
    HasRecursiveMemory = mlir::OperationName::hasTrait<mlir::OpTrait::HasRecursiveMemoryEffects>((_QWORD *)(v11 + 48));
    v13 = HasRecursiveMemory;
    if (HasRecursiveMemory)
    {
      v14 = *(unsigned int *)(v11 + 44);
      if ((v14 & 0x7FFFFF) != 0)
      {
        v15 = ((v11 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
            + 32 * *(unsigned int *)(v11 + 40);
        v16 = v15 + 24 * (v14 & 0x7FFFFF);
        for (i = *(_QWORD *)(v15 + 8); i != v15; i = *(_QWORD *)(i + 8))
        {
LABEL_17:
          v18 = i - 8;
          if (!i)
            v18 = 0;
          v19 = (ZinIrHalH13g *)(v18 + 32);
          v20 = *(ZinIrHalH13g **)(v18 + 40);
          if (v20 != (ZinIrHalH13g *)(v18 + 32))
          {
            do
            {
              ZinIrHalH13g::~ZinIrHalH13g(v20);
              v22 = v21;
              v23 = v77;
              if (v77 >= (unint64_t)v78)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v77 + 1, 8);
                v23 = v77;
              }
              v76[v23] = v22;
              ++v77;
              v20 = (ZinIrHalH13g *)*((_QWORD *)v20 + 1);
            }
            while (v20 != v19);
          }
        }
        while (1)
        {
          v15 += 24;
          if (v15 == v16)
            break;
          i = *(_QWORD *)(v15 + 8);
          if (i != v15)
            goto LABEL_17;
        }
      }
    }
    if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(v11))
    {
      v8 = v10;
      v7 = v9;
      goto LABEL_10;
    }
    v8 = v10;
    if (!v11)
    {
      v7 = v9;
LABEL_10:
      if ((v13 & 1) == 0)
        goto LABEL_108;
      goto LABEL_11;
    }
    InterfaceFor = (void (**)(_QWORD, uint64_t, void **))mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(v11);
    v7 = v9;
    v73 = v75;
    v74 = 0x100000000;
    (*InterfaceFor)(InterfaceFor, v11, &v73);
    v66 = v70;
    v67 = v70;
    v68 = 4;
    v69 = 0;
    if (!(_DWORD)v74)
    {
LABEL_100:
      v62 = 1;
      v63 = v67;
      if (v67 == v66)
        goto LABEL_102;
LABEL_101:
      free(v63);
      goto LABEL_102;
    }
    v25 = (char *)v73;
    v26 = (char *)v73 + 40 * v74;
    do
    {
      v27 = **(_QWORD **)v25;
      v28 = atomic_load(v9);
      if ((v28 & 1) == 0 && __cxa_guard_acquire((__guard *)v9))
      {
        v71 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Allocate]";
        v72 = 79;
        v37 = llvm::StringRef::find((uint64_t *)&v71, "DesiredTypeName = ", 0x12uLL, 0);
        if (v72 >= v37)
          v38 = v37;
        else
          v38 = v72;
        v39 = &v71[v38];
        v40 = v72 - v38;
        v41 = 18;
        if (v40 < 0x12)
          v41 = v40;
        v42 = v40 - v41;
        if (v42 >= v42 - 1)
          v43 = v42 - 1;
        else
          v43 = v42;
        mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v39[v41], v43);
        __cxa_guard_release((__guard *)v9);
      }
      if (v27 == mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id)
      {
        v29 = *((_QWORD *)v25 + 2);
        if (v29 >= 8 && (v29 & ((uint64_t)(v29 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8) != 0)
        {
          v71 = (const char *)(v29 & ((uint64_t)(v29 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8);
          if (mlir::Value::getDefiningOp((mlir::Value *)&v71) == v11)
          {
            v31 = *((_QWORD *)v25 + 2);
            if (v31 <= 7)
              v32 = 0;
            else
              v32 = (const void *)(v31 & ((uint64_t)(v31 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8);
            if (v67 != v66)
            {
LABEL_32:
              llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)&v66, v32);
              goto LABEL_33;
            }
            v33 = HIDWORD(v68);
            if (HIDWORD(v68))
            {
              v34 = 0;
              v35 = 8 * HIDWORD(v68);
              v36 = v67;
              while ((const void *)*v36 != v32)
              {
                if (*v36 == -2)
                  v34 = v36;
                ++v36;
                v35 -= 8;
                if (!v35)
                {
                  if (!v34)
                    goto LABEL_53;
                  *v34 = v32;
                  --v69;
                  break;
                }
              }
            }
            else
            {
LABEL_53:
              if (HIDWORD(v68) >= v68)
                goto LABEL_32;
              ++HIDWORD(v68);
              *(_QWORD *)&v67[8 * v33] = v32;
            }
          }
        }
      }
LABEL_33:
      v25 += 40;
    }
    while (v25 != v26);
    if (!(_DWORD)v74)
      goto LABEL_100;
    v44 = (char *)v73;
    v45 = (char *)v73 + 40 * v74;
    while (2)
    {
      v47 = *((_QWORD *)v44 + 2);
      if (v47 <= 7)
        v48 = 0;
      else
        v48 = (const void *)(v47 & ((uint64_t)(v47 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8);
      if (v67 != v66)
      {
        BucketFor = llvm::SmallPtrSetImplBase::FindBucketFor((llvm::SmallPtrSetImplBase *)&v66, v48);
        if (*BucketFor != v48)
        {
          v50 = v68;
          if (v67 == v66)
            v50 = HIDWORD(v68);
          BucketFor = (const void **)&v67[8 * v50];
        }
        if (v67 == v66)
          v51 = HIDWORD(v68);
        else
          v51 = v68;
        if (BucketFor == (const void **)&v67[8 * v51])
          goto LABEL_82;
LABEL_69:
        v44 += 40;
        if (v44 == v45)
          goto LABEL_100;
        continue;
      }
      break;
    }
    v46 = &v67[8 * HIDWORD(v68)];
    if (HIDWORD(v68))
    {
      v54 = 0;
      while (*(const void **)&v67[v54] != v48)
      {
        v54 += 8;
        if (8 * HIDWORD(v68) == v54)
          goto LABEL_68;
      }
      v46 = &v67[v54];
    }
LABEL_68:
    if (v46 != &v67[8 * HIDWORD(v68)])
      goto LABEL_69;
LABEL_82:
    v52 = **(_QWORD **)v44;
    if ((v53 & 1) == 0
    {
      v71 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Read]";
      v72 = 75;
      v55 = llvm::StringRef::find((uint64_t *)&v71, "DesiredTypeName = ", 0x12uLL, 0);
      if (v72 >= v55)
        v56 = v55;
      else
        v56 = v72;
      v57 = &v71[v56];
      v58 = v72 - v56;
      v59 = 18;
      if (v58 < 0x12)
        v59 = v58;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      v8[398] = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
    }
    if (v52 == v8[398])
      goto LABEL_69;
    v62 = 0;
    v63 = v67;
    if (v67 != v66)
      goto LABEL_101;
LABEL_102:
    if (v73 != v75)
      free(v73);
    if ((v62 & 1) == 0)
    {
LABEL_108:
      v3 = 0;
      v64 = v76;
      if (v76 != v79)
        goto LABEL_109;
      return v3;
    }
LABEL_11:
    v6 = v77;
  }
  while (v77);
  v3 = 1;
  v64 = v76;
  if (v76 != v79)
LABEL_109:
    free(v64);
  return v3;
}

uint64_t mlir::isMemoryEffectFree(mlir *this, mlir::Operation *a2)
{
  void (**InterfaceFor)(_QWORD, mlir *, void **);
  int v4;
  uint64_t result;
  unint64_t v6;
  mlir::Region *v7;
  mlir::Region *v8;
  ZinIrHalH13g *v9;
  ZinIrHalH13g *v10;
  mlir *v11;
  mlir::Operation *v12;
  __int128 v13;
  ZinIrHalH13g *v14;
  void *v15[2];
  ZinIrHalH13g *v16;
  uint64_t v17;
  ZinIrHalH13g *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this)
    && this)
  {
    v15[0] = &v16;
    v15[1] = (void *)0x400000000;
    InterfaceFor = (void (**)(_QWORD, mlir *, void **))mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
    (*InterfaceFor)(InterfaceFor, this, v15);
    v4 = (int)v15[1];
    if (v15[0] != &v16)
      free(v15[0]);
    if (v4)
      return 0;
    if ((mlir::OperationName::hasTrait<mlir::OpTrait::HasRecursiveMemoryEffects>((_QWORD *)this + 6) & 1) == 0)
      return 1;
    goto LABEL_11;
  }
  result = mlir::OperationName::hasTrait<mlir::OpTrait::HasRecursiveMemoryEffects>((_QWORD *)this + 6);
  if ((_DWORD)result)
  {
LABEL_11:
    v6 = *((unsigned int *)this + 11);
    if ((v6 & 0x7FFFFF) != 0)
    {
      v7 = (mlir::Region *)((((unint64_t)this + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                          + 32 * *((unsigned int *)this + 10));
      v8 = (mlir::Region *)((char *)v7 + 24 * (v6 & 0x7FFFFF));
      while (1)
      {
        mlir::Region::OpIterator::OpIterator(&v13, v7, 0);
        mlir::Region::OpIterator::OpIterator(&v17, v7, 1);
        v9 = v14;
        v16 = v14;
        *(_OWORD *)v15 = v13;
        v10 = v18;
        if (v14 != v18)
          break;
LABEL_16:
        v7 = (mlir::Region *)((char *)v7 + 24);
        result = 1;
        if (v7 == v8)
          return result;
      }
      while (1)
      {
        ZinIrHalH13g::~ZinIrHalH13g(v9);
        if ((mlir::isMemoryEffectFree(v11, v12) & 1) == 0)
          return 0;
        mlir::Region::OpIterator::operator++((uint64_t *)&v13);
        v9 = v14;
        if (v14 == v10)
          goto LABEL_16;
      }
    }
    return 1;
  }
  return result;
}

void mlir::getEffectsRecursively(mlir *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3;
  uint64_t v4;
  int HasRecursiveMemory;
  char v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t i;
  uint64_t v11;
  ZinIrHalH13g *v12;
  ZinIrHalH13g *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (**InterfaceFor)(_QWORD, uint64_t, void **);
  char v18;
  uint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  void *v24;
  unsigned int v25;
  unsigned int v26;
  _QWORD v27[6];
  void *__src;
  uint64_t v29;
  _QWORD v30[7];

  v30[5] = *MEMORY[0x24BDAC8D0];
  __src = v30;
  v29 = 0x100000000;
  v24 = v27;
  v26 = 6;
  v27[0] = this;
  v3 = 1;
  do
  {
    v4 = *((_QWORD *)v24 + v3 - 1);
    v25 = v3 - 1;
    HasRecursiveMemory = mlir::OperationName::hasTrait<mlir::OpTrait::HasRecursiveMemoryEffects>((_QWORD *)(v4 + 48));
    v6 = HasRecursiveMemory;
    if (HasRecursiveMemory)
    {
      v7 = *(unsigned int *)(v4 + 44);
      if ((v7 & 0x7FFFFF) != 0)
      {
        v8 = ((v4 + 16 * ((v7 >> 23) & 1) + ((v7 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
           + 32 * *(unsigned int *)(v4 + 40);
        v9 = v8 + 24 * (v7 & 0x7FFFFF);
        do
        {
          for (i = *(_QWORD *)(v8 + 8); i != v8; i = *(_QWORD *)(i + 8))
          {
            v11 = i - 8;
            if (!i)
              v11 = 0;
            v12 = (ZinIrHalH13g *)(v11 + 32);
            v13 = *(ZinIrHalH13g **)(v11 + 40);
            if (v13 != (ZinIrHalH13g *)(v11 + 32))
            {
              do
              {
                ZinIrHalH13g::~ZinIrHalH13g(v13);
                v15 = v14;
                v16 = v25;
                if (v25 >= (unint64_t)v26)
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, v27, v25 + 1, 8);
                  v16 = v25;
                }
                *((_QWORD *)v24 + v16) = v15;
                ++v25;
                v13 = (ZinIrHalH13g *)*((_QWORD *)v13 + 1);
              }
              while (v13 != v12);
            }
          }
          v8 += 24;
        }
        while (v8 != v9);
      }
    }
    if (mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(v4)
      && v4)
    {
      InterfaceFor = (void (**)(_QWORD, uint64_t, void **))mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(v4);
      (*InterfaceFor)(InterfaceFor, v4, &__src);
    }
    else if ((v6 & 1) == 0)
    {
      v18 = 0;
      v19 = a2;
      *(_BYTE *)a2 = 0;
      goto LABEL_34;
    }
    v3 = v25;
  }
  while (v25);
  v19 = a2;
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x100000000;
  v20 = v29;
  v18 = 1;
  if ((_DWORD)v29 && &__src != (void **)a2)
  {
    if (__src != v30)
    {
      *(_QWORD *)a2 = __src;
      v21 = HIDWORD(v29);
      *(_DWORD *)(a2 + 8) = v20;
      *(_DWORD *)(a2 + 12) = v21;
      __src = v30;
      HIDWORD(v29) = 0;
LABEL_33:
      LODWORD(v29) = 0;
      v18 = 1;
      goto LABEL_34;
    }
    if (v29 < 2)
    {
      v22 = 1;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v29, 40);
      v22 = v29;
      if (!(_DWORD)v29)
        goto LABEL_32;
    }
    memcpy(*(void **)a2, __src, 40 * v22);
LABEL_32:
    *(_DWORD *)(a2 + 8) = v20;
    goto LABEL_33;
  }
LABEL_34:
  *(_BYTE *)(v19 + 56) = v18;
  if (v24 != v27)
    free(v24);
  if (__src != v30)
    free(__src);
}

uint64_t mlir::openOutputFile@<X0>(const void *a1@<X0>, std::string::size_type a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _BYTE *v8;
  uint64_t result;
  std::string *p_dst;
  uint64_t v11;
  uint64_t v12;
  std::string *v13;
  std::string::size_type v14;
  std::string *v15;
  std::string::size_type v16;
  std::string *p_p;
  std::string::size_type size;
  std::string *v19;
  std::string::size_type v20;
  char v21;
  uint64_t v22;
  std::string __p;
  std::string __dst;
  std::string v25;
  std::string v26;
  std::error_code v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x24BDAC8D0];
  v27.__val_ = 0;
  v27.__cat_ = std::system_category();
  v8 = (_BYTE *)operator new();
  result = llvm::ToolOutputFile::ToolOutputFile(v8, a1, a2, &v27, 0);
  if (!v27.__val_)
  {
    *a4 = v8;
    return result;
  }
  if (!a3)
    goto LABEL_27;
  if (!a1)
  {
    memset(&__dst, 0, sizeof(__dst));
    goto LABEL_15;
  }
  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (a2 >= 0x17)
  {
    v11 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v11 = a2 | 7;
    v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = a2;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = a2;
    p_dst = &__dst;
    if (!a2)
      goto LABEL_14;
  }
  memmove(p_dst, a1, a2);
LABEL_14:
  p_dst->__r_.__value_.__s.__data_[a2] = 0;
LABEL_15:
  v13 = std::string::insert(&__dst, 0, "cannot open output file '");
  v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = std::string::append(&v25, "': ");
  v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  std::error_code::message(&__p, &v27);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v19 = std::string::append(&v26, (const std::string::value_type *)p_p, size);
  v20 = v19->__r_.__value_.__r.__words[0];
  v28[0] = v19->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v28 + 7) = *(std::string::size_type *)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
  v21 = HIBYTE(v19->__r_.__value_.__r.__words[2]);
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a3 + 23) < 0)
    operator delete(*(void **)a3);
  v22 = v28[0];
  *(_QWORD *)a3 = v20;
  *(_QWORD *)(a3 + 8) = v22;
  *(_QWORD *)(a3 + 15) = *(_QWORD *)((char *)v28 + 7);
  *(_BYTE *)(a3 + 23) = v21;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_25;
LABEL_31:
    operator delete(v26.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_26:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_27;
LABEL_33:
      operator delete(__dst.__r_.__value_.__l.__data_);
      *a4 = 0;
      if (!v8[128])
        goto LABEL_29;
      goto LABEL_28;
    }
    goto LABEL_32;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_31;
LABEL_25:
  if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_26;
LABEL_32:
  operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_33;
LABEL_27:
  *a4 = 0;
  if (v8[128])
LABEL_28:
    llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)(v8 + 32));
LABEL_29:
  llvm::ToolOutputFile::CleanupInstaller::~CleanupInstaller((llvm::ToolOutputFile::CleanupInstaller *)v8);
  return MEMORY[0x20BD002F8]();
}

void mlir::detail::InterfaceMap::insert(uint64_t a1, unint64_t a2, void *a3)
{
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;

  v4 = *(_QWORD **)a1;
  v5 = *(unsigned int *)(a1 + 8);
  v6 = *(_QWORD *)a1 + 16 * v5;
  if ((_DWORD)v5)
  {
    do
    {
      v7 = v5 >> 1;
      v8 = &v4[2 * (v5 >> 1)];
      v10 = *v8;
      v9 = v8 + 2;
      v5 += ~(v5 >> 1);
      if (v10 < a2)
        v4 = v9;
      else
        v5 = v7;
    }
    while (v5);
    if (v4 != (_QWORD *)v6 && *v4 == a2)
    {
      free(a3);
    }
    else
    {
      v11 = a2;
      v12 = a3;
      llvm::SmallVectorImpl<std::pair<mlir::TypeID,void *>>::insert_one_impl<std::pair<mlir::TypeID,void *>>(a1, (uint64_t)v4, &v11);
    }
  }
  else
  {
    v11 = a2;
    v12 = a3;
    llvm::SmallVectorImpl<std::pair<mlir::TypeID,void *>>::insert_one_impl<std::pair<mlir::TypeID,void *>>(a1, v6, &v11);
  }
}

_QWORD *llvm::SmallVectorImpl<std::pair<mlir::TypeID,void *>>::insert_one_impl<std::pair<mlir::TypeID,void *>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *result;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  __int128 v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  double *v19;
  uint64_t v20;
  const double *v21;
  const double *v22;
  double *v23;
  _QWORD *v24;
  uint64_t v25;
  __int128 v26;
  float64x2x2_t v27;
  float64x2x2_t v28;

  v5 = *(_QWORD *)a1;
  v6 = *(unsigned int *)(a1 + 8);
  if (*(_QWORD *)a1 + 16 * v6 != a2)
  {
    v7 = a2 - v5;
    v8 = (a2 - v5) >> 4;
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v6 + 1, 16);
      v5 = *(_QWORD *)a1;
      v6 = *(unsigned int *)(a1 + 8);
    }
    result = (_QWORD *)(v5 + 16 * v8);
    *(_OWORD *)(v5 + 16 * v6) = *(_OWORD *)(v5 + 16 * v6 - 16);
    v10 = *(unsigned int *)(a1 + 8);
    v11 = *(_QWORD *)a1 + 16 * v10;
    v12 = (_QWORD *)(v11 - 16);
    if ((_QWORD *)(v11 - 16) == result)
      goto LABEL_15;
    v13 = v11 - ((v7 & 0xFFFFFFFFFFFFFFF0) + v5) - 32;
    if (v13 >= 0x30)
    {
      v17 = (v13 >> 4) + 1;
      v18 = 16 * (v17 & 0x1FFFFFFFFFFFFFFCLL);
      v14 = v11 - v18;
      v12 = (_QWORD *)((char *)v12 - v18);
      v19 = (double *)(v11 - 32);
      v20 = v17 & 0x1FFFFFFFFFFFFFFCLL;
      do
      {
        v21 = v19 - 2;
        v27 = vld2q_f64(v21);
        v22 = v19 - 6;
        v28 = vld2q_f64(v22);
        v23 = v19 - 4;
        vst2q_f64(v19, v27);
        vst2q_f64(v23, v28);
        v19 -= 8;
        v20 -= 4;
      }
      while (v20);
      if (v17 == (v17 & 0x1FFFFFFFFFFFFFFCLL))
        goto LABEL_15;
    }
    else
    {
      v14 = *(_QWORD *)a1 + 16 * v10;
    }
    v24 = (_QWORD *)(v14 - 8);
    do
    {
      v25 = *(v12 - 2);
      v12 -= 2;
      *(v24 - 1) = v25;
      *v24 = v12[1];
      v24 -= 2;
    }
    while (v12 != result);
LABEL_15:
    *(_DWORD *)(a1 + 8) = v10 + 1;
    *result = *a3;
    result[1] = a3[1];
    return result;
  }
  v15 = *(_OWORD *)a3;
  if (v6 >= *(_DWORD *)(a1 + 12))
  {
    v26 = *(_OWORD *)a3;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v6 + 1, 16);
    v15 = v26;
    v6 = *(unsigned int *)(a1 + 8);
    v5 = *(_QWORD *)a1;
  }
  *(_OWORD *)(v5 + 16 * v6) = v15;
  v16 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v16;
  return (_QWORD *)(*(_QWORD *)a1 + 16 * v16 - 16);
}

mlir::StorageUniquer *mlir::StorageUniquer::StorageUniquer(mlir::StorageUniquer *this)
{
  uint64_t v2;
  char *v3;

  v2 = operator new();
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 208) = 0u;
  *(_OWORD *)(v2 + 224) = 0u;
  *(_OWORD *)(v2 + 240) = 0u;
  *(_QWORD *)(v2 + 256) = 0;
  *(_OWORD *)(v2 + 192) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  v3 = (char *)operator new(0x78uLL);
  *((_QWORD *)v3 + 1) = 0;
  *((_QWORD *)v3 + 2) = 0;
  *(_QWORD *)v3 = &unk_24C05C758;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *((_QWORD *)v3 + 3) = v3 + 40;
  *((_QWORD *)v3 + 4) = 0x100000000;
  MEMORY[0x20BD00034](v3 + 48);
  *((_DWORD *)v3 + 28) = 0;
  *(_QWORD *)v2 = v3 + 24;
  *(_QWORD *)(v2 + 8) = v3;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  MEMORY[0x20BD00034](v2 + 40);
  *(_DWORD *)(v2 + 104) = 0;
  *(_QWORD *)(v2 + 112) = 0;
  *(_QWORD *)(v2 + 120) = 0;
  *(_QWORD *)(v2 + 128) = v2 + 144;
  *(_QWORD *)(v2 + 136) = *(_QWORD *)"";
  *(_QWORD *)(v2 + 192) = 0;
  *(_QWORD *)(v2 + 176) = v2 + 192;
  *(_QWORD *)(v2 + 184) = 0;
  *(_QWORD *)(v2 + 208) = 0;
  *(_QWORD *)(v2 + 216) = 0;
  *(_QWORD *)(v2 + 200) = 1;
  *(_DWORD *)(v2 + 224) = 0;
  *(_QWORD *)(v2 + 232) = 0;
  *(_QWORD *)(v2 + 240) = 0;
  *(_DWORD *)(v2 + 248) = 0;
  *(_BYTE *)(v2 + 256) = 1;
  *(_QWORD *)this = v2;
  return this;
}

void mlir::StorageUniquer::~StorageUniquer(llvm ***this)
{
  llvm **v2;

  v2 = *this;
  *this = 0;
  if (v2)
    mlir::detail::StorageUniquerImpl::~StorageUniquerImpl(v2);
}

uint64_t mlir::StorageUniquer::getParametricStorageTypeImpl(unsigned __int8 **a1, uint64_t a2, unsigned int a3, uint64_t (*a4)(uint64_t), uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t), uint64_t a7)
{
  return mlir::detail::StorageUniquerImpl::getOrCreate(*a1, a2, a3, a4, a5, a6, a7);
}

uint64_t mlir::detail::StorageUniquerImpl::getOrCreate(unsigned __int8 *a1, uint64_t a2, unsigned int a3, uint64_t (*a4)(uint64_t), uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t), uint64_t a7)
{
  unsigned __int8 *v12;
  uint64_t **v13;
  uint64_t *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  pthread_rwlock_t **v18;
  unint64_t *v19;
  uint64_t (*v21)(_QWORD);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t ThreadSafeAllocator;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  unint64_t *p_shared_owners;
  unint64_t v42;
  unsigned int v43;
  std::recursive_mutex *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  unint64_t *p_shared_weak_owners;
  unint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  int v62;
  unsigned __int8 *v63;
  uint64_t *v64;
  unsigned int v65;
  uint64_t *v66;
  uint64_t *v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t *v70;
  int v71;
  uint64_t *v72;
  std::__shared_weak_count *v73;
  uint64_t v74;
  llvm *v75;
  int v76;
  int v77;
  int v78;
  uint64_t (*v79)(uint64_t);
  uint64_t v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t (*v86)(uint64_t, uint64_t);
  uint64_t v87;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t *v92;
  int v93;
  BOOL v94;
  unsigned int v95;
  unint64_t v96;
  BOOL v97;
  unint64_t v98;
  unint64_t v99;
  int v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  uint64_t *v110;
  int v111;
  unsigned int v112;
  uint64_t v113;
  char *v114;
  uint64_t *v115;
  int v116;
  BOOL v117;
  unsigned int v118;
  unsigned __int8 *v119;
  uint64_t v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  unsigned int v122;
  uint64_t v123;
  __int128 v124;
  unsigned int v125;
  uint64_t (*v126)(uint64_t);
  uint64_t v127;
  __int128 v128;
  _QWORD *v129;
  __int128 v130;
  _QWORD v131[11];

  v12 = a1;
  v131[9] = *MEMORY[0x24BDAC8D0];
  v123 = a2;
  v14 = *v13;
  v15 = v12[256];
  v16 = (*((_DWORD *)*v13 + 6) - 1) & a3;
  v17 = atomic_load((unint64_t *)((*v13)[2] + 8 * v16));
  if (!v17)
  {
    v17 = operator new();
    *(_OWORD *)v17 = 0u;
    *(_OWORD *)(v17 + 16) = 0u;
    *(_QWORD *)(v17 + 32) = 0;
    v18 = (pthread_rwlock_t **)llvm::sys::RWMutexImpl::RWMutexImpl((llvm::sys::RWMutexImpl *)(v17 + 24));
    *(_QWORD *)(v17 + 32) = 0;
    v19 = (unint64_t *)(v14[2] + 8 * v16);
    do
    {
      if (__ldaxr(v19))
      {
        __clrex();
        llvm::sys::RWMutexImpl::~RWMutexImpl(v18);
        llvm::deallocate_buffer(*(llvm **)v17, (void *)(16 * *(unsigned int *)(v17 + 16)));
      }
    }
    while (__stlxr(v17, v19));
  }
  v125 = a3;
  v126 = a4;
  v127 = a5;
  if (!v15)
  {
    LODWORD(v124) = a3;
    *((_QWORD *)&v124 + 1) = 0;
    v30 = (uint64_t)v129;
    if (!BYTE8(v130))
      return v129[1];
    ThreadSafeAllocator = mlir::detail::StorageUniquerImpl::getThreadSafeAllocator((mlir::detail::StorageUniquerImpl *)v12);
    v32 = a6(a7, ThreadSafeAllocator);
    *(_QWORD *)(v30 + 8) = v32;
    return v32;
  }
  {
    *v91 = 1;
    v91[1] = -4096;
    v91[4] = -4096;
    v91[7] = -4096;
    v91[10] = -4096;
  }
  v23 = v22;
  v24 = *v14;
  v26 = (uint64_t *)(v22 + 8);
  v25 = *(_DWORD *)v22;
  v27 = *(_DWORD *)v22 & 1;
  v120 = a7;
  if (v27)
  {
    v28 = 4;
    v29 = v22 + 8;
  }
  else
  {
    v28 = *(_DWORD *)(v22 + 16);
    if (!v28)
    {
      v35 = 0;
      v43 = 0;
      goto LABEL_26;
    }
    v29 = *(_QWORD *)(v22 + 8);
  }
  v33 = v28 - 1;
  v34 = v33 & ((v24 >> 4) ^ (v24 >> 9));
  v35 = (uint64_t *)(v29 + 24 * v34);
  v36 = *v35;
  if (*v35 == v24)
    goto LABEL_17;
  v92 = 0;
  v93 = 1;
  while (v36 != -4096)
  {
    if (v92)
      v94 = 0;
    else
      v94 = v36 == -8192;
    if (v94)
      v92 = v35;
    v95 = v34 + v93++;
    v34 = v95 & v33;
    v35 = (uint64_t *)(v29 + 24 * v34);
    v36 = *v35;
    if (*v35 == v24)
      goto LABEL_17;
  }
  if (v92)
    v35 = v92;
  if (v27)
    v43 = 4;
  else
    v43 = *(_DWORD *)(v22 + 16);
LABEL_26:
  if (4 * (v25 >> 1) + 4 >= 3 * v43)
  {
    v43 *= 2;
LABEL_114:
    if (v43 >= 5)
    {
      v98 = (v43 - 1) | ((unint64_t)(v43 - 1) >> 1);
      v99 = v98 | (v98 >> 2) | ((v98 | (v98 >> 2)) >> 4);
      v100 = ((v99 | (v99 >> 8)) >> 16) | v99 | (v99 >> 8);
      if ((v100 + 1) > 0x40)
        v43 = v100 + 1;
      else
        v43 = 64;
    }
    if (!v27)
    {
      v101 = *(uint64_t **)(v22 + 8);
      v102 = *(unsigned int *)(v22 + 16);
      if (v43 > 4)
      {
        v108 = v43;
        *(_QWORD *)(v22 + 8) = llvm::allocate_buffer(24 * v43, (std::align_val_t)8uLL);
        *(_QWORD *)(v23 + 16) = v108;
      }
      else
      {
        *(_DWORD *)v22 = v25 | 1;
      }
      llvm::deallocate_buffer((llvm *)v101, (void *)(24 * v102));
    }
    v103 = (uint64_t *)&v129;
    if ((*v26 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v104 = *(_QWORD *)(v22 + 32);
      if ((v104 | 0x1000) == 0xFFFFFFFFFFFFF000)
        goto LABEL_123;
    }
    else
    {
      v129 = (_QWORD *)*v26;
      v130 = *(_OWORD *)(v22 + 16);
      *(_QWORD *)(v22 + 16) = 0;
      *(_QWORD *)(v22 + 24) = 0;
      v103 = v131;
      v104 = *(_QWORD *)(v22 + 32);
      if ((v104 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
LABEL_123:
        v105 = *(_QWORD *)(v22 + 56);
        if ((v105 | 0x1000) == 0xFFFFFFFFFFFFF000)
          goto LABEL_124;
        goto LABEL_139;
      }
    }
    *v103 = v104;
    *(_OWORD *)(v103 + 1) = *(_OWORD *)(v22 + 40);
    *(_QWORD *)(v22 + 40) = 0;
    *(_QWORD *)(v22 + 48) = 0;
    v103 += 3;
    v105 = *(_QWORD *)(v22 + 56);
    if ((v105 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
LABEL_124:
      v106 = *(_QWORD *)(v22 + 80);
      if ((v106 | 0x1000) == 0xFFFFFFFFFFFFF000)
        goto LABEL_125;
      goto LABEL_140;
    }
LABEL_139:
    *v103 = v105;
    *(_OWORD *)(v103 + 1) = *(_OWORD *)(v22 + 64);
    *(_QWORD *)(v22 + 64) = 0;
    *(_QWORD *)(v22 + 72) = 0;
    v103 += 3;
    v106 = *(_QWORD *)(v22 + 80);
    if ((v106 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
LABEL_125:
      if (v43 < 5)
      {
LABEL_127:
        v25 = *(_DWORD *)v23;
        if ((*(_DWORD *)v23 & 1) != 0)
        {
          v109 = 4;
          v110 = v26;
        }
        else
        {
          v109 = *(_DWORD *)(v23 + 16);
          if (!v109)
          {
            v27 = 0;
            v35 = 0;
            goto LABEL_28;
          }
          v110 = *(uint64_t **)(v23 + 8);
        }
        v27 = *(_DWORD *)v23 & 1;
        v111 = v109 - 1;
        v112 = v111 & ((v24 >> 4) ^ (v24 >> 9));
        v35 = &v110[3 * v112];
        v113 = *v35;
        if (*v35 != v24)
        {
          v115 = 0;
          v116 = 1;
          while (v113 != -4096)
          {
            if (v115)
              v117 = 0;
            else
              v117 = v113 == -8192;
            if (v117)
              v115 = v35;
            v118 = v112 + v116++;
            v112 = v118 & v111;
            v35 = &v110[3 * v112];
            v113 = *v35;
            if (*v35 == v24)
              goto LABEL_28;
          }
          if (v115)
            v35 = v115;
        }
        goto LABEL_28;
      }
LABEL_126:
      *(_DWORD *)v22 &= ~1u;
      v107 = v43;
      *(_QWORD *)(v22 + 8) = llvm::allocate_buffer(24 * v43, (std::align_val_t)8uLL);
      *(_QWORD *)(v23 + 16) = v107;
      goto LABEL_127;
    }
LABEL_140:
    *v103 = v106;
    *(_OWORD *)(v103 + 1) = *(_OWORD *)(v22 + 88);
    *(_QWORD *)(v22 + 88) = 0;
    *(_QWORD *)(v22 + 96) = 0;
    v103 += 3;
    if (v43 < 5)
      goto LABEL_127;
    goto LABEL_126;
  }
  if (v43 + ~(v25 >> 1) - *(_DWORD *)(v22 + 4) <= v43 >> 3)
    goto LABEL_114;
LABEL_28:
  *(_DWORD *)v23 = (v25 & 0xFFFFFFFE | v27) + 2;
  if (*v35 != -4096)
    --*(_DWORD *)(v23 + 4);
  v35[1] = 0;
  v35[2] = 0;
  *v35 = v24;
LABEL_17:
  v121 = a6;
  v37 = (std::__shared_weak_count *)v35[2];
  if (v37)
  {
    v38 = std::__shared_weak_count::lock(v37);
    if (v38)
    {
      v39 = v38;
      v40 = v35[1];
      p_shared_owners = (unint64_t *)&v38->__shared_owners_;
      do
        v42 = __ldaxr(p_shared_owners);
      while (__stlxr(v42 - 1, p_shared_owners));
      if (v42)
      {
        if (v40)
          goto LABEL_79;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v39);
        if (v40)
          goto LABEL_79;
      }
    }
  }
  v122 = a3;
  v44 = (std::recursive_mutex *)(*v14 + 24);
  std::recursive_mutex::lock(v44);
  v45 = *v14;
  v46 = (_QWORD *)operator new();
  v46[1] = 0;
  v46[2] = 0;
  *v46 = 0;
  v129 = v46;
  v47 = *(unsigned int *)(v45 + 8);
  v48 = *(_QWORD *)v45;
  v49 = (uint64_t *)&v129;
  if (v47 >= *(_DWORD *)(v45 + 12))
  {
    v96 = v47 + 1;
    v97 = v48 + 8 * v47 > (unint64_t)&v129;
    if (v48 <= (unint64_t)&v129 && v97)
    {
      v114 = (char *)&v129 - v48;
      v48 = *(_QWORD *)v45;
      v49 = (uint64_t *)&v114[*(_QWORD *)v45];
    }
    else
    {
      v48 = *(_QWORD *)v45;
      v49 = (uint64_t *)&v129;
    }
  }
  v50 = *(unsigned int *)(v45 + 8);
  v51 = *v49;
  *v49 = 0;
  *(_QWORD *)(v48 + 8 * v50) = v51;
  *(_DWORD *)(v45 + 8) = v50 + 1;
  v52 = (uint64_t)v129;
  v129 = 0;
  if (v52)
    llvm::deallocate_buffer(*(llvm **)v52, (void *)(16 * *(unsigned int *)(v52 + 16)));
  v53 = *v14;
  v54 = (std::__shared_weak_count *)v14[1];
  v40 = *(_QWORD *)(*(_QWORD *)v53 + 8 * *(unsigned int *)(v53 + 8) - 8);
  if (v54)
  {
    v55 = (unint64_t *)&v54->__shared_owners_;
    do
      v56 = __ldxr(v55);
    while (__stxr(v56 + 1, v55));
    p_shared_weak_owners = (unint64_t *)&v54->__shared_weak_owners_;
    do
      v58 = __ldxr(p_shared_weak_owners);
    while (__stxr(v58 + 1, p_shared_weak_owners));
  }
  v59 = (std::__shared_weak_count *)v35[2];
  v35[1] = v40;
  v35[2] = (uint64_t)v54;
  if (v59)
    std::__shared_weak_count::__release_weak(v59);
  if (!v54)
    goto LABEL_46;
  v60 = (unint64_t *)&v54->__shared_owners_;
  do
    v61 = __ldaxr(v60);
  while (__stlxr(v61 - 1, v60));
  if (!v61)
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
    v62 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 <= 1u)
      goto LABEL_47;
  }
  else
  {
LABEL_46:
    v62 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 <= 1u)
    {
LABEL_47:
      v63 = v12;
      v64 = *(uint64_t **)(v23 + 8);
      v65 = *(_DWORD *)(v23 + 16);
      if (v62)
        v66 = (uint64_t *)(v23 + 104);
      else
        v66 = &v64[3 * v65];
      if (v62)
      {
        v64 = v26;
        v65 = 4;
      }
      v67 = &v64[3 * v65];
      goto LABEL_62;
    }
  }
  if ((v62 & 1) != 0)
  {
    v63 = v12;
    v67 = (uint64_t *)(v23 + 104);
  }
  else
  {
    v26 = *(uint64_t **)(v23 + 8);
    v68 = *(_DWORD *)(v23 + 16);
    v67 = &v26[3 * v68];
    v63 = v12;
    if (!v68)
    {
      v69 = 0;
      v66 = *(uint64_t **)(v23 + 8);
      goto LABEL_66;
    }
  }
  v62 &= 1u;
  v66 = v26;
  while ((*v66 | 0x1000) == 0xFFFFFFFFFFFFF000)
  {
    v66 += 3;
    if (v66 == v67)
    {
      v66 = v67;
      break;
    }
  }
LABEL_62:
  if (v62)
  {
    v70 = (uint64_t *)(v23 + 104);
    if (v66 != (uint64_t *)(v23 + 104))
      goto LABEL_70;
    goto LABEL_78;
  }
  v26 = *(uint64_t **)(v23 + 8);
  v69 = *(_DWORD *)(v23 + 16);
LABEL_66:
  v70 = &v26[3 * v69];
  if (v66 != v70)
  {
    do
    {
LABEL_70:
      v72 = v67;
      if (v66 + 3 != v67)
      {
        v72 = v66 + 3;
        while ((*v72 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v72 += 3;
          if (v72 == v67)
          {
            v72 = v67;
            break;
          }
        }
      }
      v73 = (std::__shared_weak_count *)v66[2];
      if (v73)
      {
        if (v73->__shared_owners_ != -1)
          goto LABEL_69;
        std::__shared_weak_count::__release_weak(v73);
      }
      *v66 = -8192;
      v71 = *(_DWORD *)(v23 + 4) + 1;
      *(_DWORD *)v23 -= 2;
      *(_DWORD *)(v23 + 4) = v71;
LABEL_69:
      v66 = v72;
    }
    while (v72 != v70);
  }
LABEL_78:
  std::recursive_mutex::unlock(v44);
  v12 = v63;
  a3 = v122;
LABEL_79:
  LODWORD(v129) = a3;
  *(_QWORD *)&v130 = 0;
  v74 = v124;
  v32 = *(_QWORD *)(v124 + 8);
  if (!v32)
  {
    llvm::sys::RWMutexImpl::lock_shared((pthread_rwlock_t **)(v17 + 24));
    v75 = *(llvm **)v17;
    v76 = *(_DWORD *)(v17 + 16);
    if (v76)
    {
      v119 = v12;
      v77 = v76 - 1;
      v78 = 1;
      v79 = v126;
      v80 = v127;
      v81 = v125 & (v76 - 1);
      v82 = (uint64_t)v75 + 16 * v81;
      v83 = *(_QWORD *)(v82 + 8);
      if ((v83 | 0x1000) != 0xFFFFFFFFFFFFF000)
        goto LABEL_84;
      while (v83 != -4096)
      {
        while (1)
        {
          v84 = v81 + v78++;
          v81 = v84 & v77;
          v82 = (uint64_t)v75 + 16 * (v84 & v77);
          v83 = *(_QWORD *)(v82 + 8);
          if ((v83 | 0x1000) == 0xFFFFFFFFFFFFF000)
            break;
LABEL_84:
          if ((v79(v80) & 1) != 0)
          {
            v87 = v120;
            v86 = v121;
            v12 = v119;
            if (v82 != *(_QWORD *)v17 + 16 * *(unsigned int *)(v17 + 16))
              goto LABEL_89;
            goto LABEL_92;
          }
          if (*(_QWORD *)(v82 + 8) == -4096)
            goto LABEL_86;
        }
      }
LABEL_86:
      v85 = *(unsigned int *)(v17 + 16);
      v12 = v119;
      v82 = *(_QWORD *)v17 + 16 * v85;
      v87 = v120;
      v86 = v121;
      if (v82 != *(_QWORD *)v17 + 16 * v85)
      {
LABEL_89:
        v32 = *(_QWORD *)(v82 + 8);
        *(_QWORD *)(v74 + 8) = v32;
        llvm::sys::RWMutexImpl::unlock_shared((pthread_rwlock_t **)(v17 + 24));
        return v32;
      }
    }
    else
    {
      v87 = v120;
      v86 = v121;
    }
LABEL_92:
    llvm::sys::RWMutexImpl::unlock_shared((pthread_rwlock_t **)(v17 + 24));
    llvm::sys::RWMutexImpl::lock((pthread_rwlock_t **)(v17 + 24));
    LODWORD(v128) = v125;
    *((_QWORD *)&v128 + 1) = 0;
    v89 = (uint64_t)v129;
    if (BYTE8(v130))
    {
      v90 = mlir::detail::StorageUniquerImpl::getThreadSafeAllocator((mlir::detail::StorageUniquerImpl *)v12);
      v32 = v86(v87, v90);
      *(_QWORD *)(v89 + 8) = v32;
    }
    else
    {
      v32 = v129[1];
    }
    *(_QWORD *)(v74 + 8) = v32;
    llvm::sys::RWMutexImpl::unlock_shared((pthread_rwlock_t **)(v17 + 24));
  }
  return v32;
}

uint64_t *mlir::StorageUniquer::registerParametricStorageTypeImpl(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  char *v9;
  _QWORD *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  _QWORD *v29;
  int v30;
  BOOL v31;
  unsigned int v32;
  _QWORD *v33;

  v7 = *a1;
  v8 = (_QWORD *)operator new();
  v9 = (char *)operator new(0x78uLL);
  *((_QWORD *)v9 + 1) = 0;
  *((_QWORD *)v9 + 2) = 0;
  *(_QWORD *)v9 = &off_24C05C720;
  *(_OWORD *)(v9 + 56) = 0u;
  *(_OWORD *)(v9 + 72) = 0u;
  *(_OWORD *)(v9 + 88) = 0u;
  *(_OWORD *)(v9 + 104) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *((_QWORD *)v9 + 3) = v9 + 40;
  *((_QWORD *)v9 + 4) = 0x100000000;
  MEMORY[0x20BD00034](v9 + 48);
  *((_DWORD *)v9 + 28) = 0;
  *v8 = v9 + 24;
  v8[1] = v9;
  v10 = (_QWORD *)operator new[]();
  v8[2] = v10;
  v8[3] = 8;
  v8[4] = a3;
  v8[5] = a4;
  *v10 = 0;
  v10[1] = 0;
  v10[2] = 0;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  v10[6] = 0;
  v10[7] = 0;
  v11 = *(_QWORD *)(v7 + 208);
  v33 = v8;
  v12 = *(_DWORD *)(v7 + 224);
  if (!v12)
    goto LABEL_23;
  v13 = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v14 = (_QWORD *)(v11 + 16 * v13);
  v15 = *v14;
  if (*v14 == a2)
  v16 = 0;
  v17 = 1;
  while (v15 != -4096)
  {
    if (v16)
      v18 = 0;
    else
      v18 = v15 == -8192;
    if (v18)
      v16 = v14;
    v19 = v13 + v17++;
    v13 = v19 & (v12 - 1);
    v14 = (_QWORD *)(v11 + 16 * v13);
    v15 = *v14;
    if (*v14 == a2)
  }
  v23 = v16 ? v16 : v14;
  v24 = *(_DWORD *)(v7 + 216);
  if (4 * v24 + 4 < 3 * v12)
  {
    if (v12 + ~v24 - *(_DWORD *)(v7 + 220) > v12 >> 3)
      goto LABEL_14;
  }
  else
  {
LABEL_23:
    v12 *= 2;
  }
  v25 = *(_QWORD *)(v7 + 208);
  v26 = *(_DWORD *)(v7 + 224) - 1;
  v27 = v26 & ((a2 >> 4) ^ (a2 >> 9));
  v23 = (_QWORD *)(v25 + 16 * v27);
  v28 = *v23;
  if (*v23 == a2)
  {
    v20 = a2;
    goto LABEL_15;
  }
  v29 = 0;
  v30 = 1;
  while (v28 != -4096)
  {
    if (v29)
      v31 = 0;
    else
      v31 = v28 == -8192;
    if (v31)
      v29 = v23;
    v32 = v27 + v30++;
    v27 = v32 & v26;
    v23 = (_QWORD *)(v25 + 16 * (v32 & v26));
    v28 = *v23;
    v20 = a2;
    if (*v23 == a2)
      goto LABEL_15;
  }
  if (v29)
    v23 = v29;
LABEL_14:
  v20 = *v23;
LABEL_15:
  ++*(_DWORD *)(v7 + 216);
  if (v20 != -4096)
    --*(_DWORD *)(v7 + 220);
  *v23 = a2;
  v21 = (uint64_t)v33;
  v33 = 0;
  v23[1] = v21;
}

uint64_t *std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  llvm *v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(_QWORD *)(v2 + 24))
    {
      v3 = 0;
      do
      {
        v4 = atomic_load((unint64_t *)(*(_QWORD *)(v2 + 16) + 8 * v3));
        if (v4)
        {
          if (*(_QWORD *)(v2 + 32) && *(_DWORD *)(v4 + 8))
          {
            v5 = *(unsigned int *)(v4 + 16);
            if ((_DWORD)v5)
            {
              v6 = 16 * v5;
              v7 = *(llvm **)v4;
              while ((*((_QWORD *)v7 + 1) | 0x1000) == 0xFFFFFFFFFFFFF000)
              {
                v7 = (llvm *)((char *)v7 + 16);
                v6 -= 16;
                if (!v6)
                  goto LABEL_4;
              }
            }
            else
            {
              v7 = *(llvm **)v4;
            }
            v8 = *(_QWORD *)v4 + 16 * v5;
LABEL_16:
            if (v7 != (llvm *)v8)
            {
              (*(void (**)(_QWORD, _QWORD))(v2 + 32))(*(_QWORD *)(v2 + 40), *((_QWORD *)v7 + 1));
              while (1)
              {
                v7 = (llvm *)((char *)v7 + 16);
                if (v7 == (llvm *)v8)
                  break;
                if ((*((_QWORD *)v7 + 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
                  goto LABEL_16;
              }
            }
          }
LABEL_4:
          llvm::sys::RWMutexImpl::~RWMutexImpl((pthread_rwlock_t **)(v4 + 24));
          llvm::deallocate_buffer(*(llvm **)v4, (void *)(16 * *(unsigned int *)(v4 + 16)));
        }
        ++v3;
      }
      while (v3 != *(_QWORD *)(v2 + 24));
    }
    v9 = *(_QWORD *)(v2 + 16);
    *(_QWORD *)(v2 + 16) = 0;
    if (v9)
      MEMORY[0x20BD002D4](v9, 0x20C8093837F09);
    v10 = *(std::__shared_weak_count **)(v2 + 8);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    MEMORY[0x20BD002F8](v2, 0x10A0C40E20AF11ELL);
  }
  return a1;
}

uint64_t mlir::StorageUniquer::getSingletonImpl(uint64_t *a1, uint64_t a2)
{
  return mlir::detail::StorageUniquerImpl::getSingleton(*a1, a2);
}

uint64_t mlir::detail::StorageUniquerImpl::getSingleton(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  _QWORD *v23;
  int v24;
  BOOL v25;
  unsigned int v26;

  v6 = *(_QWORD *)(a1 + 232);
  v4 = a1 + 232;
  v5 = v6;
  v7 = *(_DWORD *)(v4 + 16);
  if (!v7)
    goto LABEL_22;
  v8 = v7 - 1;
  v9 = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v10 = (_QWORD *)(v5 + 16 * v9);
  v11 = *v10;
  if (*v10 == a2)
    return v10[1];
  v14 = 0;
  v15 = 1;
  while (v11 != -4096)
  {
    if (v14)
      v16 = 0;
    else
      v16 = v11 == -8192;
    if (v16)
      v14 = v10;
    v17 = v9 + v15++;
    v9 = v17 & v8;
    v10 = (_QWORD *)(v5 + 16 * (v17 & v8));
    v11 = *v10;
    if (*v10 == a2)
      return v10[1];
  }
  if (v14)
    v10 = v14;
  v18 = *(_DWORD *)(a1 + 240);
  if (4 * v18 + 4 < 3 * v7)
  {
    if (v7 + ~v18 - *(_DWORD *)(a1 + 244) > v7 >> 3)
      goto LABEL_6;
  }
  else
  {
LABEL_22:
    v7 *= 2;
  }
  llvm::DenseMap<mlir::Block *,llvm::SMLoc,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SMLoc>>::grow(v4, v7);
  v19 = *(_QWORD *)(a1 + 232);
  v20 = *(_DWORD *)(a1 + 248) - 1;
  v21 = v20 & ((a2 >> 4) ^ (a2 >> 9));
  v10 = (_QWORD *)(v19 + 16 * v21);
  v22 = *v10;
  if (*v10 == a2)
  {
    v13 = a2;
    goto LABEL_7;
  }
  v23 = 0;
  v24 = 1;
  while (v22 != -4096)
  {
    if (v23)
      v25 = 0;
    else
      v25 = v22 == -8192;
    if (v25)
      v23 = v10;
    v26 = v21 + v24++;
    v21 = v26 & v20;
    v10 = (_QWORD *)(v19 + 16 * (v26 & v20));
    v22 = *v10;
    v13 = a2;
    if (*v10 == a2)
      goto LABEL_7;
  }
  if (v23)
    v10 = v23;
LABEL_6:
  v13 = *v10;
LABEL_7:
  ++*(_DWORD *)(a1 + 240);
  if (v13 != -4096)
    --*(_DWORD *)(a1 + 244);
  *v10 = a2;
  v10[1] = 0;
  return v10[1];
}

_QWORD *mlir::StorageUniquer::registerSingletonImpl(uint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  BOOL v26;
  unsigned int v27;

  v5 = *a1;
  v6 = a3(a4, *a1 + 112);
  result = (_QWORD *)(v5 + 232);
  v8 = *(_QWORD *)(v5 + 232);
  v9 = *(_DWORD *)(v5 + 248);
  if (!v9)
    goto LABEL_23;
  v10 = (v9 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v11 = (_QWORD *)(v8 + 16 * v10);
  v12 = *v11;
  if (*v11 == a2)
    return result;
  v14 = 0;
  v15 = 1;
  while (v12 != -4096)
  {
    if (v14)
      v16 = 0;
    else
      v16 = v12 == -8192;
    if (v16)
      v14 = v11;
    v17 = v10 + v15++;
    v10 = v17 & (v9 - 1);
    v11 = (_QWORD *)(v8 + 16 * v10);
    v12 = *v11;
    if (*v11 == a2)
      return result;
  }
  v18 = v14 ? v14 : v11;
  v19 = *(_DWORD *)(v5 + 240);
  if (4 * v19 + 4 < 3 * v9)
  {
    if (v9 + ~v19 - *(_DWORD *)(v5 + 244) > v9 >> 3)
      goto LABEL_6;
  }
  else
  {
LABEL_23:
    v9 *= 2;
  }
  result = llvm::DenseMap<mlir::Block *,llvm::SMLoc,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SMLoc>>::grow((uint64_t)result, v9);
  v20 = *(_QWORD *)(v5 + 232);
  v21 = *(_DWORD *)(v5 + 248) - 1;
  v22 = v21 & ((a2 >> 4) ^ (a2 >> 9));
  v18 = (_QWORD *)(v20 + 16 * v22);
  v23 = *v18;
  if (*v18 == a2)
  {
    v13 = a2;
    goto LABEL_7;
  }
  v24 = 0;
  v25 = 1;
  while (v23 != -4096)
  {
    if (v24)
      v26 = 0;
    else
      v26 = v23 == -8192;
    if (v26)
      v24 = v18;
    v27 = v22 + v25++;
    v22 = v27 & v21;
    v18 = (_QWORD *)(v20 + 16 * (v27 & v21));
    v23 = *v18;
    v13 = a2;
    if (*v18 == a2)
      goto LABEL_7;
  }
  if (v24)
    v18 = v24;
LABEL_6:
  v13 = *v18;
LABEL_7:
  ++*(_DWORD *)(v5 + 240);
  if (v13 != -4096)
    --*(_DWORD *)(v5 + 244);
  *v18 = a2;
  v18[1] = v6;
  return result;
}

void std::__shared_ptr_emplace<mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::PerInstanceState,std::allocator<mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::PerInstanceState>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C05C758;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::PerInstanceState,std::allocator<mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::PerInstanceState>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C05C758;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_emplace<mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::PerInstanceState,std::allocator<mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::PerInstanceState>>::__on_zero_shared(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(a1 + 48));
  v2 = *(char **)(a1 + 24);
  v3 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(_QWORD *)&v5[v4];
      *(_QWORD *)&v5[v4] = 0;
      if (v6)
        MEMORY[0x20BD002F8](v6, 0x20C4093837F09);
      v4 -= 8;
    }
    while (v4);
    v2 = *(char **)(a1 + 24);
  }
  if (v2 != (char *)(a1 + 40))
    free(v2);
}

_QWORD *llvm::DenseMapBase<llvm::DenseMap<mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>>>,mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>>>::operator[](uint64_t a1, uint64_t *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  _QWORD *v20;
  int v21;
  BOOL v22;
  unsigned int v23;

  v4 = *(_DWORD *)(a1 + 16);
  v5 = *a2;
  if (!v4)
    goto LABEL_21;
  v6 = v4 - 1;
  v7 = ((v5 >> 4) ^ (v5 >> 9)) & (v4 - 1);
  v8 = (_QWORD *)(*(_QWORD *)a1 + 16 * v7);
  v9 = *v8;
  if (*v8 == v5)
    return v8 + 1;
  v12 = 0;
  v13 = 1;
  while (v9 != -4096)
  {
    if (v12)
      v14 = 0;
    else
      v14 = v9 == -8192;
    if (v14)
      v12 = v8;
    v15 = v7 + v13++;
    v7 = v15 & v6;
    v8 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v15 & v6));
    v9 = *v8;
    if (*v8 == v5)
      return v8 + 1;
  }
  if (v12)
    v8 = v12;
  v16 = *(_DWORD *)(a1 + 8);
  if (4 * v16 + 4 < 3 * v4)
  {
    if (v4 + ~v16 - *(_DWORD *)(a1 + 12) > v4 >> 3)
      goto LABEL_6;
  }
  else
  {
LABEL_21:
    v4 *= 2;
  }
  v5 = *a2;
  v17 = *(_DWORD *)(a1 + 16) - 1;
  v18 = ((*a2 >> 4) ^ (*a2 >> 9)) & v17;
  v8 = (_QWORD *)(*(_QWORD *)a1 + 16 * v18);
  v19 = *v8;
  if (*v8 == *a2)
  {
LABEL_23:
    ++*(_DWORD *)(a1 + 8);
    if (v5 == -4096)
      goto LABEL_8;
    goto LABEL_7;
  }
  v20 = 0;
  v21 = 1;
  while (v19 != -4096)
  {
    if (v20)
      v22 = 0;
    else
      v22 = v19 == -8192;
    if (v22)
      v20 = v8;
    v23 = v18 + v21++;
    v18 = v23 & v17;
    v8 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v23 & v17));
    v19 = *v8;
    if (*v8 == v5)
      goto LABEL_23;
  }
  if (v20)
    v8 = v20;
LABEL_6:
  v11 = *v8;
  ++*(_DWORD *)(a1 + 8);
  if (v11 != -4096)
LABEL_7:
    --*(_DWORD *)(a1 + 12);
LABEL_8:
  *v8 = v5;
  v8[1] = 0;
  return v8 + 1;
}

_QWORD *llvm::DenseMapBase<llvm::DenseMap<mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>>>,mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>,llvm::DenseMapInfo<mlir::TypeID,void>,llvm::detail::DenseMapPair<mlir::TypeID,std::unique_ptr<`anonymous namespace'::ParametricStorageUniquer>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  llvm *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  BOOL v30;
  unsigned int v31;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_10;
      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 2;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_10:
        v15 = &result[2 * v11];
        do
        {
          *v10 = -4096;
          v10 += 2;
        }
        while (v10 != v15);
      }
    }
    if ((_DWORD)v3)
    {
      v16 = v4;
      do
      {
        v24 = *(_QWORD *)v16;
        if ((*(_QWORD *)v16 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v25 = *(_DWORD *)(a1 + 16) - 1;
          v26 = v25 & ((v24 >> 4) ^ (v24 >> 9));
          v22 = (_QWORD *)(*(_QWORD *)a1 + 16 * v26);
          v27 = *v22;
          if (*v22 != v24)
          {
            v28 = 0;
            v29 = 1;
            while (v27 != -4096)
            {
              if (v28)
                v30 = 0;
              else
                v30 = v27 == -8192;
              if (v30)
                v28 = v22;
              v31 = v26 + v29++;
              v26 = v31 & v25;
              v22 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v31 & v25));
              v27 = *v22;
              if (*v22 == v24)
                goto LABEL_24;
            }
            if (v28)
              v22 = v28;
          }
LABEL_24:
          *v22 = v24;
          v23 = *((_QWORD *)v16 + 1);
          *((_QWORD *)v16 + 1) = 0;
          v22[1] = v23;
          ++*(_DWORD *)(a1 + 8);
        }
        v16 = (llvm *)((char *)v16 + 16);
      }
      while (v16 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v17 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v17)
  {
    if (((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_19;
    v18 = ((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[2 * (v18 & 0x1FFFFFFFFFFFFFFELL)];
    v19 = result + 2;
    v20 = v18 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v19 - 2) = -4096;
      *v19 = -4096;
      v19 += 4;
      v20 -= 2;
    }
    while (v20);
    if (v18 != (v18 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_19:
      v21 = &result[2 * v17];
      do
      {
        *v10 = -4096;
        v10 += 2;
      }
      while (v10 != v21);
    }
  }
  return result;
}

uint64_t llvm::detail::DenseSetImpl<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,llvm::DenseMap<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,llvm::detail::DenseSetEmpty,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo,llvm::detail::DenseSetPair<`anonymous namespace'::ParametricStorageUniquer::HashedStorage>>,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>::insert_as<`anonymous namespace'::ParametricStorageUniquer::LookupKey>(uint64_t result, uint64_t a2, __int128 *a3, uint64_t a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  llvm *v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  unsigned int v18;
  int v19;
  BOOL v20;
  char v21;
  uint64_t v22;
  llvm *v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  _OWORD *v30;
  unint64_t v31;
  _OWORD *v32;
  uint64_t v33;
  _OWORD *v34;
  llvm *v35;
  uint64_t v36;
  unint64_t v37;
  _OWORD *v38;
  unint64_t v39;
  _OWORD *v40;
  __n128 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  BOOL v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  int v54;
  unsigned int v55;
  uint64_t v56;
  BOOL v57;
  unsigned int v58;
  uint64_t v59;
  __int128 v60;

  v6 = result;
  v60 = *a3;
  v7 = *(_DWORD *)(a2 + 16);
  if (!v7)
  {
    v15 = 0;
LABEL_5:
    v16 = 2 * v15;
    goto LABEL_26;
  }
  v8 = 0;
  v9 = *(llvm **)a2;
  v10 = v7 - 1;
  v11 = 1;
  v12 = *(_DWORD *)a4 & (v7 - 1);
  v13 = *(_QWORD *)a2 + 16 * v12;
  v14 = *(_QWORD *)(v13 + 8);
  if ((v14 | 0x1000) == 0xFFFFFFFFFFFFF000)
    goto LABEL_15;
  while (1)
  {
    result = (*(uint64_t (**)(_QWORD))(a4 + 8))(*(_QWORD *)(a4 + 16));
    if ((result & 1) != 0)
    {
      v21 = 0;
      goto LABEL_25;
    }
    v14 = *(_QWORD *)(v13 + 8);
    if (v14 == -4096)
      break;
    while (1)
    {
      if (v8)
        v17 = 0;
      else
        v17 = v14 == -8192;
      if (v17)
        v8 = v13;
      v18 = v12 + v11++;
      v12 = v18 & v10;
      v13 = (uint64_t)v9 + 16 * (v18 & v10);
      v14 = *(_QWORD *)(v13 + 8);
      if ((v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        break;
LABEL_15:
      if (v14 == -4096)
        goto LABEL_16;
    }
  }
LABEL_16:
  if (v8)
    v13 = v8;
  v15 = *(_DWORD *)(a2 + 16);
  v19 = *(_DWORD *)(a2 + 8);
  if (4 * v19 + 4 >= 3 * v15)
    goto LABEL_5;
  v20 = v15 + ~v19 - *(_DWORD *)(a2 + 12) > v15 >> 3;
  v16 = *(_DWORD *)(a2 + 16);
  if (v20)
    goto LABEL_21;
LABEL_26:
  v23 = *(llvm **)a2;
  v24 = (v16 - 1) | ((unint64_t)(v16 - 1) >> 1);
  v25 = v24 | (v24 >> 2) | ((v24 | (v24 >> 2)) >> 4);
  v26 = ((v25 | (v25 >> 8)) >> 16) | v25 | (v25 >> 8);
  if ((v26 + 1) > 0x40)
    v27 = v26 + 1;
  else
    v27 = 64;
  *(_DWORD *)(a2 + 16) = v27;
  result = (uint64_t)llvm::allocate_buffer(16 * v27, (std::align_val_t)8uLL);
  *(_QWORD *)a2 = result;
  if (v23)
  {
    *(_QWORD *)(a2 + 8) = 0;
    v28 = *(unsigned int *)(a2 + 16);
    if ((_DWORD)v28)
    {
      v29 = (v28 - 1) & 0xFFFFFFFFFFFFFFFLL;
      v30 = (_OWORD *)result;
      if (v29 < 3)
        goto LABEL_35;
      v31 = v29 + 1;
      v30 = (_OWORD *)(result + 16 * (v31 & 0x1FFFFFFFFFFFFFFCLL));
      v32 = (_OWORD *)(result + 32);
      v33 = v31 & 0x1FFFFFFFFFFFFFFCLL;
      do
      {
        *(v32 - 2) = xmmword_207AB7400;
        *(v32 - 1) = xmmword_207AB7400;
        *v32 = xmmword_207AB7400;
        v32[1] = xmmword_207AB7400;
        v32 += 4;
        v33 -= 4;
      }
      while (v33);
      if (v31 != (v31 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        v34 = (_OWORD *)(result + 16 * v28);
        do
          *v30++ = xmmword_207AB7400;
        while (v30 != v34);
      }
    }
    if (v15)
    {
      v35 = v23;
      do
      {
        v44 = *((_QWORD *)v35 + 1);
        if ((v44 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v45 = *(_DWORD *)(a2 + 16) - 1;
          v46 = v45 & *(_DWORD *)v35;
          v43 = *(_QWORD *)a2 + 16 * v46;
          v47 = *(_QWORD *)(v43 + 8);
          if (v47 != v44)
          {
            v48 = 0;
            v49 = 1;
            while (v47 != -4096)
            {
              if (v48)
                v50 = 0;
              else
                v50 = v47 == -8192;
              if (v50)
                v48 = v43;
              v51 = v46 + v49++;
              v46 = v51 & v45;
              v43 = *(_QWORD *)a2 + 16 * (v51 & v45);
              v47 = *(_QWORD *)(v43 + 8);
              if (v47 == v44)
                goto LABEL_49;
            }
            if (v48)
              v43 = v48;
          }
LABEL_49:
          *(_OWORD *)v43 = *(_OWORD *)v35;
          ++*(_DWORD *)(a2 + 8);
        }
        v35 = (llvm *)((char *)v35 + 16);
      }
      while (v35 != (llvm *)((char *)v23 + 16 * v15));
    }
    llvm::deallocate_buffer(v23, (void *)(16 * v15));
  }
  *(_QWORD *)(a2 + 8) = 0;
  v36 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v36)
  {
    v37 = (v36 - 1) & 0xFFFFFFFFFFFFFFFLL;
    v38 = (_OWORD *)result;
    if (v37 < 3)
      goto LABEL_44;
    v39 = v37 + 1;
    v38 = (_OWORD *)(result + 16 * (v39 & 0x1FFFFFFFFFFFFFFCLL));
    v40 = (_OWORD *)(result + 32);
    v41 = (__n128)xmmword_207AB7400;
    v42 = v39 & 0x1FFFFFFFFFFFFFFCLL;
    do
    {
      *(v40 - 2) = xmmword_207AB7400;
      *(v40 - 1) = xmmword_207AB7400;
      *v40 = xmmword_207AB7400;
      v40[1] = xmmword_207AB7400;
      v40 += 4;
      v42 -= 4;
    }
    while (v42);
    if (v39 != (v39 & 0x1FFFFFFFFFFFFFFCLL))
    {
LABEL_44:
      v41 = (__n128)xmmword_207AB7400;
      do
        *v38++ = xmmword_207AB7400;
      while (v38 != (_OWORD *)(result + 16 * v36));
    }
    v52 = 0;
    v53 = v36 - 1;
    v54 = 1;
    v55 = *(_DWORD *)a4 & (v36 - 1);
    v13 = result + 16 * v55;
    v56 = *(_QWORD *)(v13 + 8);
    if ((v56 | 0x1000) == 0xFFFFFFFFFFFFF000)
      goto LABEL_75;
    while (1)
    {
      v59 = result;
      result = (*(uint64_t (**)(_QWORD, __n128))(a4 + 8))(*(_QWORD *)(a4 + 16), v41);
      if ((result & 1) != 0)
        break;
      v56 = *(_QWORD *)(v13 + 8);
      result = v59;
      if (v56 == -4096)
      {
LABEL_76:
        if (v52)
          v13 = v52;
        break;
      }
      while (1)
      {
        if (v52)
          v57 = 0;
        else
          v57 = v56 == -8192;
        if (v57)
          v52 = v13;
        v58 = v55 + v54++;
        v55 = v58 & v53;
        v13 = result + 16 * (v58 & v53);
        v56 = *(_QWORD *)(v13 + 8);
        if ((v56 | 0x1000) != 0xFFFFFFFFFFFFF000)
          break;
LABEL_75:
        if (v56 == -4096)
          goto LABEL_76;
      }
    }
  }
  else
  {
    v13 = 0;
  }
LABEL_21:
  ++*(_DWORD *)(a2 + 8);
  if (*(_QWORD *)(v13 + 8) != -4096)
    --*(_DWORD *)(a2 + 12);
  *(_OWORD *)v13 = v60;
  v21 = 1;
LABEL_25:
  v22 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)v6 = v13;
  *(_QWORD *)(v6 + 8) = v22;
  *(_BYTE *)(v6 + 16) = v21;
  return result;
}

int *mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::CacheType::~CacheType(int *a1)
{
  int v2;
  int *v3;
  int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  std::recursive_mutex *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  int *v28;
  uint64_t v29;
  _QWORD *v30;
  unsigned int v31;
  uint64_t v32;
  std::__shared_weak_count **v33;
  uint64_t v34;
  _QWORD *v36;

  v2 = *a1;
  if (*a1 > 1)
  {
    v4 = a1 + 2;
    if ((v2 & 1) == 0)
    {
      v6 = a1[4];
      v7 = *((_QWORD *)a1 + 1) + 24 * v6;
      if (v6)
      {
        v4 = (int *)*((_QWORD *)a1 + 1);
        goto LABEL_8;
      }
      v36 = a1 + 2;
LABEL_13:
      if ((v2 & 1) != 0)
        goto LABEL_50;
      goto LABEL_14;
    }
    v7 = (uint64_t)(a1 + 26);
LABEL_8:
    while ((*(_QWORD *)v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v4 += 6;
      if (v4 == (int *)v7)
      {
        v4 = (int *)v7;
        break;
      }
    }
    v36 = a1 + 2;
    if ((v2 & 1) == 0)
    {
LABEL_18:
      v8 = *((_QWORD *)a1 + 1) + 24 * a1[4];
      if (v4 != (int *)v8)
        goto LABEL_22;
      goto LABEL_13;
    }
  }
  else
  {
    if (v2)
    {
      v3 = a1 + 2;
      v4 = a1 + 26;
      v5 = 4;
    }
    else
    {
      v3 = (int *)*((_QWORD *)a1 + 1);
      v5 = a1[4];
      v4 = &v3[6 * v5];
    }
    v7 = (uint64_t)&v3[6 * v5];
    v36 = a1 + 2;
    if (!v2)
      goto LABEL_18;
  }
  v8 = (uint64_t)(a1 + 26);
  if (v4 == a1 + 26)
    goto LABEL_13;
  do
  {
LABEL_22:
    v11 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
    if (!v11)
      goto LABEL_37;
    v12 = std::__shared_weak_count::lock(v11);
    if (!v12)
      goto LABEL_37;
    v13 = v12;
    v14 = *((_QWORD *)v4 + 1);
    if (v14)
    {
      v15 = *(_QWORD *)v4;
      v16 = (std::recursive_mutex *)(*(_QWORD *)v4 + 24);
      std::recursive_mutex::lock(v16);
      v17 = *(_QWORD **)v15;
      v18 = *(unsigned int *)(v15 + 8);
      v19 = *(_QWORD *)v15 + 8 * v18;
      v20 = *(_QWORD **)v15;
      if ((_DWORD)v18)
      {
        v21 = 8 * v18;
        v20 = *(_QWORD **)v15;
        while (*v20 != v14)
        {
          ++v20;
          v21 -= 8;
          if (!v21)
          {
            v20 = (_QWORD *)(*(_QWORD *)v15 + 8 * v18);
            break;
          }
        }
      }
      v22 = v20 + 1;
      if (v20 + 1 == (_QWORD *)v19)
      {
        v23 = v18 - 1;
        *(_DWORD *)(v15 + 8) = v23;
        v24 = v23;
        v25 = v17[v24];
        v17[v24] = 0;
        if (v25)
          goto LABEL_32;
      }
      else
      {
        do
        {
          v29 = *(v22 - 1);
          *(v22 - 1) = *v22;
          *v22 = 0;
          if (v29)
            llvm::deallocate_buffer(*(llvm **)v29, (void *)(16 * *(unsigned int *)(v29 + 16)));
          ++v22;
        }
        while (v22 != (_QWORD *)v19);
        v30 = *(_QWORD **)v15;
        v31 = *(_DWORD *)(v15 + 8) - 1;
        *(_DWORD *)(v15 + 8) = v31;
        v32 = v31;
        v25 = v30[v32];
        v30[v32] = 0;
        if (v25)
LABEL_32:
          llvm::deallocate_buffer(*(llvm **)v25, (void *)(16 * *(unsigned int *)(v25 + 16)));
      }
      std::recursive_mutex::unlock(v16);
    }
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v27 = __ldaxr(p_shared_owners);
    while (__stlxr(v27 - 1, p_shared_owners));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      v28 = v4 + 6;
      v4 = (int *)v7;
      if (v28 == (int *)v7)
        continue;
    }
    else
    {
LABEL_37:
      v28 = v4 + 6;
      v4 = (int *)v7;
      if (v28 == (int *)v7)
        continue;
    }
    v4 = v28;
    while ((*(_QWORD *)v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v4 += 6;
      if (v4 == (int *)v7)
      {
        v4 = (int *)v7;
        break;
      }
    }
  }
  while (v4 != (int *)v8);
  v2 = *a1;
  if ((*a1 & 1) != 0)
  {
LABEL_50:
    v9 = 4;
    v10 = v36;
    goto LABEL_51;
  }
LABEL_14:
  v9 = a1[4];
  if ((_DWORD)v9)
  {
    v10 = (_QWORD *)*v36;
LABEL_51:
    v33 = (std::__shared_weak_count **)(v10 + 2);
    v34 = 24 * v9;
    do
    {
      if (((unint64_t)*(v33 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v33)
        std::__shared_weak_count::__release_weak(*v33);
      v33 += 3;
      v34 -= 24;
    }
    while (v34);
    v2 = *a1;
  }
  if ((v2 & 1) == 0)
    llvm::deallocate_buffer(*((llvm **)a1 + 1), (void *)(24 * a1[4]));
  return a1;
}

void llvm::DenseMapBase<llvm::SmallDenseMap<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState *,std::weak_ptr<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>,4u,llvm::DenseMapInfo<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState *,void>,llvm::detail::DenseMapPair<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState *,std::weak_ptr<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>>>,mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState *,std::weak_ptr<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>,llvm::DenseMapInfo<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState *,void>,llvm::detail::DenseMapPair<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState *,std::weak_ptr<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>>>::moveFromOldBuckets(int *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  int v6;
  int *v7;
  int v8;
  char *v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t *v23;
  int v24;
  BOOL v25;
  unsigned int v26;

  v4 = a2;
  v6 = *a1;
  *(_QWORD *)a1 = *a1 & 1;
  v7 = a1 + 2;
  if ((v6 & 1) != 0)
  {
    v10 = (char *)(a1 + 26);
    v9 = (char *)(a1 + 2);
    v11 = 72;
  }
  else
  {
    v8 = a1[4];
    if (!v8)
      goto LABEL_11;
    v9 = (char *)*((_QWORD *)a1 + 1);
    v10 = &v9[24 * v8];
    v11 = v10 - v9 - 24;
    if (v11 < 0x18)
    {
      v13 = (char *)*((_QWORD *)a1 + 1);
      do
      {
LABEL_10:
        *(_QWORD *)v13 = -4096;
        v13 += 24;
      }
      while (v13 != v10);
      goto LABEL_11;
    }
  }
  v12 = v11 / 0x18 + 1;
  v13 = &v9[24 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
  v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
  do
  {
    *(_QWORD *)v9 = -4096;
    *((_QWORD *)v9 + 3) = -4096;
    v9 += 48;
    v14 -= 2;
  }
  while (v14);
  if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
    goto LABEL_10;
LABEL_11:
  if (a2 != a3)
  {
    do
    {
      v15 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        if ((*(_BYTE *)a1 & 1) != 0)
        {
          v17 = 4;
          v16 = v7;
        }
        else
        {
          v16 = (int *)*((_QWORD *)a1 + 1);
          v17 = a1[4];
        }
        v18 = v17 - 1;
        v19 = (v17 - 1) & ((v15 >> 4) ^ (v15 >> 9));
        v20 = (uint64_t *)&v16[6 * v19];
        v21 = *v20;
        if (*v20 != v15)
        {
          v23 = 0;
          v24 = 1;
          while (v21 != -4096)
          {
            if (v23)
              v25 = 0;
            else
              v25 = v21 == -8192;
            if (v25)
              v23 = v20;
            v26 = v19 + v24++;
            v19 = v26 & v18;
            v20 = (uint64_t *)&v16[6 * (v26 & v18)];
            v21 = *v20;
            if (*v20 == v15)
              goto LABEL_19;
          }
          if (v23)
            v20 = v23;
        }
LABEL_19:
        *v20 = v15;
        *(_OWORD *)(v20 + 1) = *(_OWORD *)(v4 + 1);
        v4[1] = 0;
        v4[2] = 0;
        *a1 += 2;
        v22 = (std::__shared_weak_count *)v4[2];
        if (v22)
          std::__shared_weak_count::__release_weak(v22);
      }
      v4 += 3;
    }
    while (v4 != a3);
  }
}

void llvm::SmallVectorTemplateBase<std::unique_ptr<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>,false>::grow(uint64_t a1, unint64_t a2)
{
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  __int128 *v14;
  _OWORD *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unint64_t v24;

  v24 = 0;
  v3 = (char *)(a1 + 16);
  v4 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 8, &v24);
  v5 = *(char **)a1;
  v6 = *(char **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v7)
    goto LABEL_19;
  v8 = (v7 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  v9 = 8 * v7;
  if (v8 < 0xB)
  {
    v10 = v4;
LABEL_12:
    v19 = &v5[8 * v7];
    do
    {
      v20 = *(_QWORD *)v6;
      *(_QWORD *)v6 = 0;
      v6 += 8;
      *(_QWORD *)v10 = v20;
      v10 += 8;
    }
    while (v6 != v19);
    goto LABEL_14;
  }
  v11 = v5 >= &v4[v9] || v4 >= &v5[v9];
  v10 = v4;
  if (!v11)
    goto LABEL_12;
  v12 = v8 + 1;
  v13 = 8 * (v12 & 0x3FFFFFFFFFFFFFFCLL);
  v10 = &v4[v13];
  v6 = &v5[v13];
  v14 = (__int128 *)(v5 + 16);
  v15 = v4 + 16;
  v16 = v12 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v17 = *(v14 - 1);
    v18 = *v14;
    *(v14 - 1) = 0uLL;
    *v14 = 0uLL;
    *(v15 - 1) = v17;
    *v15 = v18;
    v14 += 2;
    v15 += 2;
    v16 -= 4;
  }
  while (v16);
  if (v12 != (v12 & 0x3FFFFFFFFFFFFFFCLL))
    goto LABEL_12;
LABEL_14:
  v21 = *(_QWORD *)a1 - 8;
  do
  {
    v22 = *(_QWORD *)(v21 + v9);
    *(_QWORD *)(v21 + v9) = 0;
    if (v22)
      llvm::deallocate_buffer(*(llvm **)v22, (void *)(16 * *(unsigned int *)(v22 + 16)));
    v9 -= 8;
  }
  while (v9);
  v6 = *(char **)a1;
LABEL_19:
  v23 = v24;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v4;
  *(_DWORD *)(a1 + 12) = v23;
}

uint64_t mlir::detail::StorageUniquerImpl::getThreadSafeAllocator(mlir::detail::StorageUniquerImpl *this)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!*((_BYTE *)this + 256))
    return (uint64_t)this + 112;
  v2 = mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::get((uint64_t *)this);
  result = *(_QWORD *)v2;
  if (!*(_QWORD *)v2)
  {
    v4 = operator new();
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_QWORD *)(v4 + 16) = v4 + 32;
    *(_DWORD *)(v4 + 28) = 4;
    *(_QWORD *)(v4 + 80) = 0;
    *(_QWORD *)(v4 + 64) = v4 + 80;
    *(_QWORD *)(v4 + 72) = 0;
    *(_QWORD *)(v4 + 88) = 1;
    *(_QWORD *)v2 = v4;
    std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 40));
    v5 = *(_QWORD *)v2;
    v10 = *(_QWORD *)v2;
    v6 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v6 >= *((_QWORD *)this + 4))
    {
      v7 = std::vector<std::unique_ptr<mlir::StorageUniquer::StorageAllocator>>::__push_back_slow_path<std::unique_ptr<mlir::StorageUniquer::StorageAllocator>>((_QWORD *)this + 2, &v10);
      v8 = v10;
      *((_QWORD *)this + 3) = v7;
      v10 = 0;
      if (v8)
      {
        v9 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v8);
        MEMORY[0x20BD002F8](v9, 0x1090C40A49D047FLL);
      }
    }
    else
    {
      *v6 = v5;
      *((_QWORD *)this + 3) = v6 + 1;
    }
    std::recursive_mutex::unlock((std::recursive_mutex *)((char *)this + 40));
    return *(_QWORD *)v2;
  }
  return result;
}

uint64_t mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::get(uint64_t *a1)
{
  uint64_t (*v2)(_QWORD);
  uint64_t v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  _QWORD *v18;
  std::recursive_mutex *v19;
  uint64_t v20;
  _QWORD *v21;
  char *Address;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *p_shared_weak_owners;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  _QWORD *v37;
  _QWORD *v38;
  int v39;
  BOOL v40;
  unsigned int v41;
  _QWORD *v42;

  {
    v37 = (_QWORD *)mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::getStaticCache(void)::cache(&mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::getStaticCache(void)::cache);
    *v37 = 1;
    v37[1] = -4096;
    v37[4] = -4096;
    v37[7] = -4096;
    v37[10] = -4096;
    _tlv_atexit((void (__cdecl *)(void *))mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::CacheType::~CacheType, v37);
  }
  v3 = mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::getStaticCache(void)::cache(&mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::getStaticCache(void)::cache);
  v4 = (int *)v3;
  v5 = *a1;
  v42 = (_QWORD *)*a1;
  v6 = v3 + 8;
  if ((*(_BYTE *)v3 & 1) != 0)
  {
    v7 = 4;
  }
  else
  {
    v7 = *(_DWORD *)(v3 + 16);
    if (!v7)
    {
      v18 = 0;
LABEL_16:
      v10 = llvm::DenseMapBase<llvm::SmallDenseMap<mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *,std::weak_ptr<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>,4u,llvm::DenseMapInfo<mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *,void>,llvm::detail::DenseMapPair<mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *,std::weak_ptr<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>>>,mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *,std::weak_ptr<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>,llvm::DenseMapInfo<mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *,void>,llvm::detail::DenseMapPair<mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *,std::weak_ptr<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>>>::InsertIntoBucket<mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::PerInstanceState *>(v3, v18, (uint64_t *)&v42);
      goto LABEL_8;
    }
    v6 = *(_QWORD *)(v3 + 8);
  }
  v8 = v7 - 1;
  v9 = v8 & ((v5 >> 4) ^ (v5 >> 9));
  v10 = (_QWORD *)(v6 + 24 * v9);
  v11 = *v10;
  if (v5 != *v10)
  {
    v38 = 0;
    v39 = 1;
    while (v11 != -4096)
    {
      if (v38)
        v40 = 0;
      else
        v40 = v11 == -8192;
      if (v40)
        v38 = v10;
      v41 = v9 + v39++;
      v9 = v41 & v8;
      v10 = (_QWORD *)(v6 + 24 * v9);
      v11 = *v10;
      if (v5 == *v10)
        goto LABEL_8;
    }
    if (v38)
      v18 = v38;
    else
      v18 = v10;
    goto LABEL_16;
  }
LABEL_8:
  v12 = (std::__shared_weak_count *)v10[2];
  if (v12)
  {
    v13 = std::__shared_weak_count::lock(v12);
    if (v13)
    {
      v14 = v13;
      v15 = v10[1];
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (v17)
      {
        if (v15)
          return v15;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v14);
        if (v15)
          return v15;
      }
    }
  }
  v19 = (std::recursive_mutex *)(*a1 + 24);
  std::recursive_mutex::lock(v19);
  v20 = *a1;
  v21 = (_QWORD *)operator new();
  *v21 = 0;
  v42 = v21;
  Address = llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::StorageUniquer::StorageAllocator *>,false>::reserveForParamAndGetAddress(v20, (unint64_t)&v42, 1);
  v23 = *(_QWORD *)v20;
  v24 = *(unsigned int *)(v20 + 8);
  v25 = *(_QWORD *)Address;
  *(_QWORD *)Address = 0;
  *(_QWORD *)(v23 + 8 * v24) = v25;
  *(_DWORD *)(v20 + 8) = v24 + 1;
  v26 = (uint64_t)v42;
  v42 = 0;
  if (v26)
    MEMORY[0x20BD002F8](v26, 0x20C4093837F09);
  v27 = *a1;
  v28 = (std::__shared_weak_count *)a1[1];
  v15 = *(_QWORD *)(*(_QWORD *)v27 + 8 * *(unsigned int *)(v27 + 8) - 8);
  if (v28)
  {
    v29 = (unint64_t *)&v28->__shared_owners_;
    do
      v30 = __ldxr(v29);
    while (__stxr(v30 + 1, v29));
    p_shared_weak_owners = (unint64_t *)&v28->__shared_weak_owners_;
    do
      v32 = __ldxr(p_shared_weak_owners);
    while (__stxr(v32 + 1, p_shared_weak_owners));
  }
  v33 = (std::__shared_weak_count *)v10[2];
  v10[1] = v15;
  v10[2] = v28;
  if (v33)
    std::__shared_weak_count::__release_weak(v33);
  if (v28)
  {
    v34 = (unint64_t *)&v28->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  mlir::ThreadLocalCache<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>>::CacheType::clearExpiredEntries(v4);
  std::recursive_mutex::unlock(v19);
  return v15;
}

int *mlir::ThreadLocalCache<mlir::StorageUniquer::StorageAllocator *>::CacheType::~CacheType(int *a1)
{
  int v2;
  int *v3;
  int *v4;
  unsigned int v5;
  _QWORD *v6;
  unsigned int v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  std::recursive_mutex *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  int *v28;
  uint64_t v29;
  _QWORD *v30;
  unsigned int v31;
  uint64_t v32;
  std::__shared_weak_count **v33;
  uint64_t v34;

  v2 = *a1;
  if (*a1 > 1)
  {
    v6 = a1 + 2;
    if ((v2 & 1) == 0)
    {
      v4 = (int *)*((_QWORD *)a1 + 1);
      v7 = a1[4];
      v8 = &v4[6 * v7];
      if (v7)
        goto LABEL_8;
      goto LABEL_18;
    }
    v8 = a1 + 26;
    v4 = a1 + 2;
LABEL_8:
    while ((*(_QWORD *)v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v4 += 6;
      if (v4 == v8)
      {
        v4 = v8;
        break;
      }
    }
    v6 = a1 + 2;
    if ((v2 & 1) == 0)
      goto LABEL_18;
  }
  else
  {
    if (v2)
    {
      v3 = a1 + 2;
      v4 = a1 + 26;
      v5 = 4;
    }
    else
    {
      v3 = (int *)*((_QWORD *)a1 + 1);
      v5 = a1[4];
      v4 = &v3[6 * v5];
    }
    v8 = &v3[6 * v5];
    v6 = a1 + 2;
    if (!v2)
    {
LABEL_18:
      v9 = *((_QWORD *)a1 + 1) + 24 * a1[4];
      if (v4 != (int *)v9)
        goto LABEL_21;
LABEL_13:
      if ((v2 & 1) != 0)
        goto LABEL_49;
      goto LABEL_14;
    }
  }
  v9 = (uint64_t)(a1 + 26);
  if (v4 == a1 + 26)
    goto LABEL_13;
  do
  {
LABEL_21:
    v11 = (std::__shared_weak_count *)*((_QWORD *)v4 + 2);
    if (!v11)
      goto LABEL_36;
    v12 = std::__shared_weak_count::lock(v11);
    if (!v12)
      goto LABEL_36;
    v13 = v12;
    v14 = *((_QWORD *)v4 + 1);
    if (v14)
    {
      v15 = *(_QWORD *)v4;
      v16 = (std::recursive_mutex *)(*(_QWORD *)v4 + 24);
      std::recursive_mutex::lock(v16);
      v17 = *(_QWORD **)v15;
      v18 = *(unsigned int *)(v15 + 8);
      v19 = *(_QWORD *)v15 + 8 * v18;
      v20 = *(_QWORD **)v15;
      if ((_DWORD)v18)
      {
        v21 = 8 * v18;
        v20 = *(_QWORD **)v15;
        while (*v20 != v14)
        {
          ++v20;
          v21 -= 8;
          if (!v21)
          {
            v20 = (_QWORD *)(*(_QWORD *)v15 + 8 * v18);
            break;
          }
        }
      }
      v22 = v20 + 1;
      if (v20 + 1 == (_QWORD *)v19)
      {
        v23 = v18 - 1;
        *(_DWORD *)(v15 + 8) = v23;
        v24 = v23;
        v25 = v17[v24];
        v17[v24] = 0;
        if (!v25)
        {
LABEL_32:
          std::recursive_mutex::unlock(v16);
          goto LABEL_33;
        }
      }
      else
      {
        do
        {
          v29 = *(v22 - 1);
          *(v22 - 1) = *v22;
          *v22 = 0;
          if (v29)
            MEMORY[0x20BD002F8](v29, 0x20C4093837F09);
          ++v22;
        }
        while (v22 != (_QWORD *)v19);
        v30 = *(_QWORD **)v15;
        v31 = *(_DWORD *)(v15 + 8) - 1;
        *(_DWORD *)(v15 + 8) = v31;
        v32 = v31;
        v25 = v30[v32];
        v30[v32] = 0;
        if (!v25)
          goto LABEL_32;
      }
      MEMORY[0x20BD002F8](v25, 0x20C4093837F09);
      goto LABEL_32;
    }
LABEL_33:
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v27 = __ldaxr(p_shared_owners);
    while (__stlxr(v27 - 1, p_shared_owners));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      v28 = v4 + 6;
      v4 = v8;
      if (v28 == v8)
        continue;
      goto LABEL_37;
    }
LABEL_36:
    v28 = v4 + 6;
    v4 = v8;
    if (v28 == v8)
      continue;
LABEL_37:
    v4 = v28;
    while ((*(_QWORD *)v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v4 += 6;
      if (v4 == v8)
      {
        v4 = v8;
        break;
      }
    }
  }
  while (v4 != (int *)v9);
  v2 = *a1;
  if ((*a1 & 1) != 0)
  {
LABEL_49:
    v10 = 4;
    goto LABEL_50;
  }
LABEL_14:
  v10 = a1[4];
  if ((_DWORD)v10)
  {
    v6 = (_QWORD *)*v6;
LABEL_50:
    v33 = (std::__shared_weak_count **)(v6 + 2);
    v34 = 24 * v10;
    do
    {
      if (((unint64_t)*(v33 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v33)
        std::__shared_weak_count::__release_weak(*v33);
      v33 += 3;
      v34 -= 24;
    }
    while (v34);
    v2 = *a1;
  }
  if ((v2 & 1) == 0)
    llvm::deallocate_buffer(*((llvm **)a1 + 1), (void *)(24 * a1[4]));
  return a1;
}

char *llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::StorageUniquer::StorageAllocator *>,false>::reserveForParamAndGetAddress(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  __int128 *v20;
  _OWORD *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  __int128 *v41;
  _OWORD *v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  unint64_t v52;

  v3 = a2;
  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4 + a3;
  if (v5 <= *(unsigned int *)(a1 + 12))
    return (char *)v3;
  v8 = *(_QWORD *)a1 + 8 * v4;
  if (*(_QWORD *)a1 > a2 || v8 <= a2)
  {
    v52 = 0;
    v10 = (char *)(a1 + 16);
    v11 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 8, &v52);
    v12 = *(char **)a1;
    v13 = *(unsigned int *)(a1 + 8);
    if (!(_DWORD)v13)
    {
LABEL_22:
      v29 = v52;
      if (v12 != v10)
        free(v12);
      *(_QWORD *)a1 = v11;
      *(_DWORD *)(a1 + 12) = v29;
      return (char *)v3;
    }
    v14 = (v13 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    v15 = 8 * v13;
    if (v14 >= 0xB)
    {
      if (v12 >= &v11[v15] || (v16 = v11, v17 = *(char **)a1, v11 >= &v12[v15]))
      {
        v18 = v14 + 1;
        v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
        v16 = &v11[v19];
        v17 = &v12[v19];
        v20 = (__int128 *)(v12 + 16);
        v21 = v11 + 16;
        v22 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v23 = *(v20 - 1);
          v24 = *v20;
          *(v20 - 1) = 0uLL;
          *v20 = 0uLL;
          *(v21 - 1) = v23;
          *v21 = v24;
          v20 += 2;
          v21 += 2;
          v22 -= 4;
        }
        while (v22);
        if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_17:
          v27 = *(_QWORD *)a1 - 8;
          do
          {
            v28 = *(_QWORD *)(v27 + v15);
            *(_QWORD *)(v27 + v15) = 0;
            if (v28)
              MEMORY[0x20BD002F8](v28, 0x20C4093837F09);
            v15 -= 8;
          }
          while (v15);
          v12 = *(char **)a1;
          goto LABEL_22;
        }
      }
    }
    else
    {
      v16 = v11;
      v17 = *(char **)a1;
    }
    v25 = &v12[8 * v13];
    do
    {
      v26 = *(_QWORD *)v17;
      *(_QWORD *)v17 = 0;
      v17 += 8;
      *(_QWORD *)v16 = v26;
      v16 += 8;
    }
    while (v17 != v25);
    goto LABEL_17;
  }
  v30 = a2 - *(_QWORD *)a1;
  v52 = 0;
  v31 = (char *)(a1 + 16);
  v32 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 8, &v52);
  v33 = *(char **)a1;
  v34 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v34)
  {
    v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    v36 = 8 * v34;
    if (v35 >= 0xB)
    {
      if (v33 >= &v32[v36] || (v37 = v32, v38 = *(char **)a1, v32 >= &v33[v36]))
      {
        v39 = v35 + 1;
        v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
        v37 = &v32[v40];
        v38 = &v33[v40];
        v41 = (__int128 *)(v33 + 16);
        v42 = v32 + 16;
        v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v44 = *(v41 - 1);
          v45 = *v41;
          *(v41 - 1) = 0uLL;
          *v41 = 0uLL;
          *(v42 - 1) = v44;
          *v42 = v45;
          v41 += 2;
          v42 += 2;
          v43 -= 4;
        }
        while (v43);
        if (v39 == (v39 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_35:
          v48 = *(_QWORD *)a1 - 8;
          do
          {
            v49 = *(_QWORD *)(v48 + v36);
            *(_QWORD *)(v48 + v36) = 0;
            if (v49)
              MEMORY[0x20BD002F8](v49, 0x20C4093837F09);
            v36 -= 8;
          }
          while (v36);
          v33 = *(char **)a1;
          goto LABEL_40;
        }
      }
    }
    else
    {
      v37 = v32;
      v38 = *(char **)a1;
    }
    v46 = &v33[8 * v34];
    do
    {
      v47 = *(_QWORD *)v38;
      *(_QWORD *)v38 = 0;
      v38 += 8;
      *(_QWORD *)v37 = v47;
      v37 += 8;
    }
    while (v38 != v46);
    goto LABEL_35;
  }
LABEL_40:
  v50 = v30 >> 3;
  v51 = v52;
  if (v33 != v31)
    free(v33);
  *(_QWORD *)a1 = v32;
  *(_DWORD *)(a1 + 12) = v51;
  return &v32[8 * v50];
}

_QWORD *std::vector<std::unique_ptr<mlir::StorageUniquer::StorageAllocator>>::__push_back_slow_path<std::unique_ptr<mlir::StorageUniquer::StorageAllocator>>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v2 = a1[1] - *a1;
  v3 = v2 >> 3;
  v4 = (v2 >> 3) + 1;
  if (v4 >> 61)
    abort();
  v7 = a1[2] - *a1;
  if (v7 >> 2 > v4)
    v4 = v7 >> 2;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
    v8 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v8 = v4;
  if (v8)
  {
    if (v8 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v9 = (char *)operator new(8 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = &v9[8 * v3];
  v11 = &v9[8 * v8];
  v12 = *a2;
  *a2 = 0;
  *(_QWORD *)v10 = v12;
  v13 = v10 + 8;
  v14 = (char *)*a1;
  v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
      goto LABEL_31;
    v17 = (v16 >> 3) + 1;
    v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    v19 = &v15[-v18];
    v10 -= v18;
    v20 = &v9[8 * v3 - 16];
    v21 = v15 - 16;
    v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v24 = *((_OWORD *)v21 - 1);
      v23 = *(_OWORD *)v21;
      *((_OWORD *)v21 - 1) = 0uLL;
      *(_OWORD *)v21 = 0uLL;
      *((_OWORD *)v20 - 1) = v24;
      *(_OWORD *)v20 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        v25 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *(_QWORD *)v15 = 0;
        *((_QWORD *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    v15 = (char *)*a1;
    v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      v28 = *((_QWORD *)v26 - 1);
      v26 -= 8;
      v27 = v28;
      *(_QWORD *)v26 = 0;
      if (v28)
      {
        v29 = llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v27);
        MEMORY[0x20BD002F8](v29, 0x1090C40A49D047FLL);
      }
    }
  }
  if (v15)
    operator delete(v15);
  return v13;
}

void mlir::detail::StorageUniquerImpl::~StorageUniquerImpl(llvm **this)
{
  llvm::deallocate_buffer(this[29], (void *)(16 * *((unsigned int *)this + 62)));
}

void std::__shared_ptr_emplace<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState,std::allocator<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C720;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState,std::allocator<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24C05C720;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD002F8);
}

void std::__shared_ptr_emplace<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState,std::allocator<mlir::ThreadLocalCache<llvm::DenseSet<`anonymous namespace'::ParametricStorageUniquer::HashedStorage,`anonymous namespace'::ParametricStorageUniquer::StorageKeyInfo>>::PerInstanceState>>::__on_zero_shared(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(a1 + 48));
  v2 = *(char **)(a1 + 24);
  v3 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(_QWORD *)&v5[v4];
      *(_QWORD *)&v5[v4] = 0;
      if (v6)
        llvm::deallocate_buffer(*(llvm **)v6, (void *)(16 * *(unsigned int *)(v6 + 16)));
      v4 -= 8;
    }
    while (v4);
    v2 = *(char **)(a1 + 24);
  }
  if (v2 != (char *)(a1 + 40))
    free(v2);
}

unint64_t mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v3;
  uint64_t v4;
  unint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  uint64_t v9;
  void *buffer;
  unsigned int v11;
  void *v12;
  uint64_t v13;
  int v14;
  __int128 v15;
  _QWORD *v16;

  v3 = atomic_load((unsigned __int8 *)&_MergedGlobals_0);
  if ((v3 & 1) == 0)
  {
    v13 = a1;
    v14 = __cxa_guard_acquire(&_MergedGlobals_0);
    a1 = v13;
    if (v14)
    {
      llvm::sys::RWMutexImpl::RWMutexImpl((llvm::sys::RWMutexImpl *)&qword_253EA0E98);
      qword_253EA0EA0 = 0;
      qword_253EA0EA8 = 0;
      qword_253EA0EB0 = 0;
      qword_253EA0EB8 = (uint64_t)&unk_253EA0EC8;
      qword_253EA0EC0 = *(_QWORD *)"";
      qword_253EA0EE8 = (uint64_t)&qword_253EA0EF8;
      unk_253EA0EF0 = 0u;
      unk_253EA0F00 = 0u;
      *(_OWORD *)((char *)&qword_253EA0F08 + 4) = 0u;
      __cxa_guard_release(&_MergedGlobals_0);
      a1 = v13;
    }
  }
  *(_QWORD *)&v15 = a1;
  *((_QWORD *)&v15 + 1) = a2;
  llvm::sys::RWMutexImpl::lock_shared(&qword_253EA0E98);
  v16 = 0;
  if (!llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>>>,llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>>>::LookupBucketFor<llvm::StringRef>(&qword_253EA0F08, (uint64_t)&v15, &v16)|| v16 == (_QWORD *)(qword_253EA0F08 + 24 * dword_253EA0F18))
  {
    llvm::sys::RWMutexImpl::unlock_shared(&qword_253EA0E98);
    llvm::sys::RWMutexImpl::lock(&qword_253EA0E98);
    v16 = 0;
    if (llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>>>,llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,std::unique_ptr<mlir::AsmResourceParser>>>::LookupBucketFor<llvm::StringRef>(&qword_253EA0F08, (uint64_t)&v15, &v16))
    {
      v6 = v16[2];
    }
    else
    {
      v7 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::ScopedHashTableVal<llvm::StringRef,char> *,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,llvm::ScopedHashTableVal<llvm::StringRef,char> *>>,llvm::StringRef,llvm::ScopedHashTableVal<llvm::StringRef,char> *,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseMapPair<llvm::StringRef,llvm::ScopedHashTableVal<llvm::StringRef,char> *>>::InsertIntoBucketImpl<llvm::StringRef>((uint64_t)&qword_253EA0F08, (uint64_t)&v15, (uint64_t)&v15, v16);
      *(_OWORD *)v7 = v15;
      v7[2] = &mlir::detail::TypeIDResolver<void,void>::id;
      qword_253EA0EF8 += 8;
      if (qword_253EA0EA8
        && ((qword_253EA0EA8 + 7) & 0xFFFFFFFFFFFFFFF8) - qword_253EA0EA8 + 8 <= qword_253EA0EB0 - qword_253EA0EA8)
      {
        v6 = (qword_253EA0EA8 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      else
      {
        v8 = qword_253EA0EC0 >> 7;
        if (qword_253EA0EC0 >> 7 >= 0x1E)
          LOBYTE(v8) = 30;
        v9 = 4096 << v8;
        buffer = llvm::allocate_buffer(4096 << v8, (std::align_val_t)8uLL);
        v11 = qword_253EA0EC0;
        if (qword_253EA0EC0 >= HIDWORD(qword_253EA0EC0))
        {
          v12 = buffer;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&qword_253EA0EB8, &unk_253EA0EC8, qword_253EA0EC0 + 1, 8);
          buffer = v12;
          v11 = qword_253EA0EC0;
        }
        *(_QWORD *)(qword_253EA0EB8 + 8 * v11) = buffer;
        LODWORD(qword_253EA0EC0) = qword_253EA0EC0 + 1;
        qword_253EA0EB0 = (uint64_t)buffer + v9;
        v6 = ((unint64_t)buffer + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      qword_253EA0EA8 = v6 + 8;
      v7[2] = v6;
    }
    llvm::sys::RWMutexImpl::unlock_shared(&qword_253EA0E98);
    return v6;
  }
  else
  {
    v4 = v16[2];
    llvm::sys::RWMutexImpl::unlock_shared(&qword_253EA0E98);
    return v4;
  }
}

void `anonymous namespace'::ImplicitTypeIDRegistry::~ImplicitTypeIDRegistry(llvm **this)
{
  llvm::deallocate_buffer(this[14], (void *)(24 * *((unsigned int *)this + 32)));
}

void sub_2074E69B0()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  if (*(_DWORD *)(v0 + 88))
    llvm::deallocate_buffer(**(llvm ***)(v0 + 80), *(void **)(*(_QWORD *)(v0 + 80) + 8));
  *(_DWORD *)(v0 + 88) = 0;
  v1 = *(_DWORD *)(v0 + 40);
  if (v1)
  {
    *(_QWORD *)(v0 + 96) = 0;
    v2 = *(_QWORD *)(v0 + 32);
    v3 = *(_QWORD *)v2 + 4096;
    *(_QWORD *)(v0 + 16) = *(_QWORD *)v2;
    *(_QWORD *)(v0 + 24) = v3;
    if (v1 != 1)
    {
      v4 = ((unint64_t)(v2 + 8 - *(_QWORD *)(v0 + 32)) >> 10) & 0x1FFFFFF;
      if (v4 >= 0x1E)
        LOBYTE(v4) = 30;
      llvm::deallocate_buffer(*(llvm **)(v2 + 8), (void *)(4096 << v4));
    }
    *(_DWORD *)(v0 + 40) = 1;
  }
  llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v0 + 16);
  llvm::sys::RWMutexImpl::~RWMutexImpl((pthread_rwlock_t **)v0);
}

mlir::tensor::TensorDialect *mlir::tensor::TensorDialect::TensorDialect(mlir::tensor::TensorDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v8;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"tensor", 6, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::TensorDialect,void>::id);
  *v3 = off_24C0528C0;
  v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"affine", 6))
  {
    v8 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"affine", 6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::affine::AffineDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::affine::AffineDialect * mlir::MLIRContext::getOrLoadDialect<mlir::affine::AffineDialect>(void)::{lambda(void)#1}>, (uint64_t)&v8);
  }
  v5 = (uint64_t *)*((_QWORD *)this + 4);
  if (!mlir::MLIRContext::isDialectLoading(v5, (uint64_t)"arith", 5))
  {
    v8 = v5;
    mlir::MLIRContext::getOrLoadDialect(v5, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v8);
  }
  v6 = (uint64_t *)*((_QWORD *)this + 4);
  if (!mlir::MLIRContext::isDialectLoading(v6, (uint64_t)"complex", 7))
  {
    v8 = v6;
    mlir::MLIRContext::getOrLoadDialect(v6, (uint64_t)"complex", 7, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ComplexDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::complex::ComplexDialect * mlir::MLIRContext::getOrLoadDialect<mlir::complex::ComplexDialect>(void)::{lambda(void)#1}>, (uint64_t)&v8);
  }
  mlir::tensor::TensorDialect::initialize(this);
  return this;
}

const char *mlir::tensor::TensorDialect::initialize(mlir::tensor::TensorDialect *this)
{
  char *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  uint64_t v5;
  const char *result;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t v18;

  mlir::Dialect::addOperations<mlir::tensor::BitcastOp,mlir::tensor::CastOp,mlir::tensor::CollapseShapeOp,mlir::tensor::DimOp,mlir::tensor::EmptyOp,mlir::tensor::ExpandShapeOp,mlir::tensor::ExtractOp,mlir::tensor::ExtractSliceOp,mlir::tensor::FromElementsOp,mlir::tensor::GatherOp,mlir::tensor::GenerateOp,mlir::tensor::InsertOp,mlir::tensor::InsertSliceOp,mlir::tensor::PackOp,mlir::tensor::PadOp,mlir::tensor::ParallelInsertSliceOp,mlir::tensor::RankOp,mlir::tensor::ReshapeOp,mlir::tensor::ScatterOp,mlir::tensor::SplatOp,mlir::tensor::UnPackOp,mlir::tensor::YieldOp>((uint64_t)this);
  v2 = (char *)operator new();
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v16 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v8 = v7;
    v2 = v16;
    if (v8)
    {
      v17 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      v18 = 79;
      v9 = llvm::StringRef::find((uint64_t *)&v17, "DesiredTypeName = ", 0x12uLL, 0);
      if (v18 >= v9)
        v10 = v9;
      else
        v10 = v18;
      v11 = &v17[v10];
      v12 = v18 - v10;
      if (v18 - v10 >= 0x12)
        v13 = 18;
      else
        v13 = v18 - v10;
      v14 = v12 - v13;
      if (v14 >= v14 - 1)
        v15 = v14 - 1;
      else
        v15 = v14;
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v16;
    }
  }
  v5 = v4[374];
  *((_QWORD *)v2 + 1) = this;
  *((_QWORD *)v2 + 2) = v5;
  *(_QWORD *)v2 = &off_24C02A488;
  v17 = v2;
  mlir::Dialect::addInterface((uint64_t)this, (uint64_t *)&v17);
  result = v17;
  v17 = 0;
  if (result)
    return (const char *)(*(uint64_t (**)(const char *))(*(_QWORD *)result + 8))(result);
  return result;
}

void mlir::tensor::TensorDialect::~TensorDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_2074E6CEC()
{
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::Dialect::addOperations<mlir::tensor::BitcastOp,mlir::tensor::CastOp,mlir::tensor::CollapseShapeOp,mlir::tensor::DimOp,mlir::tensor::EmptyOp,mlir::tensor::ExpandShapeOp,mlir::tensor::ExtractOp,mlir::tensor::ExtractSliceOp,mlir::tensor::FromElementsOp,mlir::tensor::GatherOp,mlir::tensor::GenerateOp,mlir::tensor::InsertOp,mlir::tensor::InsertSliceOp,mlir::tensor::PackOp,mlir::tensor::PadOp,mlir::tensor::ParallelInsertSliceOp,mlir::tensor::RankOp,mlir::tensor::ReshapeOp,mlir::tensor::ScatterOp,mlir::tensor::SplatOp,mlir::tensor::UnPackOp,mlir::tensor::YieldOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t result;
  _QWORD *v42;

  v2 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v3 = (uint64_t)v42;
  v42 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v5 = (uint64_t)v42;
  v42 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::CollapseShapeOp::getAttributeNames(void)::attrNames, 1);
  v7 = (uint64_t)v42;
  v42 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v9 = (uint64_t)v42;
  v42 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v10 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::Model(v10, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v11 = (uint64_t)v42;
  v42 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  v12 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::Model(v12, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::ExpandShapeOp::getAttributeNames(void)::attrNames, 1);
  v13 = (uint64_t)v42;
  v42 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v14 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::Model(v14, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v15 = (uint64_t)v42;
  v42 = 0;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  v16 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::ExtractSliceOp>::Model(v16, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::ExtractSliceOp::getAttributeNames(void)::attrNames, 4);
  v17 = (uint64_t)v42;
  v42 = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  v18 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::FromElementsOp>::Model(v18, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v19 = (uint64_t)v42;
  v42 = 0;
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  v20 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::GatherOp>::Model(v20, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::GatherOp::getAttributeNames(void)::attrNames, 2);
  v21 = (uint64_t)v42;
  v42 = 0;
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  mlir::RegisteredOperationName::insert<mlir::tensor::GenerateOp>(a1);
  v22 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::InsertOp>::Model(v22, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v23 = (uint64_t)v42;
  v42 = 0;
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  v24 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::InsertSliceOp>::Model(v24, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::InsertSliceOp::getAttributeNames(void)::attrNames, 4);
  v25 = (uint64_t)v42;
  v42 = 0;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  v26 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::PackOp>::Model(v26, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::PackOp::getAttributeNames(void)::attrNames, 4);
  v27 = (uint64_t)v42;
  v42 = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  v28 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::PadOp>::Model(v28, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::PadOp::getAttributeNames(void)::attrNames, 4);
  v29 = (uint64_t)v42;
  v42 = 0;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  mlir::RegisteredOperationName::insert<mlir::tensor::ParallelInsertSliceOp>(a1);
  v30 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::RankOp>::Model(v30, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v31 = (uint64_t)v42;
  v42 = 0;
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  v32 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::ReshapeOp>::Model(v32, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v33 = (uint64_t)v42;
  v42 = 0;
  if (v33)
    (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
  v34 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::ScatterOp>::Model(v34, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::ScatterOp::getAttributeNames(void)::attrNames, 2);
  v35 = (uint64_t)v42;
  v42 = 0;
  if (v35)
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  v36 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::SplatOp>::Model(v36, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  v37 = (uint64_t)v42;
  v42 = 0;
  if (v37)
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
  v38 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::UnPackOp>::Model(v38, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, (uint64_t)&mlir::tensor::UnPackOp::getAttributeNames(void)::attrNames, 3);
  v39 = (uint64_t)v42;
  v42 = 0;
  if (v39)
    (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
  v40 = (_QWORD *)operator new();
  v42 = mlir::RegisteredOperationName::Model<mlir::tensor::YieldOp>::Model(v40, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v42, 0, 0);
  result = (uint64_t)v42;
  v42 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

mlir::affine::AffineDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::affine::AffineDialect * mlir::MLIRContext::getOrLoadDialect<mlir::affine::AffineDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::affine::AffineDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::affine::AffineDialect *v4;
  mlir::affine::AffineDialect *result;

  v3 = *a1;
  v4 = (mlir::affine::AffineDialect *)operator new();
  result = mlir::affine::AffineDialect::AffineDialect(v4, v3);
  *a2 = result;
  return result;
}

mlir::complex::ComplexDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::complex::ComplexDialect * mlir::MLIRContext::getOrLoadDialect<mlir::complex::ComplexDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::complex::ComplexDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::complex::ComplexDialect *v4;
  mlir::complex::ComplexDialect *result;

  v3 = *a1;
  v4 = (mlir::complex::ComplexDialect *)operator new();
  result = mlir::complex::ComplexDialect::ComplexDialect(v4, v3);
  *a2 = result;
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::tensor::GenerateOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::GenerateOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"tensor.generate", 15, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::GenerateOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24C04CA70;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::tensor::ParallelInsertSliceOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OffsetSizeAndStrideOpInterfaceInterfaceTraits::Model<mlir::tensor::ParallelInsertSliceOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"tensor.parallel_insert_slice", 28, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::ParallelInsertSliceOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24C04CF20;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::tensor::ParallelInsertSliceOp::getAttributeNames(void)::attrNames, 4);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CastOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::BitcastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.bitcast", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::BitcastOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D880;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::BitcastOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::BitcastOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::BitcastOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CastOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::CastOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>::areCastCompatible;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface]";
      v15 = 71;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[344], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::BitcastOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::BitcastOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::BitcastOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return !*(_DWORD *)(a5 + 8) && mlir::impl::foldCastInterfaceOp(a2, a3, a4, a5);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>]";
      v186 = 110;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[421];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v186 = 82;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface::Trait<Empty>]";
      v186 = 85;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::CastOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CastOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[346];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::BitcastOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::tensor::BitcastOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::impl::verifyCastInterfaceOp(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::Op<mlir::tensor::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CastOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.cast", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::CastOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D178;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::CastOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::CastOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CastOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CastOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::CastOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::areCastCompatible;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface]";
      v15 = 71;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[344], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::memref::CastOp::getAsmResultNames(&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CastOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CastOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CastOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return !*(_DWORD *)(a5 + 8) && mlir::impl::foldCastInterfaceOp(a2, a3, a4, a5);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>]";
      v210 = 110;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[421];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v210 = 82;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface::Trait<Empty>]";
      v210 = 85;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::CastOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CastOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[346];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[340];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::BitcastOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::tensor::BitcastOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::impl::verifyCastInterfaceOp(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::Op<mlir::tensor::CastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::CastOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.collapse_shape", 21, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::CollapseShapeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04CE58;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::tensor *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::tensor *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::CollapseShapeOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::CollapseShapeOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::memref::CollapseShapeOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::memref::CollapseShapeOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::memref::CollapseShapeOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::memref::CollapseShapeOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::memref::CollapseShapeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::memref::CollapseShapeOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::CollapseShapeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::CmpFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::CollapseShapeOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::CollapseShapeOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::CollapseShapeOpGenericAdaptorBase::CollapseShapeOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::CollapseShapeOp::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v210 = 116;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v210 = 82;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[340];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::CollapseShapeOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::tensor::CollapseShapeOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::tensor::CollapseShapeOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::tensor::CollapseShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::DimOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ShapedDimOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.dim", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::DimOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04CFE8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::foldHook(uint64_t a1, mlir::tensor *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, mlir::tensor *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::DimOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::DimOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::DimOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::memref::DimOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::DimOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::DimOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

BOOL mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::DimOp>::getSpeculatability(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::tensor::DimOp::getSpeculatability((mlir::tensor::DimOp *)&v3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ShapedDimOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::ShapedDimOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getShapedValue;
  v2[1] = mlir::detail::ShapedDimOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getDimension;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ShapedDimOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ShapedDimOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[229], v2);
}

uint64_t mlir::detail::ShapedDimOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getShapedValue(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v3);
}

uint64_t mlir::detail::ShapedDimOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::getDimension(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v3) | 4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::inferReturnTypes(mlir::IndexType *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::memref::DimOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::refineReturnTypes(mlir::IndexType *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::DimOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::DimOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::tensor::DimOp>::refineReturnTypes(mlir::IndexType *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::memref::DimOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "tensor.dim";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::tensor *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  mlir::tensor *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::DimOpGenericAdaptorBase::DimOpGenericAdaptorBase((uint64_t)v14, (unsigned int *)a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::DimOp::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8
    || (mlir::tensor *)((char *)a2 - 16) == (mlir::tensor *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    return v9 > 7;
  }
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<Empty>]";
      v210 = 109;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[435];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[79];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[340];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[21];
  v29 = &unk_25451B000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451B000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ShapedDimOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::ShapedDimOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ShapedDimOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451B000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[231];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::DimOp::print((mlir::memref::DimOp *)&v7, a3);
}

BOOL mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::DimOp>,mlir::OpTrait::OneResult<mlir::tensor::DimOp>,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::tensor::DimOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::DimOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::tensor::DimOp>,mlir::OpTrait::OpInvariants<mlir::tensor::DimOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::DimOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::DimOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::DimOp>,mlir::ShapedDimOpInterface::Trait<mlir::tensor::DimOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::DimOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::tensor::DimOp>,mlir::OpTrait::OneResult<mlir::tensor::DimOp>,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::tensor::DimOp>,mlir::OpTrait::ZeroSuccessors<mlir::tensor::DimOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::tensor::DimOp>,mlir::OpTrait::OpInvariants<mlir::tensor::DimOp>,mlir::OpAsmOpInterface::Trait<mlir::tensor::DimOp>,mlir::ConditionallySpeculatable::Trait<mlir::tensor::DimOp>,mlir::MemoryEffectOpInterface::Trait<mlir::tensor::DimOp>,mlir::ShapedDimOpInterface::Trait<mlir::tensor::DimOp>,mlir::InferTypeOpInterface::Trait<mlir::tensor::DimOp>>(mlir::detail *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::detail *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v7 = a1, mlir::tensor::DimOp::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::detail::verifyShapedDimOpInterface(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::tensor::DimOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::ShapedDimOpInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::EmptyOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.empty", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::EmptyOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D3D0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::EmptyOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::tensor::EmptyOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::EmptyOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::EmptyOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::EmptyOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::EmptyOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>::reifyResultShapes;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface]";
      v15 = 88;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[171], v2);
}

uint64_t mlir::detail::ReifyRankedShapedTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::EmptyOp>::reifyResultShapes(uint64_t a1, uint64_t a2, mlir::IndexType **a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::EmptyOp::reifyResultShapes((uint64_t)&v5, a3, a4);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<Empty>]";
      v186 = 116;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[425];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v186 = 88;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[73];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[21];
  v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>]";
      v186 = 102;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::ReifyRankedShapedTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::ReifyRankedShapedTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::GetResultOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[168] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::tensor::EmptyOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  v6 = a1;
  if (!mlir::tensor::EmptyOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::tensor::EmptyOp::verify((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::tensor::EmptyOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::ReifyRankedShapedTypeOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.expand_shape", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::ExpandShapeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04CB38;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::tensor::ExpandShapeOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::tensor::ExpandShapeOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::memref::CollapseShapeOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::memref::CollapseShapeOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::memref::CollapseShapeOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::memref::CollapseShapeOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::memref::CollapseShapeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::memref::CollapseShapeOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExpandShapeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::CmpFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::tensor::ExpandShapeOp::getAsmResultNames((uint64_t)&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExpandShapeOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::ExpandShapeOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::tensor::ExpandShapeOp::fold(&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::memref::CollapseShapeOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::tensor::CollapseShapeOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::tensor::ExpandShapeOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::tensor::ExpandShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::RankedTensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpAsmOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::tensor::ExtractOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::tensor::ExtractOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"tensor.extract", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04D948;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::tensor::ExtractOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

